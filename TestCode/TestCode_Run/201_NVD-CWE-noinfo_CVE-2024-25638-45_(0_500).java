import java.io.IOException;
import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.interfaces.DSAPublicKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.DSAPublicKeySpec;
import java.security.spec.ECFieldFp;
import java.security.spec.ECParameterSpec;
import java.security.spec.ECPoint;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.EllipticCurve;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import lombok.Getter;

// Start
// SPDX-License-Identifier: BSD-3-Clause
package org.xbill.DNS;

import java.util.List;

/**
 * HTTPS Service Location and Parameter Binding Record
 *
 * @see <a
 *     href="https://tools.ietf.org/html/draft-ietf-dnsop-svcb-https-06">draft-ietf-dnsop-svcb-https</a>
 * @since 3.3
 */
public class HTTPSRecord extends SVCBBase {
  HTTPSRecord() {}

  public HTTPSRecord(
      Name name, int dclass, long ttl, int priority, Name domain, List<ParameterBase> params) {
    super(name, Type.HTTPS, dclass, ttl, priority, domain, params);
  }
}
// End

/**
 * Constants and methods relating to DNSSEC.
 *
 * <p>DNSSEC provides authentication for DNS information.
 *
 * @author Brian Wellington
 * @see RRSIGRecord
 * @see DNSKEYRecord
 * @see RRset
 */
public class DNSSEC {
  /** Domain Name System Security (DNSSEC) Algorithm Numbers. */
  public static class Algorithm {
    private Algorithm() {}

    /**
     * Delete DS record in parent zone.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc8078/">RFC 8078</a>
     * @since 3.5
     */
    public static final int DELETE = 0;

    /** RSA/MD5 public key (deprecated) */
    public static final int RSAMD5 = 1;

    /** Diffie Hellman key */
    public static final int DH = 2;

    /** DSA public key */
    public static final int DSA = 3;

    /** RSA/SHA1 public key */
    public static final int RSASHA1 = 5;

    /** DSA/SHA1, NSEC3-aware public key */
    public static final int DSA_NSEC3_SHA1 = 6;

    /** RSA/SHA1, NSEC3-aware public key */
    public static final int RSA_NSEC3_SHA1 = 7;

    /** RSA/SHA256 public key */
    public static final int RSASHA256 = 8;

    /** RSA/SHA512 public key */
    public static final int RSASHA512 = 10;

    /** GOST R 34.10-2001. This requires an external cryptography provider, such as BouncyCastle. */
    public static final int ECC_GOST = 12;

    /** ECDSA Curve P-256 with SHA-256 public key. */
    public static final int ECDSAP256SHA256 = 13;

    /** ECDSA Curve P-384 with SHA-384 public key. */
    public static final int ECDSAP384SHA384 = 14;

    /**
     * Edwards-Curve Digital Security Algorithm (EdDSA) for DNSSEC.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc8080/">RFC 8080</a>
     */
    public static final int ED25519 = 15;

    /**
     * Edwards-Curve Digital Security Algorithm (EdDSA) for DNSSEC.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc8080/">RFC 8080</a>
     */
    public static final int ED448 = 16;

    /**
     * SM2 signing algorithm with SM3 hashing algorithm.
     *
     * @see <a
     *     href="https://datatracker.ietf.org/doc/draft-cuiling-dnsop-sm2-alg/15/">draft-cuiling-dnsop-sm2-alg-15</a>
     * @since 3.6
     */
    public static final int SM2SM3 = 17;

    /**
     * GOST R 34.10-2012.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc9558/">RFC 9558</a>
     * @since 3.6
     */
    public static final int ECC_GOST12 = 23;

    /** Indirect keys; the actual key is elsewhere. */
    public static final int INDIRECT = 252;

    /** Private algorithm, specified by domain name */
    public static final int PRIVATEDNS = 253;

    /** Private algorithm, specified by OID */
    public static final int PRIVATEOID = 254;

    private static final Mnemonic algs = new Mnemonic("DNSSEC algorithm", Mnemonic.CASE_UPPER);

    static {
      algs.setMaximum(0xFF);
      algs.setNumericAllowed(true);

      algs.add(DELETE, "DELETE");
      algs.add(RSAMD5, "RSAMD5");
      algs.add(DH, "DH");
      algs.add(DSA, "DSA");
      algs.add(RSASHA1, "RSASHA1");
      algs.add(DSA_NSEC3_SHA1, "DSA-NSEC3-SHA1");
      algs.add(RSA_NSEC3_SHA1, "RSASHA1-NSEC3-SHA1");
      algs.add(RSASHA256, "RSASHA256");
      algs.add(RSASHA512, "RSASHA512");
      algs.add(ECC_GOST, "ECC-GOST");
      algs.add(ECDSAP256SHA256, "ECDSAP256SHA256");
      algs.add(ECDSAP384SHA384, "ECDSAP384SHA384");
      algs.add(ED25519, "ED25519");
      algs.add(ED448, "ED448");
      algs.add(SM2SM3, "SM2SM3");
      algs.add(ECC_GOST12, "ECC-GOST12");
      algs.add(INDIRECT, "INDIRECT");
      algs.add(PRIVATEDNS, "PRIVATEDNS");
      algs.add(PRIVATEOID, "PRIVATEOID");
    }

    /** Converts an algorithm into its textual representation */
    public static String string(int alg) {
      return algs.getText(alg);
    }

    /**
     * Converts a textual representation of an algorithm into its numeric code. Integers in the
     * range 0..255 are also accepted.
     *
     * @param s The textual representation of the algorithm
     * @return The algorithm code, or -1 on error.
     */
    public static int value(String s) {
      return algs.getValue(s);
    }

    /** Checks that a numeric value is within the range [0..max] */
    public static void check(int val) {
      algs.check(val);
    }
  }

  /**
   * DNSSEC Delegation Signer (DS) Resource Record (RR) Type Digest Algorithms.
   *
   * @since 3.5
   */
  public static class Digest {
    private Digest() {}

    /**
     * SHA-1.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc3658/">RFC 3658</a>
     */
    public static final int SHA1 = 1;

    /**
     * SHA-256.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc4509/">RFC 4509</a>
     */
    public static final int SHA256 = 2;

    /**
     * GOST R 34.11-94.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc5933/">RFC 5933</a>
     */
    public static final int GOST3411 = 3;

    /**
     * SHA-384.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc6605/">RFC 6605</a>
     */
    public static final int SHA384 = 4;

    /**
     * GOST R 34.11-2012.
     *
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc9558/">RFC 9558</a>
     * @since 3.6
     */
    public static final int GOST3411_12 = 5;

    /**
     * SM3 hashing algorithm.
     *
     * @see <a
     *     href="https://datatracker.ietf.org/doc/draft-cuiling-dnsop-sm2-alg/15/">draft-cuiling-dnsop-sm2-alg-15</a>
     * @since 3.6
     */
    public static final int SM3 = 6;

    private static final Mnemonic algs =
        new Mnemonic("DNSSEC Digest Algorithm", Mnemonic.CASE_UPPER);
    private static final Map<Integer, Integer> algLengths = new HashMap<>(4);

    static {
      algs.setMaximum(0xFF);
      algs.setNumericAllowed(true);

      algs.add(SHA1, "SHA-1");
      algLengths.put(SHA1, 20);
      algs.add(SHA256, "SHA-256");
      algLengths.put(SHA256, 32);
      algs.add(GOST3411, "GOST R 34.11-94");
      algLengths.put(GOST3411, 32);
      algs.add(SHA384, "SHA-384");
      algLengths.put(SHA384, 48);
      algs.add(GOST3411_12, "GOST12");
      algLengths.put(GOST3411_12, 64);
      algs.add(SM3, "SM3");
      algLengths.put(SM3, 32);
    }

    /** Converts an algorithm into its textual representation */
    public static String string(int alg) {
      return algs.getText(alg);
    }

    /**
     * Converts a textual representation of an algorithm into its numeric code. Integers in the
     * range 0..255 are also accepted.
     *
     * @param s The textual representation of the algorithm
     * @return The algorithm code, or -1 on error.
     */
    public static int value(String s) {
      return algs.getValue(s);
    }

    /**
     * Gets the length, in bytes, of the specified digest id.
     *
     * @return The length, in bytes, or -1 for an unknown digest.
     * @since 3.6
     */
    public static int algLength(int alg) {
      Integer len = algLengths.get(alg);
      return len == null ? -1 : len;
    }
  }

  private DNSSEC() {}

  private static void digestSIG(DNSOutput out, SIGBase sig) {
    out.writeU16(sig.getTypeCovered());
    out.writeU8(sig.getAlgorithm());
    out.writeU8(sig.getLabels());
    out.writeU32(sig.getOrigTTL());
    out.writeU32(sig.getExpire().getEpochSecond());
    out.writeU32(sig.getTimeSigned().getEpochSecond());
    out.writeU16(sig.getFootprint());
    sig.getSigner().toWireCanonical(out);
  }

  /**
   * Creates a byte array containing the concatenation of the fields of the SIG record and the
   * RRsets to be signed/verified. This does not perform a cryptographic digest.
   *
   * @param rrsig The RRSIG record used to sign/verify the rrset.
   * @param rrset The data to be signed/verified.
   * @return The data to be cryptographically signed or verified.
   */
  public static byte[] digestRRset(RRSIGRecord rrsig, RRset rrset) {
    DNSOutput out = new DNSOutput();
    digestSIG(out, rrsig);

    Name name = rrset.getName();
    Name wild = null;
    int sigLabels = rrsig.getLabels() + 1; // Add the root label back.
    if (name.labels() > sigLabels) {
      wild = name.wild(name.labels() - sigLabels);
    }

    DNSOutput header = new DNSOutput();
    if (wild != null) {
      wild.toWireCanonical(header);
    } else {
      name.toWireCanonical(header);
    }
    header.writeU16(rrset.getType());
    header.writeU16(rrset.getDClass());
    header.writeU32(rrsig.getOrigTTL());
    rrset.rrs(false).stream()
        .sorted()
        .forEachOrdered(
            r -> {
              out.writeByteArray(header.toByteArray());
              int lengthPosition = out.current();
              out.writeU16(0);
              r.rrToWire(out, null, true);
              int rrlength = out.current() - lengthPosition - 2;
              out.save();
              out.jump(lengthPosition);
              out.writeU16(rrlength);
              out.restore();
            });
    return out.toByteArray();
  }

  /**
   * Creates a byte array containing the concatenation of the fields of the SIG(0) record and the
   * message to be signed. This does not perform a cryptographic digest.
   *
   * @param sig The SIG record used to sign the rrset.
   * @param msg The message to be signed.
   * @param previous If this is a response, the signature from the query.
   * @return The data to be cryptographically signed.
   */
  public static byte[] digestMessage(SIGRecord sig, Message msg, byte[] previous) {
    DNSOutput out = new DNSOutput();
    digestSIG(out, sig);

    if (previous != null) {
      out.writeByteArray(previous);
    }

    msg.toWire(out);
    return out.toByteArray();
  }

  /** A DNSSEC exception. */
  public static class DNSSECException extends Exception {
    DNSSECException(String message, Throwable cause) {
      super(message, cause);
    }

    DNSSECException(Throwable cause) {
      super(cause);
    }

    DNSSECException(String message) {
      super(message);
    }
  }

  /** An algorithm is unsupported by this DNSSEC implementation. */
  public static class UnsupportedAlgorithmException extends DNSSECException {
    UnsupportedAlgorithmException(int alg) {
      super("Unsupported algorithm: " + alg);
    }
  }

  /** The {@link DNSKEYRecord} used for the validation is not a zone signing key. */
  public static class InvalidDnskeyException extends DNSSECException {
    @Getter private final int edeCode;

    InvalidDnskeyException(DNSKEYRecord dnskey, String message, int edeCode) {
      super("DNSKEY " + dnskey.getName() + " is invalid, " + message);
      this.edeCode = edeCode;
    }
  }

  /** The cryptographic data in a DNSSEC key is malformed. */
  public static class MalformedKeyException extends DNSSECException {
    MalformedKeyException(String message) {
      super(message);
    }

    MalformedKeyException(Record rec, Throwable cause) {
      super("Invalid key data: " + rec.rdataToString(), cause);
    }
  }

  /** A DNSSEC verification failed because fields in the DNSKEY and RRSIG records do not match. */
  public static class KeyMismatchException extends DNSSECException {
    KeyMismatchException(KEYBase key, SIGBase sig) {
      super(
          "key "
              + key.getName()
              + "/"
              + DNSSEC.Algorithm.string(key.getAlgorithm())
              + "/"
              + key.getFootprint()
              + " "
              + "does not match signature "
              + sig.getSigner()
              + "/"
              + DNSSEC.Algorithm.string(sig.getAlgorithm())
              + "/"
              + sig.getFootprint());
    }
  }

  /** A DNSSEC verification failed because the signature has expired. */
  public static class SignatureExpiredException extends DNSSECException {
    private final Instant when;
    private final Instant now;

    SignatureExpiredException(Instant when, Instant now) {
      super("signature expired");
      this.when = when;
      this.now = now;
    }

    /** When the signature expired. */
    public Instant getExpiration() {
      return when;
    }

    /** When the verification was attempted. */
    public Instant getVerifyTime() {
      return now;
    }
  }

  /** A DNSSEC verification failed because the signature has not yet become valid. */
  public static class SignatureNotYetValidException extends DNSSECException {
    private final Instant when;
    private final Instant now;

    SignatureNotYetValidException(Instant when, Instant now) {
      super("signature is not yet valid");
      this.when = when;
      this.now = now;
    }

    /** When the signature will become valid. */
    public Instant getExpiration() {
      return when;
    }

    /** When the verification was attempted. */
    public Instant getVerifyTime() {
      return now;
    }
  }

  /** A DNSSEC verification failed because the cryptographic signature verification failed. */
  public static class SignatureVerificationException extends DNSSECException {
    SignatureVerificationException(Throwable inner) {
      super("Signature verification failed", inner);
    }

    SignatureVerificationException(String message) {
      super("Signature verification failed: " + message);
    }
  }

  /** The key data provided is inconsistent. */
  public static class IncompatibleKeyException extends IllegalArgumentException {
    IncompatibleKeyException() {
      super("incompatible keys");
    }
  }

  /** No signature was found. */
  public static class NoSignatureException extends DNSSECException {
    NoSignatureException() {
      super("no signature found");
    }
  }

  private static int bigIntegerLength(BigInteger i) {
    return (i.bitLength() + 7) / 8;
  }

  private static BigInteger readBigInteger(DNSInput in, int len) throws IOException {
    byte[] b = in.readByteArray(len);
    return new BigInteger(1, b);
  }

  private static BigInteger readBigInteger(DNSInput in) {
    byte[] b = in.readByteArray();
    return new BigInteger(1, b);
  }

  private static byte[] trimByteArray(byte[] array) {
    if (array[0] == 0) {
      byte[] trimmedArray = new byte[array.length - 1];
      System.arraycopy(array, 1, trimmedArray, 0, array.length - 1);
      return trimmedArray;
    } else {
      return array;
    }
  }
