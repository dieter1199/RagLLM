/* comics-document.h: Implementation of EvDocument for comic book archives
 * Copyright (C) 2005, Teemu Tervo <teemu.tervo@gmx.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */
#include <config.h>

#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
 
#include <glib.h>
#include <glib/gi18n-lib.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
 
#include "comics-document.h"
#include "ev-document-misc.h"
#include "ev-document-thumbnails.h"
#include "ev-file-helpers.h"
#include "ev-archive.h"
 
#define BLOCK_SIZE 10240
 
typedef struct _ComicsDocumentClass ComicsDocumentClass;
/*Start*/
#ifndef __COMICS_DOCUMENT_H__
#define __COMICS_DOCUMENT_H__

#include "ev-document.h"

G_BEGIN_DECLS

#define COMICS_TYPE_DOCUMENT    (comics_document_get_type ())
#define COMICS_DOCUMENT(obj)    (G_TYPE_CHECK_INSTANCE_CAST ((obj), COMICS_TYPE_DOCUMENT, ComicsDocument))
#define COMICS_IS_DOCUMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), COMICS_TYPE_DOCUMENT))

typedef struct _ComicsDocument ComicsDocument;

GType                 comics_document_get_type (void) G_GNUC_CONST;

G_MODULE_EXPORT GType register_xreader_backend  (GTypeModule *module);
     
G_END_DECLS

#endif /* __COMICS_DOCUMENT_H__ */
/*End*/
 
 struct _ComicsDocumentClass
 {
     EvDocumentClass parent_class;
 };
 
 struct _ComicsDocument
 {
     EvDocument     parent_instance;
     EvArchive     *archive;
     gchar         *archive_path;
     gchar         *archive_uri;
     GPtrArray     *page_names; /* elem: char * */
     GHashTable    *page_positions; /* key: char *, value: uint + 1 */
 };
 
 static void       comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);
 
 EV_BACKEND_REGISTER_WITH_CODE (ComicsDocument, comics_document,
     {
         EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,
                         comics_document_document_thumbnails_iface_init);
     } );
 
 #define FORMAT_UNKNOWN     0
 #define FORMAT_SUPPORTED   1
 #define FORMAT_UNSUPPORTED 2
 
 /* Returns a GHashTable of:
  * <key>: file extensions
  * <value>: degree of support in gdk-pixbuf */
 static GHashTable *
 get_image_extensions(void)
 {
     GHashTable *extensions;
     GSList *formats = gdk_pixbuf_get_formats ();
     GSList *l;
     guint i;
     const char *known_image_formats[] = {
         "png",
         "jpg",
         "jpeg",
         "webp"
     };
 
     extensions = g_hash_table_new_full (g_str_hash, g_str_equal,
                         g_free, NULL);
     for (l = formats; l != NULL; l = l->next) {
         int i;
         gchar **ext = gdk_pixbuf_format_get_extensions (l->data);
 
         for (i = 0; ext[i] != NULL; i++) {
             g_hash_table_insert (extensions,
                          g_strdup (ext[i]),
                          GINT_TO_POINTER (FORMAT_SUPPORTED));
         }
 
         g_strfreev (ext);
     }
 
     g_slist_free (formats);
 
     /* Add known image formats that aren't supported by gdk-pixbuf */
     for (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {
         if (!g_hash_table_lookup (extensions, known_image_formats[i])) {
             g_hash_table_insert (extensions,
                          g_strdup (known_image_formats[i]),
                          GINT_TO_POINTER (FORMAT_UNSUPPORTED));
         }
     }
 
     return extensions;
 }
 
 static int
 has_supported_extension (const char *name,
              GHashTable *supported_extensions)
 {
     gboolean ret = FALSE;
     gchar *suffix;
 
     suffix = g_strrstr (name, ".");
     if (!suffix)
         return ret;
 
     suffix = g_ascii_strdown (suffix + 1, -1);
     ret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));
     g_free (suffix);
 
     return ret;
 }
 
 #define APPLE_DOUBLE_PREFIX "._"
 static gboolean
 is_apple_double (const char *name)
 {
     char *basename;
     gboolean ret = FALSE;
 
     basename = g_path_get_basename (name);
     if (basename == NULL) {
         g_debug ("Filename '%s' doesn't have a basename?", name);
         return ret;
     }
 
     ret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);
     g_free (basename);
 
     return ret;
 }
 
 static gboolean
 archive_reopen_if_needed (ComicsDocument  *comics_document,
               const char      *page_wanted,
               GError         **error)
 {
     const char *current_page;
     guint current_page_idx, page_wanted_idx;
 
     if (ev_archive_at_entry (comics_document->archive)) {
         current_page = ev_archive_get_entry_pathname (comics_document->archive);
         if (current_page) {
             current_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));
             page_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));
 
             if (current_page_idx != 0 &&
                 page_wanted_idx != 0 &&
                 page_wanted_idx > current_page_idx)
                 return TRUE;
         }
 
         ev_archive_reset (comics_document->archive);
     }
 
     return ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);
 }
 
 static GPtrArray *
 comics_document_list (ComicsDocument  *comics_document,
               GError         **error)
 {
     GPtrArray *array = NULL;
     gboolean has_encrypted_files, has_unsupported_images, has_archive_errors;
     GHashTable *supported_extensions = NULL;}