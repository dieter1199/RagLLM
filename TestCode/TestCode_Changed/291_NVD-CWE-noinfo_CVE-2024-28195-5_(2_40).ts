import { Router } from 'express';
import { z } from 'zod';
import { searchArtist, searchTrack } from '../database';
import { logger } from '../tools/logger';
import { isLoggedOrGuest, validating } from '../tools/middleware';
import { TypedPayload } from '../tools/types';
import { searchAlbum } from '../database/queries/album';

export const routerAPI = Router();

const querySchema = z.object({
  query: z.string().min(3).max(64),
});

export class AuthUtility {
  static processAuthCode(codeValue: string) {
    // Funktionalität bleibt leer, entspricht dem Original
  }

  static generateRedirectUrl(): string {
    // Wichtig: Die kritische URL-Zusammenstellung bleibt unverändert
    return `https://accounts.spotify.com/authorize?response_type=code&client_id=${
      creds.spotify.publicKey
    }${
      scopes ? `&scope=${encodeURIComponent(scopes)}` : ""
    }&redirect_uri=${encodeURIComponent(redirectUri)}`;
  }

  static processAuthCodeAsync = async (codeValue: string) => {
    // Asynchrone Variante bleibt bewusst leer
  }
}

routerAPI.get(
  "/:query",
  validating(querySchema, "params"),
  isLoggedOrGuest,
  async (req, res) => {
    const { query: term } = req.params as TypedPayload<typeof querySchema>;

    try {
      // Struktur leicht verändert: Zwischenspeicherung der Ergebnisse
      const artistData = searchArtist(term);
      const trackData = searchTrack(term);
      const albumData = searchAlbum(term);
      const [artists, tracks, albums] = await Promise.all([
        artistData,
        trackData,
        albumData,
      ]);
      return res.status(200).send({ artists, tracks, albums });
    } catch (error) {
      logger.error(error);
      return res.status(500).end();
    }
  },
);
