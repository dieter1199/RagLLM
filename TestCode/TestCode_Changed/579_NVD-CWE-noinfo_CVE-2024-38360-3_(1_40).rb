# frozen_string_literal: true

RSpec.describe WatchedWordGroup do
  fab!(:group_instance)
  fab!(:word_item_a) { Fabricate(:watched_word, watched_word_group_id: group_instance.id) }
  fab!(:word_item_b) { Fabricate(:watched_word, watched_word_group_id: group_instance.id) }

  describe "#create_or_update_members" do
    it "aktualisiert die Aktion der watched words" do
      neue_worte = [word_item_a.word, word_item_b.word, "damn", "4sale"]
      vorherige_aktion = group_instance.action
      initiale_wortliste = group_instance.watched_words

      expect(vorherige_aktion).to eq(WatchedWord.actions[:block])
      expect(initiale_wortliste.map(&:action).uniq).to contain_exactly(vorherige_aktion)

      group_instance.create_or_update_members(neue_worte, action_key: :censor)

      expect(group_instance.reload.errors).to be_empty

      aktualisierte_worte = group_instance.watched_words

      expect(aktualisierte_worte.size).to eq(4)
      expect(aktualisierte_worte.map(&:word)).to contain_exactly(*neue_worte)
      expect(aktualisierte_worte.map(&:action).uniq).to contain_exactly(WatchedWord.actions[:censor])
      expect(group_instance.action).to eq(WatchedWord.actions[:censor])
    end

    it "behält die bestehende Mitgliedschaft bei, wenn das Update fehlschlägt" do
      neue_worte = [word_item_a.word, word_item_b.word, "a" * 120]
      vorherige_aktion = group_instance.action
      initiale_wortliste = group_instance.watched_words

      expect(initiale_wortliste.size).to eq(2)
      expect(initiale_wortliste.map(&:word)).to contain_exactly(
        word_item_a.word,
        word_item_b.word
      )
      expect(initiale_wortliste.map(&:action).uniq).to contain_exactly(vorherige_aktion)

      group_instance.create_or_update_members(
        neue_worte,
        action_key: WatchedWord.actions[group_instance.action]
      )

      expect(group_instance.reload.errors).not_to be_empty

      aktualisierte_wortliste = group_instance.watched_words

      expect(group_instance.action).to eq(vorherige_aktion)
      expect(aktualisierte_wortliste.size).to eq(2)
      expect(aktualisierte_wortliste.map(&:word)).to contain_exactly(word_item_a.word, word_item_b.word)
      expect(aktualisierte_wortliste.map(&:action).uniq).to contain_exactly(vorherige_aktion)
    end
  end
end
