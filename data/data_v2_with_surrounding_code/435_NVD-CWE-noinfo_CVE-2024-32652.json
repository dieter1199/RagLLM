{
    "cve_id": "CVE-2024-32652",
    "cve_description": "The adapter @hono/node-server allows you to run your Hono application on Node.js. Prior to 1.10.1, the application hangs when receiving a Host header with a value that `@hono/node-server` can't handle well. Invalid values are those that cannot be parsed by the `URL` as a hostname such as an empty string, slashes `/`, and other strings. The version 1.10.1 includes the fix for this issue.",
    "cve_publish_date": "2024-04-19T19:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix: catch ERR_INVALID_URL error in listener (#162)",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "listener.test.ts",
            "code_language": "TypeScript",
            "number_of_lines_added_for_mitigation": "22",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "listener.ts",
            "code_language": "TypeScript",
            "number_of_lines_added_for_mitigation": "11",
            "number_of_lines_deleted_vulnerable_to_cve": "11",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 9: ",
                "// Line 10: const regBuffer = /^no$/i",
                "// Line 11: const regContentType = /^(application\\/json\b|text\\/(?!event-stream\b))/i",
                "// Line 12: ",
                "// Line 13: const handleFetchError = (e: unknown): Response =>",
                "// Line 14:   new Response(null, {",
                "// Line 15:     status:",
                "// Line 16:       e instanceof Error && (e.name === 'TimeoutError' || e.constructor.name === 'TimeoutError')",
                "// Line 17:         ? 504 // timeout error emits 504 timeout",
                "// Line 18:         : 500,",
                "// vulnerable line: 19: })",
                "// Line 20: ",
                "// Line 21: const handleResponseError = (e: unknown, outgoing: ServerResponse | Http2ServerResponse) => {",
                "// Line 22:   const err = (e instanceof Error ? e : new Error('unknown error', { cause: e })) as Error & {",
                "// Line 23:     code: string",
                "// vulnerable line: 24: }",
                "// Line 25:   if (err.code === 'ERR_STREAM_PREMATURE_CLOSE') {",
                "// Line 26:     console.info('The user aborted a request.')",
                "// Line 27:   } else {",
                "// Line 28:     console.error(e)",
                "// Line 29:     if (!outgoing.headersSent) {",
                "// Line 30:       outgoing.writeHead(500, { 'Content-Type': 'text/plain' })",
                "// vulnerable line: 31: }",
                "// Line 32:     outgoing.end(`Error: ${err.message}`)",
                "// Line 33:     outgoing.destroy(err)",
                "// vulnerable line: 34: }",
                "// vulnerable line: 35: }",
                "// Line 36: ",
                "// Line 37: const responseViaCache = (",
                "// Line 38:   res: Response,",
                "// Line 39:   outgoing: ServerResponse | Http2ServerResponse",
                "// Line 40: ): undefined | Promise<undefined> => {",
                "// Line 41:   // eslint-disable-next-line @typescript-eslint/no-explicit-any",
                "// Line 42:   const [status, body, header] = (res as any)[cacheKey]",
                "// Line 43:   if (typeof body === 'string') {",
                "// Line 44:     header['Content-Length'] = Buffer.byteLength(body)",
                "// Line 45:     outgoing.writeHead(status, header)",
                "// Line 46:     outgoing.end(body)",
                "// Line 47:   } else {",
                "// Line 48:     outgoing.writeHead(status, header)",
                "// Line 49:     return writeFromReadableStream(body, outgoing)?.catch(",
                "// Line 50:       (e) => handleResponseError(e, outgoing) as undefined",
                "// Line 51:     )",
                "// vulnerable line: 52: }",
                "// vulnerable line: 53: }",
                "// Line 54: ",
                "// Line 55: const responseViaResponseObject = async (",
                "// Line 56:   res: Response | Promise<Response>,",
                "// Line 57:   outgoing: ServerResponse | Http2ServerResponse,",
                "// Line 58:   options: { errorHandler?: CustomErrorHandler } = {}",
                "// Line 59: ) => {",
                "// Line 60:   if (res instanceof Promise) {",
                "// Line 61:     if (options.errorHandler) {",
                "// Line 62:       try {",
                "// Line 63:         res = await res",
                "// Line 64:       } catch (err) {",
                "// Line 65:         const errRes = await options.errorHandler(err)",
                "// Line 66:         if (!errRes) {",
                "// Line 67:           return",
                "// vulnerable line: 68: }",
                "// Line 69:         res = errRes",
                "// vulnerable line: 70: }",
                "// Line 71:     } else {",
                "// Line 72:       res = await res.catch(handleFetchError)",
                "// vulnerable line: 73: }",
                "// vulnerable line: 74: }",
                "// Line 75: ",
                "// Line 76:   if (cacheKey in res) {",
                "// Line 77:     return responseViaCache(res as Response, outgoing)",
                "// vulnerable line: 78: }",
                "// Line 79: ",
                "// Line 80:   const resHeaderRecord: OutgoingHttpHeaders = buildOutgoingHttpHeaders(res.headers)",
                "// Line 81: ",
                "// Line 82:   // eslint-disable-next-line @typescript-eslint/no-explicit-any",
                "// Line 83:   const internalBody = getInternalBody(res as any)",
                "// Line 84:   if (internalBody) {",
                "// Line 85:     if (internalBody.length) {",
                "// Line 86:       resHeaderRecord['content-length'] = internalBody.length",
                "// vulnerable line: 87: }",
                "// Line 88:     outgoing.writeHead(res.status, resHeaderRecord)",
                "// Line 89:     if (typeof internalBody.source === 'string' || internalBody.source instanceof Uint8Array) {",
                "// Line 90:       outgoing.end(internalBody.source)",
                "// Line 91:     } else if (internalBody.source instanceof Blob) {",
                "// Line 92:       outgoing.end(new Uint8Array(await internalBody.source.arrayBuffer()))",
                "// Line 93:     } else {",
                "// Line 94:       await writeFromReadableStream(internalBody.stream, outgoing)",
                "// vulnerable line: 95: }",
                "// Line 96:   } else if (res.body) {",
                "// Line 97:     /**",
                "// Line 98:      * If content-encoding is set, we assume that the response should be not decoded.",
                "// Line 99:      * Else if transfer-encoding is set, we assume that the response should be streamed.",
                "// Line 100:      * Else if content-length is set, we assume that the response content has been taken care of.",
                "// Line 101:      * Else if x-accel-buffering is set to no, we assume that the response should be streamed.",
                "// Line 102:      * Else if content-type is not application/json nor text/* but can be text/event-stream,",
                "// Line 103:      * we assume that the response should be streamed.",
                "// Line 104:      */",
                "// Line 105: ",
                "// Line 121:     ) {",
                "// Line 122:       outgoing.writeHead(res.status, resHeaderRecord)",
                "// Line 123: ",
                "// Line 124:       await writeFromReadableStream(res.body, outgoing)",
                "// Line 125:     } else {",
                "// Line 126:       const buffer = await res.arrayBuffer()",
                "// Line 127:       resHeaderRecord['content-length'] = buffer.byteLength",
                "// Line 128: ",
                "// Line 129:       outgoing.writeHead(res.status, resHeaderRecord)",
                "// Line 130:       outgoing.end(new Uint8Array(buffer))",
                "// vulnerable line: 131: }",
                "// Line 132:   } else if (resHeaderRecord[X_ALREADY_SENT]) {",
                "// Line 133:     // do nothing, the response has already been sent",
                "// Line 134:   } else {",
                "// Line 135:     outgoing.writeHead(res.status, resHeaderRecord)",
                "// Line 136:     outgoing.end()",
                "// vulnerable line: 137: }",
                "// vulnerable line: 138: }",
                "// Line 139: ",
                "// Line 140: export const getRequestListener = (",
                "// Line 141:   fetchCallback: FetchCallback,",
                "// Line 142:   options: {",
                "// Line 143:     errorHandler?: CustomErrorHandler",
                "// Line 144:     overrideGlobalObjects?: boolean",
                "// Line 145:   } = {}",
                "// Line 146: ) => {",
                "// Line 147:   if (options.overrideGlobalObjects !== false && global.Request !== LightweightRequest) {",
                "// Line 148:     Object.defineProperty(global, 'Request', {",
                "// Line 149:       value: LightweightRequest,",
                "// vulnerable line: 150: })",
                "// Line 151:     Object.defineProperty(global, 'Response', {",
                "// Line 152:       value: LightweightResponse,",
                "// vulnerable line: 153: })",
                "// vulnerable line: 154: }",
                "// Line 155: ",
                "// Line 156:   return async (",
                "// Line 157:     incoming: IncomingMessage | Http2ServerRequest,",
                "// Line 158:     outgoing: ServerResponse | Http2ServerResponse",
                "// Line 159:   ) => {",
                "// Line 160:     let res",
                "// Line 161: ",
                "// vulnerable line: 162: // `fetchCallback()` requests a Request object, but global.Request is expensive to generate,",
                "// vulnerable line: 163: // so generate a pseudo Request object with only the minimum required information.",
                "// vulnerable line: 164: const req = newRequest(incoming)",
                "// Line 165: ",
                "// vulnerable line: 166: // Detect if request was aborted.",
                "// vulnerable line: 167: outgoing.on('close', () => {",
                "// vulnerable line: 168: if (incoming.destroyed) {",
                "// vulnerable line: 169: req[getAbortController]().abort()",
                "// vulnerable line: 170: }",
                "// vulnerable line: 171: })",
                "// Line 172: ",
                "// Line 173:     try {",
                "// Line 174:       res = fetchCallback(req, { incoming, outgoing } as HttpBindings) as",
                "// Line 175:         | Response",
                "// Line 176:         | Promise<Response>",
                "// Line 177:       if (cacheKey in res) {",
                "// Line 178:         // synchronous, cacheable response",
                "// Line 179:         return responseViaCache(res as Response, outgoing)",
                "// vulnerable line: 180: }",
                "// Line 181:     } catch (e: unknown) {",
                "// Line 182:       if (!res) {",
                "// Line 183:         if (options.errorHandler) {",
                "// Line 184:           res = await options.errorHandler(e)",
                "// Line 185:           if (!res) {",
                "// Line 186:             return",
                "// vulnerable line: 187: }",
                "// Line 188:         } else {",
                "// Line 189:           res = handleFetchError(e)",
                "// vulnerable line: 190: }",
                "// Line 191:       } else {",
                "// Line 192:         return handleResponseError(e, outgoing)",
                "// vulnerable line: 193: }",
                "// vulnerable line: 194: }",
                "// Line 195: ",
                "// Line 196:     try {",
                "// Line 197:       return responseViaResponseObject(res, outgoing, options)",
                "// Line 198:     } catch (e) {",
                "// Line 199:       return handleResponseError(e, outgoing)",
                "// vulnerable line: 200: }",
                "// vulnerable line: 201: }",
                "// vulnerable line: 202: }"
            ]
        }
    ]
}