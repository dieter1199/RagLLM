{
    "cve_id": "CVE-2024-29882",
    "cve_description": "SRS is a simple, high-efficiency, real-time video server. SRS's `/api/v1/vhosts/vid-<id>?callback=<payload>` endpoint didn't filter the callback function name which led to injecting malicious javascript payloads and executing XSS ( Cross-Site Scripting). This vulnerability is fixed in 5.0.210 and 6.0.121.",
    "cve_publish_date": "2024-03-28T14:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-gv9r-qcjc-5hj7\n\n* Filter JSONP callback function name. v5.0.210,v6.0.121\n\n* Add utest.\n\n* Refine utest",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "srs_kernel_error.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "srs_protocol_http_conn.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "21",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 21: #include <srs_protocol_conn.hpp>",
                "// Line 22: #include <srs_protocol_http_stack.hpp>",
                "// Line 23: ",
                "// Line 24: SrsHttpParser::SrsHttpParser()",
                "// Line 25: {",
                "// Line 26:     buffer = new SrsFastStream();",
                "// Line 27:     header = NULL;",
                "// Line 28: ",
                "// Line 29:     type_ = HTTP_REQUEST;",
                "// Line 30:     parsed_type_ = HTTP_BOTH;",
                "// vulnerable line: 31: }",
                "// Line 32: ",
                "// Line 33: SrsHttpParser::~SrsHttpParser()",
                "// Line 34: {",
                "// Line 35:     srs_freep(buffer);",
                "// Line 36:     srs_freep(header);",
                "// vulnerable line: 37: }",
                "// Line 38: ",
                "// Line 39: srs_error_t SrsHttpParser::initialize(enum http_parser_type type)",
                "// Line 40: {",
                "// Line 41:     srs_error_t err = srs_success;",
                "// Line 42: ",
                "// Line 43:     jsonp = false;",
                "// Line 44:     type_ = type;",
                "// Line 45: ",
                "// Line 46:     // Initialize the parser, however it's not necessary.",
                "// Line 47:     http_parser_init(&parser, type_);",
                "// Line 50:     memset(&settings, 0, sizeof(settings));",
                "// Line 51:     settings.on_message_begin = on_message_begin;",
                "// Line 52:     settings.on_url = on_url;",
                "// Line 53:     settings.on_header_field = on_header_field;",
                "// Line 54:     settings.on_header_value = on_header_value;",
                "// Line 55:     settings.on_headers_complete = on_headers_complete;",
                "// Line 56:     settings.on_body = on_body;",
                "// Line 57:     settings.on_message_complete = on_message_complete;",
                "// Line 58:     ",
                "// Line 59:     return err;",
                "// vulnerable line: 60: }",
                "// Line 61: ",
                "// Line 62: void SrsHttpParser::set_jsonp(bool allow_jsonp)",
                "// Line 63: {",
                "// Line 64:     jsonp = allow_jsonp;",
                "// vulnerable line: 65: }",
                "// Line 66: ",
                "// Line 67: srs_error_t SrsHttpParser::parse_message(ISrsReader* reader, ISrsHttpMessage** ppmsg)",
                "// Line 68: {",
                "// Line 69:     srs_error_t err = srs_success;",
                "// Line 70: ",
                "// Line 71:     *ppmsg = NULL;",
                "// Line 72:     ",
                "// Line 73:     // Reset parser data and state.",
                "// Line 74:     state = SrsHttpParseStateInit;",
                "// Line 75:     memset(&hp_header, 0, sizeof(http_parser));",
                "// Line 94:     // Reset the parsed type.",
                "// Line 95:     parsed_type_ = HTTP_BOTH;",
                "// Line 96:     // callback object ptr.",
                "// Line 97:     parser.data = (void*)this;",
                "// Line 98:     // Always skip body, because we only want to parse the header.",
                "// Line 99:     parser.flags |= F_SKIPBODY;",
                "// Line 100:     ",
                "// Line 101:     // do parse",
                "// Line 102:     if ((err = parse_message_imp(reader)) != srs_success) {",
                "// Line 103:         return srs_error_wrap(err, \"parse message\");",
                "// vulnerable line: 104: }",
                "// Line 105:     ",
                "// Line 106:     // create msg",
                "// Line 107:     SrsHttpMessage* msg = new SrsHttpMessage(reader, buffer);",
                "// Line 108: ",
                "// Line 109:     // Initialize the basic information.",
                "// Line 110:     msg->set_basic(hp_header.type, (http_method)hp_header.method, (http_status)hp_header.status_code, hp_header.content_length);",
                "// Line 111:     msg->set_header(header, http_should_keep_alive(&hp_header));",
                "// Line 112:     // For HTTP response, no url.",
                "// Line 113:     if (parsed_type_ != HTTP_RESPONSE && (err = msg->set_url(url, jsonp)) != srs_success) {",
                "// Line 114:         srs_freep(msg);",
                "// Line 115:         return srs_error_wrap(err, \"set url=%s, jsonp=%d\", url.c_str(), jsonp);",
                "// vulnerable line: 116: }",
                "// Line 117:     ",
                "// Line 118:     // parse ok, return the msg.",
                "// Line 119:     *ppmsg = msg;",
                "// Line 120:     ",
                "// Line 121:     return err;",
                "// vulnerable line: 122: }",
                "// Line 123: ",
                "// Line 124: srs_error_t SrsHttpParser::parse_message_imp(ISrsReader* reader)",
                "// Line 125: {",
                "// Line 126:     srs_error_t err = srs_success;",
                "// Line 127:     ",
                "// Line 128:     while (true) {",
                "// Line 129:         if (buffer->size() > 0) {",
                "// Line 130:             ssize_t consumed = http_parser_execute(&parser, &settings, buffer->bytes(), buffer->size());",
                "// Line 131: ",
                "// Line 132:             // The error is set in http_errno.",
                "// Line 133:             enum http_errno code = HTTP_PARSER_ERRNO(&parser);",
                "// Line 134:             if (code != HPE_OK) {",
                "// Line 135:                 return srs_error_new(ERROR_HTTP_PARSE_HEADER, \"parse %dB, nparsed=%d, err=%d/%s %s\",",
                "// Line 136:                     buffer->size(), (int)consumed, code, http_errno_name(code), http_errno_description(code));",
                "// vulnerable line: 137: }",
                "// Line 138:             ",
                "// Line 139:             srs_info(\"size=%d, nparsed=%d\", buffer->size(), (int)consumed);",
                "// Line 140: ",
                "// Line 141:             // Only consume the header bytes.",
                "// Line 142:             buffer->read_slice(consumed);",
                "// Line 143: ",
                "// Line 144:             // Done when header completed, never wait for body completed, because it maybe chunked.",
                "// Line 145:             if (state >= SrsHttpParseStateHeaderComplete) {",
                "// Line 146:                 break;",
                "// vulnerable line: 147: }",
                "// vulnerable line: 148: }",
                "// Line 149:         ",
                "// Line 150:         // when nothing parsed, read more to parse.",
                "// Line 151:         // when requires more, only grow 1bytes, but the buffer will cache more.",
                "// Line 152:         if ((err = buffer->grow(reader, buffer->size() + 1)) != srs_success) {",
                "// Line 153:             return srs_error_wrap(err, \"grow buffer\");",
                "// vulnerable line: 154: }",
                "// vulnerable line: 155: }",
                "// Line 156: ",
                "// Line 157:     SrsHttpParser* obj = this;",
                "// Line 158:     if (!obj->field_value.empty()) {",
                "// Line 159:         obj->header->set(obj->field_name, obj->field_value);",
                "// vulnerable line: 160: }",
                "// Line 161:     ",
                "// Line 162:     return err;",
                "// vulnerable line: 163: }",
                "// Line 164: ",
                "// Line 165: int SrsHttpParser::on_message_begin(http_parser* parser)",
                "// Line 166: {",
                "// Line 167:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 168:     srs_assert(obj);",
                "// Line 169: ",
                "// Line 170:     // Now, we start to parse HTTP message.",
                "// Line 171:     obj->state = SrsHttpParseStateStart;",
                "// Line 172: ",
                "// Line 173:     // If we set to HTTP_BOTH, the type is detected and speicifed by parser.",
                "// Line 174:     obj->parsed_type_ = (http_parser_type)parser->type;",
                "// Line 175:     ",
                "// Line 176:     srs_info(\"***MESSAGE BEGIN***\");",
                "// Line 177:     ",
                "// Line 178:     return 0;",
                "// vulnerable line: 179: }",
                "// Line 180: ",
                "// Line 181: int SrsHttpParser::on_headers_complete(http_parser* parser)",
                "// Line 182: {",
                "// Line 183:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 184:     srs_assert(obj);",
                "// Line 185:     ",
                "// Line 186:     obj->hp_header = *parser;",
                "// Line 187:     // save the parser when header parse completed.",
                "// Line 188:     obj->state = SrsHttpParseStateHeaderComplete;",
                "// Line 189: ",
                "// Line 190:     srs_info(\"***HEADERS COMPLETE***\");",
                "// Line 191: ",
                "// Line 192:     // The return code of this callback:",
                "// Line 193:     //      0: Continue to process body.",
                "// Line 194:     //      1: Skip body, but continue to parse util all data parsed.",
                "// Line 195:     //      2: Upgrade and skip body and left message, because it is in a different protocol.",
                "// Line 196:     //      N: Error and failed as HPE_CB_headers_complete.",
                "// Line 197:     // We choose 2 because we only want to parse the header, not the body.",
                "// Line 198:     return 2;",
                "// vulnerable line: 199: }",
                "// Line 200: ",
                "// Line 201: int SrsHttpParser::on_message_complete(http_parser* parser)",
                "// Line 202: {",
                "// Line 203:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 204:     srs_assert(obj);",
                "// Line 205:     ",
                "// Line 206:     // save the parser when body parse completed.",
                "// Line 207:     obj->state = SrsHttpParseStateMessageComplete;",
                "// Line 208:     ",
                "// Line 209:     srs_info(\"***MESSAGE COMPLETE***",
                "// Line 210: \");",
                "// Line 211:     ",
                "// Line 212:     return 0;",
                "// vulnerable line: 213: }",
                "// Line 214: ",
                "// Line 215: int SrsHttpParser::on_url(http_parser* parser, const char* at, size_t length)",
                "// Line 216: {",
                "// Line 217:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 218:     srs_assert(obj);",
                "// Line 219: ",
                "// Line 220:     if (length > 0) {",
                "// Line 221:         // Note that this function might be called for multiple times, and we got pieces of content.",
                "// Line 222:         obj->url.append(at, (int)length);",
                "// vulnerable line: 223: }",
                "// Line 224:     ",
                "// Line 225:     srs_info(\"Method: %d, Url: %.*s\", parser->method, (int)length, at);",
                "// Line 226:     ",
                "// Line 227:     return 0;",
                "// vulnerable line: 228: }",
                "// Line 229: ",
                "// Line 230: int SrsHttpParser::on_header_field(http_parser* parser, const char* at, size_t length)",
                "// Line 231: {",
                "// Line 232:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 233:     srs_assert(obj);",
                "// Line 234: ",
                "// Line 235:     if (!obj->field_value.empty()) {",
                "// Line 236:         obj->header->set(obj->field_name, obj->field_value);",
                "// Line 237:         obj->field_name = obj->field_value = \"\";",
                "// vulnerable line: 238: }",
                "// Line 239:     ",
                "// Line 240:     if (length > 0) {",
                "// Line 241:         obj->field_name.append(at, (int)length);",
                "// vulnerable line: 242: }",
                "// Line 243:     ",
                "// Line 244:     srs_info(\"Header field(%d bytes): %.*s\", (int)length, (int)length, at);",
                "// Line 245:     return 0;",
                "// vulnerable line: 246: }",
                "// Line 247: ",
                "// Line 248: int SrsHttpParser::on_header_value(http_parser* parser, const char* at, size_t length)",
                "// Line 249: {",
                "// Line 250:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 251:     srs_assert(obj);",
                "// Line 252:     ",
                "// Line 253:     if (length > 0) {",
                "// Line 254:         obj->field_value.append(at, (int)length);",
                "// vulnerable line: 255: }",
                "// Line 256:     ",
                "// Line 257:     srs_info(\"Header value(%d bytes): %.*s\", (int)length, (int)length, at);",
                "// Line 258:     return 0;",
                "// vulnerable line: 259: }",
                "// Line 260: ",
                "// Line 261: int SrsHttpParser::on_body(http_parser* parser, const char* at, size_t length)",
                "// Line 262: {",
                "// Line 263:     SrsHttpParser* obj = (SrsHttpParser*)parser->data;",
                "// Line 264:     srs_assert(obj);",
                "// Line 265: ",
                "// Line 266:     // save the parser when body parsed.",
                "// Line 267:     obj->state = SrsHttpParseStateBody;",
                "// Line 268: ",
                "// Line 269:     srs_info(\"Body: %.*s\", (int)length, at);",
                "// Line 270:     ",
                "// Line 271:     return 0;",
                "// vulnerable line: 272: }",
                "// Line 273: ",
                "// Line 274: SrsHttpMessage::SrsHttpMessage(ISrsReader* reader, SrsFastStream* buffer) : ISrsHttpMessage()",
                "// Line 275: {",
                "// Line 276:     owner_conn = NULL;",
                "// Line 277:     chunked = false;",
                "// Line 278:     _uri = new SrsHttpUri();",
                "// Line 279:     _body = new SrsHttpResponseReader(this, reader, buffer);",
                "// Line 280: ",
                "// Line 281:     jsonp = false;",
                "// Line 282: ",
                "// Line 284:     _method = (http_method)SRS_CONSTS_HTTP_GET;",
                "// Line 285:     // 200 is ok.",
                "// Line 286:     _status = (http_status)SRS_CONSTS_HTTP_OK;",
                "// Line 287:     // -1 means infinity chunked mode.",
                "// Line 288:     _content_length = -1;",
                "// Line 289:     // From HTTP/1.1, default to keep alive.",
                "// Line 290:     _keep_alive = true;",
                "// Line 291:     type_ = 0;",
                "// Line 292: ",
                "// Line 293:     schema_ = \"http\";",
                "// vulnerable line: 294: }",
                "// Line 295: ",
                "// Line 296: SrsHttpMessage::~SrsHttpMessage()",
                "// Line 297: {",
                "// Line 298:     srs_freep(_body);",
                "// Line 299:     srs_freep(_uri);",
                "// vulnerable line: 300: }",
                "// Line 301: ",
                "// Line 302: void SrsHttpMessage::set_basic(uint8_t type, http_method method, http_status status, int64_t content_length)",
                "// Line 303: {",
                "// Line 304:     type_ = type;",
                "// Line 305:     _method = method;",
                "// Line 306:     _status = status;",
                "// Line 307:     if (_content_length == -1) {",
                "// Line 308:         _content_length = content_length;",
                "// vulnerable line: 309: }",
                "// vulnerable line: 310: }",
                "// Line 311: ",
                "// Line 312: void SrsHttpMessage::set_header(SrsHttpHeader* header, bool keep_alive)",
                "// Line 313: {",
                "// Line 314:     _header = *header;",
                "// Line 315:     _keep_alive = keep_alive;",
                "// Line 316: ",
                "// Line 317:     // whether chunked.",
                "// Line 318:     chunked = (header->get(\"Transfer-Encoding\") == \"chunked\");",
                "// Line 319: ",
                "// Line 320:     // Update the content-length in header.",
                "// Line 321:     string clv = header->get(\"Content-Length\");",
                "// Line 322:     if (!clv.empty()) {",
                "// Line 323:         _content_length = ::atoll(clv.c_str());",
                "// vulnerable line: 324: }",
                "// Line 325: ",
                "// Line 326:     // If no size(content-length or chunked), it's infinite chunked,",
                "// Line 327:     // it means there is no body, so we must close the body reader.",
                "// Line 328:     if (!chunked && _content_length == -1) {",
                "// Line 329:         // The infinite chunked is only enabled for HTTP_RESPONSE, so we close the body for request.",
                "// Line 330:         if (type_ == HTTP_REQUEST) {",
                "// Line 331:             _body->close();",
                "// vulnerable line: 332: }",
                "// vulnerable line: 333: }",
                "// vulnerable line: 334: }",
                "// Line 335: ",
                "// Line 336: srs_error_t SrsHttpMessage::set_url(string url, bool allow_jsonp)",
                "// Line 337: {",
                "// Line 338:     srs_error_t err = srs_success;",
                "// Line 339:     ",
                "// Line 340:     _url = url;",
                "// Line 341: ",
                "// Line 342:     // parse uri from schema/server:port/path?query",
                "// Line 343:     std::string uri = _url;",
                "// Line 344: ",
                "// Line 345:     if (!srs_string_contains(uri, \"://\")) {",
                "// Line 346:         // use server public ip when host not specified.",
                "// Line 347:         // to make telnet happy.",
                "// Line 348:         std::string host = _header.get(\"Host\");",
                "// Line 349: ",
                "// Line 350:         // If no host in header, we use local discovered IP, IPv4 first.",
                "// Line 351:         if (host.empty()) {",
                "// Line 352:             host = srs_get_public_internet_address(true);",
                "// vulnerable line: 353: }",
                "// Line 354: ",
                "// Line 355:         // The url must starts with slash if no schema. For example, SIP request line starts with \"sip\".",
                "// Line 356:         if (!host.empty() && !srs_string_starts_with(_url, \"/\")) {",
                "// Line 357:             host += \"/\";",
                "// vulnerable line: 358: }",
                "// Line 359: ",
                "// Line 360:         if (!host.empty()) {",
                "// Line 361:             uri = \"http://\" + host + _url;",
                "// vulnerable line: 362: }",
                "// vulnerable line: 363: }",
                "// Line 364: ",
                "// Line 365:     if ((err = _uri->initialize(uri)) != srs_success) {",
                "// Line 366:         return srs_error_wrap(err, \"init uri %s\", uri.c_str());",
                "// vulnerable line: 367: }",
                "// Line 368:     ",
                "// Line 369:     // parse ext.",
                "// Line 370:     _ext = srs_path_filext(_uri->get_path());",
                "// Line 371:     ",
                "// Line 372:     // parse query string.",
                "// Line 373:     srs_parse_query_string(_uri->get_query(), _query);",
                "// Line 374:     ",
                "// Line 375:     // parse jsonp request message.",
                "// Line 376:     if (allow_jsonp) {",
                "// vulnerable line: 377: if (!query_get(\"callback\").empty()) {",
                "// vulnerable line: 378: jsonp = true;",
                "// vulnerable line: 379: }",
                "// Line 380:         if (jsonp) {",
                "// Line 381:             jsonp_method = query_get(\"method\");",
                "// vulnerable line: 382: }",
                "// vulnerable line: 383: }",
                "// Line 384:     ",
                "// Line 385:     return err;",
                "// vulnerable line: 386: }",
                "// Line 387: ",
                "// Line 388: void SrsHttpMessage::set_https(bool v)",
                "// Line 389: {",
                "// Line 390:     schema_ = v? \"https\" : \"http\";",
                "// Line 391:     _uri->set_schema(schema_);",
                "// vulnerable line: 392: }",
                "// Line 393: ",
                "// Line 394: ISrsConnection* SrsHttpMessage::connection()",
                "// Line 395: {",
                "// Line 396:     return owner_conn;",
                "// vulnerable line: 397: }",
                "// Line 398: ",
                "// Line 399: void SrsHttpMessage::set_connection(ISrsConnection* conn)",
                "// Line 400: {",
                "// Line 401:     owner_conn = conn;",
                "// vulnerable line: 402: }",
                "// Line 403: ",
                "// Line 404: string SrsHttpMessage::schema()",
                "// Line 405: {",
                "// Line 406:     return schema_;",
                "// vulnerable line: 407: }",
                "// Line 408: ",
                "// Line 409: uint8_t SrsHttpMessage::message_type()",
                "// Line 410: {",
                "// Line 411:     return type_;",
                "// vulnerable line: 412: }",
                "// Line 413: ",
                "// Line 414: uint8_t SrsHttpMessage::method()",
                "// Line 415: {",
                "// Line 416:     if (jsonp && !jsonp_method.empty()) {",
                "// Line 417:         if (jsonp_method == \"GET\") {",
                "// Line 418:             return SRS_CONSTS_HTTP_GET;",
                "// Line 419:         } else if (jsonp_method == \"PUT\") {",
                "// Line 420:             return SRS_CONSTS_HTTP_PUT;",
                "// Line 421:         } else if (jsonp_method == \"POST\") {",
                "// Line 422:             return SRS_CONSTS_HTTP_POST;",
                "// Line 423:         } else if (jsonp_method == \"DELETE\") {",
                "// Line 424:             return SRS_CONSTS_HTTP_DELETE;",
                "// vulnerable line: 425: }",
                "// vulnerable line: 426: }",
                "// Line 427: ",
                "// Line 428:     return _method;",
                "// vulnerable line: 429: }",
                "// Line 430: ",
                "// Line 431: uint16_t SrsHttpMessage::status_code()",
                "// Line 432: {",
                "// Line 433:     return _status;",
                "// vulnerable line: 434: }",
                "// Line 435: ",
                "// Line 436: string SrsHttpMessage::method_str()",
                "// Line 437: {",
                "// Line 438:     if (jsonp && !jsonp_method.empty()) {",
                "// Line 439:         return jsonp_method;",
                "// vulnerable line: 440: }",
                "// Line 441: ",
                "// Line 442:     return http_method_str((http_method)_method);",
                "// vulnerable line: 443: }",
                "// Line 444: ",
                "// Line 445: bool SrsHttpMessage::is_http_get()",
                "// Line 446: {",
                "// Line 447:     return method() == SRS_CONSTS_HTTP_GET;",
                "// vulnerable line: 448: }",
                "// Line 449: ",
                "// Line 450: bool SrsHttpMessage::is_http_put()",
                "// Line 451: {",
                "// Line 452:     return method() == SRS_CONSTS_HTTP_PUT;",
                "// vulnerable line: 453: }",
                "// Line 454: ",
                "// Line 455: bool SrsHttpMessage::is_http_post()",
                "// Line 456: {",
                "// Line 457:     return method() == SRS_CONSTS_HTTP_POST;",
                "// vulnerable line: 458: }",
                "// Line 459: ",
                "// Line 460: bool SrsHttpMessage::is_http_delete()",
                "// Line 461: {",
                "// Line 462:     return method() == SRS_CONSTS_HTTP_DELETE;",
                "// vulnerable line: 463: }",
                "// Line 464: ",
                "// Line 465: bool SrsHttpMessage::is_http_options()",
                "// Line 466: {",
                "// Line 467:     return _method == SRS_CONSTS_HTTP_OPTIONS;",
                "// vulnerable line: 468: }",
                "// Line 469: ",
                "// Line 470: bool SrsHttpMessage::is_chunked()",
                "// Line 471: {",
                "// Line 472:     return chunked;",
                "// vulnerable line: 473: }",
                "// Line 474: ",
                "// Line 475: bool SrsHttpMessage::is_keep_alive()",
                "// Line 476: {",
                "// Line 477:     return _keep_alive;",
                "// vulnerable line: 478: }",
                "// Line 479: ",
                "// Line 480: string SrsHttpMessage::uri()",
                "// Line 481: {",
                "// Line 482:     std::string uri = _uri->get_schema();",
                "// Line 483:     if (uri.empty()) {",
                "// Line 484:         uri += \"http\";",
                "// vulnerable line: 485: }",
                "// Line 486:     uri += \"://\";",
                "// Line 487:     ",
                "// Line 488:     uri += host();",
                "// Line 489:     uri += path();",
                "// Line 490:     ",
                "// Line 491:     return uri;",
                "// vulnerable line: 492: }",
                "// Line 493: ",
                "// Line 494: string SrsHttpMessage::url()",
                "// Line 495: {",
                "// Line 496:     return _uri->get_url();",
                "// vulnerable line: 497: }",
                "// Line 498: ",
                "// Line 499: string SrsHttpMessage::host()",
                "// Line 500: {",
                "// Line 501:     std::map<string, string>::iterator it = _query.find(\"vhost\");",
                "// Line 502:     if (it != _query.end() && !it->second.empty()) {",
                "// Line 503:         return it->second;",
                "// vulnerable line: 504: }",
                "// Line 505: ",
                "// Line 506:     it = _query.find(\"domain\");",
                "// Line 507:     if (it != _query.end() && !it->second.empty()) {",
                "// Line 508:         return it->second;",
                "// vulnerable line: 509: }",
                "// Line 510: ",
                "// Line 511:     return _uri->get_host();",
                "// vulnerable line: 512: }",
                "// Line 513: ",
                "// Line 514: int SrsHttpMessage::port()",
                "// Line 515: {",
                "// Line 516:     return _uri->get_port();",
                "// vulnerable line: 517: }",
                "// Line 518: ",
                "// Line 519: string SrsHttpMessage::path()",
                "// Line 520: {",
                "// Line 521:     return _uri->get_path();",
                "// vulnerable line: 522: }",
                "// Line 523: ",
                "// Line 524: string SrsHttpMessage::query()",
                "// Line 525: {",
                "// Line 526:     return _uri->get_query();",
                "// vulnerable line: 527: }",
                "// Line 528: ",
                "// Line 529: string SrsHttpMessage::ext()",
                "// Line 530: {",
                "// Line 531:     return _ext;",
                "// vulnerable line: 532: }",
                "// Line 533: ",
                "// Line 534: std::string SrsHttpMessage::parse_rest_id(string pattern)",
                "// Line 535: {",
                "// Line 536:     string p = _uri->get_path();",
                "// Line 537:     if (p.length() <= pattern.length()) {",
                "// Line 538:         return \"\";",
                "// vulnerable line: 539: }",
                "// Line 540:     ",
                "// Line 541:     string id = p.substr((int)pattern.length());",
                "// Line 542:     if (!id.empty()) {",
                "// Line 543:         return id;",
                "// vulnerable line: 544: }",
                "// Line 545:     ",
                "// Line 546:     return \"\";",
                "// vulnerable line: 547: }",
                "// Line 548: ",
                "// Line 549: srs_error_t SrsHttpMessage::body_read_all(string& body)",
                "// Line 550: {",
                "// Line 551:     return srs_ioutil_read_all(_body, body);",
                "// vulnerable line: 552: }",
                "// Line 553: ",
                "// Line 554: ISrsHttpResponseReader* SrsHttpMessage::body_reader()",
                "// Line 555: {",
                "// Line 556:     return _body;",
                "// vulnerable line: 557: }",
                "// Line 558: ",
                "// Line 559: int64_t SrsHttpMessage::content_length()",
                "// Line 560: {",
                "// Line 561:     return _content_length;",
                "// vulnerable line: 562: }",
                "// Line 563: ",
                "// Line 564: string SrsHttpMessage::query_get(string key)",
                "// Line 565: {",
                "// Line 566:     std::string v;",
                "// Line 567:     ",
                "// Line 568:     if (_query.find(key) != _query.end()) {",
                "// Line 569:         v = _query[key];",
                "// vulnerable line: 570: }",
                "// Line 571:     ",
                "// Line 572:     return v;",
                "// vulnerable line: 573: }",
                "// Line 574: ",
                "// Line 575: SrsHttpHeader* SrsHttpMessage::header()",
                "// Line 576: {",
                "// Line 577:     return &_header;",
                "// vulnerable line: 578: }",
                "// Line 579: ",
                "// Line 580: SrsRequest* SrsHttpMessage::to_request(string vhost)",
                "// Line 581: {",
                "// Line 582:     SrsRequest* req = new SrsRequest();",
                "// Line 583:     ",
                "// Line 584:     // http path, for instance, /live/livestream.flv, parse to",
                "// Line 585:     //      app: /live",
                "// Line 586:     //      stream: livestream.flv",
                "// Line 587:     srs_parse_rtmp_url(_uri->get_path(), req->app, req->stream);",
                "// Line 588:     ",
                "// Line 593:     req->stream = srs_path_filename(req->stream);",
                "// Line 594:     ",
                "// Line 595:     // generate others.",
                "// Line 596:     req->tcUrl = \"rtmp://\" + vhost + \"/\" + req->app;",
                "// Line 597:     req->pageUrl = _header.get(\"Referer\");",
                "// Line 598:     req->objectEncoding = 0;",
                "// Line 599: ",
                "// Line 600:     std::string query = _uri->get_query();",
                "// Line 601:     if (!query.empty()) {",
                "// Line 602:         req->param = \"?\" + query;",
                "// vulnerable line: 603: }",
                "// Line 604:     ",
                "// Line 605:     srs_discovery_tc_url(req->tcUrl, req->schema, req->host, req->vhost, req->app, req->stream, req->port, req->param);",
                "// Line 606:     req->strip();",
                "// Line 607:     ",
                "// Line 608:     // reset the host to http request host.",
                "// Line 609:     if (req->host == SRS_CONSTS_RTMP_DEFAULT_VHOST) {",
                "// Line 610:         req->host = _uri->get_host();",
                "// vulnerable line: 611: }",
                "// Line 612: ",
                "// Line 613:     // Set ip by remote ip of connection.",
                "// Line 614:     if (owner_conn) {",
                "// Line 615:         req->ip = owner_conn->remote_ip();",
                "// vulnerable line: 616: }",
                "// Line 617: ",
                "// Line 618:     // Overwrite by ip from proxy.",
                "// Line 619:     string oip = srs_get_original_ip(this);",
                "// Line 620:     if (!oip.empty()) {",
                "// Line 621:         req->ip = oip;",
                "// vulnerable line: 622: }",
                "// Line 623: ",
                "// Line 624:     // The request streaming protocol.",
                "// Line 625:     req->protocol = (schema_ == \"http\")? \"flv\" : \"flvs\";",
                "// Line 626:     ",
                "// Line 627:     return req;",
                "// vulnerable line: 628: }",
                "// Line 629: ",
                "// Line 630: bool SrsHttpMessage::is_jsonp()",
                "// Line 631: {",
                "// Line 632:     return jsonp;",
                "// vulnerable line: 633: }",
                "// Line 634: ",
                "// Line 635: ISrsHttpHeaderFilter::ISrsHttpHeaderFilter()",
                "// Line 636: {",
                "// vulnerable line: 637: }",
                "// Line 638: ",
                "// Line 639: ISrsHttpHeaderFilter::~ISrsHttpHeaderFilter()",
                "// Line 640: {",
                "// vulnerable line: 641: }",
                "// Line 642: ",
                "// Line 643: ISrsHttpFirstLineWriter::ISrsHttpFirstLineWriter()",
                "// Line 644: {",
                "// vulnerable line: 645: }",
                "// Line 646: ",
                "// Line 647: ISrsHttpFirstLineWriter::~ISrsHttpFirstLineWriter()",
                "// Line 648: {",
                "// vulnerable line: 649: }",
                "// Line 650: ",
                "// Line 651: SrsHttpMessageWriter::SrsHttpMessageWriter(ISrsProtocolReadWriter* io, ISrsHttpFirstLineWriter* flw)",
                "// Line 652: {",
                "// Line 653:     skt = io;",
                "// Line 654:     hdr = new SrsHttpHeader();",
                "// Line 655:     header_wrote_ = false;",
                "// Line 656:     content_length = -1;",
                "// Line 657:     written = 0;",
                "// Line 658:     header_sent = false;",
                "// Line 659:     nb_iovss_cache = 0;",
                "// Line 660:     iovss_cache = NULL;",
                "// Line 661:     hf_ = NULL;",
                "// Line 662:     flw_ = flw;",
                "// vulnerable line: 663: }",
                "// Line 664: ",
                "// Line 665: SrsHttpMessageWriter::~SrsHttpMessageWriter()",
                "// Line 666: {",
                "// Line 667:     srs_freep(hdr);",
                "// Line 668:     srs_freepa(iovss_cache);",
                "// vulnerable line: 669: }",
                "// Line 670: ",
                "// Line 671: srs_error_t SrsHttpMessageWriter::final_request()",
                "// Line 672: {",
                "// Line 673:     srs_error_t err = srs_success;",
                "// Line 674: ",
                "// Line 675:     // write the header data in memory.",
                "// Line 676:     if (!header_wrote_) {",
                "// Line 677:         flw_->write_default_header();",
                "// vulnerable line: 678: }",
                "// Line 679: ",
                "// Line 680:     // whatever header is wrote, we should try to send header.",
                "// Line 681:     if ((err = send_header(NULL, 0)) != srs_success) {",
                "// Line 682:         return srs_error_wrap(err, \"send header\");",
                "// vulnerable line: 683: }",
                "// Line 684:     ",
                "// Line 685:     // complete the chunked encoding.",
                "// Line 686:     if (content_length == -1) {",
                "// Line 687:         std::stringstream ss;",
                "// Line 688:         ss << 0 << SRS_HTTP_CRLF << SRS_HTTP_CRLF;",
                "// Line 689:         std::string ch = ss.str();",
                "// Line 690:         return skt->write((void*)ch.data(), (int)ch.length(), NULL);",
                "// vulnerable line: 691: }",
                "// Line 692:     ",
                "// Line 693:     // flush when send with content length",
                "// Line 694:     return write(NULL, 0);",
                "// vulnerable line: 695: }",
                "// Line 696: ",
                "// Line 697: SrsHttpHeader* SrsHttpMessageWriter::header()",
                "// Line 698: {",
                "// Line 699:     return hdr;",
                "// vulnerable line: 700: }",
                "// Line 701: ",
                "// Line 702: srs_error_t SrsHttpMessageWriter::write(char* data, int size)",
                "// Line 703: {",
                "// Line 704:     srs_error_t err = srs_success;",
                "// Line 705:     ",
                "// Line 706:     // write the header data in memory.",
                "// Line 707:     if (!header_wrote_) {",
                "// Line 708:         if (hdr->content_type().empty()) {",
                "// Line 709:             hdr->set_content_type(\"text/plain; charset=utf-8\");",
                "// vulnerable line: 710: }",
                "// Line 711:         if (hdr->content_length() == -1) {",
                "// Line 712:             hdr->set_content_length(size);",
                "// vulnerable line: 713: }",
                "// Line 714:         flw_->write_default_header();",
                "// vulnerable line: 715: }",
                "// Line 716:     ",
                "// Line 717:     // whatever header is wrote, we should try to send header.",
                "// Line 718:     if ((err = send_header(data, size)) != srs_success) {",
                "// Line 719:         return srs_error_wrap(err, \"send header\");",
                "// vulnerable line: 720: }",
                "// Line 721:     ",
                "// Line 722:     // check the bytes send and content length.",
                "// Line 723:     written += size;",
                "// Line 724:     if (content_length != -1 && written > content_length) {",
                "// Line 725:         return srs_error_new(ERROR_HTTP_CONTENT_LENGTH, \"overflow writen=%\" PRId64 \", max=%\" PRId64, written, content_length);",
                "// vulnerable line: 726: }",
                "// Line 727:     ",
                "// Line 728:     // ignore NULL content.",
                "// Line 729:     if (!data || size <= 0) {",
                "// Line 730:         return err;",
                "// vulnerable line: 731: }",
                "// Line 732:     ",
                "// Line 733:     // directly send with content length",
                "// Line 734:     if (content_length != -1) {",
                "// Line 735:         return skt->write((void*)data, size, NULL);",
                "// vulnerable line: 736: }",
                "// Line 737:     ",
                "// Line 738:     // send in chunked encoding.",
                "// Line 739:     int nb_size = snprintf(header_cache, SRS_HTTP_HEADER_CACHE_SIZE, \"%x\", size);",
                "// Line 740:     if (nb_size <= 0 || nb_size >= SRS_HTTP_HEADER_CACHE_SIZE) {",
                "// Line 741:         return srs_error_new(ERROR_HTTP_CONTENT_LENGTH, \"overflow size=%d, expect=%d\", size, nb_size);",
                "// vulnerable line: 742: }",
                "// Line 743:     ",
                "// Line 744:     iovec iovs[4];",
                "// Line 745:     iovs[0].iov_base = (char*)header_cache;",
                "// Line 746:     iovs[0].iov_len = (int)nb_size;",
                "// Line 747:     iovs[1].iov_base = (char*)SRS_HTTP_CRLF;",
                "// Line 748:     iovs[1].iov_len = 2;",
                "// Line 749:     iovs[2].iov_base = (char*)data;",
                "// Line 750:     iovs[2].iov_len = size;",
                "// Line 751:     iovs[3].iov_base = (char*)SRS_HTTP_CRLF;",
                "// Line 752:     iovs[3].iov_len = 2;",
                "// Line 753:     ",
                "// Line 754:     ssize_t nwrite = 0;",
                "// Line 755:     if ((err = skt->writev(iovs, 4, &nwrite)) != srs_success) {",
                "// Line 756:         return srs_error_wrap(err, \"write chunk\");",
                "// vulnerable line: 757: }",
                "// Line 758:     ",
                "// Line 759:     return err;",
                "// vulnerable line: 760: }",
                "// Line 761: ",
                "// Line 762: srs_error_t SrsHttpMessageWriter::writev(const iovec* iov, int iovcnt, ssize_t* pnwrite)",
                "// Line 763: {",
                "// Line 764:     srs_error_t err = srs_success;",
                "// Line 765:     ",
                "// Line 766:     // when header not ready, or not chunked, send one by one.",
                "// Line 767:     if (!header_wrote_ || content_length != -1) {",
                "// Line 768:         ssize_t nwrite = 0;",
                "// Line 769:         for (int i = 0; i < iovcnt; i++) {",
                "// Line 770:             nwrite += iov[i].iov_len;",
                "// Line 771:             if ((err = write((char*)iov[i].iov_base, (int)iov[i].iov_len)) != srs_success) {",
                "// Line 772:                 return srs_error_wrap(err, \"writev\");",
                "// vulnerable line: 773: }",
                "// vulnerable line: 774: }",
                "// Line 775:         ",
                "// Line 776:         if (pnwrite) {",
                "// Line 777:             *pnwrite = nwrite;",
                "// vulnerable line: 778: }",
                "// Line 779:         ",
                "// Line 780:         return err;",
                "// vulnerable line: 781: }",
                "// Line 782:     ",
                "// Line 783:     // ignore NULL content.",
                "// Line 784:     if (iovcnt <= 0) {",
                "// Line 785:         return err;",
                "// vulnerable line: 786: }",
                "// Line 787: ",
                "// Line 788:     // whatever header is wrote, we should try to send header.",
                "// Line 789:     if ((err = send_header(NULL, 0)) != srs_success) {",
                "// Line 790:         return srs_error_wrap(err, \"send header\");",
                "// vulnerable line: 791: }",
                "// Line 792:     ",
                "// Line 793:     // send in chunked encoding.",
                "// Line 794:     int nb_iovss = 3 + iovcnt;",
                "// Line 795:     iovec* iovss = iovss_cache;",
                "// Line 796:     if (nb_iovss_cache < nb_iovss) {",
                "// Line 797:         srs_freepa(iovss_cache);",
                "// Line 798:         nb_iovss_cache = nb_iovss;",
                "// Line 799:         iovss = iovss_cache = new iovec[nb_iovss];",
                "// vulnerable line: 800: }",
                "// Line 801:     ",
                "// Line 802:     // Send all iovs in one chunk, the size is the total size of iovs.",
                "// Line 803:     int size = 0;",
                "// Line 804:     for (int i = 0; i < iovcnt; i++) {",
                "// Line 805:         const iovec* data_iov = iov + i;",
                "// Line 806:         size += data_iov->iov_len;",
                "// vulnerable line: 807: }",
                "// Line 808:     written += size;",
                "// Line 809:     ",
                "// Line 810:     // chunk header",
                "// Line 811:     int nb_size = snprintf(header_cache, SRS_HTTP_HEADER_CACHE_SIZE, \"%x\", size);",
                "// Line 812:     if (nb_size <= 0 || nb_size >= SRS_HTTP_HEADER_CACHE_SIZE) {",
                "// Line 813:         return srs_error_new(ERROR_HTTP_CONTENT_LENGTH, \"overflow size=%d, expect=%d\", size, nb_size);",
                "// vulnerable line: 814: }",
                "// Line 815:     iovss[0].iov_base = (char*)header_cache;",
                "// Line 816:     iovss[0].iov_len = (int)nb_size;",
                "// Line 817: ",
                "// Line 818:     // chunk header eof.",
                "// Line 819:     iovss[1].iov_base = (char*)SRS_HTTP_CRLF;",
                "// Line 820:     iovss[1].iov_len = 2;",
                "// Line 821: ",
                "// Line 822:     // chunk body.",
                "// Line 823:     for (int i = 0; i < iovcnt; i++) {",
                "// Line 824:         iovss[2+i].iov_base = (char*)iov[i].iov_base;",
                "// Line 825:         iovss[2+i].iov_len = (int)iov[i].iov_len;",
                "// vulnerable line: 826: }",
                "// Line 827:     ",
                "// Line 828:     // chunk body eof.",
                "// Line 829:     iovss[2+iovcnt].iov_base = (char*)SRS_HTTP_CRLF;",
                "// Line 830:     iovss[2+iovcnt].iov_len = 2;",
                "// Line 831: ",
                "// Line 832:     // sendout all ioves.",
                "// Line 833:     ssize_t nwrite = 0;",
                "// Line 834:     if ((err = srs_write_large_iovs(skt, iovss, nb_iovss, &nwrite)) != srs_success) {",
                "// Line 835:         return srs_error_wrap(err, \"writev large iovs\");",
                "// vulnerable line: 836: }",
                "// Line 837:     ",
                "// Line 838:     if (pnwrite) {",
                "// Line 839:         *pnwrite = nwrite;",
                "// vulnerable line: 840: }",
                "// Line 841:     ",
                "// Line 842:     return err;",
                "// vulnerable line: 843: }",
                "// Line 844: ",
                "// Line 845: void SrsHttpMessageWriter::write_header()",
                "// Line 846: {",
                "// Line 847:     if (header_wrote_) return;",
                "// Line 848:     header_wrote_ = true;",
                "// Line 849:     ",
                "// Line 850:     // parse the content length from header.",
                "// Line 851:     content_length = hdr->content_length();",
                "// vulnerable line: 852: }",
                "// Line 853: ",
                "// Line 854: srs_error_t SrsHttpMessageWriter::send_header(char* data, int size)",
                "// Line 855: {",
                "// Line 856:     srs_error_t err = srs_success;",
                "// Line 857:     ",
                "// Line 858:     if (header_sent) {",
                "// Line 859:         return err;",
                "// vulnerable line: 860: }",
                "// Line 861:     header_sent = true;",
                "// Line 862:     ",
                "// Line 863:     std::stringstream ss;",
                "// Line 864: ",
                "// Line 865:     // First line, the request line or status line.",
                "// Line 866:     if ((err = flw_->build_first_line(ss, data, size)) != srs_success) {",
                "// Line 867:         return srs_error_wrap(err, \"first line\");",
                "// vulnerable line: 868: }",
                "// Line 869:     ",
                "// Line 870:     // set server if not set.",
                "// Line 871:     if (hdr->get(\"Server\").empty()) {",
                "// Line 872:         hdr->set(\"Server\", RTMP_SIG_SRS_SERVER);",
                "// vulnerable line: 873: }",
                "// Line 874:     ",
                "// Line 875:     // chunked encoding",
                "// Line 876:     if (content_length == -1) {",
                "// Line 877:         hdr->set(\"Transfer-Encoding\", \"chunked\");",
                "// vulnerable line: 878: }",
                "// Line 879:     ",
                "// Line 880:     // keep alive to make vlc happy.",
                "// Line 881:     if (hdr->get(\"Connection\").empty()) {",
                "// Line 882:         hdr->set(\"Connection\", \"Keep-Alive\");",
                "// vulnerable line: 883: }",
                "// Line 884: ",
                "// Line 885:     // Filter the header before writing it.",
                "// Line 886:     if (hf_ && ((err = hf_->filter(hdr)) != srs_success)) {",
                "// Line 887:         return srs_error_wrap(err, \"filter header\");",
                "// vulnerable line: 888: }",
                "// Line 889:     ",
                "// Line 890:     // write header",
                "// Line 891:     hdr->write(ss);",
                "// Line 892:     ",
                "// Line 893:     // header_eof",
                "// Line 894:     ss << SRS_HTTP_CRLF;",
                "// Line 895:     ",
                "// Line 896:     std::string buf = ss.str();",
                "// Line 897:     return skt->write((void*)buf.c_str(), buf.length(), NULL);",
                "// vulnerable line: 898: }",
                "// Line 899: ",
                "// Line 900: bool SrsHttpMessageWriter::header_wrote()",
                "// Line 901: {",
                "// Line 902:     return header_wrote_;",
                "// vulnerable line: 903: }",
                "// Line 904: ",
                "// Line 905: void SrsHttpMessageWriter::set_header_filter(ISrsHttpHeaderFilter* hf)",
                "// Line 906: {",
                "// Line 907:     hf_ = hf;",
                "// vulnerable line: 908: }",
                "// Line 909: ",
                "// Line 910: SrsHttpResponseWriter::SrsHttpResponseWriter(ISrsProtocolReadWriter* io)",
                "// Line 911: {",
                "// Line 912:     writer_ = new SrsHttpMessageWriter(io, this);",
                "// Line 913:     status = SRS_CONSTS_HTTP_OK;",
                "// vulnerable line: 914: }",
                "// Line 915: ",
                "// Line 916: SrsHttpResponseWriter::~SrsHttpResponseWriter()",
                "// Line 917: {",
                "// Line 918:     srs_freep(writer_);",
                "// vulnerable line: 919: }",
                "// Line 920: ",
                "// Line 921: void SrsHttpResponseWriter::set_header_filter(ISrsHttpHeaderFilter* hf)",
                "// Line 922: {",
                "// Line 923:     writer_->set_header_filter(hf);",
                "// vulnerable line: 924: }",
                "// Line 925: ",
                "// Line 926: srs_error_t SrsHttpResponseWriter::final_request()",
                "// Line 927: {",
                "// Line 928:     return writer_->final_request();",
                "// vulnerable line: 929: }",
                "// Line 930: ",
                "// Line 931: SrsHttpHeader* SrsHttpResponseWriter::header()",
                "// Line 932: {",
                "// Line 933:     return writer_->header();",
                "// vulnerable line: 934: }",
                "// Line 935: ",
                "// Line 936: srs_error_t SrsHttpResponseWriter::write(char* data, int size)",
                "// Line 937: {",
                "// Line 938:     return writer_->write(data, size);",
                "// vulnerable line: 939: }",
                "// Line 940: ",
                "// Line 941: srs_error_t SrsHttpResponseWriter::writev(const iovec* iov, int iovcnt, ssize_t* pnwrite)",
                "// Line 942: {",
                "// Line 943:     return writer_->writev(iov, iovcnt, pnwrite);",
                "// vulnerable line: 944: }",
                "// Line 945: ",
                "// Line 946: void SrsHttpResponseWriter::write_header(int code)",
                "// Line 947: {",
                "// Line 948:     if (writer_->header_wrote()) {",
                "// Line 949:         srs_warn(\"http: multiple write_header calls, status=%d, code=%d\", status, code);",
                "// Line 950:         return;",
                "// vulnerable line: 951: }",
                "// Line 952: ",
                "// Line 953:     status = code;",
                "// Line 954:     return writer_->write_header();",
                "// vulnerable line: 955: }",
                "// Line 956: ",
                "// Line 957: srs_error_t SrsHttpResponseWriter::build_first_line(std::stringstream& ss, char* data, int size)",
                "// Line 958: {",
                "// Line 959:     srs_error_t err = srs_success;",
                "// Line 960: ",
                "// Line 961:     // Write status line for response.",
                "// Line 962:     ss << \"HTTP/1.1 \" << status << \" \" << srs_generate_http_status_text(status) << SRS_HTTP_CRLF;",
                "// Line 963: ",
                "// Line 964:     // Try to detect content type from response body data.",
                "// Line 965:     SrsHttpHeader* hdr = writer_->header();",
                "// Line 966:     if (srs_go_http_body_allowd(status)) {",
                "// Line 967:         if (data && hdr->content_type().empty()) {",
                "// Line 968:             hdr->set_content_type(srs_go_http_detect(data, size));",
                "// vulnerable line: 969: }",
                "// vulnerable line: 970: }",
                "// Line 971: ",
                "// Line 972:     return err;",
                "// vulnerable line: 973: }",
                "// Line 974: ",
                "// Line 975: void SrsHttpResponseWriter::write_default_header()",
                "// Line 976: {",
                "// Line 977:     write_header(SRS_CONSTS_HTTP_OK);",
                "// vulnerable line: 978: }",
                "// Line 979: ",
                "// Line 980: SrsHttpRequestWriter::SrsHttpRequestWriter(ISrsProtocolReadWriter* io)",
                "// Line 981: {",
                "// Line 982:     writer_ = new SrsHttpMessageWriter(io, this);",
                "// vulnerable line: 983: }",
                "// Line 984: ",
                "// Line 985: SrsHttpRequestWriter::~SrsHttpRequestWriter()",
                "// Line 986: {",
                "// Line 987:     srs_freep(writer_);",
                "// vulnerable line: 988: }",
                "// Line 989: ",
                "// Line 990: srs_error_t SrsHttpRequestWriter::final_request()",
                "// Line 991: {",
                "// Line 992:     return writer_->final_request();",
                "// vulnerable line: 993: }",
                "// Line 994: ",
                "// Line 995: SrsHttpHeader* SrsHttpRequestWriter::header()",
                "// Line 996: {",
                "// Line 997:     return writer_->header();",
                "// vulnerable line: 998: }",
                "// Line 999: ",
                "// Line 1000: srs_error_t SrsHttpRequestWriter::write(char* data, int size)",
                "// Line 1001: {",
                "// Line 1002:     return writer_->write(data, size);",
                "// vulnerable line: 1003: }",
                "// Line 1004: ",
                "// Line 1005: srs_error_t SrsHttpRequestWriter::writev(const iovec* iov, int iovcnt, ssize_t* pnwrite)",
                "// Line 1006: {",
                "// Line 1007:     return writer_->writev(iov, iovcnt, pnwrite);",
                "// vulnerable line: 1008: }",
                "// Line 1009: ",
                "// Line 1010: void SrsHttpRequestWriter::write_header(const std::string& method, const std::string& path)",
                "// Line 1011: {",
                "// Line 1012:     if (writer_->header_wrote()) {",
                "// Line 1013:         srs_warn(\"http: multiple write_header calls, current=%s(%s), now=%s(%s)\", method_.c_str(), path_.c_str(), method.c_str(), path.c_str());",
                "// Line 1014:         return;",
                "// vulnerable line: 1015: }",
                "// Line 1016: ",
                "// Line 1017:     method_ = method;",
                "// Line 1018:     path_ = path;",
                "// Line 1019:     return writer_->write_header();",
                "// vulnerable line: 1020: }",
                "// Line 1021: ",
                "// Line 1022: srs_error_t SrsHttpRequestWriter::build_first_line(std::stringstream& ss, char* data, int size)",
                "// Line 1023: {",
                "// Line 1024:     srs_error_t err = srs_success;",
                "// Line 1025: ",
                "// Line 1026:     // Write status line for response.",
                "// Line 1027:     ss << method_ << \" \" << path_ << \" HTTP/1.1\" << SRS_HTTP_CRLF;",
                "// Line 1028: ",
                "// Line 1029:     // Try to detect content type from request body data.",
                "// Line 1030:     SrsHttpHeader* hdr = writer_->header();",
                "// Line 1031:     if (data && hdr->content_type().empty()) {",
                "// Line 1032:         hdr->set_content_type(srs_go_http_detect(data, size));",
                "// vulnerable line: 1033: }",
                "// Line 1034: ",
                "// Line 1035:     return err;",
                "// vulnerable line: 1036: }",
                "// Line 1037: ",
                "// Line 1038: void SrsHttpRequestWriter::write_default_header()",
                "// Line 1039: {",
                "// Line 1040:     write_header(\"GET\", \"/\");",
                "// vulnerable line: 1041: }",
                "// Line 1042: ",
                "// Line 1043: SrsHttpResponseReader::SrsHttpResponseReader(SrsHttpMessage* msg, ISrsReader* reader, SrsFastStream* body)",
                "// Line 1044: {",
                "// Line 1045:     skt = reader;",
                "// Line 1046:     owner = msg;",
                "// Line 1047:     is_eof = false;",
                "// Line 1048:     nb_total_read = 0;",
                "// Line 1049:     nb_left_chunk = 0;",
                "// Line 1050:     buffer = body;",
                "// Line 1051:     nb_chunk = 0;",
                "// vulnerable line: 1052: }",
                "// Line 1053: ",
                "// Line 1054: SrsHttpResponseReader::~SrsHttpResponseReader()",
                "// Line 1055: {",
                "// vulnerable line: 1056: }",
                "// Line 1057: ",
                "// Line 1058: void SrsHttpResponseReader::close()",
                "// Line 1059: {",
                "// Line 1060:     is_eof = true;",
                "// vulnerable line: 1061: }",
                "// Line 1062: ",
                "// Line 1063: bool SrsHttpResponseReader::eof()",
                "// Line 1064: {",
                "// Line 1065:     return is_eof;",
                "// vulnerable line: 1066: }",
                "// Line 1067: ",
                "// Line 1068: srs_error_t SrsHttpResponseReader::read(void* data, size_t nb_data, ssize_t* nb_read)",
                "// Line 1069: {",
                "// Line 1070:     srs_error_t err = srs_success;",
                "// Line 1071:     ",
                "// Line 1072:     if (is_eof) {",
                "// Line 1073:         return srs_error_new(ERROR_HTTP_RESPONSE_EOF, \"EOF\");",
                "// vulnerable line: 1074: }",
                "// Line 1075:     ",
                "// Line 1076:     // chunked encoding.",
                "// Line 1077:     if (owner->is_chunked()) {",
                "// Line 1078:         return read_chunked(data, nb_data, nb_read);",
                "// vulnerable line: 1079: }",
                "// Line 1080:     ",
                "// Line 1081:     // read by specified content-length",
                "// Line 1082:     if (owner->content_length() != -1) {",
                "// Line 1083:         size_t max = (size_t)owner->content_length() - (size_t)nb_total_read;",
                "// Line 1084:         if (max <= 0) {",
                "// Line 1085:             is_eof = true;",
                "// Line 1086:             return err;",
                "// vulnerable line: 1087: }",
                "// Line 1088:         ",
                "// Line 1089:         // change the max to read.",
                "// Line 1090:         nb_data = srs_min(nb_data, max);",
                "// Line 1091:         return read_specified(data, nb_data, nb_read);",
                "// vulnerable line: 1092: }",
                "// Line 1093:     ",
                "// Line 1094:     // Infinite chunked mode.",
                "// Line 1095:     // If not chunked encoding, and no content-length, it's infinite chunked.",
                "// Line 1096:     // In this mode, all body is data and never EOF util socket closed.",
                "// Line 1097:     if ((err = read_specified(data, nb_data, nb_read)) != srs_success) {",
                "// Line 1098:         // For infinite chunked, the socket close event is EOF.",
                "// Line 1099:         if (srs_error_code(err) == ERROR_SOCKET_READ) {",
                "// Line 1100:             srs_freep(err); is_eof = true;",
                "// Line 1101:             return err;",
                "// vulnerable line: 1102: }",
                "// vulnerable line: 1103: }",
                "// Line 1104: ",
                "// Line 1105:     return err;",
                "// vulnerable line: 1106: }",
                "// Line 1107: ",
                "// Line 1108: srs_error_t SrsHttpResponseReader::read_chunked(void* data, size_t nb_data, ssize_t* nb_read)",
                "// Line 1109: {",
                "// Line 1110:     srs_error_t err = srs_success;",
                "// Line 1111:     ",
                "// Line 1112:     // when no bytes left in chunk,",
                "// Line 1113:     // parse the chunk length first.",
                "// Line 1114:     if (nb_left_chunk <= 0) {",
                "// Line 1115:         char* at = NULL;",
                "// Line 1116:         int length = 0;",
                "// Line 1117:         while (!at) {",
                "// Line 1118:             // find the CRLF of chunk header end.",
                "// Line 1119:             char* start = buffer->bytes();",
                "// Line 1120:             char* end = start + buffer->size();",
                "// Line 1121:             for (char* p = start; p < end - 1; p++) {",
                "// Line 1122:                 if (p[0] == SRS_HTTP_CR && p[1] == SRS_HTTP_LF) {",
                "// Line 1123:                     // invalid chunk, ignore.",
                "// Line 1124:                     if (p == start) {",
                "// Line 1125:                         return srs_error_new(ERROR_HTTP_INVALID_CHUNK_HEADER, \"chunk header\");",
                "// vulnerable line: 1126: }",
                "// Line 1127:                     length = (int)(p - start + 2);",
                "// Line 1128:                     at = buffer->read_slice(length);",
                "// Line 1129:                     break;",
                "// vulnerable line: 1130: }",
                "// vulnerable line: 1131: }",
                "// Line 1132:             ",
                "// Line 1133:             // got at, ok.",
                "// Line 1134:             if (at) {",
                "// Line 1135:                 break;",
                "// vulnerable line: 1136: }",
                "// Line 1137:             ",
                "// Line 1138:             // when empty, only grow 1bytes, but the buffer will cache more.",
                "// Line 1139:             if ((err = buffer->grow(skt, buffer->size() + 1)) != srs_success) {",
                "// Line 1140:                 return srs_error_wrap(err, \"grow buffer\");",
                "// vulnerable line: 1141: }",
                "// vulnerable line: 1142: }",
                "// Line 1143:         srs_assert(length >= 3);",
                "// Line 1144:         ",
                "// Line 1145:         // it's ok to set the pos and pos+1 to NULL.",
                "// Line 1146:         at[length - 1] = 0;",
                "// Line 1147:         at[length - 2] = 0;",
                "// Line 1148: ",
                "// Line 1149:         // size is the bytes size, excludes the chunk header and end CRLF.",
                "// Line 1150:         // @remark It must be hex format, please read https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding#Directives",
                "// Line 1151:         // @remark For strtol, note that: If no conversion could be performed, 0 is returned and the global variable errno is set to EINVAL.",
                "// Line 1152:         char* at_parsed = at; errno = 0;",
                "// Line 1153:         int ilength = (int)::strtol(at, &at_parsed, 16);",
                "// Line 1154:         if (ilength < 0 || errno != 0 || at_parsed - at != length - 2) {",
                "// Line 1155:             return srs_error_new(ERROR_HTTP_INVALID_CHUNK_HEADER, \"invalid length %s as %d, parsed=%.*s, errno=%d\",",
                "// Line 1156:                 at, ilength, (int)(at_parsed-at), at, errno);",
                "// vulnerable line: 1157: }",
                "// Line 1158:         ",
                "// Line 1159:         // all bytes in chunk is left now.",
                "// Line 1160:         nb_chunk = nb_left_chunk = (size_t)ilength;",
                "// vulnerable line: 1161: }",
                "// Line 1162:     ",
                "// Line 1163:     if (nb_chunk <= 0) {",
                "// Line 1164:         // for the last chunk, eof.",
                "// Line 1165:         is_eof = true;",
                "// Line 1166:         if (nb_read) {",
                "// Line 1167:             *nb_read = 0;",
                "// vulnerable line: 1168: }",
                "// Line 1169:     } else {",
                "// Line 1170:         // for not the last chunk, there must always exists bytes.",
                "// Line 1171:         // left bytes in chunk, read some.",
                "// Line 1172:         srs_assert(nb_left_chunk);",
                "// Line 1173:         ",
                "// Line 1174:         size_t nb_bytes = srs_min(nb_left_chunk, nb_data);",
                "// Line 1175:         err = read_specified(data, nb_bytes, (ssize_t*)&nb_bytes);",
                "// Line 1176:         ",
                "// Line 1177:         // the nb_bytes used for output already read size of bytes.",
                "// Line 1178:         if (nb_read) {",
                "// Line 1179:             *nb_read = nb_bytes;",
                "// vulnerable line: 1180: }",
                "// Line 1181:         nb_left_chunk -= nb_bytes;",
                "// Line 1182: ",
                "// Line 1183:         if (err != srs_success) {",
                "// Line 1184:             return srs_error_wrap(err, \"read specified\");",
                "// vulnerable line: 1185: }",
                "// Line 1186: ",
                "// Line 1187:         // If still left bytes in chunk, ignore and read in future.",
                "// Line 1188:         if (nb_left_chunk > 0) {",
                "// Line 1189:             return err;",
                "// vulnerable line: 1190: }",
                "// vulnerable line: 1191: }",
                "// Line 1192:     ",
                "// Line 1193:     // for both the last or not, the CRLF of chunk payload end.",
                "// Line 1194:     if ((err = buffer->grow(skt, 2)) != srs_success) {",
                "// Line 1195:         return srs_error_wrap(err, \"grow buffer\");",
                "// vulnerable line: 1196: }",
                "// Line 1197:     buffer->read_slice(2);",
                "// Line 1198:     ",
                "// Line 1199:     return err;",
                "// vulnerable line: 1200: }",
                "// Line 1201: ",
                "// Line 1202: srs_error_t SrsHttpResponseReader::read_specified(void* data, size_t nb_data, ssize_t* nb_read)",
                "// Line 1203: {",
                "// Line 1204:     srs_error_t err = srs_success;",
                "// Line 1205:     ",
                "// Line 1206:     if (buffer->size() <= 0) {",
                "// Line 1207:         // when empty, only grow 1bytes, but the buffer will cache more.",
                "// Line 1208:         if ((err = buffer->grow(skt, 1)) != srs_success) {",
                "// Line 1209:             return srs_error_wrap(err, \"grow buffer\");",
                "// vulnerable line: 1210: }",
                "// vulnerable line: 1211: }",
                "// Line 1212:     ",
                "// Line 1213:     size_t nb_bytes = srs_min(nb_data, (size_t)buffer->size());",
                "// Line 1214:     ",
                "// Line 1215:     // read data to buffer.",
                "// Line 1216:     srs_assert(nb_bytes);",
                "// Line 1217:     char* p = buffer->read_slice(nb_bytes);",
                "// Line 1218:     memcpy(data, p, nb_bytes);",
                "// Line 1219:     if (nb_read) {",
                "// Line 1220:         *nb_read = nb_bytes;",
                "// vulnerable line: 1221: }",
                "// Line 1222:     ",
                "// Line 1223:     // increase the total read to determine whether EOF.",
                "// Line 1224:     nb_total_read += nb_bytes;",
                "// Line 1225:     ",
                "// Line 1226:     // for not chunked and specified content length.",
                "// Line 1227:     if (!owner->is_chunked() && owner->content_length() != -1) {",
                "// Line 1228:         // when read completed, eof.",
                "// Line 1229:         if (nb_total_read >= (int)owner->content_length()) {",
                "// Line 1230:             is_eof = true;",
                "// vulnerable line: 1231: }",
                "// vulnerable line: 1232: }",
                "// Line 1233:     ",
                "// Line 1234:     return err;",
                "// vulnerable line: 1235: }",
                "// Line 1236: "
            ]
        },
        {
            "filename_of_changes": "srs_utest_protocol3.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "16",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}