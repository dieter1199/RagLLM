{
    "cve_id": "CVE-2023-50257",
    "cve_description": "eProsima Fast DDS (formerly Fast RTPS) is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected. Moreover, if this disconnection packet is sent continuously, the Subscribers (Listeners) trying to connect will not be able to do so. Since the initial commit of the `SecurityManager.cpp` code (`init`, `on_process_handshake`) on Nov 8, 2016, the Disconnect Vulnerability in RTPS Packets Used by SROS2 has been present prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7.",
    "cve_publish_date": "2024-02-19T20:15Z",
    "cwe_id": "CWE-284",
    "cwe_name": "Improper Access Control",
    "cwe_description": "The product does not restrict or incorrectly restricts access to a resource from an unauthorized actor.",
    "commit_message": "Refs #1811. WIP SecurityManager.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "BuiltinPKIDHTests.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "0",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "CDRMessage.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "18",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "PKIDH.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 991:     delete ih;",
                "// Line 992: ",
                "// Line 993:     ERR_clear_error();",
                "// Line 994: ",
                "// Line 995:     return ValidationResult_t::VALIDATION_FAILED;",
                "// Line 996: }",
                "// Line 997: ",
                "// Line 998: ValidationResult_t PKIDH::validate_remote_identity(IdentityHandle** remote_identity_handle,",
                "// Line 999:         const IdentityHandle& local_identity_handle,",
                "// Line 1000:         IdentityToken&& remote_identity_token,",
                "// vulnerable line: 1001: const GUID_t remote_participant_key,",
                "// Line 1002:         SecurityException& exception)",
                "// Line 1003: {",
                "// Line 1004:     assert(remote_identity_handle);",
                "// Line 1005:     assert(local_identity_handle.nil() == false);",
                "// Line 1006: ",
                "// Line 1007:     ValidationResult_t returnedValue = ValidationResult_t::VALIDATION_FAILED;",
                "// Line 1008: ",
                "// Line 1009:     const PKIIdentityHandle& lih = PKIIdentityHandle::narrow(local_identity_handle);",
                "// Line 1010: ",
                "// Line 1011:     if(!lih.nil())"
            ]
        },
        {
            "filename_of_changes": "RTPSParticipantImpl.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 53: ",
                "// Line 54: ",
                "// Line 55: ",
                "// Line 56: namespace eprosima {",
                "// Line 57: namespace fastrtps{",
                "// Line 58: namespace rtps {",
                "// Line 59: ",
                "// Line 60: ",
                "// Line 61: ",
                "// Line 62: static EntityId_t TrustedWriter(const EntityId_t& reader)",
                "// vulnerable line: 63: {",
                "// Line 64:     if(reader == c_EntityId_SPDPReader) return c_EntityId_SPDPWriter;",
                "// Line 65:     if(reader == c_EntityId_SEDPPubReader) return c_EntityId_SEDPPubWriter;",
                "// Line 66:     if(reader == c_EntityId_SEDPSubReader) return c_EntityId_SEDPSubWriter;",
                "// Line 67:     if(reader == c_EntityId_ReaderLiveliness) return c_EntityId_WriterLiveliness;",
                "// Line 68: ",
                "// Line 69:     return c_EntityId_Unknown;",
                "// vulnerable line: 70: }",
                "// Line 71: ",
                "// Line 72: Locator_t RTPSParticipantImpl::applyLocatorAdaptRule(Locator_t loc)",
                "// vulnerable line: 73: {",
                "// Line 74:     switch (loc.kind){",
                "// Line 75:         case LOCATOR_KIND_UDPv4:",
                "// Line 76:             //This is a completely made up rule",
                "// Line 77:             loc.port += 2;",
                "// Line 78:             break;",
                "// Line 79:         case LOCATOR_KIND_UDPv6:",
                "// Line 80:             //TODO - Define the rest of rules",
                "// Line 81:             loc.port += 2;",
                "// Line 82:             break;",
                "// vulnerable line: 83: }",
                "// Line 84:     return loc;",
                "// vulnerable line: 85: }",
                "// Line 86: ",
                "// Line 87: RTPSParticipantImpl::RTPSParticipantImpl(const RTPSParticipantAttributes& PParam,",
                "// Line 88:         const GuidPrefix_t& guidP,",
                "// Line 89:         RTPSParticipant* par,",
                "// vulnerable line: 90: RTPSParticipantListener* plisten):    m_att(PParam), m_guid(guidP,c_EntityId_RTPSParticipant),",
                "// Line 91:     mp_event_thr(nullptr),",
                "// Line 92:     mp_builtinProtocols(nullptr),",
                "// Line 93:     mp_ResourceSemaphore(new boost::interprocess::interprocess_semaphore(0)),",
                "// Line 94:     IdCounter(0),",
                "// Line 95:     mp_participantListener(plisten),",
                "// Line 96:     mp_userParticipant(par),",
                "// Line 97:     mp_mutex(new boost::recursive_mutex())",
                "// Line 98: ",
                "// vulnerable line: 99: {",
                "// Line 100:     // Builtin transport by default",
                "// Line 101:     if (PParam.useBuiltinTransports)",
                "// vulnerable line: 102: {",
                "// Line 103:         UDPv4TransportDescriptor descriptor; ",
                "// Line 104:         descriptor.sendBufferSize = m_att.sendSocketBufferSize;",
                "// Line 105:         descriptor.receiveBufferSize = m_att.listenSocketBufferSize;",
                "// Line 106:         m_network_Factory.RegisterTransport(&descriptor);",
                "// vulnerable line: 107: }",
                "// Line 108: ",
                "// Line 109:     // User defined transports",
                "// Line 110:     for (const auto& transportDescriptor : PParam.userTransports)",
                "// Line 111:         m_network_Factory.RegisterTransport(transportDescriptor.get());",
                "// Line 112: ",
                "// Line 113:     boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);",
                "// Line 114:     mp_userParticipant->mp_impl = this;",
                "// Line 115:     Locator_t loc;",
                "// Line 116:     loc.port = PParam.defaultSendPort;",
                "// Line 117:     mp_event_thr = new ResourceEvent();",
                "// Line 118:     mp_event_thr->init_thread(this);",
                "// Line 119: ",
                "// Line 120: ",
                "// Line 121:     // Throughput controller, if the descriptor has valid values",
                "// Line 122:     if (PParam.throughputController.bytesPerPeriod != UINT32_MAX &&",
                "// Line 123:             PParam.throughputController.periodMillisecs != 0)",
                "// vulnerable line: 124: {",
                "// Line 125:         std::unique_ptr<FlowController> controller(new ThroughputController(PParam.throughputController, this));",
                "// Line 126:         m_controllers.push_back(std::move(controller));",
                "// vulnerable line: 127: }",
                "// Line 128: ",
                "// Line 129:     bool hasLocatorsDefined = true;",
                "// Line 130:     //If no default locators are defined we define some.",
                "// Line 131:     /* The reasoning here is the following.",
                "// Line 132:        If the parameters of the RTPS Participant don't hold default listening locators for the creation",
                "// Line 133:        of Endpoints, we make some for Unicast only.",
                "// Line 134:        If there is at least one listen locator of any kind, we do not create any default ones.",
                "// Line 135:        If there are no sending locators defined, we create default ones for the transports we implement.",
                "// Line 136:        */",
                "// Line 137:     if(m_att.defaultUnicastLocatorList.empty() && m_att.defaultMulticastLocatorList.empty())",
                "// vulnerable line: 138: {",
                "// Line 139:         //Default Unicast Locators in case they have not been provided",
                "// Line 140:         /* INSERT DEFAULT UNICAST LOCATORS FOR THE PARTICIPANT */",
                "// Line 141:         hasLocatorsDefined = false;",
                "// Line 142:         Locator_t loc2;",
                "// Line 143: ",
                "// Line 144:         LocatorList_t loclist;",
                "// Line 145:         IPFinder::getIP4Address(&loclist);",
                "// Line 146:         for(auto it=loclist.begin();it!=loclist.end();++it){",
                "// Line 147:             (*it).port=m_att.port.portBase+",
                "// Line 148:                 m_att.port.domainIDGain*PParam.builtin.domainId+",
                "// Line 149:                 m_att.port.offsetd3+",
                "// Line 150:                 m_att.port.participantIDGain*m_att.participantID;",
                "// Line 151:             (*it).kind = LOCATOR_KIND_UDPv4;",
                "// Line 152: ",
                "// Line 153:             m_att.defaultUnicastLocatorList.push_back((*it));",
                "// vulnerable line: 154: }",
                "// Line 155:         // FIXME -- We have to  discuss the rules for deafult locator assignment for each transport",
                "// Line 156:         loc2.port= m_att.port.portBase+",
                "// Line 157:             m_att.port.domainIDGain*PParam.builtin.domainId+",
                "// Line 158:             m_att.port.offsetd2+",
                "// Line 159:             m_att.port.participantIDGain*m_att.participantID;",
                "// Line 160:         loc2.set_IP4_address(239,255,1,4);",
                "// Line 161:         m_att.defaultMulticastLocatorList.push_back(loc2);",
                "// Line 162:         /* INSERT DEFAULT MULTICAST LOCATORS FOR THE PARTICIPANT */",
                "// vulnerable line: 163: }",
                "// Line 164:     else",
                "// vulnerable line: 165: {",
                "// Line 166:         // Normalize unicast locators.",
                "// Line 167:         m_network_Factory.NormalizeLocators(m_att.defaultUnicastLocatorList);",
                "// vulnerable line: 168: }",
                "// Line 169: ",
                "// Line 170:     /*    ",
                "// Line 171:         Since nothing guarantees the correct creation of the Resources on the Locators we have specified, and ",
                "// Line 172:         in order to maintain synchrony between the defaultLocator list and the actuar ReceiveResources,",
                "// Line 173:         We create the resources for these Locators now. Furthermore, in case these resources are taken, ",
                "// Line 174:         we create them on another Locator and then update de defaultList.",
                "// Line 175:         */",
                "// Line 176:     createReceiverResources(m_att.defaultUnicastLocatorList, true);",
                "// Line 177: ",
                "// Line 178:     if(!hasLocatorsDefined){",
                "// Line 179:         logInfo(RTPS_PARTICIPANT,m_att.getName()<<\" Created with NO default Unicast Locator List, adding Locators: \"<<m_att.defaultUnicastLocatorList);",
                "// vulnerable line: 180: }",
                "// Line 181:     //Multicast",
                "// Line 182:     createReceiverResources(m_att.defaultMulticastLocatorList, true);",
                "// Line 183: ",
                "// Line 184:     //Check if defaultOutLocatorsExist, create some if they don't",
                "// Line 185:     hasLocatorsDefined = true;",
                "// Line 186:     if (m_att.defaultOutLocatorList.empty()){",
                "// Line 187:         hasLocatorsDefined = false;",
                "// Line 188:         Locator_t SendLocator;",
                "// Line 189:         /*TODO - Fill with desired default Send Locators for our transports*/",
                "// Line 190:         //Warning - Mock rule being used (and only for IPv4)!",
                "// Line 191:         SendLocator.kind = LOCATOR_KIND_UDPv4;",
                "// Line 192:         m_att.defaultOutLocatorList.push_back(SendLocator);",
                "// vulnerable line: 193: }",
                "// Line 194:     //Create the default sendResources - For the same reason as in the ReceiverResources",
                "// Line 195:     std::vector<SenderResource > newSenders;",
                "// Line 196:     std::vector<SenderResource > newSendersBuffer;",
                "// Line 197:     LocatorList_t defcopy = m_att.defaultOutLocatorList;",
                "// Line 198:     for (auto it = defcopy.begin(); it != defcopy.end(); ++it){",
                "// Line 199:         /* Try to build resources with that specific Locator*/",
                "// Line 200:         newSendersBuffer = m_network_Factory.BuildSenderResources((*it));",
                "// Line 201:         uint32_t tries = 100;",
                "// Line 202:         while(newSendersBuffer.empty() && tries != 0)",
                "// vulnerable line: 203: {",
                "// Line 204:             //No ReceiverResources have been added, therefore we have to change the Locator ",
                "// Line 205:             (*it) = applyLocatorAdaptRule(*it); //Mutate the Locator to find a suitable rule. Overwrite the old one as it is useless now.",
                "// Line 206:             newSendersBuffer = m_network_Factory.BuildSenderResources((*it));",
                "// Line 207:             --tries;",
                "// vulnerable line: 208: }",
                "// Line 209:         //Now we DO have resources, and the new locator is already replacing the old one.",
                "// Line 210:         for(auto mit= newSendersBuffer.begin(); mit!= newSendersBuffer.end(); ++mit){",
                "// Line 211:             newSenders.push_back(std::move(*mit));    ",
                "// vulnerable line: 212: }",
                "// Line 213: ",
                "// Line 214:         //newSenders.insert(newSenders.end(), newSendersBuffer.begin(), newSendersBuffer.end());",
                "// Line 215:         newSendersBuffer.clear();",
                "// vulnerable line: 216: }",
                "// Line 217: ",
                "// Line 218:     m_send_resources_mutex.lock();",
                "// Line 219:     for(auto mit=newSenders.begin(); mit!=newSenders.end();++mit){",
                "// Line 220:         m_senderResource.push_back(std::move(*mit));",
                "// vulnerable line: 221: }",
                "// Line 222:     m_send_resources_mutex.unlock();",
                "// Line 223:     m_att.defaultOutLocatorList = defcopy;",
                "// Line 224: ",
                "// Line 225:     if (!hasLocatorsDefined){",
                "// Line 226:         logInfo(RTPS_PARTICIPANT, m_att.getName() << \" Created with NO default Send Locator List, adding Locators: \" << m_att.defaultOutLocatorList);",
                "// vulnerable line: 227: }",
                "// Line 228:     logInfo(RTPS_PARTICIPANT,\"RTPSParticipant \"\" <<  m_att.getName() << \"\" with guidPrefix: \" <<m_guid.guidPrefix);",
                "// Line 229:     //START BUILTIN PROTOCOLS",
                "// Line 230:     mp_builtinProtocols = new BuiltinProtocols();",
                "// Line 231:     if(!mp_builtinProtocols->initBuiltinProtocols(this,m_att.builtin))",
                "// vulnerable line: 232: {",
                "// Line 233:         logWarning(RTPS_PARTICIPANT, \"The builtin protocols were not corecctly initialized\");",
                "// vulnerable line: 234: }",
                "// Line 235:     //eClock::my_sleep(300);",
                "// vulnerable line: 236: }",
                "// Line 237: ",
                "// Line 238: const std::vector<RTPSWriter*>& RTPSParticipantImpl::getAllWriters() const",
                "// vulnerable line: 239: {",
                "// Line 240:     return m_allWriterList;",
                "// vulnerable line: 241: }",
                "// Line 242: ",
                "// Line 243: const std::vector<RTPSReader*>& RTPSParticipantImpl::getAllReaders() const",
                "// vulnerable line: 244: {",
                "// Line 245:     return m_allReaderList;",
                "// vulnerable line: 246: }",
                "// Line 247: ",
                "// Line 248: RTPSParticipantImpl::~RTPSParticipantImpl()",
                "// vulnerable line: 249: {",
                "// Line 250:     // Safely abort threads.",
                "// Line 251:     for (auto& block : m_receiverResourcelist)",
                "// vulnerable line: 252: {",
                "// Line 253:         block.resourceAlive = false;",
                "// Line 254:         block.Receiver.Abort();",
                "// Line 255:         block.m_thread->join();",
                "// Line 256:         delete block.m_thread;",
                "// vulnerable line: 257: }",
                "// Line 258: ",
                "// Line 259:     while(m_userReaderList.size()>0)",
                "// Line 260:         RTPSDomain::removeRTPSReader(*m_userReaderList.begin());",
                "// Line 261: ",
                "// Line 262:     while(m_userWriterList.size()>0)",
                "// Line 263:         RTPSDomain::removeRTPSWriter(*m_userWriterList.begin());",
                "// Line 264: ",
                "// Line 265:     // Destruct message receivers",
                "// Line 266:     for (auto& block : m_receiverResourcelist)",
                "// Line 267:         delete block.mp_receiver;",
                "// Line 268: ",
                "// Line 269:     m_receiverResourcelist.clear();",
                "// Line 270:     delete(this->mp_builtinProtocols);",
                "// Line 271:     delete(this->mp_ResourceSemaphore);",
                "// Line 272:     delete(this->mp_userParticipant);",
                "// Line 273:     m_senderResource.clear();",
                "// Line 274: ",
                "// Line 275:     delete(this->mp_event_thr);",
                "// Line 276: ",
                "// Line 277:     delete(this->mp_mutex);",
                "// vulnerable line: 278: }",
                "// Line 279: ",
                "// Line 280: /*",
                "// Line 281:  *",
                "// Line 282:  * MAIN RTPSParticipant IMPL API",
                "// Line 283:  *",
                "// Line 284:  */",
                "// Line 285: ",
                "// Line 286: ",
                "// Line 287: bool RTPSParticipantImpl::createWriter(RTPSWriter** WriterOut,",
                "// Line 288:         WriterAttributes& param,WriterHistory* hist,WriterListener* listen, const EntityId_t& entityId,bool isBuiltin)",
                "// vulnerable line: 289: {",
                "// Line 290:     std::string type = (param.endpoint.reliabilityKind == RELIABLE) ? \"RELIABLE\" :\"BEST_EFFORT\";",
                "// Line 291:     logInfo(RTPS_PARTICIPANT,\" of type \" << type);",
                "// Line 292:     EntityId_t entId;",
                "// Line 293:     if(entityId== c_EntityId_Unknown)",
                "// vulnerable line: 294: {",
                "// Line 295:         if(param.endpoint.topicKind == NO_KEY)",
                "// Line 296:             entId.value[3] = 0x03;",
                "// Line 297:         else if(param.endpoint.topicKind == WITH_KEY)",
                "// Line 298:             entId.value[3] = 0x02;",
                "// Line 299:         uint32_t idnum;",
                "// Line 300:         if(param.endpoint.getEntityID()>0)",
                "// Line 301:             idnum = param.endpoint.getEntityID();",
                "// Line 302:         else",
                "// vulnerable line: 303: {",
                "// Line 304:             IdCounter++;",
                "// Line 305:             idnum = IdCounter;",
                "// vulnerable line: 306: }",
                "// Line 307: ",
                "// Line 308:         octet* c = (octet*)&idnum;",
                "// Line 309:         entId.value[2] = c[0];",
                "// Line 310:         entId.value[1] = c[1];",
                "// Line 311:         entId.value[0] = c[2];",
                "// Line 312:         if(this->existsEntityId(entId,WRITER))",
                "// vulnerable line: 313: {",
                "// Line 314:             logError(RTPS_PARTICIPANT,\"A writer with the same entityId already exists in this RTPSParticipant\");",
                "// Line 315:             return false;",
                "// vulnerable line: 316: }",
                "// vulnerable line: 317: }",
                "// Line 318:     else",
                "// vulnerable line: 319: {",
                "// Line 320:         entId = entityId;",
                "// vulnerable line: 321: }",
                "// Line 322:     if(!param.endpoint.unicastLocatorList.isValid())",
                "// vulnerable line: 323: {",
                "// Line 324:         logError(RTPS_PARTICIPANT,\"Unicast Locator List for Writer contains invalid Locator\");",
                "// Line 325:         return false;",
                "// vulnerable line: 326: }",
                "// Line 327:     if(!param.endpoint.multicastLocatorList.isValid())",
                "// vulnerable line: 328: {",
                "// Line 329:         logError(RTPS_PARTICIPANT,\"Multicast Locator List for Writer contains invalid Locator\");",
                "// Line 330:         return false;",
                "// vulnerable line: 331: }",
                "// Line 332:     if(!param.endpoint.outLocatorList.isValid())",
                "// vulnerable line: 333: {",
                "// Line 334:         logError(RTPS_PARTICIPANT,\"Output Locator List for Writer contains invalid Locator\");",
                "// Line 335:         return false;",
                "// vulnerable line: 336: }",
                "// Line 337:     if (((param.throughputController.bytesPerPeriod != UINT32_MAX && param.throughputController.periodMillisecs != 0) ||",
                "// Line 338:                 (m_att.throughputController.bytesPerPeriod != UINT32_MAX && m_att.throughputController.periodMillisecs != 0)) &&",
                "// Line 339:             param.mode != ASYNCHRONOUS_WRITER)",
                "// vulnerable line: 340: {",
                "// Line 341:         logError(RTPS_PARTICIPANT, \"Writer has to be configured to publish asynchronously, because a flowcontroller was configured\");",
                "// Line 342:         return false;",
                "// vulnerable line: 343: }",
                "// Line 344: ",
                "// Line 345: ",
                "// Line 346:     // Normalize unicast locators",
                "// Line 347:     if (!param.endpoint.unicastLocatorList.empty())",
                "// Line 348:         m_network_Factory.NormalizeLocators(param.endpoint.unicastLocatorList);",
                "// Line 349: ",
                "// Line 350:     RTPSWriter* SWriter = nullptr;",
                "// Line 351:     GUID_t guid(m_guid.guidPrefix,entId);",
                "// Line 352:     if(param.endpoint.reliabilityKind == BEST_EFFORT)",
                "// Line 353:         SWriter = (RTPSWriter*)new StatelessWriter(this,guid,param,hist,listen);",
                "// Line 354:     else if(param.endpoint.reliabilityKind == RELIABLE)",
                "// Line 355:         SWriter = (RTPSWriter*)new StatefulWriter(this,guid,param,hist,listen);",
                "// Line 356: ",
                "// Line 357:     if(SWriter==nullptr)",
                "// Line 358:         return false;",
                "// Line 359: ",
                "// Line 360:     createSendResources((Endpoint *)SWriter);",
                "// Line 361:     if(param.endpoint.reliabilityKind == RELIABLE)",
                "// vulnerable line: 362: {",
                "// Line 363:         if (!createAndAssociateReceiverswithEndpoint((Endpoint *)SWriter))",
                "// vulnerable line: 364: {",
                "// Line 365:             delete(SWriter);",
                "// Line 366:             return false;",
                "// vulnerable line: 367: }",
                "// vulnerable line: 368: }",
                "// Line 369: ",
                "// Line 370:     // Asynchronous thread runs regardless of mode because of",
                "// Line 371:     // nack response duties.",
                "// Line 372:     AsyncWriterThread::addWriter(*SWriter);",
                "// Line 373: ",
                "// Line 374:     boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);",
                "// Line 375:     m_allWriterList.push_back(SWriter);",
                "// Line 376:     if(!isBuiltin)",
                "// Line 377:         m_userWriterList.push_back(SWriter);",
                "// Line 378:     *WriterOut = SWriter;",
                "// Line 379: ",
                "// Line 380:     // If the terminal throughput controller has proper user defined values, instantiate it",
                "// Line 381:     if (param.throughputController.bytesPerPeriod != UINT32_MAX && param.throughputController.periodMillisecs != 0)",
                "// vulnerable line: 382: {",
                "// Line 383:         std::unique_ptr<FlowController> controller(new ThroughputController(param.throughputController, SWriter));",
                "// Line 384:         SWriter->add_flow_controller(std::move(controller));",
                "// vulnerable line: 385: }",
                "// Line 386: ",
                "// Line 387:     return true;",
                "// vulnerable line: 388: }",
                "// Line 389: ",
                "// Line 390: ",
                "// Line 391: bool RTPSParticipantImpl::createReader(RTPSReader** ReaderOut,",
                "// Line 392:         ReaderAttributes& param,ReaderHistory* hist,ReaderListener* listen, const EntityId_t& entityId,bool isBuiltin, bool enable)",
                "// vulnerable line: 393: {",
                "// Line 394:     std::string type = (param.endpoint.reliabilityKind == RELIABLE) ? \"RELIABLE\" :\"BEST_EFFORT\";",
                "// Line 395:     logInfo(RTPS_PARTICIPANT,\" of type \" << type);",
                "// Line 396:     EntityId_t entId;",
                "// Line 397:     if(entityId== c_EntityId_Unknown)",
                "// vulnerable line: 398: {",
                "// Line 399:         if(param.endpoint.topicKind == NO_KEY)",
                "// Line 400:             entId.value[3] = 0x04;",
                "// Line 401:         else if(param.endpoint.topicKind == WITH_KEY)",
                "// Line 402:             entId.value[3] = 0x07;",
                "// Line 403:         uint32_t idnum;",
                "// Line 404:         if(param.endpoint.getEntityID()>0)",
                "// Line 405:             idnum = param.endpoint.getEntityID();",
                "// Line 406:         else",
                "// vulnerable line: 407: {",
                "// Line 408:             IdCounter++;",
                "// Line 409:             idnum = IdCounter;",
                "// vulnerable line: 410: }",
                "// Line 411: ",
                "// Line 412:         octet* c = (octet*)&idnum;",
                "// Line 413:         entId.value[2] = c[0];",
                "// Line 414:         entId.value[1] = c[1];",
                "// Line 415:         entId.value[0] = c[2];",
                "// Line 416:         if(this->existsEntityId(entId,WRITER))",
                "// vulnerable line: 417: {",
                "// Line 418:             logError(RTPS_PARTICIPANT,\"A reader with the same entityId already exists in this RTPSParticipant\");",
                "// Line 419:             return false;",
                "// vulnerable line: 420: }",
                "// vulnerable line: 421: }",
                "// Line 422:     else",
                "// vulnerable line: 423: {",
                "// Line 424:         entId = entityId;",
                "// vulnerable line: 425: }",
                "// Line 426:     if(!param.endpoint.unicastLocatorList.isValid())",
                "// vulnerable line: 427: {",
                "// Line 428:         logError(RTPS_PARTICIPANT,\"Unicast Locator List for Reader contains invalid Locator\");",
                "// Line 429:         return false;",
                "// vulnerable line: 430: }",
                "// Line 431:     if(!param.endpoint.multicastLocatorList.isValid())",
                "// vulnerable line: 432: {",
                "// Line 433:         logError(RTPS_PARTICIPANT,\"Multicast Locator List for Reader contains invalid Locator\");",
                "// Line 434:         return false;",
                "// vulnerable line: 435: }",
                "// Line 436:     if(!param.endpoint.outLocatorList.isValid())",
                "// vulnerable line: 437: {",
                "// Line 438:         logError(RTPS_PARTICIPANT,\"Output Locator List for Reader contains invalid Locator\");",
                "// Line 439:         return false;",
                "// vulnerable line: 440: }",
                "// Line 441: ",
                "// Line 442:     // Normalize unicast locators",
                "// Line 443:     if (!param.endpoint.unicastLocatorList.empty())",
                "// Line 444:         m_network_Factory.NormalizeLocators(param.endpoint.unicastLocatorList);",
                "// Line 445: ",
                "// Line 446:     RTPSReader* SReader = nullptr;",
                "// Line 447:     GUID_t guid(m_guid.guidPrefix,entId);",
                "// Line 448:     if(param.endpoint.reliabilityKind == BEST_EFFORT)",
                "// Line 449:         SReader = (RTPSReader*)new StatelessReader(this,guid,param,hist,listen);",
                "// Line 450:     else if(param.endpoint.reliabilityKind == RELIABLE)",
                "// Line 452: ",
                "// Line 453:     if(SReader==nullptr)",
                "// Line 454:         return false;",
                "// Line 455: ",
                "// Line 456:     //SReader->setListener(inlisten);",
                "// Line 457:     //SReader->setQos(param.qos,true);",
                "// Line 458:     if (param.endpoint.reliabilityKind == RELIABLE)",
                "// Line 459:         createSendResources((Endpoint *)SReader);",
                "// Line 460: ",
                "// Line 461:     if(isBuiltin)",
                "// vulnerable line: 462: {",
                "// Line 463:         SReader->setTrustedWriter(TrustedWriter(SReader->getGuid().entityId));",
                "// vulnerable line: 464: }",
                "// Line 465: ",
                "// Line 466:     if(enable)",
                "// vulnerable line: 467: {",
                "// Line 468:         if (!createAndAssociateReceiverswithEndpoint((Endpoint *)SReader))",
                "// vulnerable line: 469: {",
                "// Line 470:             delete(SReader);",
                "// Line 471:             return false;",
                "// vulnerable line: 472: }",
                "// vulnerable line: 473: }",
                "// Line 474: ",
                "// Line 475:     boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);",
                "// Line 476:     m_allReaderList.push_back(SReader);",
                "// Line 477:     if(!isBuiltin)",
                "// Line 478:         m_userReaderList.push_back(SReader);",
                "// Line 479:     *ReaderOut = SReader;",
                "// Line 480:     return true;",
                "// vulnerable line: 481: }",
                "// Line 482: ",
                "// Line 483: bool RTPSParticipantImpl::enableReader(RTPSReader *reader)",
                "// vulnerable line: 484: {",
                "// Line 485:     if(!assignEndpointListenResources((Endpoint*)reader))",
                "// vulnerable line: 486: {",
                "// Line 487:         return false;",
                "// vulnerable line: 488: }",
                "// Line 489: ",
                "// Line 490:     return true;",
                "// vulnerable line: 491: }",
                "// Line 492: ",
                "// Line 493: ",
                "// Line 494: ",
                "// Line 495: ",
                "// Line 496: bool RTPSParticipantImpl::registerWriter(RTPSWriter* Writer,TopicAttributes& topicAtt,WriterQos& wqos)",
                "// vulnerable line: 497: {",
                "// Line 498:     return this->mp_builtinProtocols->addLocalWriter(Writer,topicAtt,wqos);",
                "// vulnerable line: 499: }",
                "// Line 500: ",
                "// Line 501: bool RTPSParticipantImpl::registerReader(RTPSReader* reader,TopicAttributes& topicAtt,ReaderQos& rqos)",
                "// vulnerable line: 502: {",
                "// Line 503:     return this->mp_builtinProtocols->addLocalReader(reader,topicAtt,rqos);",
                "// vulnerable line: 504: }",
                "// Line 505: ",
                "// Line 506: bool RTPSParticipantImpl::updateLocalWriter(RTPSWriter* Writer,WriterQos& wqos)",
                "// vulnerable line: 507: {",
                "// Line 508:     return this->mp_builtinProtocols->updateLocalWriter(Writer,wqos);",
                "// vulnerable line: 509: }",
                "// Line 510: ",
                "// Line 511: bool RTPSParticipantImpl::updateLocalReader(RTPSReader* reader,ReaderQos& rqos)",
                "// vulnerable line: 512: {",
                "// Line 513:     return this->mp_builtinProtocols->updateLocalReader(reader,rqos);",
                "// vulnerable line: 514: }",
                "// Line 515: ",
                "// Line 516: /*",
                "// Line 517:  *",
                "// Line 518:  * AUXILIARY METHODS",
                "// Line 519:  *",
                "// Line 520:  *  */",
                "// Line 521: ",
                "// Line 522: ",
                "// Line 523: bool RTPSParticipantImpl::existsEntityId(const EntityId_t& ent,EndpointKind_t kind) const",
                "// vulnerable line: 524: {",
                "// Line 525:     if(kind == WRITER)",
                "// vulnerable line: 526: {",
                "// Line 527:         for(std::vector<RTPSWriter*>::const_iterator it = m_userWriterList.begin();",
                "// Line 528:                 it!=m_userWriterList.end();++it)",
                "// vulnerable line: 529: {",
                "// Line 530:             if(ent == (*it)->getGuid().entityId)",
                "// Line 531:                 return true;",
                "// vulnerable line: 532: }",
                "// vulnerable line: 533: }",
                "// Line 534:     else",
                "// vulnerable line: 535: {",
                "// Line 536:         for(std::vector<RTPSReader*>::const_iterator it = m_userReaderList.begin();",
                "// Line 537:                 it!=m_userReaderList.end();++it)",
                "// vulnerable line: 538: {",
                "// Line 539:             if(ent == (*it)->getGuid().entityId)",
                "// Line 540:                 return true;",
                "// vulnerable line: 541: }",
                "// vulnerable line: 542: }",
                "// Line 543:     return false;",
                "// vulnerable line: 544: }",
                "// Line 545: ",
                "// Line 546: ",
                "// Line 547: /*",
                "// Line 548:  *",
                "// Line 549:  * RECEIVER RESOURCE METHODS",
                "// Line 550:  *",
                "// Line 551:  */",
                "// Line 552: ",
                "// Line 553: ",
                "// Line 554: bool RTPSParticipantImpl::assignEndpointListenResources(Endpoint* endp)",
                "// vulnerable line: 555: {",
                "// Line 556:     //Tag the endpoint with the ReceiverResources",
                "// Line 557:     bool valid = true;",
                "// Line 558: ",
                "// Line 559:     /* No need to check for emptiness on the lists, as it was already done on part function",
                "// Line 560:        In case are using the default list of Locators they have already been embedded to the parameters */",
                "// Line 561: ",
                "// Line 562:     //UNICAST",
                "// Line 563:     assignEndpoint2LocatorList(endp, endp->getAttributes()->unicastLocatorList);",
                "// Line 564:     //MULTICAST",
                "// Line 565:     assignEndpoint2LocatorList(endp, endp->getAttributes()->multicastLocatorList);",
                "// Line 566:     return valid;",
                "// vulnerable line: 567: }",
                "// Line 568: ",
                "// Line 569: bool RTPSParticipantImpl::createAndAssociateReceiverswithEndpoint(Endpoint * pend){",
                "// Line 570:     /*    This function...",
                "// Line 571:         - Asks the network factory for new resources",
                "// Line 572:         - Encapsulates the new resources within the ReceiverControlBlock list",
                "// Line 573:         - Associated the endpoint to the new elements in the list",
                "// Line 574:         - Launches the listener thread",
                "// Line 575:         */",
                "// Line 576:     // 1 - Ask the network factory to generate the elements that do still not exist",
                "// Line 577:     std::vector<ReceiverResource> newItems;                            //Store the newly created elements",
                "// Line 578:     std::vector<ReceiverResource> newItemsBuffer;                    //Store intermediate results",
                "// Line 579:     //Iterate through the list of unicast and multicast locators the endpoint has... unless its empty",
                "// Line 580:     //In that case, just use the standard",
                "// Line 581:     if (pend->getAttributes()->unicastLocatorList.empty() && pend->getAttributes()->multicastLocatorList.empty()){",
                "// Line 582:         //Default unicast",
                "// Line 583:         pend->getAttributes()->unicastLocatorList = m_att.defaultUnicastLocatorList;",
                "// Line 584:         //Default multicast",
                "// Line 585:         pend->getAttributes()->multicastLocatorList = m_att.defaultMulticastLocatorList;",
                "// vulnerable line: 586: }",
                "// Line 587:     createReceiverResources(pend->getAttributes()->unicastLocatorList, false);",
                "// Line 588:     createReceiverResources(pend->getAttributes()->multicastLocatorList, false);",
                "// Line 589: ",
                "// Line 590:     // Associate the Endpoint with ReceiverResources inside ReceiverControlBlocks",
                "// Line 591:     assignEndpointListenResources(pend); ",
                "// Line 592:     return true;",
                "// vulnerable line: 593: }",
                "// Line 594: ",
                "// Line 595: void RTPSParticipantImpl::performListenOperation(ReceiverControlBlock *receiver, Locator_t input_locator)",
                "// vulnerable line: 596: {",
                "// Line 597:     while(receiver->resourceAlive)",
                "// vulnerable line: 598: {    ",
                "// Line 599:         // Blocking receive.",
                "// Line 600:         auto& msg = receiver->mp_receiver->m_rec_msg;",
                "// Line 601:         if(!receiver->Receiver.Receive(msg.buffer, msg.max_size, msg.length, input_locator))",
                "// Line 602:             continue;",
                "// Line 603: ",
                "// Line 604:         // Processes the data through the CDR Message interface.",
                "// Line 605:         receiver->mp_receiver->processCDRMsg(getGuid().guidPrefix, &input_locator, &receiver->mp_receiver->m_rec_msg);",
                "// vulnerable line: 606: }    ",
                "// vulnerable line: 607: }",
                "// Line 608: ",
                "// Line 609: ",
                "// Line 610: bool RTPSParticipantImpl::assignEndpoint2LocatorList(Endpoint* endp,LocatorList_t& list)",
                "// vulnerable line: 611: {",
                "// Line 612:     /* Note:",
                "// Line 613:        The previous version of this function associated (or created) ListenResources and added the endpoint to them.",
                "// Line 614:        It then requested the list of Locators the Listener is listening to and appended to the LocatorList_t from the paremeters.",
                "// Line 615: ",
                "// Line 616:        This has been removed becuase it is considered redundant. For ReceiveResources that listen on multiple interfaces, only",
                "// Line 617:        one of the supported Locators is needed to make the match, and the case of new ListenResources being created has been removed",
                "// Line 618:        since its the NetworkFactory the one that takes care of Resource creation.",
                "// Line 619:        */",
                "// Line 620:     LocatorList_t finalList;",
                "// Line 621:     for(auto lit = list.begin();lit != list.end();++lit){",
                "// Line 622:         //Iteration of all Locators within the Locator list passed down as argument",
                "// Line 623:         boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);",
                "// Line 624:         //Check among ReceiverResources whether the locator is supported or not",
                "// Line 625:         for (auto it = m_receiverResourcelist.begin(); it != m_receiverResourcelist.end(); ++it){",
                "// Line 626:             //Take mutex for the resource since we are going to interact with shared resources",
                "// Line 627:             //boost::lock_guard<boost::mutex> guard((*it).mtx);",
                "// Line 628:             if ((*it).Receiver.SupportsLocator(*lit)){",
                "// Line 629:                 //Supported! Take mutex and update lists - We maintain reader/writer discrimination just in case",
                "// Line 630:                 (*it).mp_receiver->associateEndpoint(endp);    ",
                "// Line 631:                 // end association between reader/writer and the receive resources",
                "// vulnerable line: 632: }",
                "// Line 633: ",
                "// vulnerable line: 634: }",
                "// Line 635:         //Finished iteratig through all ListenResources for a single Locator (from the parameter list).",
                "// Line 636:         //Since this function is called after checking with NetFactory we do not have to create any more resource. ",
                "// vulnerable line: 637: }",
                "// Line 638:     return true;",
                "// vulnerable line: 639: }",
                "// Line 640: bool RTPSParticipantImpl::createSendResources(Endpoint *pend){",
                "// Line 641:     std::vector<SenderResource> newSenders;",
                "// Line 642:     std::vector<SenderResource> SendersBuffer;",
                "// Line 643:     if (pend->m_att.outLocatorList.empty()){",
                "// Line 644:         //Output locator ist is empty, use predetermined ones",
                "// Line 645:         pend->m_att.outLocatorList = m_att.defaultOutLocatorList;        //Tag the Endpoint with the Default list so it can use it to send",
                "// Line 646:         //Already created them on constructor, so we can skip the creation",
                "// Line 647:         return true;",
                "// vulnerable line: 648: }",
                "// Line 649:     //Output locators have been specified, create them",
                "// Line 650:     for (auto it = pend->m_att.outLocatorList.begin(); it != pend->m_att.outLocatorList.end(); ++it){",
                "// Line 651:         SendersBuffer = m_network_Factory.BuildSenderResources((*it));",
                "// Line 652:         for(auto mit = SendersBuffer.begin(); mit!= SendersBuffer.end(); ++mit){",
                "// Line 653:             newSenders.push_back(std::move(*mit));",
                "// vulnerable line: 654: }",
                "// Line 655:         //newSenders.insert(newSenders.end(), SendersBuffer.begin(), SendersBuffer.end());",
                "// Line 656:         SendersBuffer.clear();",
                "// vulnerable line: 657: }",
                "// Line 658: ",
                "// Line 659:     boost::lock_guard<boost::mutex> guard(m_send_resources_mutex);",
                "// Line 660:     for(auto mit = newSenders.begin();mit!=newSenders.end();++mit){",
                "// Line 661:         m_senderResource.push_back(std::move(*mit));",
                "// vulnerable line: 662: }",
                "// Line 663: ",
                "// Line 664:     return true;",
                "// vulnerable line: 665: }",
                "// Line 666: ",
                "// Line 667: void RTPSParticipantImpl::createReceiverResources(LocatorList_t& Locator_list, bool ApplyMutation){",
                "// Line 668:     std::vector<ReceiverResource> newItemsBuffer;",
                "// Line 669: ",
                "// Line 670:     for(auto it_loc = Locator_list.begin(); it_loc != Locator_list.end(); ++it_loc){",
                "// Line 671:         newItemsBuffer = m_network_Factory.BuildReceiverResources((*it_loc));",
                "// Line 672:         if(ApplyMutation){",
                "// Line 673:             int tries = 0;",
                "// Line 674:             while(newItemsBuffer.empty() && (tries < MutationTries)){",
                "// Line 675:                 tries++;",
                "// Line 676:                 (*it_loc) = applyLocatorAdaptRule(*it_loc);",
                "// Line 677:                 newItemsBuffer = m_network_Factory.BuildReceiverResources((*it_loc));",
                "// vulnerable line: 678: }    ",
                "// vulnerable line: 679: }",
                "// Line 680:         for(auto it_buffer = newItemsBuffer.begin(); it_buffer != newItemsBuffer.end(); ++it_buffer){",
                "// Line 681:             //Push the new items into the ReceiverResource buffer",
                "// Line 682:             m_receiverResourcelist.push_back(ReceiverControlBlock(std::move(*it_buffer)));",
                "// Line 683:             //Create and init the MessageReceiver",
                "// Line 684:             //TODO(Ricardo) listenSocketBufferSize is too much size. Review",
                "// Line 685:             m_receiverResourcelist.back().mp_receiver = new MessageReceiver(m_att.listenSocketBufferSize);",
                "// Line 686:             m_receiverResourcelist.back().mp_receiver->init(m_att.listenSocketBufferSize);",
                "// Line 687: ",
                "// Line 688:             //Init the thread",
                "// Line 689:             m_receiverResourcelist.back().m_thread = new boost::thread(&RTPSParticipantImpl::performListenOperation,this, &(m_receiverResourcelist.back()),(*it_loc));",
                "// vulnerable line: 690: }",
                "// Line 691:         newItemsBuffer.clear();",
                "// vulnerable line: 692: }    ",
                "// vulnerable line: 693: }",
                "// Line 694: ",
                "// Line 695: ",
                "// Line 696: ",
                "// Line 697: bool RTPSParticipantImpl::deleteUserEndpoint(Endpoint* p_endpoint)",
                "// vulnerable line: 698: {",
                "// Line 699:     for(auto it=m_receiverResourcelist.begin();it!=m_receiverResourcelist.end();++it){",
                "// Line 700:         (*it).mp_receiver->removeEndpoint(p_endpoint);",
                "// vulnerable line: 701: }",
                "// Line 702:     bool found = false;",
                "// vulnerable line: 703: {",
                "// Line 704:         if(p_endpoint->getAttributes()->endpointKind == WRITER)",
                "// vulnerable line: 705: {",
                "// Line 706:             boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);",
                "// Line 707:             for(auto wit=m_userWriterList.begin();",
                "// Line 708:                     wit!=m_userWriterList.end();++wit)",
                "// vulnerable line: 709: {",
                "// Line 710:                 if((*wit)->getGuid().entityId == p_endpoint->getGuid().entityId) //Found it",
                "// vulnerable line: 711: {",
                "// Line 712:                     m_userWriterList.erase(wit);",
                "// Line 713:                     found = true;",
                "// Line 714:                     break;",
                "// vulnerable line: 715: }",
                "// vulnerable line: 716: }",
                "// Line 717:             for(auto wit=m_allWriterList.begin();",
                "// Line 718:                     wit!=m_allWriterList.end();++wit)",
                "// vulnerable line: 719: {",
                "// Line 720:                 if((*wit)->getGuid().entityId == p_endpoint->getGuid().entityId) //Found it",
                "// vulnerable line: 721: {",
                "// Line 722:                     m_allWriterList.erase(wit);",
                "// Line 723:                     found = true;",
                "// Line 724:                     break;",
                "// vulnerable line: 725: }",
                "// vulnerable line: 726: }",
                "// vulnerable line: 727: }",
                "// Line 728:         else",
                "// vulnerable line: 729: {",
                "// Line 730:             boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);",
                "// Line 731:             for(auto rit=m_userReaderList.begin()",
                "// Line 732:                     ;rit!=m_userReaderList.end();++rit)",
                "// vulnerable line: 733: {",
                "// Line 734:                 if((*rit)->getGuid().entityId == p_endpoint->getGuid().entityId) //Found it",
                "// vulnerable line: 735: {",
                "// Line 736:                     m_userReaderList.erase(rit);",
                "// Line 737:                     found = true;",
                "// Line 738:                     break;",
                "// vulnerable line: 739: }",
                "// vulnerable line: 740: }",
                "// Line 741:             for(auto rit=m_allReaderList.begin()",
                "// Line 742:                     ;rit!=m_allReaderList.end();++rit)",
                "// vulnerable line: 743: {",
                "// Line 744:                 if((*rit)->getGuid().entityId == p_endpoint->getGuid().entityId) //Found it",
                "// vulnerable line: 745: {",
                "// Line 746:                     m_allReaderList.erase(rit);",
                "// Line 747:                     found = true;",
                "// Line 748:                     break;",
                "// vulnerable line: 749: }",
                "// vulnerable line: 750: }",
                "// vulnerable line: 751: }",
                "// Line 752:         if(!found)",
                "// Line 753:             return false;",
                "// Line 754:         //REMOVE FOR BUILTINPROTOCOLS",
                "// Line 755:         if(p_endpoint->getAttributes()->endpointKind == WRITER)",
                "// Line 756:             mp_builtinProtocols->removeLocalWriter((RTPSWriter*)p_endpoint);",
                "// Line 757:         else",
                "// Line 758:             mp_builtinProtocols->removeLocalReader((RTPSReader*)p_endpoint);",
                "// Line 759:         //BUILTINPROTOCOLS",
                "// Line 760:         boost::lock_guard<boost::recursive_mutex> guardParticipant(*mp_mutex);",
                "// vulnerable line: 761: }",
                "// Line 762:     //    boost::lock_guard<boost::recursive_mutex> guardEndpoint(*p_endpoint->getMutex());",
                "// Line 763:     delete(p_endpoint);",
                "// Line 764:     return true;",
                "// vulnerable line: 765: }",
                "// Line 766: ",
                "// Line 767: ",
                "// Line 768: ResourceEvent& RTPSParticipantImpl::getEventResource()",
                "// vulnerable line: 769: {",
                "// Line 770:     return *this->mp_event_thr;",
                "// vulnerable line: 771: }",
                "// Line 772: ",
                "// Line 773: std::pair<StatefulReader*,StatefulReader*> RTPSParticipantImpl::getEDPReaders(){",
                "// Line 774:     std::pair<StatefulReader*,StatefulReader*> buffer;",
                "// Line 775:     EDPSimple *EDPPointer = dynamic_cast<EDPSimple*>(mp_builtinProtocols->mp_PDP->getEDP());",
                "// Line 776:     if(EDPPointer != nullptr){    ",
                "// Line 777:         //Means the EDP attached is actually non static and therefore it has Readers",
                "// Line 778:         buffer.first=EDPPointer->mp_SubReader.first;",
                "// Line 779:         buffer.second=EDPPointer->mp_PubReader.first;",
                "// Line 780:     }else{",
                "// Line 781:         buffer.first=nullptr;",
                "// Line 782:         buffer.second=nullptr;",
                "// vulnerable line: 783: }",
                "// Line 784:     return buffer;",
                "// Line 785: ",
                "// vulnerable line: 786: }",
                "// Line 787: ",
                "// Line 788: void RTPSParticipantImpl::sendSync(CDRMessage_t* msg, Endpoint *pend, const Locator_t& destination_loc)",
                "// vulnerable line: 789: {",
                "// Line 790:     boost::lock_guard<boost::mutex> guard(m_send_resources_mutex);",
                "// Line 791:     for (auto it = m_senderResource.begin(); it != m_senderResource.end(); ++it)",
                "// vulnerable line: 792: {",
                "// Line 793:         bool sendThroughResource = false;",
                "// Line 794:         for (auto sit = pend->m_att.outLocatorList.begin(); sit != pend->m_att.outLocatorList.end(); ++sit)",
                "// vulnerable line: 795: {",
                "// Line 796:             if ((*it).SupportsLocator((*sit)))",
                "// vulnerable line: 797: {",
                "// Line 798:                 sendThroughResource = true;",
                "// Line 799:                 break;",
                "// vulnerable line: 800: }",
                "// vulnerable line: 801: }",
                "// Line 802: ",
                "// Line 803:         if (sendThroughResource)",
                "// Line 804:             (*it).Send(msg->buffer, msg->length, destination_loc);",
                "// vulnerable line: 805: }",
                "// vulnerable line: 806: }",
                "// Line 807: ",
                "// Line 808: void RTPSParticipantImpl::announceRTPSParticipantState()",
                "// vulnerable line: 809: {",
                "// Line 810:     return mp_builtinProtocols->announceRTPSParticipantState();",
                "// vulnerable line: 811: }",
                "// Line 812: ",
                "// Line 813: void RTPSParticipantImpl::stopRTPSParticipantAnnouncement()",
                "// vulnerable line: 814: {",
                "// Line 815:     return mp_builtinProtocols->stopRTPSParticipantAnnouncement();",
                "// vulnerable line: 816: }",
                "// Line 817: ",
                "// Line 818: void RTPSParticipantImpl::resetRTPSParticipantAnnouncement()",
                "// vulnerable line: 819: {",
                "// Line 820:     return mp_builtinProtocols->resetRTPSParticipantAnnouncement();",
                "// vulnerable line: 821: }",
                "// Line 822: ",
                "// Line 823: void RTPSParticipantImpl::loose_next_change()",
                "// vulnerable line: 824: {",
                "// Line 825:     //NOTE: This is replaced by the test transport",
                "// Line 826:     //this->mp_send_thr->loose_next_change();",
                "// vulnerable line: 827: }",
                "// Line 828: ",
                "// Line 829: ",
                "// Line 830: bool RTPSParticipantImpl::newRemoteEndpointDiscovered(const GUID_t& pguid, int16_t userDefinedId,EndpointKind_t kind)",
                "// vulnerable line: 831: {",
                "// Line 832:     if(m_att.builtin.use_STATIC_EndpointDiscoveryProtocol == false)",
                "// vulnerable line: 833: {",
                "// Line 834:         logWarning(RTPS_PARTICIPANT,\"Remote Endpoints can only be activated with static discovery protocol\");",
                "// Line 835:         return false;",
                "// vulnerable line: 836: }",
                "// Line 837:     return mp_builtinProtocols->mp_PDP->newRemoteEndpointStaticallyDiscovered(pguid,userDefinedId,kind);",
                "// vulnerable line: 838: }",
                "// Line 839: ",
                "// Line 840: void RTPSParticipantImpl::ResourceSemaphorePost()",
                "// vulnerable line: 841: {",
                "// Line 842:     if(mp_ResourceSemaphore != nullptr)",
                "// vulnerable line: 843: {",
                "// Line 844:         mp_ResourceSemaphore->post();",
                "// vulnerable line: 845: }",
                "// vulnerable line: 846: }",
                "// Line 847: ",
                "// Line 848: void RTPSParticipantImpl::ResourceSemaphoreWait()",
                "// vulnerable line: 849: {",
                "// Line 850:     if (mp_ResourceSemaphore != nullptr)",
                "// vulnerable line: 851: {",
                "// Line 852:         mp_ResourceSemaphore->wait();",
                "// vulnerable line: 853: }",
                "// Line 854: ",
                "// vulnerable line: 855: }",
                "// Line 856: ",
                "// Line 857: void RTPSParticipantImpl::assertRemoteRTPSParticipantLiveliness(const GuidPrefix_t& guidP)",
                "// vulnerable line: 858: {",
                "// Line 859:     this->mp_builtinProtocols->mp_PDP->assertRemoteParticipantLiveliness(guidP);",
                "// vulnerable line: 860: }",
                "// Line 861: ",
                "// vulnerable line: 862: const RTPSParticipantAttributes& RTPSParticipantImpl::getRTPSParticipantAttributes() const",
                "// vulnerable line: 863: {",
                "// vulnerable line: 864: return this->m_att;",
                "// vulnerable line: 865: }",
                "// Line 866: ",
                "// Line 867: uint32_t RTPSParticipantImpl::getMaxMessageSize() const",
                "// vulnerable line: 868: {",
                "// Line 869:     uint32_t minMaxMessageSize = UINT32_MAX;",
                "// Line 870:     if(m_att.useBuiltinTransports)",
                "// vulnerable line: 871: {",
                "// Line 872:         UDPv4TransportDescriptor defaultDescriptor;",
                "// Line 873:         minMaxMessageSize = defaultDescriptor.maxMessageSize;",
                "// vulnerable line: 874: }",
                "// Line 875:     for(const auto& it : m_att.userTransports)",
                "// vulnerable line: 876: {",
                "// Line 877:         if(minMaxMessageSize > (*it).maxMessageSize)",
                "// Line 878:             minMaxMessageSize = (*it).maxMessageSize;",
                "// vulnerable line: 879: }",
                "// Line 880: ",
                "// Line 881:     return minMaxMessageSize;",
                "// vulnerable line: 882: }",
                "// Line 883: ",
                "// Line 884: bool RTPSParticipantImpl::networkFactoryHasRegisteredTransports() const",
                "// vulnerable line: 885: {",
                "// Line 886:     return m_network_Factory.numberOfRegisteredTransports() > 0;",
                "// vulnerable line: 887: }",
                "// Line 888: ",
                "// Line 889: } /* namespace rtps */",
                "// Line 890: } /* namespace fastrtps */",
                "// Line 891: } /* namespace eprosima */",
                "// Line 892: ",
                "// Line 893: "
            ]
        },
        {
            "filename_of_changes": "RTPSParticipantImpl.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 6: //",
                "// Line 7: //     http://www.apache.org/licenses/LICENSE-2.0",
                "// Line 8: //",
                "// Line 9: // Unless required by applicable law or agreed to in writing, software",
                "// Line 10: // distributed under the License is distributed on an \"AS IS\" BASIS,",
                "// Line 11: // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "// Line 12: // See the License for the specific language governing permissions and",
                "// Line 13: // limitations under the License.",
                "// Line 14: ",
                "// Line 15: /**",
                "// vulnerable line: 16: * @file RTPSParticipant.h",
                "// Line 17:  */",
                "// Line 18: ",
                "// Line 19: #ifndef RTPSParticipantIMPL_H_",
                "// Line 20: #define RTPSParticipantIMPL_H_",
                "// Line 21: #ifndef DOXYGEN_SHOULD_SKIP_THIS_PUBLIC",
                "// Line 22: #include <stdio.h>",
                "// Line 23: #include <stdlib.h>",
                "// Line 24: #include <list>",
                "// Line 25: #include <sys/types.h>",
                "// Line 26: ",
                "// Line 124:          * @param plisten",
                "// Line 125:          */",
                "// Line 126:         RTPSParticipantImpl(const RTPSParticipantAttributes &param,",
                "// Line 127:                 const GuidPrefix_t& guidP,RTPSParticipant* part,RTPSParticipantListener* plisten= nullptr);",
                "// Line 128:         virtual ~RTPSParticipantImpl();",
                "// Line 129: ",
                "// Line 130:         /**",
                "// Line 131:          * Get associated GUID",
                "// Line 132:          * @return Associated GUID",
                "// Line 133:          */",
                "// vulnerable line: 134: inline const GUID_t& getGuid() const {return m_guid;};",
                "// Line 135: ",
                "// Line 136:         //! Announce RTPSParticipantState (force the sending of a DPD message.)",
                "// Line 137:         void announceRTPSParticipantState();",
                "// Line 138:         //!Stop the RTPSParticipant Announcement (used in tests to avoid multiple packets being send)",
                "// Line 139:         void stopRTPSParticipantAnnouncement();",
                "// Line 140:         //!Reset to timer to make periodic RTPSParticipant Announcements.",
                "// Line 141:         void resetRTPSParticipantAnnouncement();",
                "// Line 142: ",
                "// Line 143:         void loose_next_change();",
                "// Line 144: ",
                "// Line 201:          * @remarks Non thread-safe.",
                "// Line 202:          */ ",
                "// Line 203:         const std::vector<RTPSReader*>& getAllReaders() const;",
                "// Line 204: ",
                "// Line 205:         uint32_t getMaxMessageSize() const;",
                "// Line 206: ",
                "// Line 207:     private:",
                "// Line 208:         //!Attributes of the RTPSParticipant",
                "// Line 209:         RTPSParticipantAttributes m_att;",
                "// Line 210:         //!Guid of the RTPSParticipant.",
                "// vulnerable line: 211: const GUID_t m_guid;",
                "// Line 212:         //! Sending resources. - DEPRECATED -Stays commented for reference purposes",
                "// Line 213:         // ResourceSend* mp_send_thr;",
                "// Line 214:         //! Event Resource",
                "// Line 215:         ResourceEvent* mp_event_thr;",
                "// Line 216:         //! BuiltinProtocols of this RTPSParticipant",
                "// Line 217:         BuiltinProtocols* mp_builtinProtocols;",
                "// Line 218:         //!Semaphore to wait for the listen thread creation.",
                "// Line 219:         boost::interprocess::interprocess_semaphore* mp_ResourceSemaphore;",
                "// Line 220:         //!Id counter to correctly assign the ids to writers and readers.",
                "// Line 221:         uint32_t IdCounter;",
                "// Line 297:         //!Participant Mutex",
                "// Line 298:         boost::recursive_mutex* mp_mutex;",
                "// Line 299: ",
                "// Line 300:         /*",
                "// Line 301:          * Flow controllers for this participant.",
                "// Line 302:          */",
                "// Line 303:         std::vector<std::unique_ptr<FlowController> > m_controllers;",
                "// Line 304: ",
                "// Line 305:     public:",
                "// Line 306: ",
                "// vulnerable line: 307: const RTPSParticipantAttributes& getRTPSParticipantAttributes() const;",
                "// Line 308: ",
                "// Line 309:         /**",
                "// Line 310:          * Create a Writer in this RTPSParticipant.",
                "// Line 311:          * @param Writer Pointer to pointer of the Writer, used as output. Only valid if return==true.",
                "// Line 312:          * @param param WriterAttributes to define the Writer.",
                "// Line 313:          * @param entityId EntityId assigned to the Writer.",
                "// Line 314:          * @param isBuiltin Bool value indicating if the Writer is builtin (Discovery or Liveliness protocol) or is created for the end user.",
                "// Line 315:          * @return True if the Writer was correctly created.",
                "// Line 316:          */",
                "// Line 317:         bool createWriter(RTPSWriter** Writer, WriterAttributes& param,WriterHistory* hist,WriterListener* listen,"
            ]
        },
        {
            "filename_of_changes": "RTPSParticipantImpl.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "25",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 21: ",
                "// Line 22: #include <fastrtps/rtps/attributes/WriterAttributes.h>",
                "// Line 23: #include <fastrtps/rtps/attributes/ReaderAttributes.h>",
                "// Line 24: ",
                "// Line 25: #include <gmock/gmock.h>",
                "// Line 26: ",
                "// Line 27: namespace eprosima {",
                "// Line 28: namespace fastrtps {",
                "// Line 29: namespace rtps {",
                "// Line 30: ",
                "// vulnerable line: 31: class RTPSWriter;",
                "// vulnerable line: 32: class RTPSReader;",
                "// Line 33: class WriterHistory;",
                "// Line 34: class ReaderHistory;",
                "// Line 35: class WriterListener;",
                "// Line 36: class ReaderListener;",
                "// Line 37: class EntityId_t;",
                "// Line 38: ",
                "// Line 39: class RTPSParticipantImpl",
                "// Line 40: {",
                "// Line 41:     public:",
                "// Line 42: ",
                "// Line 43:         MOCK_CONST_METHOD0(getRTPSParticipantAttributes, const RTPSParticipantAttributes&());",
                "// Line 44: ",
                "// Line 45:         MOCK_CONST_METHOD0(getGuid, const GUID_t&());",
                "// Line 46: ",
                "// vulnerable line: 47: MOCK_METHOD6(createWriter, bool (RTPSWriter** Writer, WriterAttributes& param, WriterHistory* hist,WriterListener* listen,",
                "// Line 48:                 const EntityId_t& entityId, bool isBuiltin));",
                "// Line 49: ",
                "// vulnerable line: 50: MOCK_METHOD7(createReader, bool (RTPSReader** Reader, ReaderAttributes& param, ReaderHistory* hist,ReaderListener* listen,",
                "// Line 51:                 const EntityId_t& entityId, bool isBuiltin, bool enable));",
                "// Line 52: };",
                "// Line 53: ",
                "// Line 54: } // namespace rtps",
                "// Line 55: } // namespace fastrtps",
                "// Line 56: } // namespace eprosima",
                "// Line 57: ",
                "// Line 58: #endif // RTPS_PARTICIPANT_RTPSPARTICIPANTIMPL_H_",
                "// Line 59: "
            ]
        },
        {
            "filename_of_changes": "RTPSReader.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "17",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "RTPSWriter.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "ReaderHistory.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "SecurityPluginFactory.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 18: ",
                "// Line 19: #include \"SecurityPluginFactory.h\"",
                "// Line 20: ",
                "// Line 21: using namespace eprosima::fastrtps::rtps;",
                "// Line 22: using namespace ::security;",
                "// Line 23: ",
                "// Line 24: Authentication* SecurityPluginFactory::auth_plugin_ = nullptr;",
                "// Line 25: ",
                "// Line 26: Authentication* SecurityPluginFactory::create_authentication_plugin(const PropertyPolicy& /*property_policy*/)",
                "// Line 27: {",
                "// vulnerable line: 28: return auth_plugin_;",
                "// Line 29: }",
                "// Line 30: ",
                "// Line 31: void SecurityPluginFactory::set_auth_plugin(Authentication* plugin)",
                "// Line 32: {",
                "// Line 33:     auth_plugin_ = plugin;",
                "// Line 34: }",
                "// Line 35: ",
                "// Line 36: void SecurityPluginFactory::release_auth_plugin()",
                "// Line 37: {",
                "// vulnerable line: 38: auth_plugin_ = nullptr;",
                "// Line 39: }"
            ]
        },
        {
            "filename_of_changes": "Token.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "22",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "Token.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "WriterHistory.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}