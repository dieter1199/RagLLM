{
    "cve_id": "CVE-2024-32475",
    "cve_description": "Envoy is a cloud-native, open source edge and service proxy. When an upstream TLS cluster is used with `auto_sni` enabled, a request containing a `host`/`:authority` header longer than 255 characters triggers an abnormal termination of Envoy process. Envoy does not gracefully handle an error when setting SNI for outbound TLS connection. The error can occur when Envoy attempts to use the `host`/`:authority` header value longer than 255 characters as SNI for outbound TLS connection. SNI length is limited to 255 characters per the standard. Envoy always expects this operation to succeed and abnormally aborts the process when it fails. This vulnerability is fixed in 1.30.1, 1.29.4, 1.28.3, and 1.27.5.\n",
    "cve_publish_date": "2024-04-18T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\r\n\r\nIf the `:authority` was longer than 255 characters, Envoy would\r\nRELEASE_ASSERT when creating an upstream TLS connection when\r\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\r\nwas used.\r\n\r\nSigned-off-by: Greg Greenway <ggreenway@apple.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "context_impl.cc",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 457:       out[start] = i - start;",
                "// Line 458:       start = i + 1;",
                "// Line 459:     } else {",
                "// Line 460:       out[i + 1] = alpn_protocols[i];",
                "// Line 461:     }",
                "// Line 462:   }",
                "// Line 463: ",
                "// Line 464:   return out;",
                "// Line 465: }",
                "// Line 466: ",
                "// vulnerable line: 467: bssl::UniquePtr<SSL>",
                "// Line 468: ContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
                "// Line 469:   // We use the first certificate for a new SSL object, later in the",
                "// Line 470:   // SSL_CTX_set_select_certificate_cb() callback following ClientHello, we replace with the",
                "// Line 471:   // selected certificate via SSL_set_SSL_CTX().",
                "// Line 472:   auto ssl_con = bssl::UniquePtr<SSL>(SSL_new(tls_contexts_[0].ssl_ctx_.get()));",
                "// Line 473:   SSL_set_app_data(ssl_con.get(), &options);",
                "// Line 474:   return ssl_con;",
                "// Line 475: }",
                "// Line 476: ",
                "// Line 477: enum ssl_verify_result_t ContextImpl::customVerifyCallback(SSL* ssl, uint8_t* out_alert) {",
                "// Line 695:   if (!parsed_alpn.empty()) {",
                "// Line 696:     const int rc = SSL_set_alpn_protos(&ssl, parsed_alpn.data(), parsed_alpn.size());",
                "// Line 697:     // This should only if memory allocation fails, e.g. OOM.",
                "// Line 698:     RELEASE_ASSERT(rc == 0, Utility::getLastCryptoError().value_or(\"\"));",
                "// Line 699:     return true;",
                "// Line 700:   }",
                "// Line 701: ",
                "// Line 702:   return false;",
                "// Line 703: }",
                "// Line 704: ",
                "// vulnerable line: 705: bssl::UniquePtr<SSL>",
                "// Line 706: ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {",
                "// vulnerable line: 707: bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));",
                "// Line 708: ",
                "// Line 709:   const std::string server_name_indication = options && options->serverNameOverride().has_value()",
                "// Line 710:                                                  ? options->serverNameOverride().value()",
                "// Line 711:                                                  : server_name_indication_;",
                "// Line 712:   if (!server_name_indication.empty()) {",
                "// Line 713:     const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());",
                "// vulnerable line: 714: RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));",
                "// Line 715:   }",
                "// Line 716: ",
                "// Line 717:   if (options && !options->verifySubjectAltNameListOverride().empty()) {",
                "// Line 718:     SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);",
                "// Line 719:   }",
                "// Line 720: ",
                "// Line 721:   // We determine what ALPN using the following precedence:",
                "// Line 722:   // 1. Option-provided ALPN override.",
                "// Line 723:   // 2. ALPN statically configured in the upstream TLS context.",
                "// Line 724:   // 3. Option-provided ALPN fallback."
            ]
        },
        {
            "filename_of_changes": "context_impl.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 71: };",
                "// Line 72: } // namespace Ssl",
                "// Line 73: ",
                "// Line 74: namespace Extensions {",
                "// Line 75: namespace TransportSockets {",
                "// Line 76: namespace Tls {",
                "// Line 77: ",
                "// Line 78: class ContextImpl : public virtual Envoy::Ssl::Context,",
                "// Line 79:                     protected Logger::Loggable<Logger::Id::config> {",
                "// Line 80: public:",
                "// vulnerable line: 81: virtual bssl::UniquePtr<SSL> newSsl(const Network::TransportSocketOptionsConstSharedPtr& options);",
                "// Line 82: ",
                "// Line 83:   /**",
                "// Line 84:    * Logs successful TLS handshake and updates stats.",
                "// Line 85:    * @param ssl the connection to log",
                "// Line 86:    */",
                "// Line 87:   void logHandshake(SSL* ssl) const;",
                "// Line 88: ",
                "// Line 89:   SslStats& stats() { return stats_; }",
                "// Line 90: ",
                "// Line 91:   /**",
                "// Line 169:   AccessLog::AccessLogFileSharedPtr tls_keylog_file_;",
                "// Line 170: };",
                "// Line 171: ",
                "// Line 172: using ContextImplSharedPtr = std::shared_ptr<ContextImpl>;",
                "// Line 173: ",
                "// Line 174: class ClientContextImpl : public ContextImpl, public Envoy::Ssl::ClientContext {",
                "// Line 175: public:",
                "// Line 176:   ClientContextImpl(Stats::Scope& scope, const Envoy::Ssl::ClientContextConfig& config,",
                "// Line 177:                     Server::Configuration::CommonFactoryContext& factory_context);",
                "// Line 178: ",
                "// vulnerable line: 179: bssl::UniquePtr<SSL>",
                "// Line 180:   newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) override;",
                "// Line 181: ",
                "// Line 182: private:",
                "// Line 183:   int newSessionKey(SSL_SESSION* session);",
                "// Line 184: ",
                "// Line 185:   const std::string server_name_indication_;",
                "// Line 186:   const bool allow_renegotiation_;",
                "// Line 187:   const bool enforce_rsa_key_usage_;",
                "// Line 188:   const size_t max_session_keys_;",
                "// Line 189:   absl::Mutex session_keys_mu_;"
            ]
        },
        {
            "filename_of_changes": "proxy_filter_integration_test.cc",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "18",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "ssl_socket.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 38:   ALL_SSL_SOCKET_FACTORY_STATS(GENERATE_COUNTER_STRUCT)",
                "// Line 39: };",
                "// Line 40: ",
                "// Line 41: enum class InitialState { Client, Server };",
                "// Line 42: ",
                "// Line 43: class SslSocket : public Network::TransportSocket,",
                "// Line 44:                   public Envoy::Ssl::PrivateKeyConnectionCallbacks,",
                "// Line 45:                   public Ssl::HandshakeCallbacks,",
                "// Line 46:                   protected Logger::Loggable<Logger::Id::connection> {",
                "// Line 47: public:",
                "// vulnerable line: 48: SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
                "// vulnerable line: 49: const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
                "// vulnerable line: 50: Ssl::HandshakerFactoryCb handshaker_factory_cb);",
                "// Line 51: ",
                "// Line 52:   // Network::TransportSocket",
                "// Line 53:   void setTransportSocketCallbacks(Network::TransportSocketCallbacks& callbacks) override;",
                "// Line 54:   std::string protocol() const override;",
                "// Line 55:   absl::string_view failureReason() const override;",
                "// Line 56:   bool canFlushClose() override { return info_->state() == Ssl::SocketState::HandshakeComplete; }",
                "// Line 57:   void closeSocket(Network::ConnectionEvent close_type) override;",
                "// Line 58:   Network::IoResult doRead(Buffer::Instance& read_buffer) override;",
                "// Line 59:   Network::IoResult doWrite(Buffer::Instance& write_buffer, bool end_stream) override;",
                "// Line 60:   void onConnected() override;"
            ]
        }
    ]
}