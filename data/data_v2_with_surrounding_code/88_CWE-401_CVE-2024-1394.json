{
    "cve_id": "CVE-2024-1394",
    "cve_description": "A memory leak flaw was found in Golang in the RSA encrypting/decrypting code, which might lead to a resource exhaustion vulnerability using attacker-controlled inputs?. The memory leak happens in github.com/golang-fips/openssl/openssl/rsa.go#L113. The objects leaked are pkey? and ctx?. That function uses named return parameters to free pkey? and ctx? if there is an error initializing the context or setting the different properties. All return statements related to error cases follow the \"return nil, nil, fail(...)\" pattern, meaning that pkey? and ctx? will be nil inside the deferred function that should free them.",
    "cve_publish_date": "2024-03-21T13:00Z",
    "cwe_id": "CWE-401",
    "cwe_name": "Missing Release of Memory after Effective Lifetime",
    "cwe_description": "The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.",
    "commit_message": "Fix memory leak in setupEVP",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "evpkey.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "9",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 21:     case *sha1Hash:",
                "// Line 22:         return C.go_openssl_EVP_sha1()",
                "// Line 23:     case *sha224Hash:",
                "// Line 24:         return C.go_openssl_EVP_sha224()",
                "// Line 25:     case *sha256Hash:",
                "// Line 26:         return C.go_openssl_EVP_sha256()",
                "// Line 27:     case *sha384Hash:",
                "// Line 28:         return C.go_openssl_EVP_sha384()",
                "// Line 29:     case *sha512Hash:",
                "// Line 30:         return C.go_openssl_EVP_sha512()",
                "// vulnerable line: 31: }",
                "// Line 32:     return nil",
                "// vulnerable line: 33: }",
                "// Line 34: ",
                "// Line 35: // cryptoHashToMD converts a crypto.Hash to a GO_EVP_MD_PTR.",
                "// Line 36: func cryptoHashToMD(ch crypto.Hash) C.GO_EVP_MD_PTR {",
                "// Line 37:     switch ch {",
                "// Line 38:     case crypto.MD5:",
                "// Line 39:         return C.go_openssl_EVP_md5()",
                "// Line 40:     case crypto.MD5SHA1:",
                "// Line 41:         if vMajor == 1 && vMinor == 0 {",
                "// Line 42:             // MD5SHA1 is not implemented in OpenSSL 1.0.2.",
                "// Line 43:             // It is implemented in higher versions but without FIPS support.",
                "// Line 44:             // It is considered a deprecated digest, not approved by FIPS 140-2",
                "// Line 45:             // and only used in pre-TLS 1.2, so we would rather not support it",
                "// Line 46:             // if using 1.0.2 than than implement something that is not properly validated.",
                "// Line 47:             return nil",
                "// vulnerable line: 48: }",
                "// Line 49:         return C.go_openssl_EVP_md5_sha1()",
                "// Line 50:     case crypto.SHA1:",
                "// Line 51:         return C.go_openssl_EVP_sha1()",
                "// Line 52:     case crypto.SHA224:",
                "// Line 53:         return C.go_openssl_EVP_sha224()",
                "// Line 54:     case crypto.SHA256:",
                "// Line 55:         return C.go_openssl_EVP_sha256()",
                "// Line 56:     case crypto.SHA384:",
                "// Line 57:         return C.go_openssl_EVP_sha384()",
                "// Line 58:     case crypto.SHA512:",
                "// Line 59:         return C.go_openssl_EVP_sha512()",
                "// vulnerable line: 60: }",
                "// Line 61:     return nil",
                "// vulnerable line: 62: }",
                "// Line 63: ",
                "// Line 64: func generateEVPPKey(id C.int, bits int, curve string) (C.GO_EVP_PKEY_PTR, error) {",
                "// Line 65:     if (bits == 0 && curve == \"\") || (bits != 0 && curve != \"\") {",
                "// Line 66:         return nil, fail(\"incorrect generateEVPPKey parameters\")",
                "// vulnerable line: 67: }",
                "// Line 68:     ctx := C.go_openssl_EVP_PKEY_CTX_new_id(id, nil)",
                "// vulnerable line: 69: if ctx == nil {",
                "// Line 70:         return nil, newOpenSSLError(\"EVP_PKEY_CTX_new_id failed\")",
                "// vulnerable line: 71: }",
                "// Line 72:     defer C.go_openssl_EVP_PKEY_CTX_free(ctx)",
                "// Line 73:     if C.go_openssl_EVP_PKEY_keygen_init(ctx) != 1 {",
                "// Line 74:         return nil, newOpenSSLError(\"EVP_PKEY_keygen_init failed\")",
                "// vulnerable line: 75: }",
                "// Line 76:     if bits != 0 {",
                "// Line 77:         if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, id, -1, C.GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS, C.int(bits), nil) != 1 {",
                "// Line 78:             return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 79: }",
                "// vulnerable line: 80: }",
                "// Line 81:     if curve != \"\" {",
                "// Line 82:         nid, err := curveNID(curve)",
                "// Line 83:         if err != nil {",
                "// Line 84:             return nil, err",
                "// vulnerable line: 85: }",
                "// Line 86:         if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, id, -1, C.GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, nil) != 1 {",
                "// Line 87:             return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 88: }",
                "// vulnerable line: 89: }",
                "// Line 90:     var pkey C.GO_EVP_PKEY_PTR",
                "// Line 91:     if C.go_openssl_EVP_PKEY_keygen(ctx, &pkey) != 1 {",
                "// Line 92:         return nil, newOpenSSLError(\"EVP_PKEY_keygen failed\")",
                "// vulnerable line: 93: }",
                "// Line 94:     return pkey, nil",
                "// vulnerable line: 95: }",
                "// Line 96: ",
                "// Line 97: type withKeyFunc func(func(C.GO_EVP_PKEY_PTR) C.int) C.int",
                "// Line 98: type initFunc func(C.GO_EVP_PKEY_CTX_PTR) error",
                "// Line 99: type cryptFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, *C.size_t, *C.uchar, C.size_t) error",
                "// Line 100: type verifyFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, C.size_t, *C.uchar, C.size_t) error",
                "// Line 101: ",
                "// Line 102: func setupEVP(withKey withKeyFunc, padding C.int,",
                "// Line 103:     h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,",
                "// vulnerable line: 104: init initFunc) (ctx C.GO_EVP_PKEY_CTX_PTR, err error) {",
                "// Line 105:     defer func() {",
                "// Line 106:         if err != nil {",
                "// Line 107:             if ctx != nil {",
                "// Line 108:                 C.go_openssl_EVP_PKEY_CTX_free(ctx)",
                "// Line 109:                 ctx = nil",
                "// vulnerable line: 110: }",
                "// vulnerable line: 111: }",
                "// Line 112:     }()",
                "// Line 113: ",
                "// vulnerable line: 114: withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {",
                "// vulnerable line: 115: ctx = C.go_openssl_EVP_PKEY_CTX_new(pkey, nil)",
                "// vulnerable line: 116: return 1",
                "// vulnerable line: 117: })",
                "// vulnerable line: 118: if ctx == nil {",
                "// vulnerable line: 119: return nil, newOpenSSLError(\"EVP_PKEY_CTX_new failed\")",
                "// vulnerable line: 120: }",
                "// Line 121:     if err := init(ctx); err != nil {",
                "// Line 122:         return nil, err",
                "// vulnerable line: 123: }",
                "// Line 124:     if padding == 0 {",
                "// Line 125:         return ctx, nil",
                "// vulnerable line: 126: }",
                "// Line 127:     // Each padding type has its own requirements in terms of when to apply the padding,",
                "// Line 128:     // so it can't be just set at this point.",
                "// Line 129:     setPadding := func() error {",
                "// Line 130:         if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PADDING, padding, nil) != 1 {",
                "// Line 131:             return newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 132: }",
                "// Line 133:         return nil",
                "// vulnerable line: 134: }",
                "// Line 135:     switch padding {",
                "// Line 136:     case C.GO_RSA_PKCS1_OAEP_PADDING:",
                "// Line 137:         md := hashToMD(h)",
                "// Line 138:         if md == nil {",
                "// Line 139:             return nil, errors.New(\"crypto/rsa: unsupported hash function\")",
                "// vulnerable line: 140: }",
                "// Line 141:         var mgfMD C.GO_EVP_MD_PTR",
                "// Line 142:         if mgfHash != nil {",
                "// Line 143:             // mgfHash is optional, but if it is set it must match a supported hash function.",
                "// Line 144:             mgfMD = hashToMD(mgfHash)",
                "// Line 145:             if mgfMD == nil {",
                "// Line 146:                 return nil, errors.New(\"crypto/rsa: unsupported hash function\")",
                "// vulnerable line: 147: }",
                "// vulnerable line: 148: }",
                "// Line 149:         // setPadding must happen before setting EVP_PKEY_CTRL_RSA_OAEP_MD.",
                "// Line 150:         if err := setPadding(); err != nil {",
                "// Line 151:             return nil, err",
                "// vulnerable line: 152: }",
                "// Line 153:         if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_MD, 0, unsafe.Pointer(md)) != 1 {",
                "// Line 154:             return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 155: }",
                "// Line 156:         if mgfHash != nil {",
                "// Line 157:             if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_MGF1_MD, 0, unsafe.Pointer(mgfMD)) != 1 {",
                "// Line 158:                 return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 159: }",
                "// vulnerable line: 160: }",
                "// Line 161:         // ctx takes ownership of label, so malloc a copy for OpenSSL to free.",
                "// Line 162:         // OpenSSL 1.1.1 and higher does not take ownership of the label if the length is zero,",
                "// Line 163:         // so better avoid the allocation.",
                "// Line 164:         var clabel *C.uchar",
                "// Line 165:         if len(label) > 0 {",
                "// Line 166:             // Go guarantees C.malloc never returns nil.",
                "// Line 167:             clabel = (*C.uchar)(C.malloc(C.size_t(len(label))))",
                "// Line 168:             copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)",
                "// vulnerable line: 169: }",
                "// Line 170:         var ret C.int",
                "// Line 171:         if vMajor == 1 {",
                "// Line 172:             ret = C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL, C.int(len(label)), unsafe.Pointer(clabel))",
                "// Line 173:         } else {",
                "// Line 174:             // OpenSSL 3 implements EVP_PKEY_CTX_set0_rsa_oaep_label as a function,",
                "// Line 175:             // instead of a macro around EVP_PKEY_CTX_ctrl, and it takes a different",
                "// Line 176:             // code path when the implementation is provided by FIPS provider.",
                "// Line 177:             ret = C.go_openssl_EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, unsafe.Pointer(clabel), C.int(len(label)))",
                "// vulnerable line: 178: }",
                "// Line 179:         if ret != 1 {",
                "// Line 180:             if clabel != nil {",
                "// Line 181:                 C.free(unsafe.Pointer(clabel))",
                "// vulnerable line: 182: }",
                "// Line 183:             return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 184: }",
                "// Line 185:     case C.GO_RSA_PKCS1_PSS_PADDING:",
                "// Line 186:         md := cryptoHashToMD(ch)",
                "// Line 187:         if md == nil {",
                "// Line 188:             return nil, errors.New(\"crypto/rsa: unsupported hash function\")",
                "// vulnerable line: 189: }",
                "// Line 190:         if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_MD, 0, unsafe.Pointer(md)) != 1 {",
                "// Line 191:             return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 192: }",
                "// Line 193:         // setPadding must happen after setting EVP_PKEY_CTRL_MD.",
                "// Line 194:         if err := setPadding(); err != nil {",
                "// Line 195:             return nil, err",
                "// vulnerable line: 196: }",
                "// Line 197:         if saltLen != 0 {",
                "// Line 198:             if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN, saltLen, nil) != 1 {",
                "// Line 199:                 return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 200: }",
                "// vulnerable line: 201: }",
                "// Line 202: ",
                "// Line 203:     case C.GO_RSA_PKCS1_PADDING:",
                "// Line 204:         if ch != 0 {",
                "// Line 205:             // We support unhashed messages.",
                "// Line 206:             md := cryptoHashToMD(ch)",
                "// Line 207:             if md == nil {",
                "// Line 208:                 return nil, errors.New(\"crypto/rsa: unsupported hash function\")",
                "// vulnerable line: 209: }",
                "// Line 210:             if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1, -1, C.GO_EVP_PKEY_CTRL_MD, 0, unsafe.Pointer(md)) != 1 {",
                "// Line 211:                 return nil, newOpenSSLError(\"EVP_PKEY_CTX_ctrl failed\")",
                "// vulnerable line: 212: }",
                "// Line 213:             if err := setPadding(); err != nil {",
                "// Line 214:                 return nil, err",
                "// vulnerable line: 215: }",
                "// vulnerable line: 216: }",
                "// Line 217:     default:",
                "// Line 218:         if err := setPadding(); err != nil {",
                "// Line 219:             return nil, err",
                "// vulnerable line: 220: }",
                "// vulnerable line: 221: }",
                "// Line 222:     return ctx, nil",
                "// vulnerable line: 223: }",
                "// Line 224: ",
                "// Line 225: func cryptEVP(withKey withKeyFunc, padding C.int,",
                "// Line 226:     h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,",
                "// Line 227:     init initFunc, crypt cryptFunc, in []byte) ([]byte, error) {",
                "// Line 228: ",
                "// Line 229:     ctx, err := setupEVP(withKey, padding, h, mgfHash, label, saltLen, ch, init)",
                "// Line 230:     if err != nil {",
                "// Line 231:         return nil, err",
                "// vulnerable line: 232: }",
                "// Line 233:     defer C.go_openssl_EVP_PKEY_CTX_free(ctx)",
                "// Line 234:     pkeySize := withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {",
                "// Line 235:         return C.go_openssl_EVP_PKEY_get_size(pkey)",
                "// vulnerable line: 236: })",
                "// Line 237:     outLen := C.size_t(pkeySize)",
                "// Line 238:     out := make([]byte, pkeySize)",
                "// Line 239:     if err := crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))); err != nil {",
                "// Line 240:         return nil, err",
                "// vulnerable line: 241: }",
                "// Line 242:     // The size returned by EVP_PKEY_get_size() is only preliminary and not exact,",
                "// Line 243:     // so the final contents of the out buffer may be smaller.",
                "// Line 244:     return out[:outLen], nil",
                "// vulnerable line: 245: }",
                "// Line 246: ",
                "// Line 247: func verifyEVP(withKey withKeyFunc, padding C.int,",
                "// Line 248:     h hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,",
                "// Line 249:     init initFunc, verify verifyFunc,",
                "// Line 250:     sig, in []byte) error {",
                "// Line 251: ",
                "// Line 252:     ctx, err := setupEVP(withKey, padding, h, nil, label, saltLen, ch, init)",
                "// Line 253:     if err != nil {",
                "// Line 254:         return err",
                "// vulnerable line: 255: }",
                "// Line 256:     defer C.go_openssl_EVP_PKEY_CTX_free(ctx)",
                "// Line 257:     return verify(ctx, base(sig), C.size_t(len(sig)), base(in), C.size_t(len(in)))",
                "// vulnerable line: 258: }",
                "// Line 259: ",
                "// Line 260: func evpEncrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {",
                "// Line 261:     encryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {",
                "// Line 262:         if ret := C.go_openssl_EVP_PKEY_encrypt_init(ctx); ret != 1 {",
                "// Line 263:             return newOpenSSLError(\"EVP_PKEY_encrypt_init failed\")",
                "// vulnerable line: 264: }",
                "// Line 265:         return nil",
                "// vulnerable line: 266: }",
                "// Line 267:     encrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {",
                "// Line 268:         if ret := C.go_openssl_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen); ret != 1 {",
                "// Line 269:             return newOpenSSLError(\"EVP_PKEY_encrypt failed\")",
                "// vulnerable line: 270: }",
                "// Line 271:         return nil",
                "// vulnerable line: 272: }",
                "// Line 273:     return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, encryptInit, encrypt, msg)",
                "// vulnerable line: 274: }",
                "// Line 275: ",
                "// Line 276: func evpDecrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {",
                "// Line 277:     decryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {",
                "// Line 278:         if ret := C.go_openssl_EVP_PKEY_decrypt_init(ctx); ret != 1 {",
                "// Line 279:             return newOpenSSLError(\"EVP_PKEY_decrypt_init failed\")",
                "// vulnerable line: 280: }",
                "// Line 281:         return nil",
                "// vulnerable line: 282: }",
                "// Line 283:     decrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {",
                "// Line 284:         if ret := C.go_openssl_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen); ret != 1 {",
                "// Line 285:             return newOpenSSLError(\"EVP_PKEY_decrypt failed\")",
                "// vulnerable line: 286: }",
                "// Line 287:         return nil",
                "// vulnerable line: 288: }",
                "// Line 289:     return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, decryptInit, decrypt, msg)",
                "// vulnerable line: 290: }",
                "// Line 291: ",
                "// Line 292: func evpSign(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, hashed []byte) ([]byte, error) {",
                "// Line 293:     signtInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {",
                "// Line 294:         if ret := C.go_openssl_EVP_PKEY_sign_init(ctx); ret != 1 {",
                "// Line 295:             return newOpenSSLError(\"EVP_PKEY_sign_init failed\")",
                "// vulnerable line: 296: }",
                "// Line 297:         return nil",
                "// vulnerable line: 298: }",
                "// Line 299:     sign := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {",
                "// Line 300:         if ret := C.go_openssl_EVP_PKEY_sign(ctx, out, outLen, in, inLen); ret != 1 {",
                "// Line 301:             return newOpenSSLError(\"EVP_PKEY_sign failed\")",
                "// vulnerable line: 302: }",
                "// Line 303:         return nil",
                "// vulnerable line: 304: }",
                "// Line 305:     return cryptEVP(withKey, padding, nil, nil, nil, saltLen, h, signtInit, sign, hashed)",
                "// vulnerable line: 306: }",
                "// Line 307: ",
                "// Line 308: func evpVerify(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, sig, hashed []byte) error {",
                "// Line 309:     verifyInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {",
                "// Line 310:         if ret := C.go_openssl_EVP_PKEY_verify_init(ctx); ret != 1 {",
                "// Line 311:             return newOpenSSLError(\"EVP_PKEY_verify_init failed\")",
                "// vulnerable line: 312: }",
                "// Line 313:         return nil",
                "// vulnerable line: 314: }",
                "// Line 315:     verify := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen C.size_t, in *C.uchar, inLen C.size_t) error {",
                "// Line 316:         if ret := C.go_openssl_EVP_PKEY_verify(ctx, out, outLen, in, inLen); ret != 1 {",
                "// Line 317:             return newOpenSSLError(\"EVP_PKEY_verify failed\")",
                "// vulnerable line: 318: }",
                "// Line 319:         return nil",
                "// vulnerable line: 320: }",
                "// Line 321:     return verifyEVP(withKey, padding, nil, nil, saltLen, h, verifyInit, verify, sig, hashed)",
                "// vulnerable line: 322: }",
                "// Line 323: ",
                "// Line 324: func newEVPPKEY(key C.GO_EC_KEY_PTR) (C.GO_EVP_PKEY_PTR, error) {",
                "// Line 325:     pkey := C.go_openssl_EVP_PKEY_new()",
                "// Line 326:     if pkey == nil {",
                "// Line 327:         return nil, newOpenSSLError(\"EVP_PKEY_new failed\")",
                "// vulnerable line: 328: }",
                "// Line 329:     if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_EC, (unsafe.Pointer)(key)) != 1 {",
                "// Line 330:         C.go_openssl_EVP_PKEY_free(pkey)",
                "// Line 331:         return nil, newOpenSSLError(\"EVP_PKEY_assign failed\")",
                "// vulnerable line: 332: }",
                "// Line 333:     return pkey, nil",
                "// vulnerable line: 334: }"
            ]
        }
    ]
}