{
    "cve_id": "CVE-2024-32487",
    "cve_description": "less through 653 allows OS command execution via a newline character in the name of a file, because quoting is mishandled in filename.c. Exploitation typically requires use with attacker-controlled file names, such as the files extracted from an untrusted archive. Exploitation also requires the LESSOPEN environment variable, but this is set by default in many common cases.",
    "cve_publish_date": "2024-04-13T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Fix bug when viewing a file whose name contains a newline.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "filename.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "25",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// vulnerable line: 1: /*",
                "// Line 2:  * Copyright (C) 1984-2024  Mark Nudelman",
                "// Line 3:  *",
                "// Line 4:  * You may distribute under the terms of either the GNU General Public",
                "// Line 5:  * License or the Less License, as specified in the README file.",
                "// Line 6:  *",
                "// Line 7:  * For more information, see the README file.",
                "// vulnerable line: 8: */",
                "// Line 9: ",
                "// Line 10: ",
                "// vulnerable line: 11: /*",
                "// Line 12:  * Routines to mess around with filenames (and files).",
                "// Line 13:  * Much of this is very OS dependent.",
                "// vulnerable line: 14: */",
                "// Line 15: ",
                "// Line 16: #include \"less.h\"",
                "// Line 17: #include \"lglob.h\"",
                "// Line 18: #if MSDOS_COMPILER",
                "// Line 19: #include <dos.h>",
                "// Line 20: #if MSDOS_COMPILER==WIN32C && !defined(_MSC_VER)",
                "// Line 21: #include <dir.h>",
                "// Line 22: #endif",
                "// Line 23: #if MSDOS_COMPILER==DJGPPC",
                "// Line 24: #include <glob.h>",
                "// Line 51: extern IFILE old_ifile;",
                "// Line 52: #if SPACES_IN_FILENAMES",
                "// Line 53: extern char openquote;",
                "// Line 54: extern char closequote;",
                "// Line 55: #endif",
                "// Line 56: #if HAVE_STAT_INO",
                "// Line 57: extern ino_t curr_ino;",
                "// Line 58: extern dev_t curr_dev;",
                "// Line 59: #endif",
                "// Line 60: ",
                "// vulnerable line: 61: /*",
                "// Line 62:  * Remove quotes around a filename.",
                "// vulnerable line: 63: */",
                "// Line 64: public char * shell_unquote(constant char *str)",
                "// Line 65: {",
                "// Line 66:     char *name;",
                "// Line 67:     char *p;",
                "// Line 68: ",
                "// Line 69:     name = p = (char *) ecalloc(strlen(str)+1, sizeof(char));",
                "// Line 70:     if (*str == openquote)",
                "// Line 71:     {",
                "// Line 72:         str++;",
                "// Line 73:         while (*str != '\u0000')",
                "// Line 88:         {",
                "// Line 89:             if (esclen > 0 && strncmp(str, esc, esclen) == 0)",
                "// Line 90:                 str += esclen;",
                "// Line 91:             *p++ = *str++;",
                "// Line 92:         }",
                "// Line 93:     }",
                "// Line 94:     *p = '\u0000';",
                "// Line 95:     return (name);",
                "// Line 96: }",
                "// Line 97: ",
                "// vulnerable line: 98: /*",
                "// Line 99:  * Get the shell's escape character.",
                "// vulnerable line: 100: */",
                "// Line 101: public constant char * get_meta_escape(void)",
                "// Line 102: {",
                "// Line 103:     constant char *s;",
                "// Line 104: ",
                "// Line 105:     s = lgetenv(\"LESSMETAESCAPE\");",
                "// Line 106:     if (s == NULL)",
                "// Line 107:         s = DEF_METAESCAPE;",
                "// Line 108:     return (s);",
                "// Line 109: }",
                "// Line 110: ",
                "// vulnerable line: 111: /*",
                "// Line 112:  * Get the characters which the shell considers to be \"metacharacters\".",
                "// vulnerable line: 113: */",
                "// Line 114: static constant char * metachars(void)",
                "// Line 115: {",
                "// Line 116:     static constant char *mchars = NULL;",
                "// Line 117: ",
                "// Line 118:     if (mchars == NULL)",
                "// Line 119:     {",
                "// Line 120:         mchars = lgetenv(\"LESSMETACHARS\");",
                "// Line 121:         if (mchars == NULL)",
                "// Line 122:             mchars = DEF_METACHARS;",
                "// Line 123:     }",
                "// Line 124:     return (mchars);",
                "// Line 125: }",
                "// Line 126: ",
                "// vulnerable line: 127: /*",
                "// Line 128:  * Is this a shell metacharacter?",
                "// vulnerable line: 129: */",
                "// vulnerable line: 130: static int metachar(char c)",
                "// Line 131: {",
                "// Line 132:     return (strchr(metachars(), c) != NULL);",
                "// Line 133: }",
                "// Line 134: ",
                "// vulnerable line: 135: /*",
                "// Line 136:  * Insert a backslash before each metacharacter in a string.",
                "// vulnerable line: 137: */",
                "// Line 138: public char * shell_quoten(constant char *s, size_t slen)",
                "// Line 139: {",
                "// Line 140:     constant char *p;",
                "// Line 141:     char *np;",
                "// Line 142:     char *newstr;",
                "// Line 143:     size_t len;",
                "// Line 144:     constant char *esc = get_meta_escape();",
                "// Line 145:     size_t esclen = strlen(esc);",
                "// Line 146:     lbool use_quotes = FALSE;",
                "// Line 147:     lbool have_quotes = FALSE;",
                "// Line 148: ",
                "// vulnerable line: 149: /*",
                "// Line 150:      * Determine how big a string we need to allocate.",
                "// vulnerable line: 151: */",
                "// Line 152:     len = 1; /* Trailing null byte */",
                "// Line 153:     for (p = s;  p < s + slen;  p++)",
                "// Line 154:     {",
                "// Line 155:         len++;",
                "// Line 156:         if (*p == openquote || *p == closequote)",
                "// Line 157:             have_quotes = TRUE;",
                "// Line 158:         if (metachar(*p))",
                "// Line 159:         {",
                "// Line 160:             if (esclen == 0)",
                "// Line 161:             {",
                "// vulnerable line: 162: /*",
                "// Line 163:                  * We've got a metachar, but this shell ",
                "// Line 164:                  * doesn't support escape chars.  Use quotes.",
                "// vulnerable line: 165: */",
                "// Line 166:                 use_quotes = TRUE;",
                "// Line 167:             } else",
                "// Line 168:             {",
                "// vulnerable line: 169: /*",
                "// Line 170:                  * Allow space for the escape char.",
                "// vulnerable line: 171: */",
                "// Line 172:                 len += esclen;",
                "// Line 173:             }",
                "// Line 174:         }",
                "// Line 175:     }",
                "// Line 176:     if (use_quotes)",
                "// Line 177:     {",
                "// Line 178:         if (have_quotes)",
                "// vulnerable line: 179: /*",
                "// Line 180:              * We can't quote a string that contains quotes.",
                "// vulnerable line: 181: */",
                "// Line 182:             return (NULL);",
                "// Line 183:         len = slen + 3;",
                "// Line 184:     }",
                "// vulnerable line: 185: /*",
                "// Line 186:      * Allocate and construct the new string.",
                "// vulnerable line: 187: */",
                "// Line 188:     newstr = np = (char *) ecalloc(len, sizeof(char));",
                "// Line 189:     if (use_quotes)",
                "// Line 190:     {",
                "// Line 191:         SNPRINTF4(newstr, len, \"%c%.*s%c\", openquote, (int) slen, s, closequote);",
                "// Line 192:     } else",
                "// Line 193:     {",
                "// Line 194:         constant char *es = s + slen;",
                "// Line 195:         while (s < es)",
                "// Line 196:         {",
                "// vulnerable line: 197: if (metachar(*s))",
                "// Line 198:             {",
                "// vulnerable line: 199: /*",
                "// vulnerable line: 200: * Add the escape char.",
                "// vulnerable line: 201: */",
                "// Line 202:                 strcpy(np, esc);",
                "// Line 203:                 np += esclen;",
                "// Line 204:             }",
                "// vulnerable line: 205: *np++ = *s++;",
                "// Line 206:         }",
                "// Line 207:         *np = '\u0000';",
                "// Line 208:     }",
                "// Line 209:     return (newstr);",
                "// Line 210: }",
                "// Line 211: ",
                "// Line 212: public char * shell_quote(constant char *s)",
                "// Line 213: {",
                "// Line 214:     return shell_quoten(s, strlen(s));",
                "// Line 215: }",
                "// Line 216: ",
                "// vulnerable line: 217: /*",
                "// Line 218:  * Return a pathname that points to a specified file in a specified directory.",
                "// Line 219:  * Return NULL if the file does not exist in the directory.",
                "// vulnerable line: 220: */",
                "// Line 221: public char * dirfile(constant char *dirname, constant char *filename, int must_exist)",
                "// Line 222: {",
                "// Line 223:     char *pathname;",
                "// Line 224:     size_t len;",
                "// Line 225:     int f;",
                "// Line 226: ",
                "// Line 227:     if (dirname == NULL || *dirname == '\u0000')",
                "// Line 228:         return (NULL);",
                "// vulnerable line: 229: /*",
                "// Line 230:      * Construct the full pathname.",
                "// vulnerable line: 231: */",
                "// Line 232:     len = strlen(dirname) + strlen(filename) + 2;",
                "// Line 233:     pathname = (char *) calloc(len, sizeof(char));",
                "// Line 234:     if (pathname == NULL)",
                "// Line 235:         return (NULL);",
                "// Line 236:     SNPRINTF3(pathname, len, \"%s%s%s\", dirname, PATHNAME_SEP, filename);",
                "// Line 237:     if (must_exist)",
                "// Line 238:     {",
                "// vulnerable line: 239: /*",
                "// Line 240:          * Make sure the file exists.",
                "// vulnerable line: 241: */",
                "// Line 242:         f = open(pathname, OPEN_READ);",
                "// Line 243:         if (f < 0)",
                "// Line 244:         {",
                "// Line 245:             free(pathname);",
                "// Line 246:             pathname = NULL;",
                "// Line 247:         } else",
                "// Line 248:         {",
                "// Line 249:             close(f);",
                "// Line 250:         }",
                "// Line 251:     }",
                "// Line 252:     return (pathname);",
                "// Line 253: }",
                "// Line 254: ",
                "// vulnerable line: 255: /*",
                "// Line 256:  * Return the full pathname of the given file in the \"home directory\".",
                "// vulnerable line: 257: */",
                "// Line 258: public char * homefile(constant char *filename)",
                "// Line 259: {",
                "// Line 260:     char *pathname;",
                "// Line 261: ",
                "// Line 262:     /* Try $HOME/filename. */",
                "// Line 263:     pathname = dirfile(lgetenv(\"HOME\"), filename, 1);",
                "// Line 264:     if (pathname != NULL)",
                "// Line 265:         return (pathname);",
                "// Line 266: #if OS2",
                "// Line 267:     /* Try $INIT/filename. */",
                "// Line 346:                 xcpy_filename(&xp, get_filename(ifile));",
                "// Line 347:         } else",
                "// Line 348:         {",
                "// Line 349:             xcpy_char(&xp, *fr);",
                "// Line 350:         }",
                "// Line 351:     }",
                "// Line 352:     if (xp.dest != NULL) xcpy_char(&xp, '\u0000');",
                "// Line 353:     return xp.copied;",
                "// Line 354: }",
                "// Line 355: ",
                "// vulnerable line: 356: /*",
                "// Line 357:  * Expand a string, substituting any \"%\" with the current filename,",
                "// Line 358:  * and any \"#\" with the previous filename.",
                "// Line 359:  * But a string of N \"%\"s is just replaced with N-1 \"%\"s.",
                "// Line 360:  * Likewise for a string of N \"#\"s.",
                "// Line 361:  * {{ This is a lot of work just to support % and #. }}",
                "// vulnerable line: 362: */",
                "// Line 363: public char * fexpand(constant char *s)",
                "// Line 364: {",
                "// Line 365:     size_t n;",
                "// Line 366:     char *e;",
                "// Line 367: ",
                "// vulnerable line: 368: /*",
                "// Line 369:      * Make one pass to see how big a buffer we ",
                "// Line 370:      * need to allocate for the expanded string.",
                "// vulnerable line: 371: */",
                "// Line 372:     n = fexpand_copy(s, NULL);",
                "// Line 373:     e = (char *) ecalloc(n, sizeof(char));",
                "// Line 374: ",
                "// vulnerable line: 375: /*",
                "// Line 376:      * Now copy the string, expanding any \"%\" or \"#\".",
                "// vulnerable line: 377: */",
                "// Line 378:     fexpand_copy(s, e);",
                "// Line 379:     return (e);",
                "// Line 380: }",
                "// Line 381: ",
                "// Line 382: ",
                "// Line 383: #if TAB_COMPLETE_FILENAME",
                "// Line 384: ",
                "// vulnerable line: 385: /*",
                "// Line 386:  * Return a blank-separated list of filenames which \"complete\"",
                "// Line 387:  * the given string.",
                "// vulnerable line: 388: */",
                "// Line 389: public char * fcomplete(constant char *s)",
                "// Line 390: {",
                "// Line 391:     char *fpat;",
                "// Line 392:     char *qs;",
                "// Line 393:     char *uqs;",
                "// Line 394: ",
                "// Line 395:     /* {{ Is this needed? lglob calls secure_allow. }} */",
                "// Line 396:     if (!secure_allow(SF_GLOB))",
                "// Line 397:         return (NULL);",
                "// vulnerable line: 398: /*",
                "// Line 399:      * Complete the filename \"s\" by globbing \"s*\".",
                "// vulnerable line: 400: */",
                "// Line 401: #if MSDOS_COMPILER && (MSDOS_COMPILER == MSOFTC || MSDOS_COMPILER == BORLANDC)",
                "// vulnerable line: 402: /*",
                "// Line 403:      * But in DOS, we have to glob \"s*.*\".",
                "// Line 404:      * But if the final component of the filename already has",
                "// Line 405:      * a dot in it, just do \"s*\".  ",
                "// Line 406:      * (Thus, \"FILE\" is globbed as \"FILE*.*\", ",
                "// Line 407:      *  but \"FILE.A\" is globbed as \"FILE.A*\").",
                "// vulnerable line: 408: */",
                "// Line 409:     {",
                "// Line 410:         constant char *slash;",
                "// Line 411:         size_t len;",
                "// Line 412:         for (slash = s+strlen(s)-1;  slash > s;  slash--)",
                "// Line 413:             if (*slash == *PATHNAME_SEP || *slash == '/')",
                "// Line 414:                 break;",
                "// Line 415:         len = strlen(s) + 4;",
                "// Line 416:         fpat = (char *) ecalloc(len, sizeof(char));",
                "// Line 417:         if (strchr(slash, '.') == NULL)",
                "// Line 418:             SNPRINTF1(fpat, len, \"%s*.*\", s);",
                "// Line 423:     {",
                "// Line 424:     size_t len = strlen(s) + 2;",
                "// Line 425:     fpat = (char *) ecalloc(len, sizeof(char));",
                "// Line 426:     SNPRINTF1(fpat, len, \"%s*\", s);",
                "// Line 427:     }",
                "// Line 428: #endif",
                "// Line 429:     qs = lglob(fpat);",
                "// Line 430:     uqs = shell_unquote(qs);",
                "// Line 431:     if (strcmp(uqs, fpat) == 0)",
                "// Line 432:     {",
                "// vulnerable line: 433: /*",
                "// Line 434:          * The filename didn't expand.",
                "// vulnerable line: 435: */",
                "// Line 436:         free(qs);",
                "// Line 437:         qs = NULL;",
                "// Line 438:     }",
                "// Line 439:     free(uqs);",
                "// Line 440:     free(fpat);",
                "// Line 441:     return (qs);",
                "// Line 442: }",
                "// Line 443: #endif",
                "// Line 444: ",
                "// vulnerable line: 445: /*",
                "// Line 446:  * Try to determine if a file is \"binary\".",
                "// Line 447:  * This is just a guess, and we need not try too hard to make it accurate.",
                "// Line 448:  *",
                "// Line 449:  * The number of bytes read is returned to the caller, because it will",
                "// Line 450:  * be used later to compare to st_size from stat(2) to see if the file",
                "// Line 451:  * is lying about its size.",
                "// vulnerable line: 452: */",
                "// Line 453: public int bin_file(int f, ssize_t *n)",
                "// Line 454: {",
                "// Line 455:     int bin_count = 0;",
                "// Line 456:     char data[256];",
                "// Line 457:     constant char* p;",
                "// Line 458:     constant char* edata;",
                "// Line 459: ",
                "// Line 460:     if (!seekable(f))",
                "// Line 461:         return (0);",
                "// Line 462:     if (less_lseek(f, (less_off_t)0, SEEK_SET) == BAD_LSEEK)",
                "// Line 476:             LWCHAR c = step_charc(&p, +1, edata);",
                "// Line 477:             struct ansi_state *pansi;",
                "// Line 478:             if (ctldisp == OPT_ONPLUS && (pansi = ansi_start(c)) != NULL)",
                "// Line 479:             {",
                "// Line 480:                 skip_ansi(pansi, &p, edata);",
                "// Line 481:                 ansi_done(pansi);",
                "// Line 482:             } else if (binary_char(c))",
                "// Line 483:                 bin_count++;",
                "// Line 484:         }",
                "// Line 485:     }",
                "// vulnerable line: 486: /*",
                "// Line 487:      * Call it a binary file if there are more than 5 binary characters",
                "// Line 488:      * in the first 256 bytes of the file.",
                "// vulnerable line: 489: */",
                "// Line 490:     return (bin_count > 5);",
                "// Line 491: }",
                "// Line 492: ",
                "// vulnerable line: 493: /*",
                "// Line 494:  * Try to determine the size of a file by seeking to the end.",
                "// vulnerable line: 495: */",
                "// Line 496: static POSITION seek_filesize(int f)",
                "// Line 497: {",
                "// Line 498:     less_off_t spos;",
                "// Line 499: ",
                "// Line 500:     spos = less_lseek(f, (less_off_t)0, SEEK_END);",
                "// Line 501:     if (spos == BAD_LSEEK)",
                "// Line 502:         return (NULL_POSITION);",
                "// Line 503:     return ((POSITION) spos);",
                "// Line 504: }",
                "// Line 505: ",
                "// Line 506: #if HAVE_POPEN",
                "// vulnerable line: 507: /*",
                "// Line 508:  * Read a string from a file.",
                "// Line 509:  * Return a pointer to the string in memory.",
                "// vulnerable line: 510: */",
                "// Line 511: public char * readfd(FILE *fd)",
                "// Line 512: {",
                "// Line 513:     struct xbuffer xbuf;",
                "// Line 514:     xbuf_init(&xbuf);",
                "// Line 515:     for (;;)",
                "// Line 516:     {",
                "// Line 517:         int ch;",
                "// Line 518:         if ((ch = getc(fd)) == '",
                "// Line 519: ' || ch == EOF)",
                "// Line 520:             break;",
                "// Line 521:         xbuf_add_char(&xbuf, (char) ch);",
                "// Line 522:     }",
                "// Line 523:     xbuf_add_char(&xbuf, '\u0000');",
                "// Line 524:     return (char *) xbuf.data;",
                "// Line 525: }",
                "// Line 526: ",
                "// vulnerable line: 527: /*",
                "// Line 528:  * Execute a shell command.",
                "// Line 529:  * Return a pointer to a pipe connected to the shell command's standard output.",
                "// vulnerable line: 530: */",
                "// Line 531: static FILE * shellcmd(constant char *cmd)",
                "// Line 532: {",
                "// Line 533:     FILE *fd;",
                "// Line 534: ",
                "// Line 535: #if HAVE_SHELL",
                "// Line 536:     constant char *shell;",
                "// Line 537: ",
                "// Line 538:     shell = lgetenv(\"SHELL\");",
                "// Line 539:     if (!isnullenv(shell))",
                "// Line 540:     {",
                "// Line 541:         char *scmd;",
                "// Line 542:         char *esccmd;",
                "// Line 543: ",
                "// vulnerable line: 544: /*",
                "// Line 545:          * Read the output of <$SHELL -c cmd>.  ",
                "// Line 546:          * Escape any metacharacters in the command.",
                "// vulnerable line: 547: */",
                "// Line 548:         esccmd = shell_quote(cmd);",
                "// Line 549:         if (esccmd == NULL)",
                "// Line 550:         {",
                "// Line 551:             fd = popen(cmd, \"r\");",
                "// Line 552:         } else",
                "// Line 553:         {",
                "// Line 554:             size_t len = strlen(shell) + strlen(esccmd) + 5;",
                "// Line 555:             scmd = (char *) ecalloc(len, sizeof(char));",
                "// Line 556:             SNPRINTF3(scmd, len, \"%s %s %s\", shell, shell_coption(), esccmd);",
                "// Line 557:             free(esccmd);",
                "// Line 558:             fd = popen(scmd, \"r\");",
                "// Line 559:             free(scmd);",
                "// Line 560:         }",
                "// Line 561:     } else",
                "// Line 562: #endif",
                "// Line 563:     {",
                "// Line 564:         fd = popen(cmd, \"r\");",
                "// Line 565:     }",
                "// vulnerable line: 566: /*",
                "// Line 567:      * Redirection in `popen' might have messed with the",
                "// Line 568:      * standard devices.  Restore binary input mode.",
                "// vulnerable line: 569: */",
                "// Line 570:     SET_BINARY(0);",
                "// Line 571:     return (fd);",
                "// Line 572: }",
                "// Line 573: ",
                "// Line 574: #endif /* HAVE_POPEN */",
                "// Line 575: ",
                "// Line 576: ",
                "// vulnerable line: 577: /*",
                "// Line 578:  * Expand a filename, doing any system-specific metacharacter substitutions.",
                "// vulnerable line: 579: */",
                "// Line 580: public char * lglob(constant char *afilename)",
                "// Line 581: {",
                "// Line 582:     char *gfilename;",
                "// Line 583:     char *filename = fexpand(afilename);",
                "// Line 584: ",
                "// Line 585:     if (!secure_allow(SF_GLOB))",
                "// Line 586:         return (filename);",
                "// Line 587: ",
                "// Line 588: #ifdef DECL_GLOB_LIST",
                "// Line 589: {",
                "// vulnerable line: 590: /*",
                "// Line 591:      * The globbing function returns a list of names.",
                "// vulnerable line: 592: */",
                "// Line 593:     size_t length;",
                "// Line 594:     char *p;",
                "// Line 595:     char *qfilename;",
                "// Line 596:     DECL_GLOB_LIST(list)",
                "// Line 597: ",
                "// Line 598:     GLOB_LIST(filename, list);",
                "// Line 599:     if (GLOB_LIST_FAILED(list))",
                "// Line 600:     {",
                "// Line 601:         return (filename);",
                "// Line 602:     }",
                "// Line 615:     for (SCAN_GLOB_LIST(list, p))",
                "// Line 616:     {",
                "// Line 617:         INIT_GLOB_LIST(list, p);",
                "// Line 618:         qfilename = shell_quote(p);",
                "// Line 619:         if (qfilename != NULL)",
                "// Line 620:         {",
                "// Line 621:             sprintf(gfilename + strlen(gfilename), \"%s \", qfilename);",
                "// Line 622:             free(qfilename);",
                "// Line 623:         }",
                "// Line 624:     }",
                "// vulnerable line: 625: /*",
                "// Line 626:      * Overwrite the final trailing space with a null terminator.",
                "// vulnerable line: 627: */",
                "// Line 628:     *--p = '\u0000';",
                "// Line 629:     GLOB_LIST_DONE(list);",
                "// Line 630: }",
                "// Line 631: #else",
                "// Line 632: #ifdef DECL_GLOB_NAME",
                "// Line 633: {",
                "// vulnerable line: 634: /*",
                "// Line 635:      * The globbing function returns a single name, and",
                "// Line 636:      * is called multiple times to walk thru all names.",
                "// vulnerable line: 637: */",
                "// Line 638:     char *p;",
                "// Line 639:     size_t len;",
                "// Line 640:     size_t n;",
                "// Line 641:     char *pfilename;",
                "// Line 642:     char *qfilename;",
                "// Line 643:     DECL_GLOB_NAME(fnd,drive,dir,fname,ext,handle)",
                "// Line 644:     ",
                "// Line 645:     GLOB_FIRST_NAME(filename, &fnd, handle);",
                "// Line 646:     if (GLOB_FIRST_FAILED(handle))",
                "// Line 647:     {",
                "// Line 656:         n = strlen(drive) + strlen(dir) + strlen(fnd.GLOB_NAME) + 1;",
                "// Line 657:         pfilename = (char *) ecalloc(n, sizeof(char));",
                "// Line 658:         SNPRINTF3(pfilename, n, \"%s%s%s\", drive, dir, fnd.GLOB_NAME);",
                "// Line 659:         qfilename = shell_quote(pfilename);",
                "// Line 660:         free(pfilename);",
                "// Line 661:         if (qfilename != NULL)",
                "// Line 662:         {",
                "// Line 663:             n = strlen(qfilename);",
                "// Line 664:             while (p - gfilename + n + 2 >= len)",
                "// Line 665:             {",
                "// vulnerable line: 666: /*",
                "// Line 667:                  * No room in current buffer.",
                "// Line 668:                  * Allocate a bigger one.",
                "// vulnerable line: 669: */",
                "// Line 670:                 len *= 2;",
                "// Line 671:                 *p = '\u0000';",
                "// Line 672:                 p = (char *) ecalloc(len, sizeof(char));",
                "// Line 673:                 strcpy(p, gfilename);",
                "// Line 674:                 free(gfilename);",
                "// Line 675:                 gfilename = p;",
                "// Line 676:                 p = gfilename + strlen(gfilename);",
                "// Line 677:             }",
                "// Line 678:             strcpy(p, qfilename);",
                "// Line 679:             free(qfilename);",
                "// Line 680:             p += n;",
                "// Line 681:             *p++ = ' ';",
                "// Line 682:         }",
                "// Line 683:     } while (GLOB_NEXT_NAME(handle, &fnd) == 0);",
                "// Line 684: ",
                "// vulnerable line: 685: /*",
                "// Line 686:      * Overwrite the final trailing space with a null terminator.",
                "// vulnerable line: 687: */",
                "// Line 688:     *--p = '\u0000';",
                "// Line 689:     GLOB_NAME_DONE(handle);",
                "// Line 690: }",
                "// Line 691: #else",
                "// Line 692: #if HAVE_POPEN",
                "// Line 693: {",
                "// vulnerable line: 694: /*",
                "// Line 695:      * We get the shell to glob the filename for us by passing",
                "// Line 696:      * an \"echo\" command to the shell and reading its output.",
                "// vulnerable line: 697: */",
                "// Line 698:     FILE *fd;",
                "// Line 699:     constant char *s;",
                "// Line 700:     constant char *lessecho;",
                "// Line 701:     char *cmd;",
                "// Line 702:     constant char *esc;",
                "// Line 703:     char *qesc;",
                "// Line 704:     size_t len;",
                "// Line 705: ",
                "// Line 706:     esc = get_meta_escape();",
                "// Line 707:     if (strlen(esc) == 0)",
                "// Line 708:         esc = \"-\";",
                "// Line 709:     qesc = shell_quote(esc);",
                "// Line 710:     if (qesc == NULL)",
                "// Line 711:     {",
                "// Line 712:         return (filename);",
                "// Line 713:     }",
                "// Line 714:     lessecho = lgetenv(\"LESSECHO\");",
                "// Line 715:     if (isnullenv(lessecho))",
                "// Line 716:         lessecho = \"lessecho\";",
                "// vulnerable line: 717: /*",
                "// Line 718:      * Invoke lessecho, and read its output (a globbed list of filenames).",
                "// vulnerable line: 719: */",
                "// Line 720:     len = strlen(lessecho) + strlen(filename) + (7*strlen(metachars())) + 24;",
                "// Line 721:     cmd = (char *) ecalloc(len, sizeof(char));",
                "// Line 722:     SNPRINTF4(cmd, len, \"%s -p0x%x -d0x%x -e%s \", lessecho,",
                "// Line 723:         (unsigned char) openquote, (unsigned char) closequote, qesc);",
                "// Line 724:     free(qesc);",
                "// Line 725:     for (s = metachars();  *s != '\u0000';  s++)",
                "// Line 726:         sprintf(cmd + strlen(cmd), \"-n0x%x \", (unsigned char) *s);",
                "// Line 727:     sprintf(cmd + strlen(cmd), \"-- %s\", filename);",
                "// Line 728:     fd = shellcmd(cmd);",
                "// Line 729:     free(cmd);",
                "// Line 730:     if (fd == NULL)",
                "// Line 731:     {",
                "// vulnerable line: 732: /*",
                "// Line 733:          * Cannot create the pipe.",
                "// Line 734:          * Just return the original (fexpanded) filename.",
                "// vulnerable line: 735: */",
                "// Line 736:         return (filename);",
                "// Line 737:     }",
                "// Line 738:     gfilename = readfd(fd);",
                "// Line 739:     pclose(fd);",
                "// Line 740:     if (*gfilename == '\u0000')",
                "// Line 741:     {",
                "// Line 742:         free(gfilename);",
                "// Line 743:         return (filename);",
                "// Line 744:     }",
                "// Line 745: }",
                "// Line 746: #else",
                "// vulnerable line: 747: /*",
                "// Line 748:      * No globbing functions at all.  Just use the fexpanded filename.",
                "// vulnerable line: 749: */",
                "// Line 750:     gfilename = save(filename);",
                "// Line 751: #endif",
                "// Line 752: #endif",
                "// Line 753: #endif",
                "// Line 754:     free(filename);",
                "// Line 755:     return (gfilename);",
                "// Line 756: }",
                "// Line 757: ",
                "// vulnerable line: 758: /*",
                "// Line 759:  * Does path not represent something in the file system?",
                "// vulnerable line: 760: */",
                "// Line 761: public lbool is_fake_pathname(constant char *path)",
                "// Line 762: {",
                "// Line 763:     return (strcmp(path, \"-\") == 0 ||",
                "// Line 764:             strcmp(path, FAKE_HELPFILE) == 0 || strcmp(path, FAKE_EMPTYFILE) == 0);",
                "// Line 765: }",
                "// Line 766: ",
                "// vulnerable line: 767: /*",
                "// Line 768:  * Return canonical pathname.",
                "// vulnerable line: 769: */",
                "// Line 770: public char * lrealpath(constant char *path)",
                "// Line 771: {",
                "// Line 772:     if (!is_fake_pathname(path))",
                "// Line 773:     {",
                "// Line 774: #if HAVE_REALPATH",
                "// vulnerable line: 775: /*",
                "// Line 776:          * Not all systems support the POSIX.1-2008 realpath() behavior",
                "// Line 777:          * of allocating when passing a NULL argument. And PATH_MAX is",
                "// Line 778:          * not required to be defined, or might contain an exceedingly",
                "// Line 779:          * big value. We assume that if it is not defined (such as on",
                "// Line 780:          * GNU/Hurd), then realpath() accepts NULL.",
                "// vulnerable line: 781: */",
                "// Line 782: #ifndef PATH_MAX",
                "// Line 783:         char *rpath;",
                "// Line 784: ",
                "// Line 785:         rpath = realpath(path, NULL);",
                "// Line 786:         if (rpath != NULL)",
                "// Line 787:             return (rpath);",
                "// Line 788: #else",
                "// Line 789:         char rpath[PATH_MAX];",
                "// Line 790:         if (realpath(path, rpath) != NULL)",
                "// Line 791:             return (save(rpath));",
                "// Line 792: #endif",
                "// Line 793: #endif",
                "// Line 794:     }",
                "// Line 795:     return (save(path));",
                "// Line 796: }",
                "// Line 797: ",
                "// Line 798: #if HAVE_POPEN",
                "// vulnerable line: 799: /*",
                "// Line 800:  * Return number of %s escapes in a string.",
                "// Line 801:  * Return a large number if there are any other % escapes besides %s.",
                "// vulnerable line: 802: */",
                "// Line 803: static int num_pct_s(constant char *lessopen)",
                "// Line 804: {",
                "// Line 805:     int num = 0;",
                "// Line 806: ",
                "// Line 807:     while (*lessopen != '\u0000')",
                "// Line 808:     {",
                "// Line 809:         if (*lessopen == '%')",
                "// Line 810:         {",
                "// Line 811:             if (lessopen[1] == '%')",
                "// Line 812:                 ++lessopen;",
                "// Line 814:                 ++num;",
                "// Line 815:             else",
                "// Line 816:                 return (999);",
                "// Line 817:         }",
                "// Line 818:         ++lessopen;",
                "// Line 819:     }",
                "// Line 820:     return (num);",
                "// Line 821: }",
                "// Line 822: #endif",
                "// Line 823: ",
                "// vulnerable line: 824: /*",
                "// Line 825:  * See if we should open a \"replacement file\" ",
                "// Line 826:  * instead of the file we're about to open.",
                "// vulnerable line: 827: */",
                "// Line 828: public char * open_altfile(constant char *filename, int *pf, void **pfd)",
                "// Line 829: {",
                "// Line 830: #if !HAVE_POPEN",
                "// Line 831:     return (NULL);",
                "// Line 832: #else",
                "// Line 833:     constant char *lessopen;",
                "// Line 834:     char *qfilename;",
                "// Line 835:     char *cmd;",
                "// Line 836:     size_t len;",
                "// Line 837:     FILE *fd;",
                "// Line 841:     ",
                "// Line 842:     if (!secure_allow(SF_LESSOPEN))",
                "// Line 843:         return (NULL);",
                "// Line 844:     if (!use_lessopen)",
                "// Line 845:         return (NULL);",
                "// Line 846:     ch_ungetchar(-1);",
                "// Line 847:     if ((lessopen = lgetenv(\"LESSOPEN\")) == NULL)",
                "// Line 848:         return (NULL);",
                "// Line 849:     while (*lessopen == '|')",
                "// Line 850:     {",
                "// vulnerable line: 851: /*",
                "// Line 852:          * If LESSOPEN starts with a |, it indicates ",
                "// Line 853:          * a \"pipe preprocessor\".",
                "// vulnerable line: 854: */",
                "// Line 855: #if !HAVE_FILENO",
                "// Line 856:         error(\"LESSOPEN pipe is not supported\", NULL_PARG);",
                "// Line 857:         return (NULL);",
                "// Line 858: #else",
                "// Line 859:         lessopen++;",
                "// Line 860:         returnfd++;",
                "// Line 861: #endif",
                "// Line 862:     }",
                "// Line 863:     if (*lessopen == '-')",
                "// Line 864:     {",
                "// vulnerable line: 865: /*",
                "// Line 866:          * Lessopen preprocessor will accept \"-\" as a filename.",
                "// vulnerable line: 867: */",
                "// Line 868:         lessopen++;",
                "// Line 869:     } else",
                "// Line 870:     {",
                "// Line 871:         if (strcmp(filename, \"-\") == 0)",
                "// Line 872:             return (NULL);",
                "// Line 873:     }",
                "// Line 874:     if (num_pct_s(lessopen) != 1)",
                "// Line 875:     {",
                "// Line 876:         error(\"LESSOPEN ignored: must contain exactly one %%s\", NULL_PARG);",
                "// Line 877:         return (NULL);",
                "// Line 879: ",
                "// Line 880:     qfilename = shell_quote(filename);",
                "// Line 881:     len = strlen(lessopen) + strlen(qfilename) + 2;",
                "// Line 882:     cmd = (char *) ecalloc(len, sizeof(char));",
                "// Line 883:     SNPRINTF1(cmd, len, lessopen, qfilename);",
                "// Line 884:     free(qfilename);",
                "// Line 885:     fd = shellcmd(cmd);",
                "// Line 886:     free(cmd);",
                "// Line 887:     if (fd == NULL)",
                "// Line 888:     {",
                "// vulnerable line: 889: /*",
                "// Line 890:          * Cannot create the pipe.",
                "// vulnerable line: 891: */",
                "// Line 892:         return (NULL);",
                "// Line 893:     }",
                "// Line 894: #if HAVE_FILENO",
                "// Line 895:     if (returnfd)",
                "// Line 896:     {",
                "// Line 897:         char c;",
                "// Line 898:         int f;",
                "// Line 899: ",
                "// vulnerable line: 900: /*",
                "// Line 901:          * The alt file is a pipe. Read one char ",
                "// Line 902:          * to see if the pipe will produce any data.",
                "// Line 903:          * If it does, push the char back on the pipe.",
                "// vulnerable line: 904: */",
                "// Line 905:         f = fileno(fd);",
                "// Line 906:         SET_BINARY(f);",
                "// Line 907:         if (read(f, &c, 1) != 1)",
                "// Line 908:         {",
                "// vulnerable line: 909: /*",
                "// Line 910:              * Pipe is empty.",
                "// Line 911:              * If more than 1 pipe char was specified,",
                "// Line 912:              * the exit status tells whether the file itself ",
                "// Line 913:              * is empty, or if there is no alt file.",
                "// Line 914:              * If only one pipe char, just assume no alt file.",
                "// vulnerable line: 915: */",
                "// Line 916:             int status = pclose(fd);",
                "// Line 917:             if (returnfd > 1 && status == 0) {",
                "// Line 918:                 /* File is empty. */",
                "// Line 919:                 *pfd = NULL;",
                "// Line 920:                 *pf = -1;",
                "// Line 921:                 return (save(FAKE_EMPTYFILE));",
                "// Line 922:             }",
                "// Line 923:             /* No alt file. */",
                "// Line 924:             return (NULL);",
                "// Line 925:         }",
                "// Line 928:         *pfd = (void *) fd;",
                "// Line 929:         *pf = f;",
                "// Line 930:         return (save(\"-\"));",
                "// Line 931:     }",
                "// Line 932: #endif",
                "// Line 933:     /* The alt file is a regular file. Read its name from LESSOPEN. */",
                "// Line 934:     cmd = readfd(fd);",
                "// Line 935:     pclose(fd);",
                "// Line 936:     if (*cmd == '\u0000')",
                "// Line 937:     {",
                "// vulnerable line: 938: /*",
                "// Line 939:          * Pipe is empty.  This means there is no alt file.",
                "// vulnerable line: 940: */",
                "// Line 941:         free(cmd);",
                "// Line 942:         return (NULL);",
                "// Line 943:     }",
                "// Line 944:     return (cmd);",
                "// Line 945: #endif /* HAVE_POPEN */",
                "// Line 946: }",
                "// Line 947: ",
                "// vulnerable line: 948: /*",
                "// Line 949:  * Close a replacement file.",
                "// vulnerable line: 950: */",
                "// Line 951: public void close_altfile(constant char *altfilename, constant char *filename)",
                "// Line 952: {",
                "// Line 953: #if HAVE_POPEN",
                "// Line 954:     constant char *lessclose;",
                "// Line 955:     char *qfilename;",
                "// Line 956:     char *qaltfilename;",
                "// Line 957:     FILE *fd;",
                "// Line 958:     char *cmd;",
                "// Line 959:     size_t len;",
                "// Line 960:     ",
                "// Line 974:     SNPRINTF2(cmd, len, lessclose, qfilename, qaltfilename);",
                "// Line 975:     free(qaltfilename);",
                "// Line 976:     free(qfilename);",
                "// Line 977:     fd = shellcmd(cmd);",
                "// Line 978:     free(cmd);",
                "// Line 979:     if (fd != NULL)",
                "// Line 980:         pclose(fd);",
                "// Line 981: #endif",
                "// Line 982: }",
                "// Line 983:         ",
                "// vulnerable line: 984: /*",
                "// Line 985:  * Is the specified file a directory?",
                "// vulnerable line: 986: */",
                "// Line 987: public lbool is_dir(constant char *filename)",
                "// Line 988: {",
                "// Line 989:     lbool isdir = FALSE;",
                "// Line 990: ",
                "// Line 991: #if HAVE_STAT",
                "// Line 992: {",
                "// Line 993:     int r;",
                "// Line 994:     less_stat_t statbuf;",
                "// Line 995: ",
                "// Line 996:     r = less_stat(filename, &statbuf);",
                "// Line 1004:     f = open(filename, S_IREAD | S_IFDIR);",
                "// Line 1005:     if (f >= 0)",
                "// Line 1006:         close(f);",
                "// Line 1007:     isdir = (f >= 0);",
                "// Line 1008: }",
                "// Line 1009: #endif",
                "// Line 1010: #endif",
                "// Line 1011:     return (isdir);",
                "// Line 1012: }",
                "// Line 1013: ",
                "// vulnerable line: 1014: /*",
                "// Line 1015:  * Returns NULL if the file can be opened and",
                "// Line 1016:  * is an ordinary file, otherwise an error message",
                "// Line 1017:  * (if it cannot be opened or is a directory, etc.)",
                "// vulnerable line: 1018: */",
                "// Line 1019: public char * bad_file(constant char *filename)",
                "// Line 1020: {",
                "// Line 1021:     char *m = NULL;",
                "// Line 1022: ",
                "// Line 1023:     if (!force_open && is_dir(filename))",
                "// Line 1024:     {",
                "// Line 1025:         static char is_a_dir[] = \" is a directory\";",
                "// Line 1026: ",
                "// Line 1027:         m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), ",
                "// Line 1028:             sizeof(char));",
                "// Line 1047:             m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),",
                "// Line 1048:                 sizeof(char));",
                "// Line 1049:             strcpy(m, filename);",
                "// Line 1050:             strcat(m, not_reg);",
                "// Line 1051:         }",
                "// Line 1052: #endif",
                "// Line 1053:     }",
                "// Line 1054:     return (m);",
                "// Line 1055: }",
                "// Line 1056: ",
                "// vulnerable line: 1057: /*",
                "// Line 1058:  * Return the size of a file, as cheaply as possible.",
                "// Line 1059:  * In Unix, we can stat the file.",
                "// vulnerable line: 1060: */",
                "// Line 1061: public POSITION filesize(int f)",
                "// Line 1062: {",
                "// Line 1063: #if HAVE_STAT",
                "// Line 1064:     less_stat_t statbuf;",
                "// Line 1065: ",
                "// Line 1066:     if (less_fstat(f, &statbuf) >= 0)",
                "// Line 1067:         return ((POSITION) statbuf.st_size);",
                "// Line 1068: #else",
                "// Line 1069: #ifdef _OSK",
                "// Line 1070:     long size;",
                "// Line 1072:     if ((size = (long) _gs_size(f)) >= 0)",
                "// Line 1073:         return ((POSITION) size);",
                "// Line 1074: #endif",
                "// Line 1075: #endif",
                "// Line 1076:     return (seek_filesize(f));",
                "// Line 1077: }",
                "// Line 1078: ",
                "// Line 1079: public lbool curr_ifile_changed(void)",
                "// Line 1080: {",
                "// Line 1081: #if HAVE_STAT_INO",
                "// vulnerable line: 1082: /* ",
                "// Line 1083:      * If the file's i-number or device has changed,",
                "// Line 1084:      * or if the file is smaller than it previously was,",
                "// Line 1085:      * the file must be different.",
                "// vulnerable line: 1086: */",
                "// Line 1087:     struct stat st;",
                "// Line 1088:     POSITION curr_pos = ch_tell();",
                "// Line 1089:     int r = stat(get_filename(curr_ifile), &st);",
                "// Line 1090:     if (r == 0 && (st.st_ino != curr_ino ||",
                "// Line 1091:         st.st_dev != curr_dev ||",
                "// Line 1092:         (curr_pos != NULL_POSITION && st.st_size < curr_pos)))",
                "// Line 1093:         return (TRUE);",
                "// Line 1094: #endif",
                "// Line 1095:     return (FALSE);",
                "// Line 1096: }",
                "// Line 1097: ",
                "// vulnerable line: 1098: /*",
                "// Line 1099:  * ",
                "// vulnerable line: 1100: */",
                "// Line 1101: public constant char * shell_coption(void)",
                "// Line 1102: {",
                "// Line 1103:     return (\"-c\");",
                "// Line 1104: }",
                "// Line 1105: ",
                "// vulnerable line: 1106: /*",
                "// Line 1107:  * Return last component of a pathname.",
                "// vulnerable line: 1108: */",
                "// Line 1109: public constant char * last_component(constant char *name)",
                "// Line 1110: {",
                "// Line 1111:     constant char *slash;",
                "// Line 1112: ",
                "// Line 1113:     for (slash = name + strlen(name);  slash > name; )",
                "// Line 1114:     {",
                "// Line 1115:         --slash;",
                "// Line 1116:         if (*slash == *PATHNAME_SEP || *slash == '/')",
                "// Line 1117:             return (slash + 1);",
                "// Line 1118:     }"
            ]
        }
    ]
}