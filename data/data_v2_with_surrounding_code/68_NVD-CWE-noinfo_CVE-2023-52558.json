{
    "cve_id": "CVE-2023-52558",
    "cve_description": "In OpenBSD 7.4 before errata 002 and OpenBSD 7.3 before errata 019, aÂ network buffer that had to be split at certain length that could crash the kernel after receiving specially crafted escape sequences.",
    "cve_publish_date": "2024-03-01T17:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Avoid assertion failure when splitting mbuf cluster.\n\nm_split() calls m_align() to initialize the data pointer of newly\nallocated mbuf.  If the new mbuf will be converted to a cluster,\nthis is not necessary.  If additionally the new mbuf is larger than\nMLEN, this can lead to a panic.\nOnly call m_align() when a valid m_data is needed.  This is the\ncase if we do not refecence the existing cluster, but memcpy() the\ndata into the new mbuf.\n\nReported-by: syzbot+0e6817f5877926f0e96a@syzkaller.appspotmail.com\nOK claudio@ deraadt@",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "uipc_mbuf.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "8",
            "Code_with_highlighted_vulnerability_lines": [
                "// vulnerable line: 1: /*    $OpenBSD: uipc_mbuf.c,v 1.287 2023/06/23 04:36:49 gnezdo Exp $    */",
                "// Line 2: /*    $NetBSD: uipc_mbuf.c,v 1.15.4.1 1996/06/13 17:11:44 cgd Exp $    */",
                "// Line 3: ",
                "// Line 4: /*",
                "// Line 5:  * Copyright (c) 1982, 1986, 1988, 1991, 1993",
                "// Line 6:  *    The Regents of the University of California.  All rights reserved.",
                "// Line 7:  *",
                "// Line 8:  * Redistribution and use in source and binary forms, with or without",
                "// Line 9:  * modification, are permitted provided that the following conditions",
                "// Line 10:  * are met:",
                "// Line 11:  * 1. Redistributions of source code must retain the above copyright",
                "// Line 435:         if (n)",
                "// Line 436:             n->m_flags |= M_ZEROIZE;",
                "// Line 437:     }",
                "// Line 438:     if (m->m_flags & M_PKTHDR) {",
                "// Line 439:         m_tag_delete_chain(m);",
                "// Line 440: #if NPF > 0",
                "// Line 441:         pf_mbuf_unlink_state_key(m);",
                "// Line 442:         pf_mbuf_unlink_inpcb(m);",
                "// Line 443: #endif    /* NPF > 0 */",
                "// Line 444:     }",
                "// vulnerable line: 445: if (m->m_flags & M_EXT)",
                "// Line 446:         m_extfree(m);",
                "// Line 447: ",
                "// Line 448:     pool_put(&mbpool, m);",
                "// Line 449: ",
                "// Line 450:     return (n);",
                "// Line 451: }",
                "// Line 452: ",
                "// Line 453: void",
                "// Line 454: m_extref(struct mbuf *o, struct mbuf *n)",
                "// Line 455: {",
                "// Line 562:             m_free(m0);",
                "// Line 563:             return (ENOBUFS);",
                "// Line 564:         }",
                "// Line 565:     }",
                "// Line 566:     m_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));",
                "// Line 567:     m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;",
                "// Line 568: ",
                "// Line 569:     /* free chain behind and possible ext buf on the first mbuf */",
                "// Line 570:     m_freem(m->m_next);",
                "// Line 571:     m->m_next = NULL;",
                "// vulnerable line: 572: if (m->m_flags & M_EXT)",
                "// Line 573:         m_extfree(m);",
                "// Line 574: ",
                "// Line 575:     /*",
                "// Line 576:      * Bounce copy mbuf over to the original mbuf and set everything up.",
                "// Line 577:      * This needs to reset or clear all pointers that may go into the",
                "// Line 578:      * original mbuf chain.",
                "// Line 579:      */",
                "// Line 580:     if (m0->m_flags & M_EXT) {",
                "// Line 581:         memcpy(&m->m_ext, &m0->m_ext, sizeof(struct mbuf_ext));",
                "// Line 582:         MCLINITREFERENCE(m);",
                "// Line 931: ",
                "// Line 932:     head = M_DATABUF(m0);",
                "// Line 933:     if (m0->m_len == 0) {",
                "// Line 934:         while (m->m_len == 0) {",
                "// Line 935:             m = m_free(m);",
                "// Line 936:             if (m == NULL)",
                "// Line 937:                 goto freem0;",
                "// Line 938:         }",
                "// Line 939: ",
                "// Line 940:         adj = mtod(m, unsigned long) & (sizeof(long) - 1);",
                "// vulnerable line: 941: } else",
                "// Line 942:         adj = mtod(m0, unsigned long) & (sizeof(long) - 1);",
                "// Line 943: ",
                "// Line 944:     tail = head + M_SIZE(m0);",
                "// Line 945:     head += adj;",
                "// Line 946: ",
                "// Line 947:     if (!M_READONLY(m0) && len <= tail - head) {",
                "// Line 948:         /* we can copy everything into the first mbuf */",
                "// Line 949:         if (m0->m_len == 0) {",
                "// Line 950:             m0->m_data = head;",
                "// Line 951:         } else if (len > tail - mtod(m0, caddr_t)) {",
                "// Line 1071:         }",
                "// Line 1072:         n->m_pkthdr.len -= len0;",
                "// Line 1073:         olen = m0->m_pkthdr.len;",
                "// Line 1074:         m0->m_pkthdr.len = len0;",
                "// Line 1075:         if (remain == 0) {",
                "// Line 1076:             n->m_next = m->m_next;",
                "// Line 1077:             m->m_next = NULL;",
                "// Line 1078:             n->m_len = 0;",
                "// Line 1079:             return (n);",
                "// Line 1080:         }",
                "// vulnerable line: 1081: if (m->m_flags & M_EXT)",
                "// vulnerable line: 1082: goto extpacket;",
                "// vulnerable line: 1083: if (remain > MHLEN) {",
                "// Line 1084:             /* m can't be the lead packet */",
                "// Line 1085:             m_align(n, 0);",
                "// Line 1086:             n->m_next = m_split(m, len, wait);",
                "// Line 1087:             if (n->m_next == NULL) {",
                "// Line 1088:                 (void) m_free(n);",
                "// Line 1089:                 m0->m_pkthdr.len = olen;",
                "// Line 1090:                 return (NULL);",
                "// Line 1091:             } else {",
                "// Line 1092:                 n->m_len = 0;",
                "// Line 1093:                 return (n);",
                "// Line 1094:             }",
                "// vulnerable line: 1095: } else",
                "// vulnerable line: 1096: m_align(n, remain);",
                "// Line 1097:     } else if (remain == 0) {",
                "// Line 1098:         n = m->m_next;",
                "// Line 1099:         m->m_next = NULL;",
                "// Line 1100:         return (n);",
                "// Line 1101:     } else {",
                "// Line 1102:         MGET(n, wait, m->m_type);",
                "// Line 1103:         if (n == NULL)",
                "// Line 1104:             return (NULL);",
                "// vulnerable line: 1105: m_align(n, remain);",
                "// Line 1106:     }",
                "// vulnerable line: 1107: extpacket:",
                "// Line 1108:     if (m->m_flags & M_EXT) {",
                "// Line 1109:         n->m_ext = m->m_ext;",
                "// Line 1110:         MCLADDREFERENCE(m, n);",
                "// Line 1111:         n->m_data = m->m_data + len;",
                "// Line 1112:     } else {",
                "// Line 1113:         memcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);",
                "// Line 1114:     }",
                "// Line 1115:     n->m_len = remain;",
                "// Line 1116:     m->m_len = len;",
                "// Line 1117:     n->m_next = m->m_next;",
                "// Line 1250:                  */",
                "// Line 1251:                 top->m_flags |= M_ZEROIZE;",
                "// Line 1252:                 m_freem(top);",
                "// Line 1253:                 return (NULL);",
                "// Line 1254:             }",
                "// Line 1255:             len = MLEN;",
                "// Line 1256:         }",
                "// Line 1257: ",
                "// Line 1258:         if (totlen + off >= MINCLSIZE) {",
                "// Line 1259:             MCLGET(m, M_DONTWAIT);",
                "// vulnerable line: 1260: if (m->m_flags & M_EXT)",
                "// Line 1261:                 len = MCLBYTES;",
                "// Line 1262:         } else {",
                "// Line 1263:             /* Place initial small packet/header at end of mbuf. */",
                "// Line 1264:             if (top == NULL && totlen + off + max_linkhdr <= len) {",
                "// Line 1265:                 m->m_data += max_linkhdr;",
                "// Line 1266:                 len -= max_linkhdr;",
                "// Line 1267:             }",
                "// Line 1268:         }",
                "// Line 1269: ",
                "// Line 1270:         if (off) {",
                "// Line 1451: ",
                "// Line 1452: void",
                "// Line 1453: m_microtime(const struct mbuf *m, struct timeval *tv)",
                "// Line 1454: {",
                "// Line 1455:     if (ISSET(m->m_pkthdr.csum_flags, M_TIMESTAMP)) {",
                "// Line 1456:         struct timeval btv, utv;",
                "// Line 1457: ",
                "// Line 1458:         NSEC_TO_TIMEVAL(m->m_pkthdr.ph_timestamp, &utv);",
                "// Line 1459:         microboottime(&btv);",
                "// Line 1460:         timeradd(&btv, &utv, tv);",
                "// vulnerable line: 1461: } else",
                "// Line 1462:         microtime(tv);",
                "// Line 1463: }",
                "// Line 1464: ",
                "// Line 1465: void *",
                "// Line 1466: m_pool_alloc(struct pool *pp, int flags, int *slowdown)",
                "// Line 1467: {",
                "// Line 1468:     void *v;",
                "// Line 1469: ",
                "// Line 1470:     if (atomic_add_long_nv(&mbuf_mem_alloc, pp->pr_pgsize) > mbuf_mem_limit)",
                "// Line 1471:         goto fail;"
            ]
        }
    ]
}