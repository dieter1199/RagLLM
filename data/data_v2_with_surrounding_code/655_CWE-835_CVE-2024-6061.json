{
    "cve_id": "CVE-2024-6061",
    "cve_description": "A vulnerability has been found in GPAC 2.5-DEV-rev228-g11067ea92-master and classified as problematic. Affected by this vulnerability is the function isoffin_process of the file src/filters/isoffin_read.c of the component MP4Box. The manipulation leads to infinite loop. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used. The identifier of the patch is 20c0f29139a82779b86453ce7f68d0681ec7624c. It is recommended to apply a patch to fix this issue. The identifier VDB-268789 was assigned to this vulnerability.",
    "cve_publish_date": "2024-06-17T20:15Z",
    "cwe_id": "CWE-835",
    "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
    "cwe_description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
    "commit_message": "fixed #2871",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "isoffin_read.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1724:                     gf_filter_pid_send_flush(ch->pid);",
                "// Line 1725:                 }",
                "// Line 1726:                 else if (ch->playing == 2) {",
                "// Line 1727:                     if (in_is_eos) {",
                "// Line 1728:                         ch->playing = 0;",
                "// Line 1729:                     } else {",
                "// Line 1730:                         nb_forced_end++;",
                "// Line 1731:                         check_forced_end = GF_TRUE;",
                "// Line 1732:                     }",
                "// Line 1733:                 }",
                "// vulnerable line: 1734: ch->nb_empty_retry++;",
                "// Line 1735:                 if (in_is_eos && !ch->eos_sent) {",
                "// Line 1736:                     void *tfrf;",
                "// Line 1737:                     const void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);",
                "// Line 1738: ",
                "// Line 1739:                     ch->eos_sent = 1;",
                "// Line 1740:                     read->eos_signaled = GF_TRUE;",
                "// Line 1741: ",
                "// Line 1742:                     tfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);",
                "// Line 1743:                     if (tfrf) {",
                "// Line 1744:                         gf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );",
                "// Line 1745:                         ch->last_has_tfrf = 1;",
                "// Line 1746:                     } else if (ch->last_has_tfrf) {",
                "// Line 1747:                         gf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);",
                "// Line 1748:                         ch->last_has_tfrf = 0;",
                "// Line 1749:                     }",
                "// Line 1750: ",
                "// Line 1751:                     gf_filter_pid_set_eos(ch->pid);",
                "// Line 1752:                 }",
                "// Line 1753:                 break;",
                "// Line 1754:             } else if (ch->last_state==GF_ISOM_INVALID_FILE) {",
                "// vulnerable line: 1755: ch->nb_empty_retry++;",
                "// Line 1756:                 if (!ch->eos_sent) {",
                "// Line 1757:                     ch->eos_sent = 1;",
                "// Line 1758:                     read->eos_signaled = GF_TRUE;",
                "// Line 1759:                     gf_filter_pid_set_eos(ch->pid);",
                "// Line 1760:                 }",
                "// Line 1761:                 return ch->last_state;",
                "// Line 1762:             } else {",
                "// Line 1763:                 if ((ch->last_state==GF_OK) && ch->sap_only)",
                "// Line 1764:                     gf_filter_ask_rt_reschedule(filter, 1);",
                "// Line 1765: ",
                "// Line 1766:                 read->force_fetch = GF_TRUE;",
                "// vulnerable line: 1767: ch->nb_empty_retry++;",
                "// Line 1768:                 break;",
                "// Line 1769:             }",
                "// Line 1770:         }",
                "// Line 1771:         //if no sample fetched for 100 calls, consider no sample for this track and don't use it for memory purge",
                "// Line 1772:         //this is typically needed when some tracks are declared in fragmented mode but not present in the stream (at all or for a long time):",
                "// Line 1773:         //for these tracks, min_offset_plus_one is always 1 (no samples) or a much smaller value than for active tracks",
                "// Line 1774:         // hence forever growing mem storage until stuck at max size...",
                "// Line 1775:         if ((ch->nb_empty_retry<100)",
                "// Line 1776:             && (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))",
                "// Line 1777:         ) {"
            ]
        },
        {
            "filename_of_changes": "isoffin_read_ch.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "0",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 41:     if (ch->static_sample) {",
                "// Line 42:         ch->static_sample->dataLength = ch->static_sample->alloc_size;",
                "// Line 43:         gf_isom_sample_del(&ch->static_sample);",
                "// Line 44:     }",
                "// Line 45:     ch->sample = NULL;",
                "// Line 46:     ch->sample_num = 0;",
                "// Line 47:     ch->speed = 1.0;",
                "// Line 48:     ch->start = ch->end = 0;",
                "// Line 49:     ch->to_init = 1;",
                "// Line 50:     ch->playing = 0;",
                "// vulnerable line: 51: ch->nb_empty_retry = 0;",
                "// Line 52:     if (ch->sai_buffer) gf_free(ch->sai_buffer);",
                "// Line 53:     ch->sai_buffer = NULL;",
                "// Line 54:     ch->sai_alloc_size = 0;",
                "// Line 55:     ch->dts = ch->cts = 0;",
                "// Line 56:     ch->seek_flag = 0;",
                "// Line 57: }",
                "// Line 58: ",
                "// Line 59: void isor_check_producer_ref_time(ISOMReader *read)",
                "// Line 60: {",
                "// Line 61:     GF_ISOTrackID trackID;",
                "// Line 531:         isor_reader_get_sample(ch);",
                "// Line 532:         return;",
                "// Line 533:     }",
                "// Line 534: ",
                "// Line 535:     if (!ch->sample) {",
                "// Line 536:         u32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);",
                "// Line 537:         ch->sample_data_offset = 0;",
                "// Line 538:         /*incomplete file - check if we're still downloading or not*/",
                "// Line 539:         if (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {",
                "// Line 540:             ch->last_state = GF_ISOM_INCOMPLETE_FILE;",
                "// vulnerable line: 541: ch->nb_empty_retry = 0;",
                "// Line 542:             if (ch->owner->mem_load_mode==2)",
                "// Line 543:                 ch->owner->force_fetch = GF_TRUE;",
                "// Line 544: ",
                "// Line 545:             if (!ch->owner->input_loaded) {",
                "// Line 546:                 ch->last_state = GF_OK;",
                "// Line 547:                 if (!ch->has_edit_list && ch->sample_num)",
                "// Line 548:                     ch->sample_num--;",
                "// Line 549:             } else {",
                "// Line 550:                 if (ch->to_init && ch->sample_num) {",
                "// Line 551:                     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d"
            ]
        }
    ]
}