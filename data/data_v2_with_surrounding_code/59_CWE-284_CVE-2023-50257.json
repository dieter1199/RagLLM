{
    "cve_id": "CVE-2023-50257",
    "cve_description": "eProsima Fast DDS (formerly Fast RTPS) is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Even with the application of SROS2, due to the issue where the data (`p[UD]`) and `guid` values used to disconnect between nodes are not encrypted, a vulnerability has been discovered where a malicious attacker can forcibly disconnect a Subscriber and can deny a Subscriber attempting to connect. Afterwards, if the attacker sends the packet for disconnecting, which is data (`p[UD]`), to the Global Data Space (`239.255.0.1:7400`) using the said Publisher ID, all the Subscribers (Listeners) connected to the Publisher (Talker) will not receive any data and their connection will be disconnected. Moreover, if this disconnection packet is sent continuously, the Subscribers (Listeners) trying to connect will not be able to do so. Since the initial commit of the `SecurityManager.cpp` code (`init`, `on_process_handshake`) on Nov 8, 2016, the Disconnect Vulnerability in RTPS Packets Used by SROS2 has been present prior to versions 2.13.0, 2.12.2, 2.11.3, 2.10.3, and 2.6.7.",
    "cve_publish_date": "2024-02-19T20:15Z",
    "cwe_id": "CWE-284",
    "cwe_name": "Improper Access Control",
    "cwe_description": "The product does not restrict or incorrectly restricts access to a resource from an unauthorized actor.",
    "commit_message": "Fix CVE-2023-50257\n\nSigned-off-by: Miguel Company <miguelcompany@eprosima.com>\nCo-authored-by: Mario Dominguez <mariodominguez@eprosima.com>\n\ncommit f2bcd264798ebd0d45241e57f7d522c68920b26f\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Thu Dec 14 10:52:32 2023 +0100\n\n    Refs #19770. Improve BuiltinAuthenticationPlugin_second_participant_creation_loop.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit 07380f840422f8ea2a6ae62ec901fe94687f3b3c\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Wed Dec 13 08:21:34 2023 +0100\n\n    Refs #19770. Fix PDPTests.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit 4c2c21e5f2be63c1f4e0766cc8bc5a59a857b106\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Wed Dec 13 07:26:51 2023 +0100\n\n    Refs #19770. Adding override keyword.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit d185a85b937a1fd64f86a40b9db2d0b994e39a7f\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Tue Dec 12 16:05:00 2023 +0100\n\n    Refs #19770. Uncrustify.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit 54a01ab0eff0e326c868d1a32bd44203bf184b4d\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Tue Dec 12 10:29:42 2023 +0100\n\n    Refs #19770. PDPSecurityInitiatorListener relies on PDPListener::onNewCacheChangeAdded.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit 202bc52a4584025c897e06a40f50d5d7d6be8ce6\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Tue Dec 12 09:49:20 2023 +0100\n\n    Refs #19770. Only process removals when reader is matched.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit a4a30779c0ae3b410b8cce4aa56f47490995d20d\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Tue Dec 12 09:46:03 2023 +0100\n\n    Refs #19770. Added PDPSecurityInitiatorListener::process_alive_data.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit 3c7547e0b125ab7156aaf3f72b1a431a9d77672f\nAuthor: Miguel Company <miguelcompany@eprosima.com>\nDate:   Tue Dec 12 09:32:55 2023 +0100\n\n    Refs #19770. Refactor with PDPListener::process_alive_data.\n\n    Signed-off-by: Miguel Company <miguelcompany@eprosima.com>\n\ncommit 4571178679af32902a5ba6719807b75eabafc296\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 15 12:28:14 2023 +0100\n\n    Refs #19770. StatelessReader does not call update_last_notified for not matched writers.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 8294ca3b0bae320f066779dfa1d9a8690b16ebfc\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 29 13:30:14 2023 +0100\n\n    Refs #19770. Avoid dynamic_cast when participant is not secure.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 83820e84c6cc3dcaf53e6ffe784ed03b2fac9bfa\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 29 13:24:59 2023 +0100\n\n    Refs #19770. Avoid warning when built without security.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 8ce1216f6af4758f4cb8dc1ea63c770a5ff86e1a\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 29 12:55:28 2023 +0100\n\n    Refs #19770. Fixed typo in comments.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 7bb64eb4a0b899b8055beb8a8b0b279db80e20d6\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 29 12:52:07 2023 +0100\n\n    Refs #19770. Use constexpr for topic names.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit eef95273d5464210c50a01cb22cc4a3989233f2f\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 29 12:50:56 2023 +0100\n\n    Refs #19770. Send participant dispose messages through both writers.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit c3c831f5f047c4a02a3ddd9944ce3015644f3e27\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Tue Nov 28 10:07:17 2023 +0100\n\n    Refs #19770. Move to `AUTHENTICATION_FAILED` when authentication fails.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 11f98a4d0132d630b76c68ed4157a8624dcffaa5\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Tue Nov 28 10:05:47 2023 +0100\n\n    Refs #19770. Simulate DATA(p) reception on non secure `notifyAboveRemoteEndpoints`.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 5097288e5f4816e653a7c5a4c4839d2a077f3d19\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Wed Nov 22 09:36:14 2023 +0100\n\n    Refs #19770. Common factor method `notify_and_maybe_ignore_new_participant`.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 9364310c5c3cf47b586470b90f9511b0be11fbc4\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Tue Nov 21 07:56:17 2023 +0100\n\n    Refs #19770. Improve AllowUnauthenticatedParticipants blackbox tests.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit bb8af40be3c8c138e48acfced5835f2066d864dd\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Mon Nov 20 09:53:10 2023 +0100\n\n    Refs #19770. Change builtin endpoints matching workflow.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 4fc685f75949637ee07ede7a72dd43ed4ab351f3\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Fri Nov 17 12:34:40 2023 +0100\n\n    Refs #19770. Chages in announceParticipantState.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit fb26bbccf6400123d2cb0d89d34f8c907e301d1a\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Fri Nov 17 12:23:48 2023 +0100\n\n    Refs #19770. Chages in removeRemoteEndpoints.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 96442d58fa0b16984289bbe16a132769e9cbcd81\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Fri Nov 17 12:15:35 2023 +0100\n\n    Refs #19770. Chages in notifyAboveRemoteEndpoints.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit cea35be6c84e633a500bd4565119d1a7ec6066da\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Fri Nov 17 11:52:15 2023 +0100\n\n    Refs #19770. Additional work on endpoints creation.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 02f95cf90b8acdf84c0c6dd357b8a7a26816db93\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Fri Nov 17 10:46:48 2023 +0100\n\n    Refs #19770. Methods in PDP to setup builtin endpoints security attributes.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 1f5c43734dfc6d420103e16132034e7e85ba0c3a\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Fri Nov 17 10:38:57 2023 +0100\n\n    Refs #19770. Methods in PDP to create builtin endpoints attributes.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 49624e88746389b44384f007dc17610ba929731a\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 16:56:25 2023 +0100\n\n    Refs #19770. Endpoints creation refactor.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 4ab8d1e1e24819da5d27009ec3e80051329dfbb0\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 16:28:15 2023 +0100\n\n    Refs #19770. Fix unprotected access to local participant data.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 57b99075eae290412b4d08798e1df27fc9972e1c\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 15:38:24 2023 +0100\n\n    Refs #19770. Added SimplePDPEndpointsSecure.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit e67c703db6956e15e187868f90f1f99b25e37627\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 15:28:38 2023 +0100\n\n    Refs #19770. Listeners moved into BuiltinReader.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit b2fe97e1e0001b24b18d4b145143139a084dc37d\nAuthor: Mario Dominguez <mariodominguez@eprosima.com>\nDate:   Wed Nov 8 15:42:34 2023 +0100\n\n    Refs #19770. PDP listener moved into PDPEndpoints.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 1af9da00af27591be14a1abe1d9928ccff83048d\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 13:33:37 2023 +0100\n\n    Refs #19770. Test improvements.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 03eeda5f6b305768cc876056ff6584c153c947d1\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 13:21:45 2023 +0100\n\n    Refs #19770. Regression test for vulnerability.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\ncommit 6cd538753fb8be550f9b3a58c508021d2bdf6ccd\nAuthor: Miguel Company <MiguelCompany@eprosima.com>\nDate:   Thu Nov 16 12:30:36 2023 +0100\n\n    Refs #19770. Refactor on BlackboxTestsSecurity.\n\n    Signed-off-by: Miguel Company <MiguelCompany@eprosima.com>\n\nSigned-off-by: Miguel Company <miguelcompany@eprosima.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "BuiltinReader.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "DiscoveryServerPDPEndpoints.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "DiscoveryServerPDPEndpointsSecure.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "0",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 82:             stateless_reader.history_->remove_change(change);",
                "// Line 83:         }",
                "// Line 84:         else",
                "// Line 85:         {",
                "// Line 86:             DiscoveryServerPDPEndpoints::remove_from_pdp_reader_history(change);",
                "// Line 87:         }",
                "// Line 88:     }",
                "// Line 89: ",
                "// Line 90:     //! Builtin Simple PDP reader",
                "// Line 91:     BuiltinReader<fastrtps::rtps::StatelessReader> stateless_reader;",
                "// vulnerable line: 92: //! Listener for stateless_reader",
                "// vulnerable line: 93: std::unique_ptr<fastrtps::rtps::ReaderListener> stateless_listener;",
                "// Line 94: };",
                "// Line 95: ",
                "// Line 96: } // namespace rtps",
                "// Line 97: } // namespace fastdds",
                "// Line 98: } // namespace eprosima",
                "// Line 99: ",
                "// Line 100: #endif  // FASTDDS_RTPS_BUILTIN_DISCOVERY_PARTICIPANT_DS__DISCOVERYSERVERPDPENDPOINTSSECURE_HPP_"
            ]
        },
        {
            "filename_of_changes": "PDP.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "14",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 323:     /**",
                "// Line 324:      * This method returns the BuiltinAttributes of the local participant.",
                "// Line 325:      * @return const reference to the BuiltinAttributes of the local participant.",
                "// Line 326:      */",
                "// Line 327:     const BuiltinAttributes& builtin_attributes() const;",
                "// Line 328: ",
                "// Line 329:     /**",
                "// Line 330:      * Get a pointer to the local RTPSParticipant ParticipantProxyData object.",
                "// Line 331:      * @return Pointer to the local RTPSParticipant ParticipantProxyData object.",
                "// Line 332:      */",
                "// vulnerable line: 333: ParticipantProxyData* getLocalParticipantProxyData()",
                "// Line 334:     {",
                "// vulnerable line: 335: return participant_proxies_.front();",
                "// Line 336:     }",
                "// Line 337: ",
                "// Line 338:     /**",
                "// Line 339:      * Get a pointer to the EDP object.",
                "// Line 340:      * @return pointer to the EDP object.",
                "// Line 341:      */",
                "// Line 342:     inline EDP* getEDP()",
                "// Line 343:     {",
                "// Line 344:         return mp_EDP;",
                "// Line 345:     }",
                "// Line 494:     //!Number of reader proxy data objects created",
                "// Line 495:     size_t reader_proxies_number_;",
                "// Line 496:     //!Pool of reader proxy data objects ready for reuse",
                "// Line 497:     ResourceLimitedVector<ReaderProxyData*> reader_proxies_pool_;",
                "// Line 498:     //!Number of writer proxy data objects created",
                "// Line 499:     size_t writer_proxies_number_;",
                "// Line 500:     //!Pool of writer proxy data objects ready for reuse",
                "// Line 501:     ResourceLimitedVector<WriterProxyData*> writer_proxies_pool_;",
                "// Line 502:     //!Variable to indicate if any parameter has changed.",
                "// Line 503:     std::atomic_bool m_hasChangedLocalPDP;",
                "// vulnerable line: 504: //!Listener for the SPDP messages.",
                "// vulnerable line: 505: ReaderListener* mp_listener;",
                "// Line 506:     //! ProxyPool for temporary reader proxies",
                "// Line 507:     ProxyPool<ReaderProxyData> temp_reader_proxies_;",
                "// Line 508:     //! ProxyPool for temporary writer proxies",
                "// Line 509:     ProxyPool<WriterProxyData> temp_writer_proxies_;",
                "// Line 510:     //!Participant data atomic access assurance",
                "// Line 511:     std::recursive_mutex* mp_mutex;",
                "// Line 512:     //!To protect callbacks (ParticipantProxyData&)",
                "// Line 513:     std::mutex callback_mtx_;",
                "// Line 514:     //!Tell if object is enabled",
                "// Line 515:     std::atomic<bool> enabled_ {false};"
            ]
        },
        {
            "filename_of_changes": "PDPClient.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "21",
            "number_of_lines_deleted_vulnerable_to_cve": "23",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 55: namespace rtps {",
                "// Line 56: ",
                "// Line 57: using namespace fastrtps::rtps;",
                "// Line 58: ",
                "// Line 59: static void direct_send(",
                "// Line 60:         RTPSParticipantImpl* participant,",
                "// Line 61:         LocatorList& locators,",
                "// Line 62:         std::vector<GUID_t>& remote_readers,",
                "// Line 63:         const CacheChange_t& change,",
                "// Line 64:         fastrtps::rtps::Endpoint& sender_endpt)",
                "// vulnerable line: 65: {",
                "// Line 66:     DirectMessageSender sender(participant, &remote_readers, &locators);",
                "// Line 67:     RTPSMessageGroup group(participant, &sender_endpt, &sender);",
                "// Line 68:     if (!group.add_data(change, false))",
                "// vulnerable line: 69: {",
                "// Line 70:         EPROSIMA_LOG_ERROR(RTPS_PDP, \"Error sending announcement from client to servers\");",
                "// vulnerable line: 71: }",
                "// vulnerable line: 72: }",
                "// Line 73: ",
                "// Line 74: static void direct_send(",
                "// Line 75:         RTPSParticipantImpl* participant,",
                "// Line 76:         LocatorList& locators,",
                "// Line 77:         const CacheChange_t& change)",
                "// vulnerable line: 78: {",
                "// Line 79:     FakeWriter writer(participant, c_EntityId_SPDPWriter);",
                "// Line 80:     std::vector<GUID_t> remote_readers;",
                "// Line 81:     direct_send(participant, locators, remote_readers, change, writer);",
                "// vulnerable line: 82: }",
                "// Line 83: ",
                "// Line 84: PDPClient::PDPClient(",
                "// Line 85:         BuiltinProtocols* builtin,",
                "// Line 86:         const RTPSParticipantAllocationAttributes& allocation,",
                "// Line 87:         bool super_client)",
                "// Line 88:     : PDP(builtin, allocation)",
                "// Line 89:     , mp_sync(nullptr)",
                "// Line 90:     , _serverPing(false)",
                "// Line 91:     , _super_client(super_client)",
                "// vulnerable line: 92: {",
                "// vulnerable line: 93: }",
                "// Line 94: ",
                "// Line 95: PDPClient::~PDPClient()",
                "// vulnerable line: 96: {",
                "// Line 97:     if (mp_sync != nullptr)",
                "// vulnerable line: 98: {",
                "// Line 99:         delete mp_sync;",
                "// vulnerable line: 100: }",
                "// vulnerable line: 101: }",
                "// Line 102: ",
                "// Line 103: void PDPClient::initializeParticipantProxyData(",
                "// Line 104:         ParticipantProxyData* participant_data)",
                "// vulnerable line: 105: {",
                "// Line 106:     PDP::initializeParticipantProxyData(participant_data); // TODO: Remember that the PDP version USES security",
                "// Line 107: ",
                "// Line 108:     if (",
                "// Line 109:         getRTPSParticipant()->getAttributes().builtin.discovery_config.discoveryProtocol",
                "// Line 110:         != DiscoveryProtocol_t::CLIENT",
                "// Line 111:         &&",
                "// Line 112:         getRTPSParticipant()->getAttributes().builtin.discovery_config.discoveryProtocol",
                "// Line 113:         != DiscoveryProtocol_t::SUPER_CLIENT    )",
                "// vulnerable line: 114: {",
                "// Line 115:         EPROSIMA_LOG_ERROR(RTPS_PDP, \"Using a PDP client object with another user's settings\");",
                "// vulnerable line: 116: }",
                "// Line 117: ",
                "// Line 118:     if (getRTPSParticipant()->getAttributes().builtin.discovery_config.m_simpleEDP.",
                "// Line 119:                     use_PublicationWriterANDSubscriptionReader)",
                "// vulnerable line: 120: {",
                "// Line 121:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER;",
                "// Line 122:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR;",
                "// vulnerable line: 123: }",
                "// Line 124: ",
                "// Line 125:     if (getRTPSParticipant()->getAttributes().builtin.discovery_config.m_simpleEDP.",
                "// Line 126:                     use_PublicationReaderANDSubscriptionWriter)",
                "// vulnerable line: 127: {",
                "// Line 128:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR;",
                "// Line 129:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER;",
                "// vulnerable line: 130: }",
                "// Line 131: ",
                "// Line 132:     // Set discovery server version property",
                "// Line 133:     participant_data->m_properties.push_back(std::pair<std::string,",
                "// Line 134:             std::string>({fastdds::dds::parameter_property_ds_version,",
                "// Line 135:                           fastdds::dds::parameter_property_current_ds_version}));",
                "// Line 136: ",
                "// Line 137: #if HAVE_SECURITY",
                "// Line 138:     if (getRTPSParticipant()->getAttributes().builtin.discovery_config.m_simpleEDP",
                "// Line 139:                     .enable_builtin_secure_publications_writer_and_subscriptions_reader)",
                "// vulnerable line: 140: {",
                "// Line 141:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_PUBLICATION_SECURE_ANNOUNCER;",
                "// Line 142:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_SECURE_DETECTOR;",
                "// vulnerable line: 143: }",
                "// Line 144: ",
                "// Line 145:     if (getRTPSParticipant()->getAttributes().builtin.discovery_config.m_simpleEDP",
                "// Line 146:                     .enable_builtin_secure_subscriptions_writer_and_publications_reader)",
                "// vulnerable line: 147: {",
                "// Line 148:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_SECURE_ANNOUNCER;",
                "// Line 149:         participant_data->m_availableBuiltinEndpoints |= DISC_BUILTIN_ENDPOINT_PUBLICATION_SECURE_DETECTOR;",
                "// vulnerable line: 150: }",
                "// Line 151: #endif // HAVE_SECURITY",
                "// Line 152: ",
                "// vulnerable line: 153: }",
                "// Line 154: ",
                "// Line 155: bool PDPClient::init(",
                "// Line 156:         RTPSParticipantImpl* part)",
                "// vulnerable line: 157: {",
                "// Line 158:     if (!PDP::initPDP(part))",
                "// vulnerable line: 159: {",
                "// Line 160:         return false;",
                "// vulnerable line: 161: }",
                "// Line 162: ",
                "// Line 163:     /* We keep using EPDSimple notwithstanding its method EDPSimple::assignRemoteEndpoints regards",
                "// Line 164:        all server EDPs as TRANSIENT_LOCAL. Server builtin Writers are actually TRANSIENT.",
                "// Line 165:        Currently this mistake is not an issue but must be kept in mind if further development",
                "// Line 166:        justifies the creation of an EDPClient class.",
                "// Line 167:      */",
                "// Line 168:     mp_EDP = new EDPClient(this, mp_RTPSParticipant);",
                "// Line 169:     if (!mp_EDP->initEDP(m_discovery))",
                "// vulnerable line: 170: {",
                "// Line 171:         EPROSIMA_LOG_ERROR(RTPS_PDP, \"Endpoint discovery configuration failed\");",
                "// Line 172:         return false;",
                "// vulnerable line: 173: }",
                "// Line 174: ",
                "// Line 175:     mp_sync =",
                "// Line 176:             new DSClientEvent(this, TimeConv::Duration_t2MilliSecondsDouble(",
                "// Line 177:                         m_discovery.discovery_config.discoveryServer_client_syncperiod));",
                "// Line 178:     mp_sync->restart_timer();",
                "// Line 179: ",
                "// Line 180:     return true;",
                "// vulnerable line: 181: }",
                "// Line 182: ",
                "// Line 183: ParticipantProxyData* PDPClient::createParticipantProxyData(",
                "// Line 184:         const ParticipantProxyData& participant_data,",
                "// Line 185:         const GUID_t&)",
                "// vulnerable line: 186: {",
                "// vulnerable line: 187: std::unique_lock<std::recursive_mutex> lock(*getMutex());",
                "// Line 188: ",
                "// vulnerable line: 189: // Verify if this participant is a server",
                "// Line 190:     bool is_server = false;",
                "// Line 191: ",
                "// vulnerable line: 192: {",
                "// vulnerable line: 193: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 194: ",
                "// vulnerable line: 195: for (auto& svr : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 196: {",
                "// Line 197:             if (data_matches_with_prefix(svr.guidPrefix, participant_data))",
                "// vulnerable line: 198: {",
                "// Line 199:                 is_server = true;",
                "// vulnerable line: 200: }",
                "// vulnerable line: 201: }",
                "// vulnerable line: 202: }",
                "// Line 203: ",
                "// Line 204:     ParticipantProxyData* pdata = add_participant_proxy_data(participant_data.m_guid, is_server, &participant_data);",
                "// Line 205:     if (pdata != nullptr)",
                "// vulnerable line: 206: {",
                "// Line 207:         // Clients only assert its server lifeliness, other clients liveliness is provided",
                "// Line 208:         // through server's PDP discovery data",
                "// Line 209:         if (is_server)",
                "// vulnerable line: 210: {",
                "// Line 211:             pdata->lease_duration_event->update_interval(pdata->m_leaseDuration);",
                "// Line 212:             pdata->lease_duration_event->restart_timer();",
                "// vulnerable line: 213: }",
                "// vulnerable line: 214: }",
                "// Line 215: ",
                "// Line 216:     return pdata;",
                "// vulnerable line: 217: }",
                "// Line 218: ",
                "// Line 219: void PDPClient::update_builtin_locators()",
                "// vulnerable line: 220: {",
                "// Line 221:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 222:     mp_builtin->updateMetatrafficLocators(endpoints->reader.reader_->getAttributes().unicastLocatorList);",
                "// vulnerable line: 223: }",
                "// Line 224: ",
                "// Line 225: bool PDPClient::createPDPEndpoints()",
                "// vulnerable line: 226: {",
                "// Line 227: #if HAVE_SECURITY",
                "// Line 228:     if (should_protect_discovery())",
                "// vulnerable line: 229: {",
                "// Line 230:         return create_secure_ds_pdp_endpoints();",
                "// vulnerable line: 231: }",
                "// Line 232: #endif  // HAVE_SECURITY",
                "// Line 233: ",
                "// Line 234:     return create_ds_pdp_endpoints();",
                "// vulnerable line: 235: }",
                "// Line 236: ",
                "// Line 237: #if HAVE_SECURITY",
                "// Line 238: bool PDPClient::should_protect_discovery()",
                "// vulnerable line: 239: {",
                "// Line 240:     return mp_RTPSParticipant->is_secure() && mp_RTPSParticipant->security_attributes().is_discovery_protected;",
                "// vulnerable line: 241: }",
                "// Line 242: ",
                "// Line 243: bool PDPClient::create_secure_ds_pdp_endpoints()",
                "// vulnerable line: 244: {",
                "// Line 245:     EPROSIMA_LOG_INFO(RTPS_PDP_SERVER, \"Beginning PDPClient Secure PDP Endpoints creation\");",
                "// Line 246: ",
                "// Line 247:     auto endpoints = new fastdds::rtps::DiscoveryServerPDPEndpointsSecure();",
                "// Line 248:     builtin_endpoints_.reset(endpoints);",
                "// Line 249: ",
                "// Line 250:     bool ret_val = create_ds_pdp_reliable_endpoints(*endpoints, true) && create_ds_pdp_best_effort_reader(*endpoints);",
                "// Line 251: ",
                "// Line 252:     EPROSIMA_LOG_INFO(RTPS_PDP_SERVER, \"PDPClient Secure PDP Endpoints creation finished\");",
                "// Line 253: ",
                "// Line 254:     return ret_val;",
                "// vulnerable line: 255: }",
                "// Line 256: ",
                "// Line 257: bool PDPClient::create_ds_pdp_best_effort_reader(",
                "// Line 258:         DiscoveryServerPDPEndpointsSecure& endpoints)",
                "// vulnerable line: 259: {",
                "// Line 260:     const RTPSParticipantAttributes& pattr = mp_RTPSParticipant->getRTPSParticipantAttributes();",
                "// Line 261: ",
                "// Line 262:     HistoryAttributes hatt;",
                "// Line 263:     hatt.payloadMaxSize = mp_builtin->m_att.readerPayloadSize;",
                "// Line 264:     hatt.initialReservedCaches = pdp_initial_reserved_caches;",
                "// Line 265:     hatt.memoryPolicy = mp_builtin->m_att.readerHistoryMemoryPolicy;",
                "// Line 266:     endpoints.stateless_reader.history_.reset(new ReaderHistory(hatt));",
                "// Line 267: ",
                "// Line 268:     ReaderAttributes ratt;",
                "// Line 269:     ratt.expectsInlineQos = false;",
                "// Line 271:     ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;",
                "// Line 272:     ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;",
                "// Line 273:     ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;",
                "// Line 274:     ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;",
                "// Line 275:     ratt.endpoint.topicKind = WITH_KEY;",
                "// Line 276: ",
                "// Line 277:     // change depending of backup mode",
                "// Line 278:     ratt.endpoint.durabilityKind = VOLATILE;",
                "// Line 279:     ratt.endpoint.reliabilityKind = BEST_EFFORT;",
                "// Line 280: ",
                "// vulnerable line: 281: endpoints.stateless_listener.reset(new PDPSecurityInitiatorListener(this));",
                "// Line 282: ",
                "// Line 283:     // Create PDP Reader",
                "// Line 284:     RTPSReader* reader = nullptr;",
                "// Line 285:     if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.stateless_reader.history_.get(),",
                "// vulnerable line: 286: endpoints.stateless_listener.get(), c_EntityId_SPDPReader, true, false))",
                "// vulnerable line: 287: {",
                "// Line 288:         endpoints.stateless_reader.reader_ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);",
                "// Line 289: ",
                "// vulnerable line: 290: // Enable unknown clients to reach this reader",
                "// vulnerable line: 291: reader->enableMessagesFromUnkownWriters(true);",
                "// Line 292: ",
                "// Line 293:         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);",
                "// vulnerable line: 294: }",
                "// Line 295:     // Could not create PDP Reader, so return false",
                "// Line 296:     else",
                "// vulnerable line: 297: {",
                "// Line 298:         EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security initiation Reader creation failed\");",
                "// Line 299: ",
                "// vulnerable line: 300: endpoints.stateless_listener.reset();",
                "// Line 301:         endpoints.stateless_reader.release();",
                "// Line 302:         return false;",
                "// vulnerable line: 303: }",
                "// Line 304: ",
                "// Line 305:     return true;",
                "// vulnerable line: 306: }",
                "// Line 307: ",
                "// Line 308: #endif  // HAVE_SECURITY",
                "// Line 309: ",
                "// Line 310: bool PDPClient::create_ds_pdp_endpoints()",
                "// vulnerable line: 311: {",
                "// Line 312:     EPROSIMA_LOG_INFO(RTPS_PDP_SERVER, \"Beginning PDPCLient Endpoints creation\");",
                "// Line 313: ",
                "// Line 314:     auto endpoints = new fastdds::rtps::DiscoveryServerPDPEndpoints();",
                "// Line 315:     builtin_endpoints_.reset(endpoints);",
                "// Line 316: ",
                "// Line 317:     bool ret_val = create_ds_pdp_reliable_endpoints(*endpoints, false);",
                "// Line 318: ",
                "// Line 319:     EPROSIMA_LOG_INFO(RTPS_PDP_SERVER, \"PDPCLient Endpoints creation finished\");",
                "// Line 320: ",
                "// Line 321:     return ret_val;",
                "// vulnerable line: 322: }",
                "// Line 323: ",
                "// Line 324: bool PDPClient::create_ds_pdp_reliable_endpoints(",
                "// Line 325:         DiscoveryServerPDPEndpoints& endpoints,",
                "// Line 326:         bool is_discovery_protected)",
                "// vulnerable line: 327: {",
                "// Line 328: ",
                "// Line 329:     EPROSIMA_LOG_INFO(RTPS_PDP, \"Beginning PDPClient Endpoints creation\");",
                "// Line 330: ",
                "// Line 331:     const RTPSParticipantAttributes& pattr = mp_RTPSParticipant->getRTPSParticipantAttributes();",
                "// Line 332: ",
                "// Line 333:     /***********************************",
                "// Line 334:     * PDP READER",
                "// Line 335:     ***********************************/",
                "// Line 336: ",
                "// Line 337:     HistoryAttributes hatt;",
                "// Line 346:     ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;",
                "// Line 347:     ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;",
                "// Line 348:     ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;",
                "// Line 349:     ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;",
                "// Line 350:     ratt.endpoint.topicKind = WITH_KEY;",
                "// Line 351:     ratt.endpoint.durabilityKind = TRANSIENT_LOCAL;",
                "// Line 352:     ratt.endpoint.reliabilityKind = RELIABLE;",
                "// Line 353:     ratt.times.heartbeatResponseDelay = pdp_heartbeat_response_delay;",
                "// Line 354: #if HAVE_SECURITY",
                "// Line 355:     if (is_discovery_protected)",
                "// vulnerable line: 356: {",
                "// Line 357:         ratt.endpoint.security_attributes().is_submessage_protected = true;",
                "// Line 358:         ratt.endpoint.security_attributes().plugin_endpoint_attributes =",
                "// Line 359:                 PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;",
                "// vulnerable line: 360: }",
                "// Line 361: #endif // HAVE_SECURITY",
                "// Line 362: ",
                "// vulnerable line: 363: mp_listener = new PDPListener(this);",
                "// Line 364: ",
                "// Line 365:     RTPSReader* reader = nullptr;",
                "// Line 366: #if HAVE_SECURITY",
                "// Line 367:     EntityId_t reader_entity =",
                "// Line 368:             is_discovery_protected ? c_EntityId_spdp_reliable_participant_secure_reader : c_EntityId_SPDPReader;",
                "// Line 369: #else",
                "// Line 370:     EntityId_t reader_entity = c_EntityId_SPDPReader;",
                "// Line 371: #endif // if HAVE_SECURITY",
                "// vulnerable line: 372: if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.reader.history_.get(), mp_listener,",
                "// Line 373:             reader_entity, true, false))",
                "// vulnerable line: 374: {",
                "// Line 375:         endpoints.reader.reader_ = dynamic_cast<fastrtps::rtps::StatefulReader*>(reader);",
                "// Line 376: ",
                "// Line 377: #if HAVE_SECURITY",
                "// Line 378:         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);",
                "// Line 379: #endif // if HAVE_SECURITY",
                "// vulnerable line: 380: }",
                "// Line 381:     else",
                "// vulnerable line: 382: {",
                "// Line 383:         EPROSIMA_LOG_ERROR(RTPS_PDP, \"PDPClient Reader creation failed\");",
                "// vulnerable line: 384: delete mp_listener;",
                "// vulnerable line: 385: mp_listener = nullptr;",
                "// Line 386:         endpoints.reader.release();",
                "// Line 387:         return false;",
                "// vulnerable line: 388: }",
                "// Line 389: ",
                "// Line 390:     /***********************************",
                "// Line 391:     * PDP WRITER",
                "// Line 392:     ***********************************/",
                "// Line 393: ",
                "// Line 394:     hatt.payloadMaxSize = mp_builtin->m_att.writerPayloadSize;",
                "// Line 395:     hatt.initialReservedCaches = pdp_initial_reserved_caches;",
                "// Line 396:     hatt.memoryPolicy = mp_builtin->m_att.writerHistoryMemoryPolicy;",
                "// Line 397:     endpoints.writer.history_.reset(new WriterHistory(hatt));",
                "// Line 398: ",
                "// Line 404:     watt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;",
                "// Line 405:     watt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;",
                "// Line 406:     watt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;",
                "// Line 407:     watt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;",
                "// Line 408:     watt.times.heartbeatPeriod = pdp_heartbeat_period;",
                "// Line 409:     watt.times.nackResponseDelay = pdp_nack_response_delay;",
                "// Line 410:     watt.times.nackSupressionDuration = pdp_nack_supression_duration;",
                "// Line 411: ",
                "// Line 412: #if HAVE_SECURITY",
                "// Line 413:     if (is_discovery_protected)",
                "// vulnerable line: 414: {",
                "// Line 415:         watt.endpoint.security_attributes().is_submessage_protected = true;",
                "// Line 416:         watt.endpoint.security_attributes().plugin_endpoint_attributes =",
                "// Line 417:                 PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;",
                "// vulnerable line: 418: }",
                "// Line 419: #endif // HAVE_SECURITY",
                "// Line 420: ",
                "// Line 421:     if (pattr.throughputController.bytesPerPeriod != UINT32_MAX && pattr.throughputController.periodMillisecs != 0)",
                "// vulnerable line: 422: {",
                "// Line 423:         watt.mode = ASYNCHRONOUS_WRITER;",
                "// vulnerable line: 424: }",
                "// Line 425: ",
                "// Line 426:     RTPSWriter* wout = nullptr;",
                "// Line 427: #if HAVE_SECURITY",
                "// Line 428:     EntityId_t writer_entity =",
                "// Line 429:             is_discovery_protected ? c_EntityId_spdp_reliable_participant_secure_writer : c_EntityId_SPDPWriter;",
                "// Line 430: #else",
                "// Line 431:     EntityId_t writer_entity = c_EntityId_SPDPWriter;",
                "// Line 432: #endif // if HAVE_SECURITY",
                "// Line 433:     if (mp_RTPSParticipant->createWriter(&wout, watt, endpoints.writer.history_.get(), nullptr, writer_entity, true))",
                "// vulnerable line: 434: {",
                "// Line 435:         endpoints.writer.writer_ = dynamic_cast<fastrtps::rtps::StatefulWriter*>(wout);",
                "// Line 436: ",
                "// Line 437: #if HAVE_SECURITY",
                "// Line 438:         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(wout, false);",
                "// Line 439: #endif // if HAVE_SECURITY",
                "// vulnerable line: 440: }",
                "// Line 441:     else",
                "// vulnerable line: 442: {",
                "// Line 443:         EPROSIMA_LOG_ERROR(RTPS_PDP, \"PDPClient Writer creation failed\");",
                "// Line 444:         endpoints.writer.release();",
                "// Line 445:         return false;",
                "// vulnerable line: 446: }",
                "// Line 447: ",
                "// Line 448:     // Perform matching with remote servers and ensure output channels are open in the transport for the corresponding",
                "// Line 449:     // locators",
                "// vulnerable line: 450: {",
                "// vulnerable line: 451: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 452: ",
                "// Line 453:         for (const eprosima::fastdds::rtps::RemoteServerAttributes& it : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 454: {",
                "// Line 455:             mp_RTPSParticipant->createSenderResources(it.metatrafficMulticastLocatorList);",
                "// Line 456:             mp_RTPSParticipant->createSenderResources(it.metatrafficUnicastLocatorList);",
                "// Line 457: ",
                "// Line 458: #if HAVE_SECURITY",
                "// Line 459:             if (!mp_RTPSParticipant->is_secure())",
                "// vulnerable line: 460: {",
                "// Line 461:                 match_pdp_writer_nts_(it);",
                "// Line 462:                 match_pdp_reader_nts_(it);",
                "// vulnerable line: 463: }",
                "// Line 464:             else if (!is_discovery_protected)",
                "// vulnerable line: 465: {",
                "// Line 466:                 endpoints.reader.reader_->enableMessagesFromUnkownWriters(true);",
                "// vulnerable line: 467: }",
                "// Line 468: #else",
                "// Line 469:             if (!is_discovery_protected)",
                "// vulnerable line: 470: {",
                "// Line 471:                 match_pdp_writer_nts_(it);",
                "// Line 472:                 match_pdp_reader_nts_(it);",
                "// vulnerable line: 473: }",
                "// Line 474: #endif // HAVE_SECURITY",
                "// vulnerable line: 475: }",
                "// vulnerable line: 476: }",
                "// Line 477: ",
                "// Line 478:     EPROSIMA_LOG_INFO(RTPS_PDP, \"PDPClient Endpoints creation finished\");",
                "// Line 479:     return true;",
                "// vulnerable line: 480: }",
                "// Line 481: ",
                "// Line 482: // the ParticipantProxyData* pdata must be the one kept in PDP database",
                "// Line 483: void PDPClient::assignRemoteEndpoints(",
                "// Line 484:         ParticipantProxyData* pdata)",
                "// vulnerable line: 485: {",
                "// vulnerable line: 486: {",
                "// vulnerable line: 487: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 488: ",
                "// vulnerable line: 489: // Verify if this participant is a server",
                "// vulnerable line: 490: for (auto& svr : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 491: {",
                "// vulnerable line: 492: if (data_matches_with_prefix(svr.guidPrefix, *pdata))",
                "// vulnerable line: 493: {",
                "// vulnerable line: 494: std::unique_lock<std::recursive_mutex> lock(*getMutex());",
                "// vulnerable line: 495: svr.proxy = pdata;",
                "// vulnerable line: 496: }",
                "// vulnerable line: 497: }",
                "// vulnerable line: 498: }",
                "// Line 499: ",
                "// Line 500: #if HAVE_SECURITY",
                "// vulnerable line: 501: if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))",
                "// Line 502: #endif // HAVE_SECURITY",
                "// vulnerable line: 503: {",
                "// vulnerable line: 504: perform_builtin_endpoints_matching(*pdata);",
                "// vulnerable line: 505: }",
                "// vulnerable line: 506: }",
                "// Line 507: ",
                "// Line 508: void PDPClient::notifyAboveRemoteEndpoints(",
                "// Line 509:         const ParticipantProxyData& pdata,",
                "// Line 510:         bool /*notify_secure_endpoints*/)",
                "// vulnerable line: 511: {",
                "// Line 512: #if HAVE_SECURITY",
                "// Line 513:     if (mp_RTPSParticipant->is_secure())",
                "// vulnerable line: 514: {",
                "// vulnerable line: 515: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 516: ",
                "// vulnerable line: 517: // Verify if this participant is a server",
                "// vulnerable line: 518: for (auto& svr : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 519: {",
                "// Line 520:             if (data_matches_with_prefix(svr.guidPrefix, pdata))",
                "// vulnerable line: 521: {",
                "// Line 522:                 if (nullptr == svr.proxy)",
                "// vulnerable line: 523: {",
                "// Line 524:                     //! try to retrieve the participant proxy data from an unmangled prefix in case",
                "// Line 525:                     //! we could not fill svr.proxy in assignRemoteEndpoints()",
                "// Line 526:                     svr.proxy = get_participant_proxy_data(svr.guidPrefix);",
                "// vulnerable line: 527: }",
                "// Line 528: ",
                "// Line 529:                 match_pdp_reader_nts_(svr, pdata.m_guid.guidPrefix);",
                "// Line 530:                 match_pdp_writer_nts_(svr, pdata.m_guid.guidPrefix);",
                "// Line 531:                 break;",
                "// vulnerable line: 532: }",
                "// vulnerable line: 533: }",
                "// vulnerable line: 534: }",
                "// Line 535: #endif // HAVE_SECURITY",
                "// Line 536: ",
                "// Line 537:     perform_builtin_endpoints_matching(pdata);",
                "// vulnerable line: 538: }",
                "// Line 539: ",
                "// Line 540: #if HAVE_SECURITY",
                "// Line 541: bool PDPClient::pairing_remote_writer_with_local_reader_after_security(",
                "// Line 542:         const GUID_t& local_reader,",
                "// Line 543:         const WriterProxyData& remote_writer_data)",
                "// vulnerable line: 544: {",
                "// Line 545:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 546: ",
                "// Line 547:     if (local_reader == endpoints->reader.reader_->getGuid())",
                "// vulnerable line: 548: {",
                "// Line 549:         endpoints->reader.reader_->matched_writer_add(remote_writer_data);",
                "// Line 550:         return true;",
                "// vulnerable line: 551: }",
                "// Line 552: ",
                "// Line 553:     return PDP::pairing_remote_writer_with_local_reader_after_security(local_reader, remote_writer_data);",
                "// vulnerable line: 554: }",
                "// Line 555: ",
                "// Line 556: bool PDPClient::pairing_remote_reader_with_local_writer_after_security(",
                "// Line 557:         const GUID_t& local_writer,",
                "// Line 558:         const ReaderProxyData& remote_reader_data)",
                "// vulnerable line: 559: {",
                "// Line 560:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 561: ",
                "// Line 562:     if (local_writer == endpoints->writer.writer_->getGuid())",
                "// vulnerable line: 563: {",
                "// Line 564:         endpoints->writer.writer_->matched_reader_add(remote_reader_data);",
                "// Line 565:         return true;",
                "// vulnerable line: 566: }",
                "// Line 567: ",
                "// Line 568:     return PDP::pairing_remote_reader_with_local_writer_after_security(local_writer, remote_reader_data);",
                "// vulnerable line: 569: }",
                "// Line 570: ",
                "// Line 571: #endif // HAVE_SECURITY",
                "// Line 572: ",
                "// Line 573: void PDPClient::perform_builtin_endpoints_matching(",
                "// Line 574:         const ParticipantProxyData& pdata)",
                "// vulnerable line: 575: {",
                "// Line 576:     // No EDP notification needed. EDP endpoints would be match when PDP synchronization is granted",
                "// Line 577:     if (mp_builtin->mp_WLP != nullptr)",
                "// vulnerable line: 578: {",
                "// Line 579:         mp_builtin->mp_WLP->assignRemoteEndpoints(pdata, true);",
                "// vulnerable line: 580: }",
                "// vulnerable line: 581: }",
                "// Line 582: ",
                "// Line 583: void PDPClient::removeRemoteEndpoints(",
                "// Line 584:         ParticipantProxyData* pdata)",
                "// vulnerable line: 585: {",
                "// Line 586:     // EDP endpoints have been already unmatch by the associated listener",
                "// Line 587:     assert(!mp_EDP->areRemoteEndpointsMatched(pdata));",
                "// Line 588: ",
                "// Line 589:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 590: ",
                "// Line 591:     bool is_server = false;",
                "// vulnerable line: 592: {",
                "// vulnerable line: 593: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 594: ",
                "// vulnerable line: 595: // Verify if this participant is a server",
                "// vulnerable line: 596: for (auto& svr : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 597: {",
                "// Line 598:             if (svr.guidPrefix == pdata->m_guid.guidPrefix)",
                "// vulnerable line: 599: {",
                "// vulnerable line: 600: std::unique_lock<std::recursive_mutex> lock(*getMutex());",
                "// Line 601:                 svr.proxy = nullptr; // reasign when we receive again server DATA(p)",
                "// Line 602:                 is_server = true;",
                "// Line 603:                 mp_sync->restart_timer(); // enable announcement and sync mechanism till this server reappears",
                "// vulnerable line: 604: }",
                "// vulnerable line: 605: }",
                "// vulnerable line: 606: }",
                "// Line 607: ",
                "// Line 608:     if (is_server)",
                "// vulnerable line: 609: {",
                "// Line 610:         // We should unmatch and match the PDP endpoints to renew the PDP reader and writer associated proxies",
                "// Line 611:         EPROSIMA_LOG_INFO(RTPS_PDP, \"For unmatching for server: \" << pdata->m_guid);",
                "// Line 612:         const NetworkFactory& network = mp_RTPSParticipant->network_factory();",
                "// Line 613:         uint32_t endp = pdata->m_availableBuiltinEndpoints;",
                "// Line 614:         uint32_t auxendp = endp;",
                "// Line 615:         auxendp &= (DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER | DISC_BUILTIN_ENDPOINT_PARTICIPANT_SECURE_ANNOUNCER);",
                "// Line 616: ",
                "// Line 617:         if (auxendp != 0)",
                "// vulnerable line: 618: {",
                "// Line 619:             GUID_t wguid;",
                "// Line 620: ",
                "// Line 621:             wguid.guidPrefix = pdata->m_guid.guidPrefix;",
                "// Line 622:             wguid.entityId = endpoints->writer.writer_->getGuid().entityId;",
                "// Line 623:             endpoints->reader.reader_->matched_writer_remove(wguid);",
                "// Line 624: ",
                "// Line 625: #if HAVE_SECURITY",
                "// Line 626:             if (!should_protect_discovery())",
                "// Line 627: #endif // HAVE_SECURITY",
                "// vulnerable line: 628: {",
                "// Line 629:                 // rematch but discarding any previous state of the server",
                "// Line 630:                 // because we know the server shutdown intentionally",
                "// Line 631:                 auto temp_writer_data = get_temporary_writer_proxies_pool().get();",
                "// Line 632: ",
                "// Line 633:                 temp_writer_data->clear();",
                "// Line 634:                 temp_writer_data->guid(wguid);",
                "// Line 635:                 temp_writer_data->persistence_guid(pdata->get_persistence_guid());",
                "// Line 636:                 temp_writer_data->set_persistence_entity_id(c_EntityId_SPDPWriter);",
                "// Line 637:                 temp_writer_data->set_remote_locators(pdata->metatraffic_locators, network, true);",
                "// Line 638:                 temp_writer_data->m_qos.m_reliability.kind = RELIABLE_RELIABILITY_QOS;",
                "// Line 639:                 temp_writer_data->m_qos.m_durability.kind = TRANSIENT_DURABILITY_QOS;",
                "// Line 640:                 endpoints->reader.reader_->matched_writer_add(*temp_writer_data);",
                "// vulnerable line: 641: }",
                "// vulnerable line: 642: }",
                "// Line 643: ",
                "// Line 644:         auxendp = endp;",
                "// Line 645:         auxendp &= (DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR | DISC_BUILTIN_ENDPOINT_PARTICIPANT_SECURE_DETECTOR);",
                "// Line 646: ",
                "// Line 647:         if (auxendp != 0)",
                "// vulnerable line: 648: {",
                "// Line 649:             GUID_t rguid;",
                "// Line 650:             rguid.guidPrefix = pdata->m_guid.guidPrefix;",
                "// Line 651:             rguid.entityId = endpoints->reader.reader_->getGuid().entityId;",
                "// Line 652:             endpoints->writer.writer_->matched_reader_remove(rguid);",
                "// Line 653: ",
                "// Line 654: #if HAVE_SECURITY",
                "// Line 655:             if (!should_protect_discovery())",
                "// Line 656: #endif // HAVE_SECURITY",
                "// vulnerable line: 657: {",
                "// Line 658:                 auto temp_reader_data = get_temporary_reader_proxies_pool().get();",
                "// Line 659: ",
                "// Line 660:                 temp_reader_data->clear();",
                "// Line 661:                 temp_reader_data->m_expectsInlineQos = false;",
                "// Line 662:                 temp_reader_data->guid(rguid);",
                "// Line 663:                 temp_reader_data->set_remote_locators(pdata->metatraffic_locators, network, true);",
                "// Line 664:                 temp_reader_data->m_qos.m_reliability.kind = RELIABLE_RELIABILITY_QOS;",
                "// Line 665:                 temp_reader_data->m_qos.m_durability.kind = TRANSIENT_LOCAL_DURABILITY_QOS;",
                "// Line 666:                 endpoints->writer.writer_->matched_reader_add(*temp_reader_data);",
                "// vulnerable line: 667: }",
                "// vulnerable line: 668: }",
                "// vulnerable line: 669: }",
                "// vulnerable line: 670: }",
                "// Line 671: ",
                "// Line 672: bool PDPClient::all_servers_acknowledge_PDP()",
                "// vulnerable line: 673: {",
                "// Line 674:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 675: ",
                "// Line 676:     // check if already initialized",
                "// Line 677:     assert(endpoints->writer.history_ && endpoints->writer.writer_);",
                "// Line 678: ",
                "// Line 679:     // get a reference to client proxy data",
                "// Line 680:     CacheChange_t* pPD;",
                "// Line 681:     if (endpoints->writer.history_->get_min_change(&pPD))",
                "// vulnerable line: 682: {",
                "// Line 683:         return endpoints->writer.writer_->is_acked_by_all(pPD);",
                "// vulnerable line: 684: }",
                "// Line 685:     else",
                "// vulnerable line: 686: {",
                "// Line 687:         EPROSIMA_LOG_ERROR(RTPS_PDP, \"ParticipantProxy data should have been added to client PDP history cache \"",
                "// Line 688:                 \"by a previous call to announceParticipantState()\");",
                "// vulnerable line: 689: }",
                "// Line 690: ",
                "// Line 691:     return false;",
                "// vulnerable line: 692: }",
                "// Line 693: ",
                "// Line 694: bool PDPClient::is_all_servers_PDPdata_updated()",
                "// vulnerable line: 695: {",
                "// Line 696:     // Assess all server DATA has been received",
                "// Line 697:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 698:     assert(endpoints->reader.reader_);",
                "// Line 699:     return endpoints->reader.reader_->isInCleanState();",
                "// vulnerable line: 700: }",
                "// Line 701: ",
                "// Line 702: void PDPClient::announceParticipantState(",
                "// Line 703:         bool new_change,",
                "// Line 704:         bool dispose,",
                "// Line 705:         WriteParams& )",
                "// vulnerable line: 706: {",
                "// Line 707:     if (enabled_)",
                "// vulnerable line: 708: {",
                "// Line 709:         auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 710:         fastrtps::rtps::StatefulWriter& writer = *(endpoints->writer.writer_);",
                "// Line 711:         WriterHistory& history = *endpoints->writer.history_;",
                "// Line 712: ",
                "// Line 713:         /*",
                "// Line 714:            Protect writer sequence number. Make sure in order to prevent AB BA deadlock that the",
                "// Line 715:            PDP mutex is systematically lock before the writer one (if needed):",
                "// Line 716:             - transport callbacks on PDPListener",
                "// Line 717:             - initialization and removal on BuiltinProtocols::initBuiltinProtocols and ~BuiltinProtocols",
                "// Line 718:             - DSClientEvent (own thread)",
                "// Line 725: ",
                "// Line 726:         WriteParams wp;",
                "// Line 727:         SampleIdentity local;",
                "// Line 728:         local.writer_guid(writer.getGuid());",
                "// Line 729:         local.sequence_number(history.next_sequence_number());",
                "// Line 730:         wp.sample_identity(local);",
                "// Line 731:         wp.related_sample_identity(local);",
                "// Line 732: ",
                "// Line 733:         // Add the write params to the sample",
                "// Line 734:         if (dispose)",
                "// vulnerable line: 735: {",
                "// Line 736:             // we must assure when the server is dying that all client are send at least a DATA(p)",
                "// Line 737:             // note here we can no longer receive and DATA or ACKNACK from clients.",
                "// Line 738:             // In order to avoid that we send the message directly as in the standard stateless PDP",
                "// Line 739: ",
                "// Line 740:             CacheChange_t* change = nullptr;",
                "// Line 741: ",
                "// Line 742:             if ((change = writer.new_change(",
                "// Line 743:                         [this]() -> uint32_t",
                "// vulnerable line: 744: {",
                "// Line 745:                             return mp_builtin->m_att.writerPayloadSize;",
                "// Line 746:                         },",
                "// Line 747:                         NOT_ALIVE_DISPOSED_UNREGISTERED, getLocalParticipantProxyData()->m_key)))",
                "// vulnerable line: 748: {",
                "// Line 749:                 // update the sequence number",
                "// Line 750:                 change->sequenceNumber = history.next_sequence_number();",
                "// Line 751:                 change->write_params = wp;",
                "// Line 752: ",
                "// Line 753:                 std::vector<GUID_t> remote_readers;",
                "// Line 754:                 LocatorList locators;",
                "// Line 755: ",
                "// Line 756:                 //  TODO: modify announcement mechanism to allow direct message sending",
                "// Line 757:                 //for (auto it = pW->matchedReadersBegin(); it != pW->matchedReadersEnd(); ++it)",
                "// Line 758:                 //{",
                "// Line 759:                 //    RemoteReaderAttributes & att = (*it)->m_att;",
                "// Line 760:                 //    remote_readers.push_back(att.guid);",
                "// Line 761: ",
                "// Line 762:                 //    EndpointAttributes & ep = att.endpoint;",
                "// Line 763:                 //    locators.push_back(ep.unicastLocatorList);",
                "// Line 764:                 //    //locators.push_back(ep.multicastLocatorList);",
                "// Line 765:                 //}",
                "// vulnerable line: 766: {",
                "// Line 767:                     // temporary workaround",
                "// vulnerable line: 768: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 769: ",
                "// vulnerable line: 770: for (auto& svr : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 771: {",
                "// Line 772:                         // if we are matched to a server report demise",
                "// Line 773:                         if (svr.proxy != nullptr)",
                "// vulnerable line: 774: {",
                "// Line 775:                             //locators.push_back(svr.metatrafficMulticastLocatorList);",
                "// Line 776:                             locators.push_back(svr.metatrafficUnicastLocatorList);",
                "// Line 777:                             remote_readers.emplace_back(svr.proxy->m_guid.guidPrefix,",
                "// Line 778:                                     endpoints->reader.reader_->getGuid().entityId);",
                "// vulnerable line: 779: }",
                "// vulnerable line: 780: }",
                "// vulnerable line: 781: }",
                "// Line 782: ",
                "// Line 783:                 if (!remote_readers.empty())",
                "// vulnerable line: 784: {",
                "// Line 785:                     direct_send(getRTPSParticipant(), locators, remote_readers, *change, *endpoints->writer.writer_);",
                "// vulnerable line: 786: }",
                "// vulnerable line: 787: }",
                "// Line 788: ",
                "// Line 789:             // free change",
                "// Line 790:             writer.release_change(change);",
                "// vulnerable line: 791: }",
                "// Line 792:         else",
                "// vulnerable line: 793: {",
                "// Line 794:             PDP::announceParticipantState(writer, history, new_change, dispose, wp);",
                "// Line 795: ",
                "// Line 796:             if (!new_change)",
                "// vulnerable line: 797: {",
                "// Line 798:                 // retrieve the participant discovery data",
                "// Line 799:                 CacheChange_t* pPD;",
                "// Line 800:                 if (history.get_min_change(&pPD))",
                "// vulnerable line: 801: {",
                "// Line 802:                     LocatorList locators;",
                "// Line 803: ",
                "// vulnerable line: 804: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 805: ",
                "// vulnerable line: 806: for (auto& svr : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 807: {",
                "// Line 808:                         // non-pinging announcements like lease duration ones must be",
                "// Line 809:                         // broadcast to all servers",
                "// Line 810:                         if (svr.proxy == nullptr || !_serverPing)",
                "// vulnerable line: 811: {",
                "// Line 812:                             locators.push_back(svr.metatrafficMulticastLocatorList);",
                "// Line 813:                             locators.push_back(svr.metatrafficUnicastLocatorList);",
                "// vulnerable line: 814: }",
                "// vulnerable line: 815: }",
                "// Line 816: ",
                "// Line 817:                     direct_send(getRTPSParticipant(), locators, *pPD);",
                "// Line 818: ",
                "// Line 819:                     // ping done independtly of which triggered the announcement",
                "// Line 820:                     // note all event callbacks are currently serialized",
                "// Line 821:                     _serverPing = false;",
                "// vulnerable line: 822: }",
                "// Line 823:                 else",
                "// vulnerable line: 824: {",
                "// Line 825:                     EPROSIMA_LOG_ERROR(RTPS_PDP, \"ParticipantProxy data should have been added to client PDP history \"",
                "// Line 826:                             \"cache by a previous call to announceParticipantState()\");",
                "// vulnerable line: 827: }",
                "// vulnerable line: 828: }",
                "// vulnerable line: 829: }",
                "// vulnerable line: 830: }",
                "// vulnerable line: 831: }",
                "// Line 832: ",
                "// Line 833: void PDPClient::update_remote_servers_list()",
                "// vulnerable line: 834: {",
                "// Line 835:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 836:     if (!endpoints->reader.reader_ || !endpoints->writer.writer_)",
                "// vulnerable line: 837: {",
                "// Line 838:         EPROSIMA_LOG_ERROR(SERVER_CLIENT_DISCOVERY, \"Cannot update server list within an uninitialized Client\");",
                "// Line 839:         return;",
                "// vulnerable line: 840: }",
                "// Line 841: ",
                "// Line 842: #if HAVE_SECURITY",
                "// Line 843:     if (!should_protect_discovery())",
                "// Line 844: #endif  // HAVE_SECURITY",
                "// vulnerable line: 845: {",
                "// vulnerable line: 846: eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());",
                "// Line 847: ",
                "// Line 848:         for (const eprosima::fastdds::rtps::RemoteServerAttributes& it : mp_builtin->m_DiscoveryServers)",
                "// vulnerable line: 849: {",
                "// Line 850:             if (!endpoints->reader.reader_->matched_writer_is_matched(it.GetPDPWriter()))",
                "// vulnerable line: 851: {",
                "// Line 852:                 match_pdp_writer_nts_(it);",
                "// vulnerable line: 853: }",
                "// Line 854: ",
                "// Line 855:             if (!endpoints->writer.writer_->matched_reader_is_matched(it.GetPDPReader()))",
                "// vulnerable line: 856: {",
                "// Line 857:                 match_pdp_reader_nts_(it);",
                "// vulnerable line: 858: }",
                "// vulnerable line: 859: }",
                "// vulnerable line: 860: }",
                "// Line 861:     mp_sync->restart_timer();",
                "// vulnerable line: 862: }",
                "// Line 863: ",
                "// Line 864: void PDPClient::match_pdp_writer_nts_(",
                "// Line 865:         const eprosima::fastdds::rtps::RemoteServerAttributes& server_att)",
                "// vulnerable line: 866: {",
                "// Line 867:     match_pdp_writer_nts_(server_att, server_att.guidPrefix);",
                "// vulnerable line: 868: }",
                "// Line 869: ",
                "// Line 870: void PDPClient::match_pdp_writer_nts_(",
                "// Line 871:         const eprosima::fastdds::rtps::RemoteServerAttributes& server_att,",
                "// Line 872:         const eprosima::fastdds::rtps::GuidPrefix_t& prefix_override)",
                "// vulnerable line: 873: {",
                "// Line 874:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 875:     const NetworkFactory& network = mp_RTPSParticipant->network_factory();",
                "// Line 876:     auto temp_writer_data = get_temporary_writer_proxies_pool().get();",
                "// Line 877: ",
                "// Line 878:     temp_writer_data->clear();",
                "// Line 879:     temp_writer_data->guid({ prefix_override, endpoints->writer.writer_->getGuid().entityId });",
                "// Line 880:     temp_writer_data->set_multicast_locators(server_att.metatrafficMulticastLocatorList, network);",
                "// Line 881:     temp_writer_data->set_remote_unicast_locators(server_att.metatrafficUnicastLocatorList, network);",
                "// Line 882:     temp_writer_data->m_qos.m_durability.kind = TRANSIENT_DURABILITY_QOS;",
                "// Line 883:     temp_writer_data->m_qos.m_reliability.kind = RELIABLE_RELIABILITY_QOS;",
                "// Line 884: #if HAVE_SECURITY",
                "// Line 885:     if (should_protect_discovery())",
                "// vulnerable line: 886: {",
                "// Line 887:         mp_RTPSParticipant->security_manager().discovered_builtin_writer(",
                "// Line 888:             endpoints->reader.reader_->getGuid(), { prefix_override, c_EntityId_RTPSParticipant },",
                "// Line 889:             *temp_writer_data, endpoints->reader.reader_->getAttributes().security_attributes());",
                "// vulnerable line: 890: }",
                "// Line 891:     else",
                "// Line 892: #endif // HAVE_SECURITY",
                "// vulnerable line: 893: {",
                "// Line 894:         endpoints->reader.reader_->matched_writer_add(*temp_writer_data);",
                "// vulnerable line: 895: }",
                "// vulnerable line: 896: }",
                "// Line 897: ",
                "// Line 898: void PDPClient::match_pdp_reader_nts_(",
                "// Line 899:         const eprosima::fastdds::rtps::RemoteServerAttributes& server_att)",
                "// vulnerable line: 900: {",
                "// Line 901:     match_pdp_reader_nts_(server_att, server_att.guidPrefix);",
                "// vulnerable line: 902: }",
                "// Line 903: ",
                "// Line 904: void PDPClient::match_pdp_reader_nts_(",
                "// Line 905:         const eprosima::fastdds::rtps::RemoteServerAttributes& server_att,",
                "// Line 906:         const eprosima::fastdds::rtps::GuidPrefix_t& prefix_override)",
                "// vulnerable line: 907: {",
                "// Line 908:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 909:     const NetworkFactory& network = mp_RTPSParticipant->network_factory();",
                "// Line 910:     auto temp_reader_data = get_temporary_reader_proxies_pool().get();",
                "// Line 911: ",
                "// Line 912:     temp_reader_data->clear();",
                "// Line 913:     temp_reader_data->guid({ prefix_override, endpoints->reader.reader_->getGuid().entityId });",
                "// Line 914:     temp_reader_data->set_multicast_locators(server_att.metatrafficMulticastLocatorList, network);",
                "// Line 915:     temp_reader_data->set_remote_unicast_locators(server_att.metatrafficUnicastLocatorList, network);",
                "// Line 916:     temp_reader_data->m_qos.m_durability.kind = TRANSIENT_LOCAL_DURABILITY_QOS;",
                "// Line 917:     temp_reader_data->m_qos.m_reliability.kind = RELIABLE_RELIABILITY_QOS;",
                "// Line 918: #if HAVE_SECURITY",
                "// Line 919:     if (should_protect_discovery())",
                "// vulnerable line: 920: {",
                "// Line 921:         mp_RTPSParticipant->security_manager().discovered_builtin_reader(",
                "// Line 922:             endpoints->writer.writer_->getGuid(), { prefix_override, c_EntityId_RTPSParticipant },",
                "// Line 923:             *temp_reader_data, endpoints->writer.writer_->getAttributes().security_attributes());",
                "// vulnerable line: 924: }",
                "// Line 925:     else",
                "// Line 926: #endif // HAVE_SECURITY",
                "// vulnerable line: 927: {",
                "// Line 928:         endpoints->writer.writer_->matched_reader_add(*temp_reader_data);",
                "// vulnerable line: 929: }",
                "// vulnerable line: 930: }",
                "// Line 931: ",
                "// Line 932: bool ros_super_client_env()",
                "// vulnerable line: 933: {",
                "// Line 934:     std::string super_client_str;",
                "// Line 935:     bool super_client = false;",
                "// Line 936:     std::vector<std::string> true_vec = {\"TRUE\", \"true\", \"True\", \"1\"};",
                "// Line 937:     std::vector<std::string> false_vec = {\"FALSE\", \"false\", \"False\", \"0\"};",
                "// Line 938: ",
                "// Line 939:     SystemInfo::get_env(ROS_SUPER_CLIENT, super_client_str);",
                "// Line 940:     if (super_client_str != \"\")",
                "// vulnerable line: 941: {",
                "// Line 942:         if (find(true_vec.begin(), true_vec.end(), super_client_str) != true_vec.end())",
                "// vulnerable line: 943: {",
                "// Line 944:             super_client = true;",
                "// vulnerable line: 945: }",
                "// Line 946:         else if (find(false_vec.begin(), false_vec.end(), super_client_str) != false_vec.end())",
                "// vulnerable line: 947: {",
                "// Line 948:             super_client = false;",
                "// vulnerable line: 949: }",
                "// Line 950:         else",
                "// vulnerable line: 951: {",
                "// Line 952:             EPROSIMA_LOG_ERROR(RTPS_PDP,",
                "// Line 953:                     \"Invalid value for ROS_SUPER_CLIENT environment variable : \" << super_client_str);",
                "// vulnerable line: 954: }",
                "// vulnerable line: 955: }",
                "// Line 956:     return super_client;",
                "// vulnerable line: 957: }",
                "// Line 958: ",
                "// Line 959: const std::string& ros_discovery_server_env()",
                "// vulnerable line: 960: {",
                "// Line 961:     static std::string servers;",
                "// Line 962:     SystemInfo::get_env(DEFAULT_ROS2_MASTER_URI, servers);",
                "// Line 963:     return servers;",
                "// vulnerable line: 964: }",
                "// Line 965: ",
                "// Line 966: bool load_environment_server_info(",
                "// Line 967:         RemoteServerList_t& attributes)",
                "// vulnerable line: 968: {",
                "// Line 969:     return load_environment_server_info(ros_discovery_server_env(), attributes);",
                "// vulnerable line: 970: }",
                "// Line 971: ",
                "// Line 972: bool load_environment_server_info(",
                "// Line 973:         const std::string& list,",
                "// Line 974:         RemoteServerList_t& attributes)",
                "// vulnerable line: 975: {",
                "// Line 976:     attributes.clear();",
                "// Line 977:     if (list.empty())",
                "// vulnerable line: 978: {",
                "// Line 979:         return true;",
                "// vulnerable line: 980: }",
                "// Line 981: ",
                "// Line 982:     /* Parsing ancillary regex",
                "// Line 983:      * Addresses should be ; separated. IPLocator functions are used to identify them in the order:",
                "// Line 984:      * IPv4, IPv6 or try dns resolution.",
                "// Line 985:      **/",
                "// Line 986:     const static std::regex ROS2_SERVER_LIST_PATTERN(R\"(([^;]*);?)\");",
                "// Line 987:     const static std::regex ROS2_IPV4_ADDRESSPORT_PATTERN(R\"(^((?:[0-9]{1,3}\\.){3}[0-9]{1,3})?:?(?:(\\d+))?$)\");",
                "// Line 988:     const static std::regex ROS2_IPV6_ADDRESSPORT_PATTERN(",
                "// Line 989:         R\"(^\\[?((?:[0-9a-fA-F]{0,4}\\:){0,7}[0-9a-fA-F]{0,4})?(?:\\])?:?(?:(\\d+))?$)\");",
                "// Line 990:     // Regex to handle DNS and UDPv4/6 expressions",
                "// Line 991:     const static std::regex ROS2_DNS_DOMAINPORT_PATTERN(R\"(^(UDPv[46]?:\\[[\\w\\.:-]{0,63}\\]|[\\w\\.-]{0,63}):?(?:(\\d+))?$)\");",
                "// Line 992:     // Regex to handle TCPv4/6 expressions",
                "// Line 993:     const static std::regex ROS2_DNS_DOMAINPORT_PATTERN_TCP(",
                "// Line 994:         R\"(^(TCPv[46]?:\\[[\\w\\.:-]{0,63}\\]):?(?:(\\d+))?$)\");",
                "// Line 995: ",
                "// Line 996:     // Filling port info",
                "// Line 997:     auto process_port = [](int port, Locator_t& server)",
                "// vulnerable line: 998: {",
                "// Line 999:                 if (port > std::numeric_limits<uint16_t>::max())",
                "// vulnerable line: 1000: {",
                "// Line 1001:                     throw std::out_of_range(\"Too large udp port passed into the server's list\");",
                "// vulnerable line: 1002: }",
                "// Line 1003: ",
                "// Line 1004:                 if (!IPLocator::setPhysicalPort(server, static_cast<uint16_t>(port)))",
                "// vulnerable line: 1005: {",
                "// Line 1006:                     std::stringstream ss;",
                "// Line 1007:                     ss << \"Wrong udp port passed into the server's list \" << port;",
                "// Line 1008:                     throw std::invalid_argument(ss.str());",
                "// vulnerable line: 1009: }",
                "// Line 1010:             };",
                "// Line 1011: ",
                "// Line 1012:     // Add new server",
                "// Line 1013:     auto add_server2qos = [](int id, std::forward_list<Locator>&& locators, RemoteServerList_t& attributes)",
                "// vulnerable line: 1014: {",
                "// Line 1015:                 RemoteServerAttributes server_att;",
                "// Line 1016: ",
                "// Line 1017:                 // add the server to the list",
                "// Line 1018:                 if (!get_server_client_default_guidPrefix(id, server_att.guidPrefix))",
                "// vulnerable line: 1019: {",
                "// Line 1020:                     throw std::invalid_argument(\"The maximum number of default discovery servers has been reached\");",
                "// vulnerable line: 1021: }",
                "// Line 1022: ",
                "// Line 1023:                 // split multi and unicast locators",
                "// Line 1024:                 auto unicast = std::partition(locators.begin(), locators.end(), IPLocator::isMulticast);",
                "// Line 1025: ",
                "// Line 1026:                 LocatorList mlist;",
                "// Line 1027:                 std::copy(locators.begin(), unicast, std::back_inserter(mlist));",
                "// Line 1028:                 if (!mlist.empty())",
                "// vulnerable line: 1029: {",
                "// Line 1030:                     server_att.metatrafficMulticastLocatorList.push_back(std::move(mlist));",
                "// vulnerable line: 1031: }",
                "// Line 1032: ",
                "// Line 1033:                 LocatorList ulist;",
                "// Line 1034:                 std::copy(unicast, locators.end(), std::back_inserter(ulist));",
                "// Line 1035:                 if (!ulist.empty())",
                "// vulnerable line: 1036: {",
                "// Line 1037:                     server_att.metatrafficUnicastLocatorList.push_back(std::move(ulist));",
                "// vulnerable line: 1038: }",
                "// Line 1039: ",
                "// Line 1040:                 attributes.push_back(std::move(server_att));",
                "// Line 1041:             };",
                "// Line 1042: ",
                "// Line 1043:     try",
                "// vulnerable line: 1044: {",
                "// Line 1045:         // Do the parsing and populate the list",
                "// Line 1046:         Locator_t server_locator(LOCATOR_KIND_UDPv4, DEFAULT_ROS2_SERVER_PORT);",
                "// Line 1047:         int server_id = 0;",
                "// Line 1048: ",
                "// Line 1049:         std::sregex_iterator server_it(",
                "// Line 1050:             list.begin(),",
                "// Line 1051:             list.end(),",
                "// Line 1052:             ROS2_SERVER_LIST_PATTERN,",
                "// Line 1053:             std::regex_constants::match_not_null);",
                "// Line 1054: ",
                "// Line 1055:         while (server_it != std::sregex_iterator())",
                "// vulnerable line: 1056: {",
                "// Line 1057:             // Retrieve the address (IPv4, IPv6 or DNS name)",
                "// Line 1058:             const std::smatch::value_type sm = *++(server_it->cbegin());",
                "// Line 1059: ",
                "// Line 1060:             if (sm.matched)",
                "// vulnerable line: 1061: {",
                "// Line 1062:                 // now we must parse the inner expression",
                "// Line 1063:                 std::smatch mr;",
                "// Line 1064:                 std::string locator(sm);",
                "// Line 1065: ",
                "// Line 1066:                 if (locator.empty())",
                "// vulnerable line: 1067: {",
                "// Line 1068:                     // it's intencionally empty to hint us to ignore this server",
                "// vulnerable line: 1069: }",
                "// Line 1070:                 // Try first with IPv4",
                "// Line 1071:                 else if (std::regex_match(locator, mr, ROS2_IPV4_ADDRESSPORT_PATTERN,",
                "// Line 1072:                         std::regex_constants::match_not_null))",
                "// vulnerable line: 1073: {",
                "// Line 1074:                     std::smatch::iterator it = mr.cbegin();",
                "// Line 1075: ",
                "// Line 1076:                     // traverse submatches",
                "// Line 1077:                     if (++it != mr.cend())",
                "// vulnerable line: 1078: {",
                "// Line 1079:                         std::string address = it->str();",
                "// Line 1080:                         server_locator.kind = LOCATOR_KIND_UDPv4;",
                "// Line 1081:                         server_locator.set_Invalid_Address();",
                "// Line 1082: ",
                "// Line 1083:                         if (!IPLocator::setIPv4(server_locator, address))",
                "// vulnerable line: 1084: {",
                "// Line 1085:                             std::stringstream ss;",
                "// Line 1086:                             ss << \"Wrong ipv4 address passed into the server's list \" << address;",
                "// Line 1087:                             throw std::invalid_argument(ss.str());",
                "// vulnerable line: 1088: }",
                "// Line 1089: ",
                "// Line 1090:                         if (IPLocator::isAny(server_locator))",
                "// vulnerable line: 1091: {",
                "// Line 1092:                             // A server cannot be reach in all interfaces, it's clearly a localhost call",
                "// Line 1093:                             IPLocator::setIPv4(server_locator, \"127.0.0.1\");",
                "// vulnerable line: 1094: }",
                "// Line 1095: ",
                "// Line 1096:                         // get port if any",
                "// Line 1097:                         int port = DEFAULT_ROS2_SERVER_PORT;",
                "// Line 1098:                         if (++it != mr.cend() && it->matched)",
                "// vulnerable line: 1099: {",
                "// Line 1100:                             port = stoi(it->str());",
                "// vulnerable line: 1101: }",
                "// Line 1102: ",
                "// Line 1103:                         process_port( port, server_locator);",
                "// vulnerable line: 1104: }",
                "// Line 1105: ",
                "// Line 1106:                     // add server to the list",
                "// Line 1107:                     add_server2qos(server_id, std::forward_list<Locator>{server_locator}, attributes);",
                "// vulnerable line: 1108: }",
                "// Line 1109:                 // Try IPv6 next",
                "// Line 1110:                 else if (std::regex_match(locator, mr, ROS2_IPV6_ADDRESSPORT_PATTERN,",
                "// Line 1111:                         std::regex_constants::match_not_null))",
                "// vulnerable line: 1112: {",
                "// Line 1113:                     std::smatch::iterator it = mr.cbegin();",
                "// Line 1114: ",
                "// Line 1115:                     // traverse submatches",
                "// Line 1116:                     if (++it != mr.cend())",
                "// vulnerable line: 1117: {",
                "// Line 1118:                         std::string address = it->str();",
                "// Line 1119:                         server_locator.kind = LOCATOR_KIND_UDPv6;",
                "// Line 1120:                         server_locator.set_Invalid_Address();",
                "// Line 1121: ",
                "// Line 1122:                         if (!IPLocator::setIPv6(server_locator, address))",
                "// vulnerable line: 1123: {",
                "// Line 1124:                             std::stringstream ss;",
                "// Line 1125:                             ss << \"Wrong ipv6 address passed into the server's list \" << address;",
                "// Line 1126:                             throw std::invalid_argument(ss.str());",
                "// vulnerable line: 1127: }",
                "// Line 1128: ",
                "// Line 1129:                         if (IPLocator::isAny(server_locator))",
                "// vulnerable line: 1130: {",
                "// Line 1131:                             // A server cannot be reach in all interfaces, it's clearly a localhost call",
                "// Line 1132:                             IPLocator::setIPv6(server_locator, \"::1\");",
                "// vulnerable line: 1133: }",
                "// Line 1134: ",
                "// Line 1135:                         // get port if any",
                "// Line 1136:                         int port = DEFAULT_ROS2_SERVER_PORT;",
                "// Line 1137:                         if (++it != mr.cend() && it->matched)",
                "// vulnerable line: 1138: {",
                "// Line 1139:                             port = stoi(it->str());",
                "// vulnerable line: 1140: }",
                "// Line 1141: ",
                "// Line 1142:                         process_port( port, server_locator);",
                "// vulnerable line: 1143: }",
                "// Line 1144: ",
                "// Line 1145:                     // add server to the list",
                "// Line 1146:                     add_server2qos(server_id, std::forward_list<Locator>{server_locator}, attributes);",
                "// vulnerable line: 1147: }",
                "// Line 1148:                 // try resolve DNS",
                "// Line 1149:                 else if (std::regex_match(locator, mr, ROS2_DNS_DOMAINPORT_PATTERN,",
                "// Line 1150:                         std::regex_constants::match_not_null))",
                "// vulnerable line: 1151: {",
                "// Line 1152:                     std::forward_list<Locator> flist;",
                "// Line 1153: ",
                "// vulnerable line: 1154: {",
                "// Line 1155:                         std::stringstream new_locator(locator,",
                "// Line 1156:                                 std::ios_base::in |",
                "// Line 1157:                                 std::ios_base::out |",
                "// Line 1158:                                 std::ios_base::ate);",
                "// Line 1159: ",
                "// Line 1160:                         // first try the formal notation, add default port if necessary",
                "// Line 1161:                         if (!mr[2].matched)",
                "// vulnerable line: 1162: {",
                "// Line 1163:                             new_locator << \":\" << DEFAULT_ROS2_SERVER_PORT;",
                "// vulnerable line: 1164: }",
                "// Line 1165: ",
                "// Line 1166:                         new_locator >> server_locator;",
                "// vulnerable line: 1167: }",
                "// Line 1168: ",
                "// Line 1169:                     // Otherwise add all resolved locators",
                "// Line 1170:                     switch ( server_locator.kind )",
                "// vulnerable line: 1171: {",
                "// Line 1172:                         case LOCATOR_KIND_UDPv4:",
                "// Line 1173:                         case LOCATOR_KIND_UDPv6:",
                "// Line 1174:                             flist.push_front(server_locator);",
                "// Line 1175:                             break;",
                "// Line 1176:                         case LOCATOR_KIND_INVALID:",
                "// vulnerable line: 1177: {",
                "// Line 1178:                             std::smatch::iterator it = mr.cbegin();",
                "// Line 1179: ",
                "// Line 1180:                             // traverse submatches",
                "// Line 1181:                             if (++it != mr.cend())",
                "// vulnerable line: 1182: {",
                "// Line 1183:                                 std::string domain_name = it->str();",
                "// Line 1184:                                 std::set<std::string> ipv4, ipv6;",
                "// Line 1185:                                 std::tie(ipv4, ipv6) = IPLocator::resolveNameDNS(domain_name);",
                "// Line 1186: ",
                "// Line 1187:                                 // get port if any",
                "// Line 1188:                                 int port = DEFAULT_ROS2_SERVER_PORT;",
                "// Line 1189:                                 if (++it != mr.cend() && it->matched)",
                "// vulnerable line: 1190: {",
                "// Line 1191:                                     port = stoi(it->str());",
                "// vulnerable line: 1192: }",
                "// Line 1193: ",
                "// Line 1194:                                 for ( const std::string& loc : ipv4 )",
                "// vulnerable line: 1195: {",
                "// Line 1196:                                     server_locator.kind = LOCATOR_KIND_UDPv4;",
                "// Line 1197:                                     server_locator.set_Invalid_Address();",
                "// Line 1198:                                     IPLocator::setIPv4(server_locator, loc);",
                "// Line 1199: ",
                "// Line 1200:                                     if (IPLocator::isAny(server_locator))",
                "// vulnerable line: 1201: {",
                "// Line 1202:                                         // A server cannot be reach in all interfaces, it's clearly a localhost call",
                "// Line 1203:                                         IPLocator::setIPv4(server_locator, \"127.0.0.1\");",
                "// vulnerable line: 1204: }",
                "// Line 1205: ",
                "// Line 1206:                                     process_port( port, server_locator);",
                "// Line 1207:                                     flist.push_front(server_locator);",
                "// vulnerable line: 1208: }",
                "// Line 1209: ",
                "// Line 1210:                                 for ( const std::string& loc : ipv6 )",
                "// vulnerable line: 1211: {",
                "// Line 1212:                                     server_locator.kind = LOCATOR_KIND_UDPv6;",
                "// Line 1213:                                     server_locator.set_Invalid_Address();",
                "// Line 1214:                                     IPLocator::setIPv6(server_locator, loc);",
                "// Line 1215: ",
                "// Line 1216:                                     if (IPLocator::isAny(server_locator))",
                "// vulnerable line: 1217: {",
                "// Line 1218:                                         // A server cannot be reach in all interfaces, it's clearly a localhost call",
                "// Line 1219:                                         IPLocator::setIPv6(server_locator, \"::1\");",
                "// vulnerable line: 1220: }",
                "// Line 1221: ",
                "// Line 1222:                                     process_port( port, server_locator);",
                "// Line 1223:                                     flist.push_front(server_locator);",
                "// vulnerable line: 1224: }",
                "// vulnerable line: 1225: }",
                "// vulnerable line: 1226: }",
                "// vulnerable line: 1227: }",
                "// Line 1228: ",
                "// Line 1229:                     if (flist.empty())",
                "// vulnerable line: 1230: {",
                "// Line 1231:                         std::stringstream ss;",
                "// Line 1232:                         ss << \"Wrong domain name passed into the server's list \" << locator;",
                "// Line 1233:                         throw std::invalid_argument(ss.str());",
                "// vulnerable line: 1234: }",
                "// Line 1235: ",
                "// Line 1236:                     // add server to the list",
                "// Line 1237:                     add_server2qos(server_id, std::move(flist), attributes);",
                "// vulnerable line: 1238: }",
                "// Line 1239:                 // try resolve TCP DNS",
                "// Line 1240:                 else if (std::regex_match(locator, mr, ROS2_DNS_DOMAINPORT_PATTERN_TCP,",
                "// Line 1241:                         std::regex_constants::match_not_null))",
                "// vulnerable line: 1242: {",
                "// Line 1243:                     std::forward_list<Locator> flist;",
                "// Line 1244: ",
                "// vulnerable line: 1245: {",
                "// Line 1246:                         std::stringstream new_locator(locator,",
                "// Line 1247:                                 std::ios_base::in |",
                "// Line 1248:                                 std::ios_base::out |",
                "// Line 1249:                                 std::ios_base::ate);",
                "// Line 1250: ",
                "// Line 1251:                         // first try the formal notation, add default port if necessary",
                "// Line 1252:                         if (!mr[2].matched)",
                "// vulnerable line: 1253: {",
                "// Line 1254:                             new_locator << \":\" << DEFAULT_TCP_SERVER_PORT;",
                "// vulnerable line: 1255: }",
                "// Line 1256: ",
                "// Line 1257:                         new_locator >> server_locator;",
                "// vulnerable line: 1258: }",
                "// Line 1259: ",
                "// Line 1260:                     // Otherwise add all resolved locators",
                "// Line 1261:                     switch ( server_locator.kind )",
                "// vulnerable line: 1262: {",
                "// Line 1263:                         case LOCATOR_KIND_TCPv4:",
                "// Line 1264:                         case LOCATOR_KIND_TCPv6:",
                "// Line 1265:                             IPLocator::setLogicalPort(server_locator, static_cast<uint16_t>(server_locator.port));",
                "// Line 1266:                             flist.push_front(server_locator);",
                "// Line 1267:                             break;",
                "// Line 1268:                         case LOCATOR_KIND_INVALID:",
                "// vulnerable line: 1269: {",
                "// Line 1270:                             std::smatch::iterator it = mr.cbegin();",
                "// Line 1271: ",
                "// Line 1272:                             // traverse submatches",
                "// Line 1273:                             if (++it != mr.cend())",
                "// vulnerable line: 1274: {",
                "// Line 1275:                                 std::string domain_name = it->str();",
                "// Line 1276:                                 std::set<std::string> ipv4, ipv6;",
                "// Line 1277:                                 std::tie(ipv4, ipv6) = IPLocator::resolveNameDNS(domain_name);",
                "// Line 1278: ",
                "// Line 1279:                                 // get port if any",
                "// Line 1280:                                 int port = DEFAULT_TCP_SERVER_PORT;",
                "// Line 1281:                                 if (++it != mr.cend() && it->matched)",
                "// vulnerable line: 1282: {",
                "// Line 1283:                                     port = stoi(it->str());",
                "// vulnerable line: 1284: }",
                "// Line 1285: ",
                "// Line 1286:                                 for ( const std::string& loc : ipv4 )",
                "// vulnerable line: 1287: {",
                "// Line 1288:                                     server_locator.kind = LOCATOR_KIND_TCPv4;",
                "// Line 1289:                                     server_locator.set_Invalid_Address();",
                "// Line 1290:                                     IPLocator::setIPv4(server_locator, loc);",
                "// Line 1291: ",
                "// Line 1292:                                     if (IPLocator::isAny(server_locator))",
                "// vulnerable line: 1293: {",
                "// Line 1294:                                         // A server cannot be reach in all interfaces, it's clearly a localhost call",
                "// Line 1295:                                         IPLocator::setIPv4(server_locator, \"127.0.0.1\");",
                "// vulnerable line: 1296: }",
                "// Line 1297: ",
                "// Line 1298:                                     process_port( port, server_locator);",
                "// Line 1299:                                     IPLocator::setLogicalPort(server_locator, static_cast<uint16_t>(port));",
                "// Line 1300:                                     flist.push_front(server_locator);",
                "// vulnerable line: 1301: }",
                "// Line 1302: ",
                "// Line 1303:                                 for ( const std::string& loc : ipv6 )",
                "// vulnerable line: 1304: {",
                "// Line 1305:                                     server_locator.kind = LOCATOR_KIND_TCPv6;",
                "// Line 1306:                                     server_locator.set_Invalid_Address();",
                "// Line 1307:                                     IPLocator::setIPv6(server_locator, loc);",
                "// Line 1308: ",
                "// Line 1309:                                     if (IPLocator::isAny(server_locator))",
                "// vulnerable line: 1310: {",
                "// Line 1311:                                         // A server cannot be reach in all interfaces, it's clearly a localhost call",
                "// Line 1312:                                         IPLocator::setIPv6(server_locator, \"::1\");",
                "// vulnerable line: 1313: }",
                "// Line 1314: ",
                "// Line 1315:                                     process_port( port, server_locator);",
                "// Line 1316:                                     IPLocator::setLogicalPort(server_locator, static_cast<uint16_t>(port));",
                "// Line 1317:                                     flist.push_front(server_locator);",
                "// vulnerable line: 1318: }",
                "// vulnerable line: 1319: }",
                "// vulnerable line: 1320: }",
                "// vulnerable line: 1321: }",
                "// Line 1322: ",
                "// Line 1323:                     if (flist.empty())",
                "// vulnerable line: 1324: {",
                "// Line 1325:                         std::stringstream ss;",
                "// Line 1326:                         ss << \"Wrong domain name passed into the server's list \" << locator;",
                "// Line 1327:                         throw std::invalid_argument(ss.str());",
                "// vulnerable line: 1328: }",
                "// Line 1329: ",
                "// Line 1330:                     // add server to the list",
                "// Line 1331:                     add_server2qos(server_id, std::move(flist), attributes);",
                "// vulnerable line: 1332: }",
                "// Line 1333:                 else",
                "// vulnerable line: 1334: {",
                "// Line 1335:                     std::stringstream ss;",
                "// Line 1336:                     ss << \"Wrong locator passed into the server's list \" << locator;",
                "// Line 1337:                     throw std::invalid_argument(ss.str());",
                "// vulnerable line: 1338: }",
                "// vulnerable line: 1339: }",
                "// Line 1340: ",
                "// Line 1341:             // advance to the next server if any",
                "// Line 1342:             ++server_id;",
                "// Line 1343:             ++server_it;",
                "// vulnerable line: 1344: }",
                "// Line 1345: ",
                "// Line 1346:         // Check for server info",
                "// Line 1347:         if (attributes.empty())",
                "// vulnerable line: 1348: {",
                "// Line 1349:             throw std::invalid_argument(\"No default server locators were provided.\");",
                "// vulnerable line: 1350: }",
                "// vulnerable line: 1351: }",
                "// Line 1352:     catch (std::exception& e)",
                "// vulnerable line: 1353: {",
                "// Line 1354:         EPROSIMA_LOG_ERROR(SERVER_CLIENT_DISCOVERY, e.what());",
                "// Line 1355:         attributes.clear();",
                "// Line 1356:         return false;",
                "// vulnerable line: 1357: }",
                "// Line 1358: ",
                "// Line 1359:     return true;",
                "// vulnerable line: 1360: }",
                "// Line 1361: ",
                "// Line 1362: GUID_t RemoteServerAttributes::GetParticipant() const",
                "// vulnerable line: 1363: {",
                "// Line 1364:     return GUID_t(guidPrefix, c_EntityId_RTPSParticipant);",
                "// vulnerable line: 1365: }",
                "// Line 1366: ",
                "// Line 1367: GUID_t RemoteServerAttributes::GetPDPReader() const",
                "// vulnerable line: 1368: {",
                "// Line 1369:     return GUID_t(guidPrefix, c_EntityId_SPDPReader);",
                "// vulnerable line: 1370: }",
                "// Line 1371: ",
                "// Line 1372: GUID_t RemoteServerAttributes::GetPDPWriter() const",
                "// vulnerable line: 1373: {",
                "// Line 1374:     return GUID_t(guidPrefix, c_EntityId_SPDPWriter);",
                "// vulnerable line: 1375: }",
                "// Line 1376: ",
                "// Line 1377: bool get_server_client_default_guidPrefix(",
                "// Line 1378:         int id,",
                "// Line 1379:         GuidPrefix_t& guid)",
                "// vulnerable line: 1380: {",
                "// Line 1381:     if ( id >= 0",
                "// Line 1382:             && id < 256",
                "// Line 1383:             && std::istringstream(DEFAULT_ROS2_SERVER_GUIDPREFIX) >> guid)",
                "// vulnerable line: 1384: {",
                "// Line 1385:         // Third octet denotes the server id",
                "// Line 1386:         guid.value[2] = static_cast<octet>(id);",
                "// Line 1387: ",
                "// Line 1388:         return true;",
                "// vulnerable line: 1389: }",
                "// Line 1390: ",
                "// Line 1391:     return false;",
                "// vulnerable line: 1392: }",
                "// Line 1393: ",
                "// Line 1394: bool PDPClient::remove_remote_participant(",
                "// Line 1395:         const GUID_t& partGUID,",
                "// Line 1396:         ParticipantDiscoveryInfo::DISCOVERY_STATUS reason)",
                "// vulnerable line: 1397: {",
                "// Line 1398:     if (PDP::remove_remote_participant(partGUID, reason))",
                "// vulnerable line: 1399: {",
                "// Line 1400:         // If it works fine, return",
                "// Line 1401:         return true;",
                "// vulnerable line: 1402: }",
                "// Line 1403: ",
                "// Line 1404:     auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 1405: ",
                "// Line 1406:     // Erase Proxies created before having the Participant",
                "// Line 1407:     GUID_t wguid;",
                "// Line 1408:     wguid.guidPrefix = partGUID.guidPrefix;",
                "// Line 1409:     wguid.entityId = endpoints->writer.writer_->getGuid().entityId;",
                "// Line 1410:     endpoints->reader.reader_->matched_writer_remove(wguid);",
                "// Line 1411: ",
                "// Line 1412:     GUID_t rguid;",
                "// Line 1413:     rguid.guidPrefix = partGUID.guidPrefix;",
                "// Line 1414:     rguid.entityId = endpoints->reader.reader_->getGuid().entityId;",
                "// Line 1415:     endpoints->writer.writer_->matched_reader_remove(rguid);",
                "// Line 1416: ",
                "// Line 1417:     update_remote_servers_list();",
                "// Line 1418: ",
                "// Line 1419:     return false;",
                "// vulnerable line: 1420: }",
                "// Line 1421: ",
                "// Line 1422: } /* namespace rtps */",
                "// Line 1423: } /* namespace fastdds */",
                "// Line 1424: } /* namespace eprosima */"
            ]
        },
        {
            "filename_of_changes": "PDPEndpoints.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "PDPListener.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "30",
            "number_of_lines_deleted_vulnerable_to_cve": "8",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 8: //",
                "// Line 9: // Unless required by applicable law or agreed to in writing, software",
                "// Line 10: // distributed under the License is distributed on an \"AS IS\" BASIS,",
                "// Line 11: // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "// Line 12: // See the License for the specific language governing permissions and",
                "// Line 13: // limitations under the License.",
                "// Line 14: ",
                "// Line 15: /**",
                "// Line 16:  * @file PDPListener.h",
                "// Line 17:  *",
                "// vulnerable line: 18: */",
                "// Line 19: ",
                "// Line 20: #ifndef _FASTDDS_RTPS_PDPLISTENER_H_",
                "// Line 21: #define _FASTDDS_RTPS_PDPLISTENER_H_",
                "// Line 22: #ifndef DOXYGEN_SHOULD_SKIP_THIS_PUBLIC",
                "// Line 23: ",
                "// Line 24: #include <fastdds/rtps/reader/ReaderListener.h>",
                "// Line 25: #include <fastdds/rtps/builtin/data/ParticipantProxyData.h>",
                "// Line 26: ",
                "// Line 27: #include <mutex>",
                "// Line 28: ",
                "// Line 29: namespace eprosima {",
                "// Line 30: namespace fastrtps {",
                "// Line 31: namespace rtps {",
                "// Line 32: ",
                "// Line 33: class PDP;",
                "// Line 34: ",
                "// Line 35: /**",
                "// Line 36:  * Class PDPListener, specification used by the PDP to perform the History check when a new message is received.",
                "// Line 37:  * This class is implemented in order to use the same structure than with any other RTPSReader.",
                "// Line 38:  * @ingroup DISCOVERY_MODULE",
                "// vulnerable line: 39: */",
                "// vulnerable line: 40: class PDPListener: public ReaderListener",
                "// Line 41: {",
                "// Line 42: ",
                "// Line 43: public:",
                "// Line 44:     /**",
                "// Line 45:      * @param parent Pointer to object creating this object",
                "// vulnerable line: 46: */",
                "// vulnerable line: 47: PDPListener(PDP* parent);",
                "// Line 48: ",
                "// Line 49:     virtual ~PDPListener() override = default;",
                "// Line 50: ",
                "// Line 51:     /**",
                "// vulnerable line: 52: * New added cache",
                "// vulnerable line: 53: * @param reader",
                "// vulnerable line: 54: * @param change",
                "// vulnerable line: 55: */",
                "// Line 56:     void onNewCacheChangeAdded(",
                "// Line 57:             RTPSReader* reader,",
                "// Line 58:             const CacheChange_t* const change) override;",
                "// Line 59: ",
                "// Line 60: protected:",
                "// Line 61: ",
                "// Line 62:     /**",
                "// Line 63:      * Get the key of a CacheChange_t",
                "// Line 64:      * @param change Pointer to the CacheChange_t",
                "// Line 65:      * @return True on success",
                "// vulnerable line: 66: */",
                "// vulnerable line: 67: bool get_key(CacheChange_t* change);",
                "// Line 68: ",
                "// Line 69:     //!Pointer to the associated mp_SPDP;",
                "// Line 70:     PDP* parent_pdp_;",
                "// Line 71: ",
                "// Line 72:     /**",
                "// Line 73:      * @brief Temporary data to avoid reallocations.",
                "// Line 74:      *",
                "// Line 75:      * @remarks This should be always accessed with the pdp_reader lock taken",
                "// vulnerable line: 76: */",
                "// Line 77:     ParticipantProxyData temp_participant_data_;",
                "// Line 78: };",
                "// Line 79: ",
                "// Line 80: ",
                "// Line 81: } /* namespace rtps */",
                "// Line 82: } /* namespace fastrtps */",
                "// Line 83: } /* namespace eprosima */",
                "// Line 84: ",
                "// vulnerable line: 85: #endif",
                "// Line 86: #endif /* _FASTDDS_RTPS_PDPLISTENER_H_ */"
            ]
        },
        {
            "filename_of_changes": "PDPSecurityInitiatorListener.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "28",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 5: // You may obtain a copy of the License at",
                "// Line 6: //",
                "// Line 7: //     http://www.apache.org/licenses/LICENSE-2.0",
                "// Line 8: //",
                "// Line 9: // Unless required by applicable law or agreed to in writing, software",
                "// Line 10: // distributed under the License is distributed on an \"AS IS\" BASIS,",
                "// Line 11: // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
                "// Line 12: // See the License for the specific language governing permissions and",
                "// Line 13: // limitations under the License.",
                "// Line 14: ",
                "// vulnerable line: 15: /**",
                "// Line 16:  * @file PDPSecurityInitiatorListener.h",
                "// vulnerable line: 17: *",
                "// vulnerable line: 18: */",
                "// Line 19: ",
                "// Line 20: #ifndef _DS_PDP_SECURITY_INITIATOR_LISTENER_H_",
                "// Line 21: #define _DS_PDP_SECURITY_INITIATOR_LISTENER_H_",
                "// Line 22: #ifndef DOXYGEN_SHOULD_SKIP_THIS_PUBLIC",
                "// Line 23: ",
                "// vulnerable line: 24: #include <fastdds/rtps/reader/ReaderListener.h>",
                "// Line 25: #include <fastdds/rtps/builtin/data/ParticipantProxyData.h>",
                "// Line 26: ",
                "// Line 27: #include <mutex>",
                "// Line 28: ",
                "// Line 29: namespace eprosima {",
                "// Line 30: namespace fastrtps {",
                "// Line 31: namespace rtps {",
                "// Line 32: ",
                "// Line 33: class PDP;",
                "// Line 34: ",
                "// vulnerable line: 35: /**",
                "// Line 36:  * Class PDPSecurityInitiatorListener, implementation for the secure discovery server handshake initiator.",
                "// Line 37:  * @ingroup DISCOVERY_MODULE",
                "// vulnerable line: 38: */",
                "// vulnerable line: 39: class PDPSecurityInitiatorListener : public ReaderListener",
                "// Line 40: {",
                "// Line 41: ",
                "// Line 42:     using SecurityInitiatedCallback = std::function<void (const ParticipantProxyData& participant_data)>;",
                "// Line 43: ",
                "// Line 44: public:",
                "// Line 45: ",
                "// vulnerable line: 46: /**",
                "// Line 47:      * @param parent Pointer to object creating this object",
                "// vulnerable line: 48: */",
                "// Line 49:     PDPSecurityInitiatorListener(",
                "// Line 50:             PDP* parent,",
                "// Line 51:             SecurityInitiatedCallback response_cb = [] (const ParticipantProxyData&)->void {});",
                "// Line 52: ",
                "// Line 53:     virtual ~PDPSecurityInitiatorListener() override = default;",
                "// Line 54: ",
                "// vulnerable line: 55: /**",
                "// vulnerable line: 56: * New added cache",
                "// vulnerable line: 57: * @param reader",
                "// vulnerable line: 58: * @param change",
                "// vulnerable line: 59: */",
                "// vulnerable line: 60: void onNewCacheChangeAdded(",
                "// vulnerable line: 61: RTPSReader* reader,",
                "// vulnerable line: 62: const CacheChange_t* const change) override;",
                "// Line 63: ",
                "// Line 64: protected:",
                "// Line 65: ",
                "// vulnerable line: 66: /**",
                "// vulnerable line: 67: * Get the key of a CacheChange_t",
                "// vulnerable line: 68: * @param change Pointer to the CacheChange_t",
                "// vulnerable line: 69: * @return True on success",
                "// vulnerable line: 70: */",
                "// vulnerable line: 71: bool get_key(",
                "// vulnerable line: 72: CacheChange_t* change);",
                "// Line 73: ",
                "// vulnerable line: 74: //!Pointer to the associated mp_SPDP;",
                "// vulnerable line: 75: PDP* parent_pdp_;",
                "// Line 76: ",
                "// vulnerable line: 77: /**",
                "// vulnerable line: 78: * @brief Temporary data to avoid reallocations.",
                "// vulnerable line: 79: *",
                "// vulnerable line: 80: * @remarks This should be always accessed with the pdp_reader lock taken",
                "// vulnerable line: 81: */",
                "// vulnerable line: 82: ParticipantProxyData temp_participant_data_;",
                "// Line 83: ",
                "// Line 84:     //! What action to perform upon participant discovery",
                "// Line 85:     SecurityInitiatedCallback response_cb_;",
                "// Line 86: };",
                "// Line 87: ",
                "// Line 88: ",
                "// Line 89: } /* namespace rtps */",
                "// Line 90: } /* namespace fastrtps */",
                "// Line 91: } /* namespace eprosima */",
                "// Line 92: "
            ]
        },
        {
            "filename_of_changes": "PDPServer.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "14",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 286:     ratt.endpoint.endpointKind = READER;",
                "// Line 287:     ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;",
                "// Line 288:     ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;",
                "// Line 289:     ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;",
                "// Line 290:     ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;",
                "// Line 291:     ratt.endpoint.topicKind = WITH_KEY;",
                "// Line 292:     // change depending of backup mode",
                "// Line 293:     ratt.endpoint.durabilityKind = VOLATILE;",
                "// Line 294:     ratt.endpoint.reliabilityKind = BEST_EFFORT;",
                "// Line 295: ",
                "// vulnerable line: 296: endpoints.stateless_listener.reset(new PDPSecurityInitiatorListener(this,",
                "// Line 297:             [this](const ParticipantProxyData& participant_data)",
                "// Line 298:             {",
                "// Line 299:                 auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());",
                "// Line 300:                 std::lock_guard<fastrtps::RecursiveTimedMutex> wlock(endpoints->writer.writer_->getMutex());",
                "// Line 301: ",
                "// Line 302:                 CacheChange_t* change = discovery_db().cache_change_own_participant();",
                "// Line 303:                 if (change != nullptr)",
                "// Line 304:                 {",
                "// Line 305:                     std::vector<GUID_t> remote_readers;",
                "// Line 306:                     LocatorList locators;",
                "// Line 313:                     }",
                "// Line 314: ",
                "// Line 315:                     send_announcement(change, remote_readers, locators, false);",
                "// Line 316: ",
                "// Line 317:                 }",
                "// Line 318:             }));",
                "// Line 319: ",
                "// Line 320:     // Create PDP Reader",
                "// Line 321:     RTPSReader* reader = nullptr;",
                "// Line 322:     if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.stateless_reader.history_.get(),",
                "// vulnerable line: 323: endpoints.stateless_listener.get(), c_EntityId_SPDPReader, true, false))",
                "// Line 324:     {",
                "// Line 325:         endpoints.stateless_reader.reader_ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);",
                "// Line 326: ",
                "// vulnerable line: 327: // Enable unknown clients to reach this reader",
                "// vulnerable line: 328: reader->enableMessagesFromUnkownWriters(true);",
                "// Line 329: ",
                "// Line 330:         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);",
                "// Line 331:     }",
                "// Line 332:     // Could not create PDP Reader, so return false",
                "// Line 333:     else",
                "// Line 334:     {",
                "// Line 335:         EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security initiation Reader creation failed\");",
                "// Line 336: ",
                "// vulnerable line: 337: endpoints.stateless_listener.reset();",
                "// Line 338:         endpoints.stateless_reader.release();",
                "// Line 339:         return false;",
                "// Line 340:     }",
                "// Line 341: ",
                "// Line 342:     return true;",
                "// Line 343: }",
                "// Line 344: ",
                "// Line 345: #endif  // HAVE_SECURITY",
                "// Line 346: ",
                "// Line 347: bool PDPServer::create_ds_pdp_endpoints()",
                "// Line 396:     }",
                "// Line 397: #endif // HAVE_SECURITY",
                "// Line 398: ",
                "// Line 399: #if HAVE_SQLITE3",
                "// Line 400:     ratt.endpoint.properties.properties().push_back(Property(\"dds.persistence.plugin\", \"builtin.SQLITE3\"));",
                "// Line 401:     ratt.endpoint.properties.properties().push_back(Property(\"dds.persistence.sqlite3.filename\",",
                "// Line 402:             get_reader_persistence_file_name()));",
                "// Line 403: #endif // HAVE_SQLITE3",
                "// Line 404: ",
                "// Line 405:     // PDP Listener",
                "// vulnerable line: 406: mp_listener = new PDPServerListener(this);",
                "// Line 407: ",
                "// Line 408:     // Create PDP Reader",
                "// Line 409:     RTPSReader* reader = nullptr;",
                "// Line 410: #if HAVE_SECURITY",
                "// Line 411:     EntityId_t reader_entity = secure ? c_EntityId_spdp_reliable_participant_secure_reader : c_EntityId_SPDPReader;",
                "// Line 412: #else",
                "// Line 413:     EntityId_t reader_entity = c_EntityId_SPDPReader;",
                "// Line 414: #endif // if HAVE_SECURITY",
                "// vulnerable line: 415: if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.reader.history_.get(), mp_listener,",
                "// vulnerable line: 416: reader_entity, true, false))",
                "// Line 417:     {",
                "// Line 418:         endpoints.reader.reader_ = dynamic_cast<fastrtps::rtps::StatefulReader*>(reader);",
                "// Line 419: ",
                "// vulnerable line: 420: // Enable unknown clients to reach this reader",
                "// vulnerable line: 421: reader->enableMessagesFromUnkownWriters(true);",
                "// Line 422: ",
                "// Line 423: #if HAVE_SECURITY",
                "// Line 424:         mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);",
                "// Line 425: #endif // if HAVE_SECURITY",
                "// Line 426:     }",
                "// Line 427:     // Could not create PDP Reader, so return false",
                "// Line 428:     else",
                "// Line 429:     {",
                "// Line 430:         EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer Reader creation failed\");",
                "// vulnerable line: 431: delete mp_listener;",
                "// vulnerable line: 432: mp_listener = nullptr;",
                "// Line 433:         endpoints.reader.release();",
                "// Line 434:         return false;",
                "// Line 435:     }",
                "// Line 436: ",
                "// Line 437:     /***********************************",
                "// Line 438:     * PDP WRITER",
                "// Line 439:     ***********************************/",
                "// Line 440: ",
                "// Line 441:     // PDP Writer History",
                "// Line 442:     hatt.payloadMaxSize = mp_builtin->m_att.writerPayloadSize;",
                "// Line 1774:                 std::make_pair(change_aux->instanceHandle, change_aux));",
                "// Line 1775: ",
                "// Line 1776:             // If the change was read as is_local we must pass it to listener with his own writer_guid",
                "// Line 1777:             if (it.value()[\"is_local\"].get<bool>() &&",
                "// Line 1778:                     change_aux->write_params.sample_identity().writer_guid().guidPrefix !=",
                "// Line 1779:                     endpoints->writer.writer_->getGuid().guidPrefix &&",
                "// Line 1780:                     change_aux->kind == fastrtps::rtps::ALIVE)",
                "// Line 1781:             {",
                "// Line 1782:                 change_aux->writerGUID = change_aux->write_params.sample_identity().writer_guid();",
                "// Line 1783:                 change_aux->sequenceNumber = change_aux->write_params.sample_identity().sequence_number();",
                "// vulnerable line: 1784: mp_listener->onNewCacheChangeAdded(endpoints->reader.reader_, change_aux);",
                "// Line 1785:             }",
                "// Line 1786:         }",
                "// Line 1787: ",
                "// Line 1788:         // Create every writer change. If it is external creates it from Reader,",
                "// Line 1789:         // if it is from the server, it is created from writer",
                "// Line 1790:         for (auto it = j[\"writers\"].begin(); it != j[\"writers\"].end(); ++it)",
                "// Line 1791:         {",
                "// Line 1792:             length = it.value()[\"change\"][\"serialized_payload\"][\"length\"].get<std::uint32_t>();",
                "// Line 1793:             std::istringstream(it.value()[\"change\"][\"sample_identity\"].get<std::string>()) >> sample_identity_aux;",
                "// Line 1794: "
            ]
        },
        {
            "filename_of_changes": "PDPTests.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "RTPSParticipantImpl.h",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "SecurityManager.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 101: {",
                "// Line 102:     destroy();",
                "// Line 103: }",
                "// Line 104: ",
                "// Line 105: bool SecurityManager::init(",
                "// Line 106:         ParticipantSecurityAttributes& attributes,",
                "// Line 107:         const PropertyPolicy& participant_properties)",
                "// Line 108: {",
                "// Line 109:     try",
                "// Line 110:     {",
                "// vulnerable line: 111: SecurityException exception;",
                "// Line 112:         domain_id_ = participant_->get_domain_id();",
                "// Line 113:         const PropertyPolicy log_properties = PropertyPolicyHelper::get_properties_with_prefix(",
                "// Line 114:             participant_->getRTPSParticipantAttributes().properties,",
                "// Line 115:             \"dds.sec.log.builtin.DDS_LogTopic.\");",
                "// Line 116: ",
                "// Line 117:         // length(log_properties) == 0 considered as logging disable.",
                "// Line 118:         if (PropertyPolicyHelper::length(log_properties) > 0)",
                "// Line 119:         {",
                "// Line 120:             logging_plugin_ = factory_.create_logging_plugin(participant_properties);",
                "// Line 121: ",
                "// Line 377:             return false;",
                "// Line 378:         }",
                "// Line 379:     }",
                "// Line 380: ",
                "// Line 381:     enable_security_manager();",
                "// Line 382:     return true;",
                "// Line 383: }",
                "// Line 384: ",
                "// Line 385: void SecurityManager::cancel_init()",
                "// Line 386: {",
                "// vulnerable line: 387: SecurityException exception;",
                "// Line 388:     if (local_participant_crypto_handle_)",
                "// Line 389:     {",
                "// Line 390:         crypto_plugin_->cryptokeyfactory()->unregister_participant(local_participant_crypto_handle_, exception);",
                "// Line 391:     }",
                "// Line 392: ",
                "// Line 393:     if (crypto_plugin_ != nullptr)",
                "// Line 394:     {",
                "// Line 395:         delete crypto_plugin_;",
                "// Line 396:         crypto_plugin_ = nullptr;",
                "// Line 397:     }",
                "// Line 424: }",
                "// Line 425: ",
                "// Line 426: void SecurityManager::destroy()",
                "// Line 427: {",
                "// Line 428:     disable_security_manager();",
                "// Line 429: ",
                "// Line 430:     if (authentication_plugin_ != nullptr)",
                "// Line 431:     {",
                "// Line 432:         shared_lock<shared_mutex> _(mutex_);",
                "// Line 433: ",
                "// vulnerable line: 434: SecurityException exception;",
                "// Line 435: ",
                "// Line 436:         // writer_handles_ and reader_handles_ contents reference the discovered_participants_ ones and are disposed on",
                "// Line 437:         // this collection removal",
                "// Line 438: ",
                "// Line 439:         for (auto& dp_it : discovered_participants_)",
                "// Line 440:         {",
                "// Line 441:             std::shared_ptr<ParticipantCryptoHandle> participant_crypto_handle = dp_it.second->get_participant_crypto();",
                "// Line 442:             if (participant_crypto_handle != nullptr)",
                "// Line 443:             {",
                "// Line 444:                 crypto_plugin_->cryptokeyfactory()->unregister_participant(participant_crypto_handle, exception);",
                "// Line 509:     if (logging_plugin_ != nullptr)",
                "// Line 510:     {",
                "// Line 511:         delete logging_plugin_;",
                "// Line 512:         logging_plugin_ = nullptr;",
                "// Line 513:     }",
                "// Line 514: }",
                "// Line 515: ",
                "// Line 516: void SecurityManager::remove_discovered_participant_info(",
                "// Line 517:         const DiscoveredParticipantInfo::AuthUniquePtr& auth_ptr)",
                "// Line 518: {",
                "// vulnerable line: 519: SecurityException exception;",
                "// Line 520: ",
                "// Line 521:     if (auth_ptr)",
                "// Line 522:     {",
                "// Line 523:         if (auth_ptr->handshake_handle_ != nullptr)",
                "// Line 524:         {",
                "// Line 525:             authentication_plugin_->return_handshake_handle(auth_ptr->handshake_handle_, exception);",
                "// Line 526:             auth_ptr->handshake_handle_ = nullptr;",
                "// Line 527:         }",
                "// Line 528: ",
                "// Line 529:         authentication_plugin_->return_identity_handle(auth_ptr->identity_handle_, exception);",
                "// Line 534:             participant_stateless_message_writer_history_->remove_change(auth_ptr->change_sequence_number_);",
                "// Line 535:             auth_ptr->change_sequence_number_ = SequenceNumber_t::unknown();",
                "// Line 536:         }",
                "// Line 537:     }",
                "// Line 538: }",
                "// Line 539: ",
                "// Line 540: bool SecurityManager::restore_discovered_participant_info(",
                "// Line 541:         const GUID_t& remote_participant_key,",
                "// Line 542:         DiscoveredParticipantInfo::AuthUniquePtr& auth_ptr)",
                "// Line 543: {",
                "// vulnerable line: 544: SecurityException exception;",
                "// Line 545:     bool returned_value = false;",
                "// Line 546: ",
                "// Line 547:     shared_lock<shared_mutex> _(mutex_);",
                "// Line 548: ",
                "// Line 549:     auto dp_it = discovered_participants_.find(remote_participant_key);",
                "// Line 550: ",
                "// Line 551:     if (dp_it != discovered_participants_.end())",
                "// Line 552:     {",
                "// Line 553:         dp_it->second->set_auth(auth_ptr);",
                "// Line 554:         returned_value = true;",
                "// Line 576:     {",
                "// Line 577:         return false;",
                "// Line 578:     }",
                "// Line 579: ",
                "// Line 580:     if (authentication_plugin_ == nullptr)",
                "// Line 581:     {",
                "// Line 582:         participant_->pdp()->notifyAboveRemoteEndpoints(participant_data, true);",
                "// Line 583:         return true;",
                "// Line 584:     }",
                "// Line 585: ",
                "// vulnerable line: 586: SecurityException exception;",
                "// Line 587:     AuthenticationStatus auth_status = AUTHENTICATION_INIT;",
                "// Line 588: ",
                "// Line 589:     // Create or find information",
                "// Line 590:     bool undiscovered = false;",
                "// Line 591:     DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info;",
                "// Line 592:     {",
                "// Line 593:         std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 594: ",
                "// Line 595:         auto map_ret = discovered_participants_.insert(",
                "// Line 596:             std::make_pair(",
                "// Line 713:     // Unmatch from builtin endpoints.",
                "// Line 714:     unmatch_builtin_endpoints(participant_data);",
                "// Line 715: ",
                "// Line 716:     {",
                "// Line 717:         shared_lock<shared_mutex> sl(mutex_);",
                "// Line 718: ",
                "// Line 719:         auto dp_it = discovered_participants_.find(participant_data.m_guid);",
                "// Line 720: ",
                "// Line 721:         if (dp_it != discovered_participants_.end())",
                "// Line 722:         {",
                "// vulnerable line: 723: SecurityException exception;",
                "// Line 724: ",
                "// Line 725:             std::shared_ptr<ParticipantCryptoHandle> participant_crypto_handle =",
                "// Line 726:                     dp_it->second->get_participant_crypto();",
                "// Line 727:             if (participant_crypto_handle != nullptr)",
                "// Line 728:             {",
                "// Line 729:                 crypto_plugin_->cryptokeyfactory()->unregister_participant(participant_crypto_handle,",
                "// Line 730:                         exception);",
                "// Line 731:             }",
                "// Line 732: ",
                "// Line 733:             PermissionsHandle* permissions_handle = dp_it->second->get_permissions_handle();",
                "// Line 795:         HandshakeMessageToken&& message_in,",
                "// Line 796:         bool& notify_part_authorized)",
                "// Line 797: {",
                "// Line 798:     auto sentry = is_security_manager_initialized();",
                "// Line 799:     if (!sentry)",
                "// Line 800:     {",
                "// Line 801:         return false;",
                "// Line 802:     }",
                "// Line 803: ",
                "// Line 804:     HandshakeMessageToken* handshake_message = nullptr;",
                "// vulnerable line: 805: SecurityException exception;",
                "// Line 806: ",
                "// Line 807:     ValidationResult_t ret = VALIDATION_FAILED;",
                "// Line 808: ",
                "// Line 809:     assert(remote_participant_info->identity_handle_ != nullptr);",
                "// Line 810: ",
                "// Line 811:     EPROSIMA_LOG_INFO(SECURITY, \"Processing handshake from participant \" << participant_data.m_guid);",
                "// Line 812: ",
                "// Line 813:     if (remote_participant_info->auth_status_ == AUTHENTICATION_REQUEST_NOT_SEND)",
                "// Line 814:     {",
                "// Line 815:         ret = authentication_plugin_->begin_handshake_request(&remote_participant_info->handshake_handle_,",
                "// Line 846: ",
                "// Line 847:     if (ret == VALIDATION_FAILED)",
                "// Line 848:     {",
                "// Line 849:         on_validation_failed(participant_data, exception);",
                "// Line 850:         return false;",
                "// Line 851:     }",
                "// Line 852: ",
                "// Line 853:     assert(remote_participant_info->handshake_handle_ != nullptr);",
                "// Line 854: ",
                "// Line 855:     // Remove previous change",
                "// vulnerable line: 856: remote_participant_info->event_->cancel_timer();",
                "// Line 857:     if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())",
                "// Line 858:     {",
                "// Line 859:         participant_stateless_message_writer_history_->remove_change(remote_participant_info->change_sequence_number_);",
                "// Line 860:         remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();",
                "// Line 861:     }",
                "// Line 862:     int64_t expected_sequence_number = 0;",
                "// Line 863: ",
                "// Line 864:     bool handshake_message_send = true;",
                "// Line 865: ",
                "// Line 866:     if (ret == VALIDATION_PENDING_HANDSHAKE_MESSAGE ||",
                "// Line 1712:             }",
                "// Line 1713:             else",
                "// Line 1714:             {",
                "// Line 1715:                 EPROSIMA_LOG_INFO(SECURITY,",
                "// Line 1716:                         \"Received Participant Cryptography message but not found related remote_participant_key\");",
                "// Line 1717:             }",
                "// Line 1718:         }",
                "// Line 1719: ",
                "// Line 1720:         if (remote_participant_crypto != nullptr)",
                "// Line 1721:         {",
                "// vulnerable line: 1722: SecurityException exception;",
                "// Line 1723: ",
                "// Line 1724:             if (!crypto_plugin_->cryptokeyexchange()->set_remote_participant_crypto_tokens(",
                "// Line 1725:                         *local_participant_crypto_handle_,",
                "// Line 1726:                         *remote_participant_crypto,",
                "// Line 1727:                         message.message_data(),",
                "// Line 1728:                         exception))",
                "// Line 1729:             {",
                "// Line 1730:                 EPROSIMA_LOG_ERROR(SECURITY, \"Cannot set remote participant crypto tokens (\"",
                "// Line 1731:                         << remote_participant_key << \") - (\" << exception.what() << \")\");",
                "// Line 1732:             }",
                "// Line 1769:             std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 1770: ",
                "// Line 1771:             auto wr_it = writer_handles_.find(message.destination_endpoint_key());",
                "// Line 1772: ",
                "// Line 1773:             if (wr_it != writer_handles_.end())",
                "// Line 1774:             {",
                "// Line 1775:                 auto rd_it = wr_it->second.associated_readers.find(message.source_endpoint_key());",
                "// Line 1776: ",
                "// Line 1777:                 if (rd_it != wr_it->second.associated_readers.end())",
                "// Line 1778:                 {",
                "// vulnerable line: 1779: SecurityException exception;",
                "// Line 1780: ",
                "// Line 1781:                     if (crypto_plugin_->cryptokeyexchange()->set_remote_datareader_crypto_tokens(",
                "// Line 1782:                                 *wr_it->second.writer_handle,",
                "// Line 1783:                                 *std::get<1>(rd_it->second),",
                "// Line 1784:                                 message.message_data(),",
                "// Line 1785:                                 exception))",
                "// Line 1786:                     {",
                "// Line 1787:                         writer_guid = wr_it->first;",
                "// Line 1788:                         reader_data = &(std::get<0>(rd_it->second));",
                "// Line 1789:                     }",
                "// Line 1845:         {",
                "// Line 1846:             std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 1847:             auto rd_it = reader_handles_.find(message.destination_endpoint_key());",
                "// Line 1848: ",
                "// Line 1849:             if (rd_it != reader_handles_.end())",
                "// Line 1850:             {",
                "// Line 1851:                 auto wr_it = rd_it->second.associated_writers.find(message.source_endpoint_key());",
                "// Line 1852: ",
                "// Line 1853:                 if (wr_it != rd_it->second.associated_writers.end())",
                "// Line 1854:                 {",
                "// vulnerable line: 1855: SecurityException exception;",
                "// Line 1856: ",
                "// Line 1857:                     if (crypto_plugin_->cryptokeyexchange()->set_remote_datawriter_crypto_tokens(",
                "// Line 1858:                                 *rd_it->second.reader_handle,",
                "// Line 1859:                                 *std::get<1>(wr_it->second),",
                "// Line 1860:                                 message.message_data(),",
                "// Line 1861:                                 exception))",
                "// Line 1862:                     {",
                "// Line 1863:                         reader_guid = rd_it->first;",
                "// Line 1864:                         writer_data = &(std::get<0>(wr_it->second));",
                "// Line 1865:                     }",
                "// Line 1923:     assert(identity_token);",
                "// Line 1924: ",
                "// Line 1925:     auto sentry = is_security_manager_initialized();",
                "// Line 1926:     if (!sentry)",
                "// Line 1927:     {",
                "// Line 1928:         return false;",
                "// Line 1929:     }",
                "// Line 1930: ",
                "// Line 1931:     if (authentication_plugin_)",
                "// Line 1932:     {",
                "// vulnerable line: 1933: SecurityException exception;",
                "// Line 1934:         return authentication_plugin_->get_identity_token(identity_token,",
                "// Line 1935:                        *local_identity_handle_, exception);",
                "// Line 1936:     }",
                "// Line 1937: ",
                "// Line 1938:     return false;",
                "// Line 1939: }",
                "// Line 1940: ",
                "// Line 1941: bool SecurityManager::return_identity_token(",
                "// Line 1942:         IdentityToken* identity_token) const",
                "// Line 1943: {",
                "// Line 1947:     }",
                "// Line 1948: ",
                "// Line 1949:     auto sentry = is_security_manager_initialized();",
                "// Line 1950:     if (!sentry)",
                "// Line 1951:     {",
                "// Line 1952:         return false;",
                "// Line 1953:     }",
                "// Line 1954: ",
                "// Line 1955:     if (authentication_plugin_)",
                "// Line 1956:     {",
                "// vulnerable line: 1957: SecurityException exception;",
                "// Line 1958:         return authentication_plugin_->return_identity_token(identity_token,",
                "// Line 1959:                        exception);",
                "// Line 1960:     }",
                "// Line 1961: ",
                "// Line 1962:     return false;",
                "// Line 1963: }",
                "// Line 1964: ",
                "// Line 1965: bool SecurityManager::get_permissions_token(",
                "// Line 1966:         PermissionsToken** permissions_token) const",
                "// Line 1967: {",
                "// Line 1968:     assert(permissions_token);",
                "// Line 1969: ",
                "// Line 1970:     auto sentry = is_security_manager_initialized();",
                "// Line 1971:     if (!sentry)",
                "// Line 1972:     {",
                "// Line 1973:         return false;",
                "// Line 1974:     }",
                "// Line 1975: ",
                "// Line 1976:     if (access_plugin_)",
                "// Line 1977:     {",
                "// vulnerable line: 1978: SecurityException exception;",
                "// Line 1979:         return access_plugin_->get_permissions_token(permissions_token,",
                "// Line 1980:                        *local_permissions_handle_, exception);",
                "// Line 1981:     }",
                "// Line 1982: ",
                "// Line 1983:     return false;",
                "// Line 1984: }",
                "// Line 1985: ",
                "// Line 1986: bool SecurityManager::return_permissions_token(",
                "// Line 1987:         PermissionsToken* permissions_token) const",
                "// Line 1988: {",
                "// Line 1992:     }",
                "// Line 1993: ",
                "// Line 1994:     auto sentry = is_security_manager_initialized();",
                "// Line 1995:     if (!sentry)",
                "// Line 1996:     {",
                "// Line 1997:         return false;",
                "// Line 1998:     }",
                "// Line 1999: ",
                "// Line 2000:     if (access_plugin_)",
                "// Line 2001:     {",
                "// vulnerable line: 2002: SecurityException exception;",
                "// Line 2003:         return access_plugin_->return_permissions_token(permissions_token,",
                "// Line 2004:                        exception);",
                "// Line 2005:     }",
                "// Line 2006: ",
                "// Line 2007:     return false;",
                "// Line 2008: }",
                "// Line 2009: ",
                "// Line 2010: uint32_t SecurityManager::builtin_endpoints() const",
                "// Line 2011: {",
                "// Line 2012:     uint32_t be = 0;",
                "// Line 2166:     {",
                "// Line 2167:         tmp_guid.entityId = participant_volatile_message_secure_reader_entity_id;",
                "// Line 2168:         participant_volatile_message_secure_writer_->matched_reader_remove(tmp_guid);",
                "// Line 2169:     }",
                "// Line 2170: }",
                "// Line 2171: ",
                "// Line 2172: void SecurityManager::exchange_participant_crypto(",
                "// Line 2173:         std::shared_ptr<ParticipantCryptoHandle> remote_participant_crypto,",
                "// Line 2174:         const GUID_t& remote_participant_guid)",
                "// Line 2175: {",
                "// vulnerable line: 2176: SecurityException exception;",
                "// Line 2177: ",
                "// Line 2178:     // Get participant crypto tokens.",
                "// Line 2179:     ParticipantCryptoTokenSeq local_participant_crypto_tokens;",
                "// Line 2180:     if (crypto_plugin_->cryptokeyexchange()->create_local_participant_crypto_tokens(local_participant_crypto_tokens,",
                "// Line 2181:             *local_participant_crypto_handle_, *remote_participant_crypto, exception))",
                "// Line 2182:     {",
                "// Line 2183:         ParticipantGenericMessage message = generate_participant_crypto_token_message(remote_participant_guid,",
                "// Line 2184:                         local_participant_crypto_tokens);",
                "// Line 2185: ",
                "// Line 2186:         CacheChange_t* change = participant_volatile_message_secure_writer_->new_change(",
                "// Line 2239: std::shared_ptr<ParticipantCryptoHandle> SecurityManager::register_and_match_crypto_endpoint(",
                "// Line 2240:         IdentityHandle& remote_participant_identity,",
                "// Line 2241:         SecretHandle& shared_secret)",
                "// Line 2242: {",
                "// Line 2243:     if (crypto_plugin_ == nullptr)",
                "// Line 2244:     {",
                "// Line 2245:         return nullptr;",
                "// Line 2246:     }",
                "// Line 2247: ",
                "// Line 2248:     NilHandle nil_handle;",
                "// vulnerable line: 2249: SecurityException exception;",
                "// Line 2250: ",
                "// Line 2251:     // Register remote participant into crypto plugin.",
                "// Line 2252:     std::shared_ptr<ParticipantCryptoHandle> remote_participant_crypto =",
                "// Line 2253:             crypto_plugin_->cryptokeyfactory()->register_matched_remote_participant(*local_participant_crypto_handle_,",
                "// Line 2254:                     remote_participant_identity, nil_handle, shared_secret, exception);",
                "// Line 2255: ",
                "// Line 2256:     if (remote_participant_crypto != nullptr)",
                "// Line 2257:     {",
                "// Line 2258:         return remote_participant_crypto;",
                "// Line 2259:     }",
                "// Line 2304:             {",
                "// Line 2305:                 receiving_crypto_list.push_back(dp_it->second->get_participant_crypto());",
                "// Line 2306:             }",
                "// Line 2307:             else",
                "// Line 2308:             {",
                "// Line 2309:                 EPROSIMA_LOG_INFO(SECURITY, \"Cannot encode message for participant \" << remote_participant_key);",
                "// Line 2310:             }",
                "// Line 2311:         }",
                "// Line 2312:     }",
                "// Line 2313: ",
                "// vulnerable line: 2314: SecurityException exception;",
                "// Line 2315:     return crypto_plugin_->cryptotransform()->encode_rtps_message(output_message,",
                "// Line 2316:                    input_message, *local_participant_crypto_handle_, receiving_crypto_list,",
                "// Line 2317:                    exception);",
                "// Line 2318: }",
                "// Line 2319: ",
                "// Line 2320: int SecurityManager::decode_rtps_message(",
                "// Line 2321:         const CDRMessage_t& message,",
                "// Line 2322:         CDRMessage_t& out_message,",
                "// Line 2323:         const GuidPrefix_t& remote_participant) const",
                "// Line 2324: {",
                "// Line 2358:         if (dp_it != discovered_participants_.end())",
                "// Line 2359:         {",
                "// Line 2360:             remote_participant_crypto_handle = dp_it->second->get_participant_crypto();",
                "// Line 2361:         }",
                "// Line 2362:     }",
                "// Line 2363: ",
                "// Line 2364:     int returnedValue = -1;",
                "// Line 2365: ",
                "// Line 2366:     if (remote_participant_crypto_handle != nullptr)",
                "// Line 2367:     {",
                "// vulnerable line: 2368: SecurityException exception;",
                "// Line 2369:         bool ret = crypto_plugin_->cryptotransform()->decode_rtps_message(out_message,",
                "// Line 2370:                         message,",
                "// Line 2371:                         *local_participant_crypto_handle_,",
                "// Line 2372:                         *remote_participant_crypto_handle,",
                "// Line 2373:                         exception);",
                "// Line 2374: ",
                "// Line 2375:         if (ret)",
                "// Line 2376:         {",
                "// Line 2377:             returnedValue = 0;",
                "// Line 2378:         }",
                "// Line 2395:         const GUID_t& writer_guid,",
                "// Line 2396:         const PropertyPolicy& writer_properties,",
                "// Line 2397:         EndpointSecurityAttributes& security_attributes)",
                "// Line 2398: {",
                "// Line 2399:     auto sentry = is_security_manager_initialized();",
                "// Line 2400:     if (!sentry)",
                "// Line 2401:     {",
                "// Line 2402:         return false;",
                "// Line 2403:     }",
                "// Line 2404: ",
                "// vulnerable line: 2405: SecurityException exception;",
                "// Line 2406:     bool returned_value = get_datawriter_sec_attributes(writer_properties, security_attributes);",
                "// Line 2407: ",
                "// Line 2408:     if (returned_value && crypto_plugin_ != nullptr && (security_attributes.is_submessage_protected ||",
                "// Line 2409:             security_attributes.is_payload_protected))",
                "// Line 2410:     {",
                "// Line 2411:         DatawriterCryptoHandle* writer_handle = crypto_plugin_->cryptokeyfactory()->register_local_datawriter(",
                "// Line 2412:             *local_participant_crypto_handle_, writer_properties.properties(), security_attributes, exception);",
                "// Line 2413: ",
                "// Line 2414:         if (writer_handle != nullptr && !writer_handle->nil())",
                "// Line 2415:         {",
                "// Line 2430:         const PropertyPolicy& writer_properties,",
                "// Line 2431:         EndpointSecurityAttributes& security_attributes)",
                "// Line 2432: {",
                "// Line 2433:     auto sentry = is_security_manager_initialized();",
                "// Line 2434:     if (!sentry)",
                "// Line 2435:     {",
                "// Line 2436:         return false;",
                "// Line 2437:     }",
                "// Line 2438: ",
                "// Line 2439:     bool returned_value = true;",
                "// vulnerable line: 2440: SecurityException exception;",
                "// Line 2441: ",
                "// Line 2442:     if (access_plugin_ != nullptr)",
                "// Line 2443:     {",
                "// Line 2444:         // Extract topic and partitions.",
                "// Line 2445:         std::string topic_name, partitions_str;",
                "// Line 2446:         std::vector<std::string> partitions;",
                "// Line 2447:         const std::string* property_value = PropertyPolicyHelper::find_property(writer_properties,",
                "// Line 2448:                         \"topic_name\");",
                "// Line 2449: ",
                "// Line 2450:         if (property_value != nullptr)",
                "// Line 2504:         const GUID_t& writer_guid,",
                "// Line 2505:         EndpointSecurityAttributes& security_attributes)",
                "// Line 2506: {",
                "// Line 2507:     auto sentry = is_security_manager_initialized();",
                "// Line 2508:     if (!sentry)",
                "// Line 2509:     {",
                "// Line 2510:         return false;",
                "// Line 2511:     }",
                "// Line 2512: ",
                "// Line 2513:     bool returned_value = true;",
                "// vulnerable line: 2514: SecurityException exception;",
                "// Line 2515: ",
                "// Line 2516:     if (crypto_plugin_ != nullptr && security_attributes.is_submessage_protected &&",
                "// Line 2517:             writer_guid.entityId != participant_volatile_message_secure_writer_entity_id)",
                "// Line 2518:     {",
                "// Line 2519:         PropertySeq auxProps;",
                "// Line 2520:         DatawriterCryptoHandle* writer_handle = crypto_plugin_->cryptokeyfactory()->register_local_datawriter(",
                "// Line 2521:             *local_participant_crypto_handle_, auxProps, security_attributes, exception);",
                "// Line 2522: ",
                "// Line 2523:         if (writer_handle != nullptr && !writer_handle->nil())",
                "// Line 2524:         {",
                "// Line 2548:     {",
                "// Line 2549:         return false;",
                "// Line 2550:     }",
                "// Line 2551: ",
                "// Line 2552:     std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 2553: ",
                "// Line 2554:     auto local_writer = writer_handles_.find(writer_guid);",
                "// Line 2555: ",
                "// Line 2556:     if (local_writer != writer_handles_.end())",
                "// Line 2557:     {",
                "// vulnerable line: 2558: SecurityException exception;",
                "// Line 2559: ",
                "// Line 2560:         for (auto& rit : local_writer->second.associated_readers)",
                "// Line 2561:         {",
                "// Line 2562:             crypto_plugin_->cryptokeyfactory()->unregister_datareader(std::get<1>(rit.second), exception);",
                "// Line 2563:         }",
                "// Line 2564: ",
                "// Line 2565:         crypto_plugin_->cryptokeyfactory()->unregister_datawriter(local_writer->second.writer_handle,",
                "// Line 2566:                 exception);",
                "// Line 2567:         writer_handles_.erase(local_writer);",
                "// Line 2568: ",
                "// Line 2576:         const GUID_t& reader_guid,",
                "// Line 2577:         const PropertyPolicy& reader_properties,",
                "// Line 2578:         EndpointSecurityAttributes& security_attributes)",
                "// Line 2579: {",
                "// Line 2580:     auto sentry = is_security_manager_initialized();",
                "// Line 2581:     if (!sentry)",
                "// Line 2582:     {",
                "// Line 2583:         return false;",
                "// Line 2584:     }",
                "// Line 2585: ",
                "// vulnerable line: 2586: SecurityException exception;",
                "// Line 2587:     bool returned_value = get_datareader_sec_attributes(reader_properties, security_attributes);",
                "// Line 2588: ",
                "// Line 2589:     if (returned_value && crypto_plugin_ != nullptr && (security_attributes.is_submessage_protected ||",
                "// Line 2590:             security_attributes.is_payload_protected))",
                "// Line 2591:     {",
                "// Line 2592: ",
                "// Line 2593:         DatareaderCryptoHandle* reader_handle = crypto_plugin_->cryptokeyfactory()->register_local_datareader(",
                "// Line 2594:             *local_participant_crypto_handle_, reader_properties.properties(), security_attributes, exception);",
                "// Line 2595: ",
                "// Line 2596:         if (reader_handle != nullptr && !reader_handle->nil())",
                "// Line 2612:         const PropertyPolicy& reader_properties,",
                "// Line 2613:         EndpointSecurityAttributes& security_attributes)",
                "// Line 2614: {",
                "// Line 2615:     auto sentry = is_security_manager_initialized();",
                "// Line 2616:     if (!sentry)",
                "// Line 2617:     {",
                "// Line 2618:         return false;",
                "// Line 2619:     }",
                "// Line 2620: ",
                "// Line 2621:     bool returned_value = true;",
                "// vulnerable line: 2622: SecurityException exception;",
                "// Line 2623: ",
                "// Line 2624:     if (access_plugin_ != nullptr)",
                "// Line 2625:     {",
                "// Line 2626:         // Extract topic and partitions.",
                "// Line 2627:         std::string topic_name, partitions_str;",
                "// Line 2628:         std::vector<std::string> partitions;",
                "// Line 2629:         const std::string* property_value = PropertyPolicyHelper::find_property(reader_properties,",
                "// Line 2630:                         \"topic_name\");",
                "// Line 2631: ",
                "// Line 2632:         if (property_value != nullptr)",
                "// Line 2686:         const GUID_t& reader_guid,",
                "// Line 2687:         EndpointSecurityAttributes& security_attributes)",
                "// Line 2688: {",
                "// Line 2689:     auto sentry = is_security_manager_initialized();",
                "// Line 2690:     if (!sentry)",
                "// Line 2691:     {",
                "// Line 2692:         return false;",
                "// Line 2693:     }",
                "// Line 2694: ",
                "// Line 2695:     bool returned_value = true;",
                "// vulnerable line: 2696: SecurityException exception;",
                "// Line 2697: ",
                "// Line 2698:     if (crypto_plugin_ != nullptr && security_attributes.is_submessage_protected &&",
                "// Line 2699:             reader_guid.entityId != participant_volatile_message_secure_reader_entity_id)",
                "// Line 2700:     {",
                "// Line 2701:         PropertySeq auxProps;",
                "// Line 2702:         DatareaderCryptoHandle* reader_handle = crypto_plugin_->cryptokeyfactory()->register_local_datareader(",
                "// Line 2703:             *local_participant_crypto_handle_, auxProps, security_attributes, exception);",
                "// Line 2704: ",
                "// Line 2705:         if (reader_handle != nullptr && !reader_handle->nil())",
                "// Line 2706:         {",
                "// Line 2730:     {",
                "// Line 2731:         return false;",
                "// Line 2732:     }",
                "// Line 2733: ",
                "// Line 2734:     std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 2735: ",
                "// Line 2736:     auto local_reader = reader_handles_.find(reader_guid);",
                "// Line 2737: ",
                "// Line 2738:     if (local_reader != reader_handles_.end())",
                "// Line 2739:     {",
                "// vulnerable line: 2740: SecurityException exception;",
                "// Line 2741: ",
                "// Line 2742:         for (auto& wit : local_reader->second.associated_writers)",
                "// Line 2743:         {",
                "// Line 2744:             crypto_plugin_->cryptokeyfactory()->unregister_datawriter(std::get<1>(wit.second), exception);",
                "// Line 2745:         }",
                "// Line 2746: ",
                "// Line 2747:         crypto_plugin_->cryptokeyfactory()->unregister_datareader(local_reader->second.reader_handle, exception);",
                "// Line 2748:         reader_handles_.erase(local_reader);",
                "// Line 2749: ",
                "// Line 2750:         return true;",
                "// Line 2777:     {",
                "// Line 2778:         return;",
                "// Line 2779:     }",
                "// Line 2780: ",
                "// Line 2781:     std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 2782: ",
                "// Line 2783:     auto local_writer = writer_handles_.find(writer_guid);",
                "// Line 2784: ",
                "// Line 2785:     if (local_writer != writer_handles_.end())",
                "// Line 2786:     {",
                "// vulnerable line: 2787: SecurityException exception;",
                "// Line 2788: ",
                "// Line 2789:         auto rit = local_writer->second.associated_readers.find(remote_reader_guid);",
                "// Line 2790: ",
                "// Line 2791:         if (rit != local_writer->second.associated_readers.end())",
                "// Line 2792:         {",
                "// Line 2793:             crypto_plugin_->cryptokeyfactory()->unregister_datareader(std::get<1>(rit->second), exception);",
                "// Line 2794:             local_writer->second.associated_readers.erase(rit);",
                "// Line 2795:         }",
                "// Line 2796:         else",
                "// Line 2797:         {",
                "// Line 2850:             shared_secret_handle = dp_it->second->get_shared_secret();",
                "// Line 2851:             auth_status = dp_it->second->get_auth_status();",
                "// Line 2852:         }",
                "// Line 2853:     }",
                "// Line 2854: ",
                "// Line 2855:     // assert(access_plugin_ == nullptr || remote_permissions != nullptr);",
                "// Line 2856:     // assert(crypto_plugin_ == nullptr || remote_participant_crypto_handle != nullptr);",
                "// Line 2857: ",
                "// Line 2858:     bool relay_only = false;",
                "// Line 2859:     bool returned_value = true;",
                "// vulnerable line: 2860: SecurityException exception;",
                "// Line 2861: ",
                "// Line 2862:     if (!is_builtin)",
                "// Line 2863:     {",
                "// Line 2864:         //! Check if it is an unathenticated participant",
                "// Line 2865:         if (participant_->security_attributes().allow_unauthenticated_participants &&",
                "// Line 2866:                 auth_status != AUTHENTICATION_NOT_AVAILABLE && auth_status != AUTHENTICATION_OK &&",
                "// Line 2867:                 (security_attributes.is_write_protected || security_attributes.is_read_protected))",
                "// Line 2868:         {",
                "// Line 2869:             //!Do not match if read or write protection is enabled for this local endpoint",
                "// Line 2870:             return false;",
                "// Line 3141:     {",
                "// Line 3142:         return;",
                "// Line 3143:     }",
                "// Line 3144: ",
                "// Line 3145:     std::lock_guard<shared_mutex> _(mutex_);",
                "// Line 3146: ",
                "// Line 3147:     auto local_reader = reader_handles_.find(reader_guid);",
                "// Line 3148: ",
                "// Line 3149:     if (local_reader != reader_handles_.end())",
                "// Line 3150:     {",
                "// vulnerable line: 3151: SecurityException exception;",
                "// Line 3152: ",
                "// Line 3153:         auto wit = local_reader->second.associated_writers.find(remote_writer_guid);",
                "// Line 3154: ",
                "// Line 3155:         if (wit != local_reader->second.associated_writers.end())",
                "// Line 3156:         {",
                "// Line 3157:             crypto_plugin_->cryptokeyfactory()->unregister_datawriter(std::get<1>(wit->second), exception);",
                "// Line 3158:             local_reader->second.associated_writers.erase(wit);",
                "// Line 3159:         }",
                "// Line 3160:         else",
                "// Line 3161:         {",
                "// Line 3213:             remote_participant_crypto_handle = dp_it->second->get_participant_crypto();",
                "// Line 3214:             shared_secret_handle = dp_it->second->get_shared_secret();",
                "// Line 3215:             auth_status = dp_it->second->get_auth_status();",
                "// Line 3216:         }",
                "// Line 3217:     }",
                "// Line 3218: ",
                "// Line 3219:     // assert(access_plugin_ == nullptr || remote_permissions != nullptr);",
                "// Line 3220:     // assert(crypto_plugin_ == nullptr || remote_participant_crypto_handle != nullptr);",
                "// Line 3221: ",
                "// Line 3222:     bool returned_value = true;",
                "// vulnerable line: 3223: SecurityException exception;",
                "// Line 3224: ",
                "// Line 3225:     if (!is_builtin)",
                "// Line 3226:     {",
                "// Line 3227:         //! Check if it is an unathenticated participant",
                "// Line 3228:         if (participant_->security_attributes().allow_unauthenticated_participants &&",
                "// Line 3229:                 auth_status != AUTHENTICATION_NOT_AVAILABLE && auth_status != AUTHENTICATION_OK &&",
                "// Line 3230:                 (security_attributes.is_write_protected || security_attributes.is_read_protected))",
                "// Line 3231:         {",
                "// Line 3232:             //!Do not match if read or write protection is enabled for this local endpoint",
                "// Line 3233:             return false;",
                "// Line 3508:         {",
                "// Line 3509:             GUID_t participant_guid(receiving_list.at(0).guidPrefix, c_EntityId_RTPSParticipant);",
                "// Line 3510:             auto part = discovered_participants_.find(participant_guid);",
                "// Line 3511:             if (part != discovered_participants_.end())",
                "// Line 3512:             {",
                "// Line 3513:                 auto pCrypto = part->second->get_participant_crypto();",
                "// Line 3514: ",
                "// Line 3515:                 if (pCrypto)",
                "// Line 3516:                 {",
                "// Line 3517:                     EndpointSecurityAttributes attr;",
                "// vulnerable line: 3518: SecurityException exception;",
                "// Line 3519:                     PropertySeq auxProps;",
                "// Line 3520:                     auxProps.emplace_back(",
                "// Line 3521:                         Property(\"dds.sec.builtin_endpoint_name\", \"BuiltinParticipantVolatileMessageSecureWriter\"));",
                "// Line 3522:                     auto wHandle =",
                "// Line 3523:                             crypto_plugin_->cryptokeyfactory()->register_local_datawriter(",
                "// Line 3524:                         *pCrypto, auxProps, attr, exception);",
                "// Line 3525:                     std::vector<std::shared_ptr<DatareaderCryptoHandle>> receiving_crypto_list;",
                "// Line 3526:                     if (wHandle != nullptr)",
                "// Line 3527:                     {",
                "// Line 3528:                         ret_val = crypto_plugin_->cryptotransform()->encode_datawriter_submessage(output_message,",
                "// Line 3550:                 receiving_datareader_crypto_list.emplace_back(std::get<1>(rd_it_handle->second)->shared_from_this());",
                "// Line 3551:             }",
                "// Line 3552:             else",
                "// Line 3553:             {",
                "// Line 3554:                 EPROSIMA_LOG_ERROR(SECURITY, \"Cannot find remote reader \" << rd_it);",
                "// Line 3555:             }",
                "// Line 3556:         }",
                "// Line 3557: ",
                "// Line 3558:         if (receiving_datareader_crypto_list.size() > 0)",
                "// Line 3559:         {",
                "// vulnerable line: 3560: SecurityException exception;",
                "// Line 3561: ",
                "// Line 3562:             if (crypto_plugin_->cryptotransform()->encode_datawriter_submessage(output_message,",
                "// Line 3563:                     input_message,",
                "// Line 3564:                     *wr_it->second.writer_handle,",
                "// Line 3565:                     receiving_datareader_crypto_list,",
                "// Line 3566:                     exception))",
                "// Line 3567:             {",
                "// Line 3568:                 return true;",
                "// Line 3569:             }",
                "// Line 3570:         }",
                "// Line 3604:         {",
                "// Line 3605:             GUID_t participant_guid(receiving_list.at(0).guidPrefix, c_EntityId_RTPSParticipant);",
                "// Line 3606:             auto part = discovered_participants_.find(participant_guid);",
                "// Line 3607:             if (part != discovered_participants_.end())",
                "// Line 3608:             {",
                "// Line 3609:                 auto pCrypto = part->second->get_participant_crypto();",
                "// Line 3610: ",
                "// Line 3611:                 if (pCrypto)",
                "// Line 3612:                 {",
                "// Line 3613:                     EndpointSecurityAttributes attr;",
                "// vulnerable line: 3614: SecurityException exception;",
                "// Line 3615:                     PropertySeq auxProps;",
                "// Line 3616:                     auxProps.emplace_back(",
                "// Line 3617:                         Property(\"dds.sec.builtin_endpoint_name\", \"BuiltinParticipantVolatileMessageSecureReader\"));",
                "// Line 3618:                     auto rHandle =",
                "// Line 3619:                             crypto_plugin_->cryptokeyfactory()->register_local_datareader(",
                "// Line 3620:                         *pCrypto, auxProps, attr, exception);",
                "// Line 3621:                     std::vector<std::shared_ptr<DatawriterCryptoHandle>> receiving_crypto_list;",
                "// Line 3622:                     if (rHandle != nullptr)",
                "// Line 3623:                     {",
                "// Line 3624:                         ret_val = crypto_plugin_->cryptotransform()->encode_datareader_submessage(output_message,",
                "// Line 3646:                 receiving_datawriter_crypto_list.push_back(std::get<1>(wr_it_handle->second)->shared_from_this());",
                "// Line 3647:             }",
                "// Line 3648:             else",
                "// Line 3649:             {",
                "// Line 3650:                 EPROSIMA_LOG_ERROR(SECURITY, \"Cannot find remote writer \" << wr_it);",
                "// Line 3651:             }",
                "// Line 3652:         }",
                "// Line 3653: ",
                "// Line 3654:         if (receiving_datawriter_crypto_list.size() > 0)",
                "// Line 3655:         {",
                "// vulnerable line: 3656: SecurityException exception;",
                "// Line 3657: ",
                "// Line 3658:             if (crypto_plugin_->cryptotransform()->encode_datareader_submessage(output_message,",
                "// Line 3659:                     input_message,",
                "// Line 3660:                     *rd_it->second.reader_handle,",
                "// Line 3661:                     receiving_datawriter_crypto_list,",
                "// Line 3662:                     exception))",
                "// Line 3663:             {",
                "// Line 3664:                 return true;",
                "// Line 3665:             }",
                "// Line 3666:         }",
                "// Line 3713:         {",
                "// Line 3714:             remote_participant_crypto_handle = dp_it->second->get_participant_crypto();",
                "// Line 3715:         }",
                "// Line 3716:     }",
                "// Line 3717: ",
                "// Line 3718:     if (remote_participant_crypto_handle != nullptr)",
                "// Line 3719:     {",
                "// Line 3720:         DatawriterCryptoHandle* writer_handle = nullptr;",
                "// Line 3721:         DatareaderCryptoHandle* reader_handle = nullptr;",
                "// Line 3722:         SecureSubmessageCategory_t category = INFO_SUBMESSAGE;",
                "// vulnerable line: 3723: SecurityException exception;",
                "// Line 3724: ",
                "// Line 3725:         // encoding requires modifying the handle but it takes care of its own synchronization",
                "// Line 3726:         if (crypto_plugin_->cryptotransform()->preprocess_secure_submsg(&writer_handle, &reader_handle,",
                "// Line 3727:                 category, message, *local_participant_crypto_handle_,",
                "// Line 3728:                 *remote_participant_crypto_handle, exception))",
                "// Line 3729:         {",
                "// Line 3730:             // TODO (Ricardo) Category INFO",
                "// Line 3731:             if (category == DATAWRITER_SUBMESSAGE)",
                "// Line 3732:             {",
                "// Line 3733:                 if (crypto_plugin_->cryptotransform()->decode_datawriter_submessage(out_message, message,",
                "// Line 3781:     {",
                "// Line 3782:         return false;",
                "// Line 3783:     }",
                "// Line 3784: ",
                "// Line 3785:     shared_lock<shared_mutex> _(mutex_);",
                "// Line 3786: ",
                "// Line 3787:     const auto& wr_it = writer_handles_.find(writer_guid);",
                "// Line 3788: ",
                "// Line 3789:     if (wr_it != writer_handles_.end())",
                "// Line 3790:     {",
                "// vulnerable line: 3791: SecurityException exception;",
                "// Line 3792:         std::vector<uint8_t> extra_inline_qos;",
                "// Line 3793: ",
                "// Line 3794:         if (crypto_plugin_->cryptotransform()->encode_serialized_payload(output_payload,",
                "// Line 3795:                 extra_inline_qos,",
                "// Line 3796:                 payload,",
                "// Line 3797:                 *wr_it->second.writer_handle,",
                "// Line 3798:                 exception))",
                "// Line 3799:         {",
                "// Line 3800:             return true;",
                "// Line 3801:         }",
                "// Line 3833: ",
                "// Line 3834:     const auto& rd_it = reader_handles_.find(reader_guid);",
                "// Line 3835: ",
                "// Line 3836:     if (rd_it != reader_handles_.end())",
                "// Line 3837:     {",
                "// Line 3838:         const auto wr_it_handle = rd_it->second.associated_writers.find(writer_guid);",
                "// Line 3839: ",
                "// Line 3840:         if (wr_it_handle != rd_it->second.associated_writers.end())",
                "// Line 3841:         {",
                "// Line 3842:             std::vector<uint8_t> inline_qos;",
                "// vulnerable line: 3843: SecurityException exception;",
                "// Line 3844: ",
                "// Line 3845:             if (crypto_plugin_->cryptotransform()->decode_serialized_payload(payload,",
                "// Line 3846:                     secure_payload, inline_qos, *rd_it->second.reader_handle,",
                "// Line 3847:                     *std::get<1>(wr_it_handle->second), exception))",
                "// Line 3848:             {",
                "// Line 3849:                 return true;",
                "// Line 3850:             }",
                "// Line 3851:             else",
                "// Line 3852:             {",
                "// Line 3853:                 EPROSIMA_LOG_ERROR(SECURITY, \"Error decoding encoded payload (\" << exception.what() << \")\");",
                "// Line 3872:         std::shared_ptr<SecretHandle>& shared_secret_handle)",
                "// Line 3873: {",
                "// Line 3874:     auto sentry = is_security_manager_initialized();",
                "// Line 3875:     if (!sentry)",
                "// Line 3876:     {",
                "// Line 3877:         return false;",
                "// Line 3878:     }",
                "// Line 3879: ",
                "// Line 3880:     EPROSIMA_LOG_INFO(SECURITY, \"Authorized participant \" << participant_data.m_guid);",
                "// Line 3881: ",
                "// vulnerable line: 3882: SecurityException exception;",
                "// Line 3883:     PermissionsHandle* remote_permissions = nullptr;",
                "// Line 3884: ",
                "// Line 3885:     if (access_plugin_ != nullptr)",
                "// Line 3886:     {",
                "// Line 3887:         PermissionsCredentialToken* credential_token = nullptr;",
                "// Line 3888:         if (authentication_plugin_->get_authenticated_peer_credential_token(&credential_token,",
                "// Line 3889:                 *remote_participant_info->identity_handle_, exception))",
                "// Line 3890:         {",
                "// Line 3891:             remote_permissions =",
                "// Line 3892:                     access_plugin_->validate_remote_permissions(*authentication_plugin_,",
                "// Line 4173:     auto dp_it = discovered_participants_.find(remote_participant_key);",
                "// Line 4174: ",
                "// Line 4175:     if (dp_it != discovered_participants_.end())",
                "// Line 4176:     {",
                "// Line 4177:         SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();",
                "// Line 4178: ",
                "// Line 4179:         if (remote_participant_info)",
                "// Line 4180:         {",
                "// Line 4181:             if (remote_participant_info->handshake_requests_sent_ >= DiscoveredParticipantInfo::MAX_HANDSHAKE_REQUESTS)",
                "// Line 4182:             {",
                "// vulnerable line: 4183: SecurityException exception;",
                "// vulnerable line: 4184: remote_participant_info->event_->cancel_timer();",
                "// vulnerable line: 4185: on_validation_failed(dp_it->second->participant_data(), exception);",
                "// Line 4186:             }",
                "// Line 4187:             else",
                "// Line 4188:             {",
                "// Line 4189:                 if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())",
                "// Line 4190:                 {",
                "// Line 4191:                     CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(",
                "// Line 4192:                         remote_participant_info->change_sequence_number_);",
                "// Line 4193:                     remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();",
                "// Line 4194: ",
                "// Line 4195:                     if (p_change != nullptr)"
            ]
        },
        {
            "filename_of_changes": "SimplePDPEndpoints.hpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "StatelessReader.cpp",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "18",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 299:     return false;",
                "// Line 300: }",
                "// Line 301: ",
                "// Line 302: bool StatelessReader::change_received(",
                "// Line 303:         CacheChange_t* change)",
                "// Line 304: {",
                "// Line 305:     // Only make the change visible if there is not another with a bigger sequence number.",
                "// Line 306:     // TODO Revisar si no hay que incluirlo.",
                "// Line 307:     if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))",
                "// Line 308:     {",
                "// vulnerable line: 309: // Update Ownership strength.",
                "// vulnerable line: 310: if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)",
                "// Line 311:         {",
                "// vulnerable line: 312: auto writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),",
                "// Line 313:                             [change](const RemoteWriterInfo_t& item)",
                "// Line 314:                             {",
                "// Line 315:                                 return item.guid == change->writerGUID;",
                "// Line 316:                             });",
                "// Line 317:             assert(matched_writers_.end() != writer);",
                "// Line 318:             change->reader_info.writer_ownership_strength = writer->ownership_strength;",
                "// Line 319:         }",
                "// Line 320:         else",
                "// Line 321:         {",
                "// Line 322:             change->reader_info.writer_ownership_strength = std::numeric_limits<uint32_t>::max();",
                "// Line 323:         }",
                "// Line 324: ",
                "// Line 325:         if (mp_history->received_change(change, 0))",
                "// Line 326:         {",
                "// Line 327:             auto payload_length = change->serializedPayload.length;",
                "// Line 328:             auto guid = change->writerGUID;",
                "// Line 329:             auto seq = change->sequenceNumber;",
                "// Line 330: ",
                "// Line 331:             Time_t::now(change->reader_info.receptionTimestamp);",
                "// vulnerable line: 332: SequenceNumber_t previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);",
                "// Line 333:             ++total_unread_;",
                "// Line 334: ",
                "// Line 335:             on_data_notify(guid, change->sourceTimestamp);",
                "// Line 336: ",
                "// Line 337:             auto listener = getListener();",
                "// Line 338:             if (listener != nullptr)",
                "// Line 339:             {",
                "// Line 340:                 if (SequenceNumber_t{0, 0} != previous_seq)",
                "// Line 341:                 {",
                "// Line 342:                     assert(previous_seq < seq);"
            ]
        }
    ]
}