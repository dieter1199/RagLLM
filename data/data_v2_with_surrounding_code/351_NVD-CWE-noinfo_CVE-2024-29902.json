{
    "cve_id": "CVE-2024-29902",
    "cve_description": "Cosign provides code signing and transparency for containers and binaries. Prior to version 2.2.4, a remote image with a malicious attachment can cause denial of service of the host machine running Cosign. This can impact other services on the machine that rely on having memory available such as a Redis database which can result in data loss. It can also impact the availability of other services on the machine that will not be available for the duration of the machine denial. The root cause of this issue is that Cosign reads the attachment from a remote image entirely into memory without checking the size of the attachment first. As such, a large attachment can make Cosign read a large attachment into memory; If the attachments size is larger than the machine has memory available, the machine will be denied of service. The Go runtime will make a SigKill after a few seconds of system-wide denial. This issue can allow a supply-chain escalation from a compromised registry to the Cosign user: If an attacher has compromised a registry or the account of an image vendor, they can include a malicious attachment and hurt the image consumer. Version 2.2.4 contains a patch for the vulnerability.",
    "cve_publish_date": "2024-04-10T23:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Fixes for GHSA-88jx-383q-w4qc and GHSA-95pr-fxf5-86gv (#3661)\n\n* Merge pull request from GHSA-95pr-fxf5-86gv\r\n\r\nAn Image may come from an untrusted source and contain an unknown number\r\nof signatures in the .sig manifest. A common pattern in cosign is to use\r\nthe number of signatures as the capacity for a new slice. But this means\r\nthe size of the slice is based on an unvalidated external input and\r\ncould result in cosign running out of memory.\r\n\r\nThis change adds validation for certain implementations of the\r\noci.Signatures Get() method to limit the number of image descriptors\r\nreturned. This way, callers can rely on the returned slice of signatures\r\nbeing a reasonable size to process safely.\r\n\r\nThe limit is set to 1000, which is a generous size based on the\r\npractical restrictions that container registries set for image manifest\r\nsize and approximations of memory allocations for signature layers.\r\n\r\nSigned-off-by: Colleen Murphy <colleenmurphy@google.com>\r\n\r\n* Merge pull request from GHSA-88jx-383q-w4qc\r\n\r\nWhen downloading an attestation or SBOM from an external source, check\r\nits size before reading it into memory. This protects the host from\r\npotentially reading a maliciously large attachment into memory and\r\nexhausting the system.\r\n\r\nSBOMs can vary widely in size, and there could be legitimate SBOMs of up\r\nto 700MB. However, reading a 700MB SBOM into memory would easily bring\r\ndown a small cloud VM. Moreover, most SBOMs are not going to be that\r\nlarge. This change sets a reasonable default of 128MiB, and allows\r\noverriding the default by setting the environment variable\r\n`COSIGN_MAX_ATTACHMENT_SIZE`.\r\n\r\nSigned-off-by: Colleen Murphy <colleenmurphy@google.com>\r\n\r\n---------\r\n\r\nSigned-off-by: Colleen Murphy <colleenmurphy@google.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "env.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "file.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "go.mod",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "layer.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "remote.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "10",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "signatures.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "7",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 26: }",
                "// Line 27: ",
                "// Line 28: var _ oci.Signatures = (*sigs)(nil)",
                "// Line 29: ",
                "// Line 30: // Get implements oci.Signatures",
                "// Line 31: func (s *sigs) Get() ([]oci.Signature, error) {",
                "// Line 32:     manifest, err := s.Image.Manifest()",
                "// Line 33:     if err != nil {",
                "// Line 34:         return nil, err",
                "// Line 35:     }",
                "// vulnerable line: 36: signatures := make([]oci.Signature, 0, len(manifest.Layers))",
                "// Line 37:     for _, desc := range manifest.Layers {",
                "// Line 38:         l, err := s.Image.LayerByDigest(desc.Digest)",
                "// Line 39:         if err != nil {",
                "// Line 40:             return nil, err",
                "// Line 41:         }",
                "// Line 42:         signatures = append(signatures, signature.New(l, desc))",
                "// Line 43:     }",
                "// Line 44:     return signatures, nil",
                "// Line 45: }"
            ]
        },
        {
            "filename_of_changes": "signatures.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "signatures.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "signatures_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "22",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "verify_blob_attestation.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "verify_blob_attestation_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "12",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}