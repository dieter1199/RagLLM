{
    "cve_id": "CVE-2024-28183",
    "cve_description": "ESP-IDF is the development framework for Espressif SoCs supported on Windows, Linux and macOS. A Time-of-Check to Time-of-Use (TOCTOU) vulnerability was discovered in the implementation of the ESP-IDF bootloader which could allow an attacker with physical access to flash of the device to bypass anti-rollback protection. Anti-rollback prevents rollback to application with security version lower than one programmed in eFuse of chip. This attack can allow to boot past (passive) application partition having lower security version of the same device even in the presence of the flash encryption scheme. The attack requires carefully modifying the flash contents after the anti-rollback checks have been performed by the bootloader (before loading the application). The vulnerability is fixed in 4.4.7 and 5.2.1.",
    "cve_publish_date": "2024-03-25T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix(bootloader_support): check the secure version only for app image\n\nSecure version in the image header is only available for the application\nimage. However, for certain security workflows, bootloader verifies\nitself (own image) and hence the secure version check during that must be\navoided.\n\nRegression introduced in recent commit-id: 3305cb4d\n\nTested that both secure boot and flash-enc workflows work correctly\nwith the anti-rollback scenario.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "esp_image_format.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 24: #include \"soc/soc_caps.h\"",
                "// Line 25: #include \"hal/cache_ll.h\"",
                "// Line 26: #if CONFIG_IDF_TARGET_ESP32C2",
                "// Line 27: #include \"esp32c2/rom/rtc.h\"",
                "// Line 28: #elif CONFIG_IDF_TARGET_ESP32C6",
                "// Line 29: #include \"esp32c6/rom/rtc.h\"",
                "// Line 30: #elif CONFIG_IDF_TARGET_ESP32H2",
                "// Line 31: #include \"esp32h2/rom/rtc.h\"",
                "// Line 32: #elif CONFIG_IDF_TARGET_ESP32P4",
                "// Line 33: #include \"esp32p4/rom/rtc.h\"",
                "// vulnerable line: 34: #endif",
                "// Line 35: ",
                "// Line 36: #define ALIGN_UP(num, align) (((num) + ((align) - 1)) & ~((align) - 1))",
                "// Line 37: ",
                "// Line 38: /* Checking signatures as part of verifying images is necessary:",
                "// Line 39:    - Always if secure boot is enabled",
                "// Line 40:    - Differently in bootloader and/or app, depending on kconfig",
                "// Line 41: */",
                "// Line 42: #ifdef BOOTLOADER_BUILD",
                "// Line 43: #ifdef CONFIG_SECURE_SIGNED_ON_BOOT",
                "// Line 44: #define SECURE_BOOT_CHECK_SIGNATURE 1",
                "// Line 45: #else",
                "// Line 46: #define SECURE_BOOT_CHECK_SIGNATURE 0",
                "// vulnerable line: 47: #endif",
                "// Line 48: #else /* !BOOTLOADER_BUILD */",
                "// Line 49: #ifdef CONFIG_SECURE_SIGNED_ON_UPDATE",
                "// Line 50: #define SECURE_BOOT_CHECK_SIGNATURE 1",
                "// Line 51: #else",
                "// Line 52: #define SECURE_BOOT_CHECK_SIGNATURE 0",
                "// vulnerable line: 53: #endif",
                "// vulnerable line: 54: #endif",
                "// Line 55: ",
                "// Line 56: static const char *TAG = \"esp_image\";",
                "// Line 57: ",
                "// Line 58: #define HASH_LEN ESP_IMAGE_HASH_LEN",
                "// Line 59: ",
                "// Line 60: #define SIXTEEN_MB 0x1000000",
                "// Line 61: #define ESP_ROM_CHECKSUM_INITIAL 0xEF",
                "// Line 62: ",
                "// Line 63: /* Headroom to ensure between stack SP (at time of checking) and data loaded from flash */",
                "// Line 64: #define STACK_LOAD_HEADROOM 32768",
                "// Line 65: ",
                "// Line 66: #ifdef BOOTLOADER_BUILD",
                "// Line 67: /* 64 bits of random data to obfuscate loaded RAM with, until verification is complete",
                "// Line 68:    (Means loaded code isn't executable until after the secure boot check.)",
                "// Line 69: */",
                "// Line 70: static uint32_t ram_obfs_value[2];",
                "// Line 71: ",
                "// vulnerable line: 72: #endif",
                "// Line 73: ",
                "// Line 74: /* Return true if load_addr is an address the bootloader should load into */",
                "// Line 75: static bool should_load(uint32_t load_addr);",
                "// Line 76: /* Return true if load_addr is an address the bootloader should map via flash cache */",
                "// Line 77: static bool should_map(uint32_t load_addr);",
                "// Line 78: ",
                "// Line 79: static esp_err_t process_segments(esp_image_metadata_t *data, bool silent, bool do_load, bootloader_sha256_handle_t sha_handle, uint32_t *checksum);",
                "// Line 80: /* Load or verify a segment */",
                "// Line 81: static esp_err_t process_segment(int index, uint32_t flash_addr, esp_image_segment_header_t *header, bool silent, bool do_load, bootloader_sha256_handle_t sha_handle, uint32_t *checksum, esp_image_metadata_t *metadata);",
                "// Line 82: ",
                "// Line 102: static esp_err_t __attribute__((unused)) verify_simple_hash(bootloader_sha256_handle_t sha_handle, esp_image_metadata_t *data);",
                "// Line 103: ",
                "// Line 104: static esp_err_t image_load(esp_image_load_mode_t mode, const esp_partition_pos_t *part, esp_image_metadata_t *data)",
                "// Line 105: {",
                "// Line 106: #ifdef BOOTLOADER_BUILD",
                "// Line 107:     bool do_load   = (mode == ESP_IMAGE_LOAD) || (mode == ESP_IMAGE_LOAD_NO_VALIDATE);",
                "// Line 108:     bool do_verify = (mode == ESP_IMAGE_LOAD) || (mode == ESP_IMAGE_VERIFY) || (mode == ESP_IMAGE_VERIFY_SILENT);",
                "// Line 109: #else",
                "// Line 110:     bool do_load   = false; // Can't load the image in app mode",
                "// Line 111:     bool do_verify = true;  // In app mode is available only verify mode",
                "// vulnerable line: 112: #endif",
                "// Line 113:     bool silent    = (mode == ESP_IMAGE_VERIFY_SILENT);",
                "// Line 114:     esp_err_t err = ESP_OK;",
                "// Line 115:     // checksum the image a word at a time. This shaves 30-40ms per MB of image size",
                "// Line 116:     uint32_t checksum_word = ESP_ROM_CHECKSUM_INITIAL;",
                "// Line 117:     uint32_t *checksum = (do_verify) ? &checksum_word : NULL;",
                "// Line 118:     bootloader_sha256_handle_t sha_handle = NULL;",
                "// Line 119:     bool verify_sha;",
                "// Line 120: #if (SECURE_BOOT_CHECK_SIGNATURE == 1)",
                "// Line 121:      /* used for anti-FI checks */",
                "// Line 122:     uint8_t image_digest[HASH_LEN] = { [ 0 ... 31] = 0xEE };",
                "// Line 123:     uint8_t verified_digest[HASH_LEN] = { [ 0 ... 31 ] = 0x01 };",
                "// vulnerable line: 124: #endif",
                "// Line 125: ",
                "// Line 126:     if (data == NULL || part == NULL) {",
                "// Line 127:         return ESP_ERR_INVALID_ARG;",
                "// Line 128:     }",
                "// Line 129: ",
                "// Line 130: #if CONFIG_SECURE_BOOT_V2_ENABLED",
                "// Line 131:     // For Secure Boot V2, we do verify signature on bootloader which includes the SHA calculation.",
                "// Line 132:     verify_sha = do_verify;",
                "// Line 133: #else // Secure boot not enabled",
                "// Line 134:     // For secure boot V1 on ESP32, we don't calculate SHA or verify signature on bootloaders.",
                "// Line 135:     // (For non-secure boot, we don't verify any SHA-256 hash appended to the bootloader because",
                "// Line 136:     // esptool.py may have rewritten the header - rely on esptool.py having verified the bootloader at flashing time, instead.)",
                "// Line 137:     verify_sha = (part->offset != ESP_BOOTLOADER_OFFSET) && do_verify;",
                "// vulnerable line: 138: #endif",
                "// Line 139: ",
                "// Line 140:     if (part->size > SIXTEEN_MB) {",
                "// Line 141:         err = ESP_ERR_INVALID_ARG;",
                "// Line 142:         FAIL_LOAD(\"partition size 0x%\"PRIx32\" invalid, larger than 16MB\", part->size);",
                "// Line 143:     }",
                "// Line 144: ",
                "// Line 145:     bootloader_sha256_handle_t *p_sha_handle = &sha_handle;",
                "// Line 146:     CHECK_ERR(process_image_header(data, part->offset, (verify_sha) ? p_sha_handle : NULL, do_verify, silent));",
                "// Line 147:     CHECK_ERR(process_segments(data, silent, do_load, sha_handle, checksum));",
                "// Line 148:     bool skip_check_checksum = !do_verify || esp_cpu_dbgr_is_attached();",
                "// Line 192:        Any attack which bypasses this check should be of limited use as the RAM contents are still obfuscated, therefore we do the check",
                "// Line 193:        immediately before we deobfuscate.",
                "// Line 194: ",
                "// Line 195:        Note: the conditions for making this check are the same as for setting verify_sha above, but on ESP32 SB V1 we move the test for",
                "// Line 196:        \"only verify signature in bootloader\" into the macro so it's tested multiple times.",
                "// Line 197:      */",
                "// Line 198: #if CONFIG_SECURE_BOOT_V2_ENABLED",
                "// Line 199:     ESP_FAULT_ASSERT(!esp_secure_boot_enabled() || memcmp(image_digest, verified_digest, HASH_LEN) == 0);",
                "// Line 200: #else // Secure Boot V1 on ESP32, only verify signatures for apps not bootloaders",
                "// Line 201:     ESP_FAULT_ASSERT(data->start_addr == ESP_BOOTLOADER_OFFSET || memcmp(image_digest, verified_digest, HASH_LEN) == 0);",
                "// vulnerable line: 202: #endif",
                "// Line 203: ",
                "// Line 204: #endif // SECURE_BOOT_CHECK_SIGNATURE",
                "// Line 205: ",
                "// Line 206:     // Deobfuscate RAM",
                "// Line 207:     if (do_load && ram_obfs_value[0] != 0 && ram_obfs_value[1] != 0) {",
                "// Line 208:         for (int i = 0; i < data->image.segment_count; i++) {",
                "// Line 209:             uint32_t load_addr = data->segments[i].load_addr;",
                "// Line 210:             if (should_load(load_addr)) {",
                "// Line 211:                 uint32_t *loaded = (uint32_t *)load_addr;",
                "// Line 212:                 for (size_t j = 0; j < data->segments[i].data_len / sizeof(uint32_t); j++) {",
                "// Line 213:                     loaded[j] ^= (j & 1) ? ram_obfs_value[0] : ram_obfs_value[1];",
                "// Line 214:                 }",
                "// Line 215:             }",
                "// Line 216:         }",
                "// Line 217: #if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE",
                "// Line 218:         cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);",
                "// vulnerable line: 219: #endif",
                "// Line 220:     }",
                "// Line 221: ",
                "// Line 222: #if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK",
                "// Line 223:     /* For anti-rollback case, reconfirm security version of the application to prevent FI attacks */",
                "// Line 224:     bool sec_ver = false;",
                "// Line 225:     if (do_load) {",
                "// Line 226:         sec_ver = esp_efuse_check_secure_version(data->secure_version);",
                "// Line 227:         if (!sec_ver) {",
                "// Line 228:             err = ESP_FAIL;",
                "// Line 229:             goto err;",
                "// Line 259:     esp_image_load_mode_t mode = ESP_IMAGE_LOAD;",
                "// Line 260: ",
                "// Line 261: #if !defined(CONFIG_SECURE_BOOT)",
                "// Line 262:     /* Skip validation under particular configurations */",
                "// Line 263: #if CONFIG_BOOTLOADER_SKIP_VALIDATE_ALWAYS",
                "// Line 264:     mode = ESP_IMAGE_LOAD_NO_VALIDATE;",
                "// Line 265: #elif CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON",
                "// Line 266:     if (esp_rom_get_reset_reason(0) == RESET_REASON_CHIP_POWER_ON",
                "// Line 267: #if SOC_EFUSE_HAS_EFUSE_RST_BUG",
                "// Line 268:         || esp_rom_get_reset_reason(0) == RESET_REASON_CORE_EFUSE_CRC",
                "// vulnerable line: 269: #endif",
                "// Line 270:         ) {",
                "// Line 271:         mode = ESP_IMAGE_LOAD_NO_VALIDATE;",
                "// Line 272:     }",
                "// Line 273: #endif // CONFIG_BOOTLOADER_SKIP_...",
                "// Line 274: #endif // CONFIG_SECURE_BOOT",
                "// Line 275: ",
                "// Line 276:  return image_load(mode, part, data);",
                "// Line 277: #endif // BOOTLOADER_BUILD",
                "// Line 278: }",
                "// Line 279: ",
                "// Line 280: esp_err_t bootloader_load_image_no_verify(const esp_partition_pos_t *part, esp_image_metadata_t *data)",
                "// Line 281: {",
                "// Line 282: #ifdef BOOTLOADER_BUILD",
                "// Line 283:     return image_load(ESP_IMAGE_LOAD_NO_VALIDATE, part, data);",
                "// Line 284: #else",
                "// Line 285:     return ESP_FAIL;",
                "// vulnerable line: 286: #endif",
                "// Line 287: }",
                "// Line 288: ",
                "// Line 289: esp_err_t esp_image_verify(esp_image_load_mode_t mode, const esp_partition_pos_t *part, esp_image_metadata_t *data)",
                "// Line 290: {",
                "// Line 291:     return image_load(mode, part, data);",
                "// Line 292: }",
                "// Line 293: ",
                "// Line 294: esp_err_t esp_image_get_metadata(const esp_partition_pos_t *part, esp_image_metadata_t *metadata)",
                "// Line 295: {",
                "// Line 296:     esp_err_t err;",
                "// Line 444:             }",
                "// Line 445:         }",
                "// Line 446:     /* Sections entirely in RTC memory won't overlap with a vanilla bootloader but are valid load addresses, thus skipping them from the check */",
                "// Line 447:     }",
                "// Line 448: #if SOC_RTC_FAST_MEM_SUPPORTED",
                "// Line 449:     else if (esp_ptr_in_rtc_iram_fast(load_addr_p) && esp_ptr_in_rtc_iram_fast(load_inclusive_end_p)){",
                "// Line 450:         return true;",
                "// Line 451:     } else if (esp_ptr_in_rtc_dram_fast(load_addr_p) && esp_ptr_in_rtc_dram_fast(load_inclusive_end_p)){",
                "// Line 452:         return true;",
                "// Line 453:     }",
                "// vulnerable line: 454: #endif",
                "// Line 455: ",
                "// Line 456: #if SOC_RTC_SLOW_MEM_SUPPORTED",
                "// Line 457:     else if (esp_ptr_in_rtc_slow(load_addr_p) && esp_ptr_in_rtc_slow(load_inclusive_end_p)) {",
                "// Line 458:         return true;",
                "// Line 459:     }",
                "// vulnerable line: 460: #endif",
                "// Line 461: ",
                "// Line 462: #if SOC_MEM_TCM_SUPPORTED",
                "// Line 463:     else if (esp_ptr_in_tcm(load_addr_p) && esp_ptr_in_tcm(load_inclusive_end_p)) {",
                "// Line 464:         return true;",
                "// Line 465:     }",
                "// vulnerable line: 466: #endif",
                "// Line 467: ",
                "// Line 468:     else { /* Not a DRAM or an IRAM or RTC Fast IRAM, RTC Fast DRAM or RTC Slow address */",
                "// Line 469:         reason = \"bad load address range\";",
                "// Line 470:         goto invalid;",
                "// Line 471:     }",
                "// Line 472:     return true;",
                "// Line 473: ",
                "// Line 474:  invalid:",
                "// Line 475:     if (print_error) {",
                "// Line 476:         ESP_LOGE(TAG, \"Segment %d 0x%08x-0x%08x invalid: %s\", segment_index, load_addr, load_end, reason);",
                "// Line 583: #endif // BOOTLOADER_BUILD",
                "// Line 584: ",
                "// Line 585:     uint32_t free_page_count = bootloader_mmap_get_free_pages();",
                "// Line 586:     ESP_LOGD(TAG, \"free data page_count 0x%08\"PRIx32, free_page_count);",
                "// Line 587: ",
                "// Line 588:     uint32_t data_len_remain = data_len;",
                "// Line 589:     while (data_len_remain > 0) {",
                "// Line 590: #if (SECURE_BOOT_CHECK_SIGNATURE == 1) && defined(BOOTLOADER_BUILD)",
                "// Line 591:         /* Double check the address verification done above */",
                "// Line 592:         ESP_FAULT_ASSERT(!do_load || verify_load_addresses(0, load_addr, load_addr + data_len_remain, false, false));",
                "// vulnerable line: 593: #endif",
                "// Line 594:         uint32_t offset_page = ((data_addr & MMAP_ALIGNED_MASK) != 0) ? 1 : 0;",
                "// Line 595:         /* Data we could map in case we are not aligned to PAGE boundary is one page size lesser. */",
                "// Line 596:         data_len = MIN(data_len_remain, ((free_page_count - offset_page) * SPI_FLASH_MMU_PAGE_SIZE));",
                "// Line 597:         CHECK_ERR(process_segment_data(index, load_addr, data_addr, data_len, do_load, sha_handle, checksum, metadata));",
                "// Line 598:         data_addr += data_len;",
                "// Line 599:         data_len_remain -= data_len;",
                "// Line 600:     }",
                "// Line 601: ",
                "// Line 602:     return ESP_OK;",
                "// Line 603: ",
                "// Line 667:     }",
                "// Line 668: ",
                "// Line 669: #ifdef BOOTLOADER_BUILD",
                "// Line 670:     // Set up the obfuscation value to use for loading",
                "// Line 671:     while (ram_obfs_value[0] == 0 || ram_obfs_value[1] == 0) {",
                "// Line 672:         bootloader_fill_random(ram_obfs_value, sizeof(ram_obfs_value));",
                "// Line 673: #if CONFIG_IDF_ENV_FPGA",
                "// Line 674:         /* FPGA doesn't always emulate the RNG */",
                "// Line 675:         ram_obfs_value[0] ^= 0x33;",
                "// Line 676:         ram_obfs_value[1] ^= 0x66;",
                "// vulnerable line: 677: #endif",
                "// Line 678:     }",
                "// Line 679:     uint32_t *dest = (uint32_t *)load_addr;",
                "// vulnerable line: 680: #endif",
                "// Line 681: ",
                "// Line 682:     const uint32_t *src = data;",
                "// Line 683: ",
                "// Line 684: #if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK",
                "// vulnerable line: 685: if (segment == 0) {",
                "// Line 686:         // The esp_app_desc_t structure is located in DROM and is always in segment #0.",
                "// Line 687:         size_t len = process_esp_app_desc_data(src, sha_handle, checksum, metadata);",
                "// Line 688:         data_len -= len;",
                "// Line 689:         src += len / 4;",
                "// Line 690:         // In BOOTLOADER_BUILD, for DROM (segment #0) we do not load it into dest (only map it), do_load = false.",
                "// Line 691:     }",
                "// Line 692: #endif // CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK",
                "// Line 693: ",
                "// Line 694:     for (size_t i = 0; i < data_len; i += 4) {",
                "// Line 695:         int w_i = i / 4; // Word index",
                "// Line 696:         uint32_t w = src[w_i];",
                "// Line 697:         if (checksum != NULL) {",
                "// Line 698:             *checksum ^= w;",
                "// Line 699:         }",
                "// Line 700: #ifdef BOOTLOADER_BUILD",
                "// Line 701:         if (do_load) {",
                "// Line 702:             dest[w_i] = w ^ ((w_i & 1) ? ram_obfs_value[0] : ram_obfs_value[1]);",
                "// Line 703:         }",
                "// vulnerable line: 704: #endif",
                "// Line 705:         // SHA_CHUNK determined experimentally as the optimum size",
                "// Line 706:         // to call bootloader_sha256_data() with. This is a bit",
                "// Line 707:         // counter-intuitive, but it's ~3ms better than using the",
                "// Line 708:         // SHA256 block size.",
                "// Line 709:         const size_t SHA_CHUNK = 1024;",
                "// Line 710:         if (sha_handle != NULL && i % SHA_CHUNK == 0) {",
                "// Line 711:             bootloader_sha256_data(sha_handle, &src[w_i],",
                "// Line 712:                                    MIN(SHA_CHUNK, data_len - i));",
                "// Line 713:         }",
                "// Line 714:     }",
                "// Line 715: #if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE",
                "// Line 716:     if (do_load && esp_ptr_in_diram_iram((uint32_t *)load_addr)) {",
                "// Line 717:         cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);",
                "// Line 718:     }",
                "// vulnerable line: 719: #endif",
                "// Line 720: ",
                "// Line 721:     bootloader_munmap(data);",
                "// Line 722: ",
                "// Line 723:     return ESP_OK;",
                "// Line 724: }",
                "// Line 725: ",
                "// Line 726: static esp_err_t verify_segment_header(int index, const esp_image_segment_header_t *segment, uint32_t segment_data_offs, bool silent)",
                "// Line 727: {",
                "// Line 728:     if ((segment->data_len & 3) != 0",
                "// Line 729:             || segment->data_len >= SIXTEEN_MB) {",
                "// Line 780:     if (!load_rtc_memory) {",
                "// Line 781: #if SOC_RTC_FAST_MEM_SUPPORTED",
                "// Line 782:         if (load_addr >= SOC_RTC_IRAM_LOW && load_addr < SOC_RTC_IRAM_HIGH) {",
                "// Line 783:             ESP_LOGD(TAG, \"Skipping RTC fast memory segment at 0x%08\"PRIx32, load_addr);",
                "// Line 784:             return false;",
                "// Line 785:         }",
                "// Line 786:         if (load_addr >= SOC_RTC_DRAM_LOW && load_addr < SOC_RTC_DRAM_HIGH) {",
                "// Line 787:             ESP_LOGD(TAG, \"Skipping RTC fast memory segment at 0x%08\"PRIx32, load_addr);",
                "// Line 788:             return false;",
                "// Line 789:         }",
                "// vulnerable line: 790: #endif",
                "// Line 791: ",
                "// Line 792: #if SOC_RTC_SLOW_MEM_SUPPORTED",
                "// Line 793:         if (load_addr >= SOC_RTC_DATA_LOW && load_addr < SOC_RTC_DATA_HIGH) {",
                "// Line 794:             ESP_LOGD(TAG, \"Skipping RTC slow memory segment at 0x%08\"PRIx32, load_addr);",
                "// Line 795:             return false;",
                "// Line 796:         }",
                "// vulnerable line: 797: #endif",
                "// Line 798:     }",
                "// Line 799: ",
                "// Line 800:     return true;",
                "// Line 801: }",
                "// Line 802: ",
                "// Line 803: esp_err_t esp_image_verify_bootloader(uint32_t *length)",
                "// Line 804: {",
                "// Line 805:     esp_image_metadata_t data;",
                "// Line 806:     esp_err_t err = esp_image_verify_bootloader_data(&data);",
                "// Line 807:     if (length != NULL) {",
                "// Line 840: #if CONFIG_SECURE_BOOT || CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT",
                "// Line 841: ",
                "// Line 842:     // Case I: Bootloader part",
                "// Line 843:     if (part_offset == ESP_BOOTLOADER_OFFSET) {",
                "// Line 844:         // For bootloader with secure boot v1, signature stays in an independant flash",
                "// Line 845:         // sector (offset 0x0)  and does not get appended to the image.",
                "// Line 846: #if CONFIG_SECURE_BOOT_V2_ENABLED",
                "// Line 847:         // Sanity check - secure boot v2 signature block starts on 4K boundary",
                "// Line 848:         sig_block_len = ALIGN_UP(end, FLASH_SECTOR_SIZE) - end;",
                "// Line 849:         sig_block_len += sizeof(ets_secure_boot_signature_t);",
                "// vulnerable line: 850: #endif",
                "// Line 851:     } else {",
                "// Line 852:     // Case II: Application part",
                "// Line 853: #if CONFIG_SECURE_SIGNED_APPS_ECDSA_SCHEME",
                "// Line 854:         sig_block_len = sizeof(esp_secure_boot_sig_block_t);",
                "// Line 855: #else",
                "// Line 856:         // Sanity check - secure boot v2 signature block starts on 4K boundary",
                "// Line 857:         sig_block_len = ALIGN_UP(end, FLASH_SECTOR_SIZE) - end;",
                "// Line 858:         sig_block_len += sizeof(ets_secure_boot_signature_t);",
                "// vulnerable line: 859: #endif",
                "// Line 860:     }",
                "// Line 861: #endif // CONFIG_SECURE_BOOT || CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT",
                "// Line 862: ",
                "// Line 863:     const uint32_t full_image_len = end + sig_block_len;",
                "// Line 864:     if (full_image_len > part_len) {",
                "// Line 865:         FAIL_LOAD(\"Image length %\"PRIu32\" doesn't fit in partition length %\"PRIu32, full_image_len, part_len);",
                "// Line 866:     }",
                "// Line 867:     return err;",
                "// Line 868: err:",
                "// Line 869:     if (err == ESP_OK) {",
                "// Line 941:     esp_err_t err = ESP_ERR_IMAGE_INVALID;",
                "// Line 942: #if CONFIG_SECURE_BOOT || CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT",
                "// Line 943:     const void *sig_block;",
                "// Line 944:     ESP_FAULT_ASSERT(memcmp(image_digest, verified_digest, HASH_LEN) != 0); /* sanity check that these values start differently */",
                "// Line 945: #if defined(CONFIG_SECURE_SIGNED_APPS_ECDSA_SCHEME)",
                "// Line 946:     sig_block = bootloader_mmap(data->start_addr + data->image_len, sizeof(esp_secure_boot_sig_block_t));",
                "// Line 947:     err = esp_secure_boot_verify_ecdsa_signature_block(sig_block, image_digest, verified_digest);",
                "// Line 948: #else",
                "// Line 949:     sig_block = bootloader_mmap(end, sizeof(ets_secure_boot_signature_t));",
                "// Line 950:     err = esp_secure_boot_verify_sbv2_signature_block(sig_block, image_digest, verified_digest);",
                "// vulnerable line: 951: #endif",
                "// Line 952:     bootloader_munmap(sig_block);",
                "// Line 953: #endif // CONFIG_SECURE_BOOT || CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT",
                "// Line 954:     if (err != ESP_OK) {",
                "// Line 955:         ESP_LOGE(TAG, \"Secure boot signature verification failed\");",
                "// Line 956: ",
                "// Line 957:         // Go back and check if the simple hash matches or not (we're off the fast path so we can re-hash the whole image now)",
                "// Line 958:         ESP_LOGI(TAG, \"Calculating simple hash to check for corruption...\");",
                "// Line 959:         const void *whole_image = bootloader_mmap(data->start_addr, data->image_len - HASH_LEN);",
                "// Line 960:         if (whole_image != NULL) {",
                "// Line 961:             sha_handle = bootloader_sha256_start();",
                "// Line 970:         return ESP_ERR_IMAGE_INVALID;",
                "// Line 971:     }",
                "// Line 972: ",
                "// Line 973:     // Adjust image length result to include the appended signature",
                "// Line 974: #if CONFIG_SECURE_SIGNED_APPS_RSA_SCHEME || CONFIG_SECURE_SIGNED_APPS_ECDSA_V2_SCHEME",
                "// Line 975:     data->image_len = end - data->start_addr + sizeof(ets_secure_boot_signature_t);",
                "// Line 976: #elif defined(CONFIG_SECURE_SIGNED_APPS_ECDSA_SCHEME)",
                "// Line 977:     if (data->start_addr != ESP_BOOTLOADER_OFFSET) {",
                "// Line 978:         data->image_len = end - data->start_addr + sizeof(esp_secure_boot_sig_block_t);",
                "// Line 979:     }",
                "// vulnerable line: 980: #endif",
                "// Line 981: ",
                "// Line 982: #endif // SECURE_BOOT_CHECK_SIGNATURE",
                "// Line 983:     return ESP_OK;",
                "// Line 984: }",
                "// Line 985: ",
                "// Line 986: static esp_err_t verify_simple_hash(bootloader_sha256_handle_t sha_handle, esp_image_metadata_t *data)",
                "// Line 987: {",
                "// Line 988:     uint8_t image_hash[HASH_LEN] = { 0 };",
                "// Line 989:     bootloader_sha256_finish(sha_handle, image_hash);",
                "// Line 990: ",
                "// Line 991:     // Log the hash for debugging",
                "// Line 992:     bootloader_debug_buffer(image_hash, HASH_LEN, \"Calculated hash\");",
                "// Line 993: ",
                "// Line 994:     // Simple hash for verification only",
                "// Line 995:     if (memcmp(data->image_digest, image_hash, HASH_LEN) != 0) {",
                "// Line 996:         ESP_LOGE(TAG, \"Image hash failed - image is corrupt\");",
                "// Line 997:         bootloader_debug_buffer(data->image_digest, HASH_LEN, \"Expected hash\");",
                "// Line 998: #if CONFIG_IDF_ENV_FPGA || CONFIG_IDF_ENV_BRINGUP",
                "// Line 999:         ESP_LOGW(TAG, \"Ignoring invalid SHA-256 as running on FPGA / doing bringup\");",
                "// Line 1000:         return ESP_OK;",
                "// vulnerable line: 1001: #endif",
                "// Line 1002:         return ESP_ERR_IMAGE_INVALID;",
                "// Line 1003:     }",
                "// Line 1004: ",
                "// Line 1005:     return ESP_OK;",
                "// Line 1006: }",
                "// Line 1007: ",
                "// Line 1008: int esp_image_get_flash_size(esp_image_flash_size_t app_flash_size)",
                "// Line 1009: {",
                "// Line 1010:     switch (app_flash_size) {",
                "// Line 1011:     case ESP_IMAGE_FLASH_SIZE_1MB:"
            ]
        }
    ]
}