{
    "cve_id": "CVE-2024-39897",
    "cve_description": "zot is an OCI image registry. Prior to 2.1.0, the cache driver `GetBlob()` allows read access to any blob without access control check. If a Zot `accessControl` policy allows users read access to some repositories but restricts read access to other repositories and `dedupe` is enabled (it is enabled by default), then an attacker who knows the name of an image and the digest of a blob (that they do not have read access to), they may maliciously read it via a second repository they do have read access to. \n This attack is possible because [`ImageStore.CheckBlob()` calls `checkCacheBlob()`](https://github.com/project-zot/zot/blob/v2.1.0-rc2/pkg/storage/imagestore/imagestore.go#L1158-L1159) to find the blob a global cache by searching for the digest. If it is found, it is copied to the user requested repository with `copyBlob()`. The attack may be mitigated by configuring \"dedupe\": false in the \"storage\" settings. The vulnerability is fixed in 2.1.0.",
    "cve_publish_date": "2024-07-09T19:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-55r9-5mx9-qq7r\n\nwhen a client pushes an image zot's inline dedupe\nwill try to find the blob path corresponding with the blob digest\nthat it's currently pushed and if it's found in the cache\nthen zot will make a symbolic link to that cache entry and report\nto the client that the blob already exists on the location.\n\nBefore this patch authorization was not applied on this process meaning\nthat a user could copy blobs without having permissions on the source repo.\n\nAdded a rule which says that the client should have read permissions on the source repo\nbefore deduping, otherwise just Stat() the blob and return the corresponding status code.\n\nSigned-off-by: Petu Eusebiu <peusebiu@cisco.com>\nCo-authored-by: Petu Eusebiu <peusebiu@cisco.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "cache_mock.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "10",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "cacheinterface.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "image_store_mock.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "16",
            "number_of_lines_deleted_vulnerable_to_cve": "7",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 43:     DeleteBlobFn         func(repo string, digest godigest.Digest) error",
                "// Line 44:     GetIndexContentFn    func(repo string) ([]byte, error)",
                "// Line 45:     GetBlobContentFn     func(repo string, digest godigest.Digest) ([]byte, error)",
                "// Line 46:     GetReferrersFn       func(repo string, digest godigest.Digest, artifactTypes []string) (ispec.Index, error)",
                "// Line 47:     URLForPathFn         func(path string) (string, error)",
                "// Line 48:     RunGCRepoFn          func(repo string) error",
                "// Line 49:     RunGCPeriodicallyFn  func(interval time.Duration, sch *scheduler.Scheduler)",
                "// Line 50:     RunDedupeBlobsFn     func(interval time.Duration, sch *scheduler.Scheduler)",
                "// Line 51:     RunDedupeForDigestFn func(ctx context.Context, digest godigest.Digest, dedupe bool,",
                "// Line 52:         duplicateBlobs []string) error",
                "// vulnerable line: 53: GetNextDigestWithBlobPathsFn func(repos []string, lastDigests []godigest.Digest) (godigest.Digest, []string, error)",
                "// vulnerable line: 54: GetAllBlobsFn                func(repo string) ([]string, error)",
                "// vulnerable line: 55: CleanupRepoFn                func(repo string, blobs []godigest.Digest, removeRepo bool) (int, error)",
                "// vulnerable line: 56: PutIndexContentFn            func(repo string, index ispec.Index) error",
                "// vulnerable line: 57: PopulateStorageMetricsFn     func(interval time.Duration, sch *scheduler.Scheduler)",
                "// vulnerable line: 58: StatIndexFn                  func(repo string) (bool, int64, time.Time, error)",
                "// vulnerable line: 59: VerifyBlobDigestValueFn      func(repo string, digest godigest.Digest) error",
                "// Line 60: }",
                "// Line 61: ",
                "// Line 62: func (is MockedImageStore) StatIndex(repo string) (bool, int64, time.Time, error) {",
                "// Line 63:     if is.StatIndexFn != nil {",
                "// Line 64:         return is.StatIndexFn(repo)",
                "// Line 65:     }",
                "// Line 66: ",
                "// Line 67:     return true, 0, time.Time{}, nil",
                "// Line 68: }",
                "// Line 69: "
            ]
        },
        {
            "filename_of_changes": "types.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}