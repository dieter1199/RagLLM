{
    "cve_id": "CVE-2024-24476",
    "cve_description": "A buffer overflow in Wireshark before 4.2.0 allows a remote attacker to cause a denial of service via the pan/addr_resolv.c, and ws_manuf_lookup_str(), size components. NOTE: this is disputed by the vendor because neither release 4.2.0 nor any other release was affected.",
    "cve_publish_date": "2024-02-21T19:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "addr_resolv: Fix a heap buffer overflow\n\nMake sure we always pass at least 6 bytes to ws_manuf_lookup_str().\n\nFixes #19344.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "addr_resolv.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "17",
            "number_of_lines_deleted_vulnerable_to_cve": "8",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1664:         break;",
                "// Line 1665: ",
                "// Line 1666:     default:",
                "// Line 1667:         /* This is a range of well-known addresses; add it to the well-known-address table */",
                "// Line 1668:         wka_hash_new_entry(addr, name);",
                "// Line 1669:         break;",
                "// Line 1670:     }",
                "// Line 1671: } /* add_manuf_name */",
                "// Line 1672: ",
                "// Line 1673: static hashmanuf_t *",
                "// vulnerable line: 1674: manuf_name_lookup(const guint8 *addr)",
                "// Line 1675: {",
                "// Line 1676:     guint32       manuf_key;",
                "// Line 1677:     guint8       oct;",
                "// Line 1678:     hashmanuf_t  *manuf_value;",
                "// Line 1679: ",
                "// Line 1680:     /* manuf needs only the 3 most significant octets of the ethernet address */",
                "// Line 1681:     manuf_key = addr[0];",
                "// Line 1682:     manuf_key = manuf_key<<8;",
                "// Line 1683:     oct = addr[1];",
                "// Line 1684:     manuf_key = manuf_key | oct;",
                "// Line 1911:             /* Only the topmost 3 bytes participate fully */",
                "// Line 1912:             if ((name = wka_name_lookup(addr, mask+24)) != NULL) {",
                "// Line 1913:                 snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",",
                "// Line 1914:                         name, addr[3] & (0xFF >> mask), addr[4], addr[5]);",
                "// Line 1915:                 tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;",
                "// Line 1916:                 return tp;",
                "// Line 1917:             }",
                "// Line 1918:         } while (mask--);",
                "// Line 1919: ",
                "// Line 1920:         /* Now try looking in the manufacturer table. */",
                "// vulnerable line: 1921: manuf_value = manuf_name_lookup(addr);",
                "// Line 1922:         if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {",
                "// Line 1923:             snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",",
                "// Line 1924:                     manuf_value->resolved_name, addr[3], addr[4], addr[5]);",
                "// Line 1925:             tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;",
                "// Line 1926:             return tp;",
                "// Line 1927:         }",
                "// Line 1928: ",
                "// Line 1929:         /* Now try looking for it in the well-known-address",
                "// Line 1930:            tables for well-known address ranges larger than 2^24. */",
                "// Line 1931:         mask = 7;",
                "// Line 3484: ",
                "// Line 3485:     if (!gbl_resolv_flags.vlan_name) {",
                "// Line 3486:         return NULL;",
                "// Line 3487:     }",
                "// Line 3488: ",
                "// Line 3489:     return wmem_strdup(allocator, vlan_name_lookup(id));",
                "// Line 3490: ",
                "// Line 3491: } /* get_vlan_name */",
                "// Line 3492: ",
                "// Line 3493: const gchar *",
                "// vulnerable line: 3494: get_manuf_name(const guint8 *addr)",
                "// Line 3495: {",
                "// Line 3496:     hashmanuf_t *manuf_value;",
                "// Line 3497: ",
                "// vulnerable line: 3498: manuf_value = manuf_name_lookup(addr);",
                "// Line 3499:     if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)",
                "// Line 3500:         return manuf_value->resolved_name;",
                "// Line 3501: ",
                "// Line 3502:     return manuf_value->hexaddr;",
                "// Line 3503: ",
                "// Line 3504: } /* get_manuf_name */",
                "// Line 3505: ",
                "// Line 3506: const gchar *",
                "// Line 3507: tvb_get_manuf_name(tvbuff_t *tvb, gint offset)",
                "// Line 3508: {",
                "// vulnerable line: 3509: return get_manuf_name(tvb_get_ptr(tvb, offset, 3));",
                "// Line 3510: }",
                "// Line 3511: ",
                "// Line 3512: const gchar *",
                "// vulnerable line: 3513: get_manuf_name_if_known(const guint8 *addr)",
                "// Line 3514: {",
                "// Line 3515:     hashmanuf_t *manuf_value;",
                "// Line 3516:     guint manuf_key;",
                "// Line 3517:     guint8 oct;",
                "// Line 3518: ",
                "// Line 3519:     /* manuf needs only the 3 most significant octets of the ethernet address */",
                "// Line 3520:     manuf_key = addr[0];",
                "// Line 3521:     manuf_key = manuf_key<<8;",
                "// Line 3522:     oct = addr[1];",
                "// Line 3523:     manuf_key = manuf_key | oct;",
                "// Line 3564:         /* Found it */",
                "// Line 3565:         return long_name;",
                "// Line 3566:     }",
                "// Line 3567: ",
                "// Line 3568:     return NULL;",
                "// Line 3569: }",
                "// Line 3570: ",
                "// Line 3571: const gchar *",
                "// Line 3572: tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)",
                "// Line 3573: {",
                "// vulnerable line: 3574: return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));",
                "// Line 3575: }",
                "// Line 3576: ",
                "// Line 3577: char* get_hash_manuf_resolved_name(hashmanuf_t* manuf)",
                "// Line 3578: {",
                "// Line 3579:     return manuf->resolved_longname;",
                "// Line 3580: }",
                "// Line 3581: ",
                "// Line 3582: gchar *",
                "// Line 3583: eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)",
                "// Line 3584: {",
                "// Line 3585:     guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);",
                "// Line 3586:     hashmanuf_t *manuf_value;",
                "// Line 3587:     gchar *ret;",
                "// Line 3588: ",
                "// Line 3589:     /* Copy and convert the address to network byte order. */",
                "// Line 3590:     *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));",
                "// Line 3591: ",
                "// vulnerable line: 3592: manuf_value = manuf_name_lookup(addr);",
                "// Line 3593:     if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {",
                "// Line 3594:         ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);",
                "// Line 3595:     } else {",
                "// Line 3596:         ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);",
                "// Line 3597:     }",
                "// Line 3598: ",
                "// Line 3599:     wmem_free(NULL, addr);",
                "// Line 3600:     return ret;",
                "// Line 3601: } /* eui64_to_display */",
                "// Line 3602: "
            ]
        },
        {
            "filename_of_changes": "addr_resolv.h",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 216: /* Same as get_ether_name with tvb support */",
                "// Line 217: WS_DLL_PUBLIC const gchar *tvb_get_ether_name(tvbuff_t *tvb, gint offset);",
                "// Line 218: ",
                "// Line 219: /* get_ether_name_if_known returns the logical name if found in ethers files else NULL */",
                "// Line 220: const gchar *get_ether_name_if_known(const guint8 *addr);",
                "// Line 221: ",
                "// Line 222: /*",
                "// Line 223:  * Given a sequence of 3 octets containing an OID, get_manuf_name()",
                "// Line 224:  * returns the vendor name, or \"%02x:%02x:%02x\" if not known.",
                "// Line 225:  */",
                "// vulnerable line: 226: extern const gchar *get_manuf_name(const guint8 *addr);",
                "// Line 227: ",
                "// Line 228: /*",
                "// Line 229:  * Given a sequence of 3 octets containing an OID, get_manuf_name_if_known()",
                "// Line 230:  * returns the vendor name, or NULL if not known.",
                "// Line 231:  */",
                "// vulnerable line: 232: WS_DLL_PUBLIC const gchar *get_manuf_name_if_known(const guint8 *addr);",
                "// Line 233: ",
                "// Line 234: /*",
                "// Line 235:  * Given an integer containing a 24-bit OID, uint_get_manuf_name_if_known()",
                "// Line 236:  * returns the vendor name, or NULL if not known.",
                "// Line 237:  */",
                "// Line 238: extern const gchar *uint_get_manuf_name_if_known(const guint32 oid);",
                "// Line 239: ",
                "// Line 240: /*",
                "// Line 241:  * Given a tvbuff and an offset in that tvbuff for a 3-octet OID,",
                "// Line 242:  * tvb_get_manuf_name() returns the vendor name, or \"%02x:%02x:%02x\""
            ]
        },
        {
            "filename_of_changes": "address_types.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 370:     int fmt;",
                "// Line 371:     guint8 oui[6];",
                "// Line 372: ",
                "// Line 373:     fmt = (addrp[0] & 0xF0) >> 4;",
                "// Line 374:     switch (fmt) {",
                "// Line 375: ",
                "// Line 376:     case FC_NH_NAA_IEEE:",
                "// Line 377:     case FC_NH_NAA_IEEE_E:",
                "// Line 378: ",
                "// Line 379:         memcpy (oui, &addrp[2], 6);",
                "// vulnerable line: 380: return get_manuf_name(oui);",
                "// Line 381: ",
                "// Line 382:     case FC_NH_NAA_IEEE_R:",
                "// Line 383:         oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);",
                "// Line 384:         oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);",
                "// Line 385:         oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);",
                "// Line 386:         oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);",
                "// Line 387:         oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);",
                "// Line 388:         oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);",
                "// Line 389: ",
                "// vulnerable line: 390: return get_manuf_name(oui);",
                "// Line 391:     }",
                "// Line 392: ",
                "// Line 393:     return \"\";",
                "// Line 394: }",
                "// Line 395: ",
                "// Line 396: static int fcwwn_name_res_len(void)",
                "// Line 397: {",
                "// Line 398:     return MAX_ADDR_STR_LEN; /* XXX - This can be lower */",
                "// Line 399: }",
                "// Line 400: "
            ]
        }
    ]
}