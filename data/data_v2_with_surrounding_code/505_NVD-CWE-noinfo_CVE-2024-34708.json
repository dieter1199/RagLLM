{
    "cve_id": "CVE-2024-34708",
    "cve_description": "Directus is a real-time API and App dashboard for managing SQL database content. A user with permission to view any collection using redacted hashed fields can get access the raw stored version using the `alias` functionality on the API. Normally, these redacted fields will return `**********` however  if we change the request to `?alias[workaround]=redacted` we can instead retrieve the plain text value for the field. This can be avoided by removing permission to view the sensitive fields entirely from users or roles that should not be able to see them. This vulnerability is fixed in 10.11.0.",
    "cve_publish_date": "2024-05-14T15:39Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Improved values redacting (#22332)\n\nCo-authored-by: Pascal Jufer <pascal-jufer@bluewin.ch>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "payload.ts",
            "code_language": "TypeScript",
            "number_of_lines_added_for_mitigation": "29",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: import { ForbiddenError, InvalidPayloadError } from '@directus/errors';",
                "// vulnerable line: 2: import type { Accountability, Alterations, Item, PrimaryKey, Query, SchemaOverview } from '@directus/types';",
                "// Line 3: import { parseJSON, toArray } from '@directus/utils';",
                "// Line 4: import { format, isValid, parseISO } from 'date-fns';",
                "// Line 5: import { unflatten } from 'flat';",
                "// Line 6: import Joi from 'joi';",
                "// Line 7: import type { Knex } from 'knex';",
                "// Line 8: import { clone, cloneDeep, isNil, isObject, isPlainObject, omit, pick } from 'lodash-es';",
                "// Line 9: import { randomUUID } from 'node:crypto';",
                "// Line 10: import { parse as wktToGeoJSON } from 'wellknown';",
                "// Line 11: import type { Helpers } from '../database/helpers/index.js';",
                "// Line 12: import { getHelpers } from '../database/helpers/index.js';",
                "// Line 144:     async processValues(",
                "// Line 145:         action: Action,",
                "// Line 146:         payload: Partial<Item> | Partial<Item>[],",
                "// Line 147:     ): Promise<Partial<Item> | Partial<Item>[]> {",
                "// Line 148:         const processedPayload = toArray(payload);",
                "// Line 149: ",
                "// Line 150:         if (processedPayload.length === 0) return [];",
                "// Line 151: ",
                "// Line 152:         const fieldsInPayload = Object.keys(processedPayload[0]!);",
                "// Line 153: ",
                "// vulnerable line: 154: let specialFieldsInCollection = Object.entries(this.schema.collections[this.collection]!.fields).filter(",
                "// vulnerable line: 155: ([_name, field]) => field.special && field.special.length > 0,",
                "// vulnerable line: 156: );",
                "// Line 157: ",
                "// Line 158:         if (action === 'read') {",
                "// vulnerable line: 159: specialFieldsInCollection = specialFieldsInCollection.filter(([name]) => {",
                "// Line 160:                 return fieldsInPayload.includes(name);",
                "// Line 161:             });",
                "// Line 162:         }",
                "// Line 163: ",
                "// Line 164:         await Promise.all(",
                "// Line 165:             processedPayload.map(async (record: any) => {",
                "// Line 166:                 await Promise.all(",
                "// vulnerable line: 167: specialFieldsInCollection.map(async ([name, field]) => {",
                "// Line 168:                         const newValue = await this.processField(field, record, action, this.accountability);",
                "// Line 169:                         if (newValue !== undefined) record[name] = newValue;",
                "// Line 170:                     }),",
                "// vulnerable line: 171: );",
                "// Line 172:             }),",
                "// vulnerable line: 173: );",
                "// Line 174: ",
                "// Line 175:         this.processGeometries(processedPayload, action);",
                "// Line 176:         this.processDates(processedPayload, action);",
                "// Line 177: ",
                "// Line 178:         if (['create', 'update'].includes(action)) {",
                "// Line 179:             processedPayload.forEach((record) => {",
                "// Line 180:                 for (const [key, value] of Object.entries(record)) {",
                "// Line 181:                     if (Array.isArray(value) || (typeof value === 'object' && !(value instanceof Date) && value !== null)) {",
                "// Line 182:                         if (!value.isRawInstance) {",
                "// Line 183:                             record[key] = JSON.stringify(value);",
                "// Line 264: ",
                "// Line 265:     /**",
                "// Line 266:      * Knex returns `datetime` and `date` columns as Date.. This is wrong for date / datetime, as those",
                "// Line 267:      * shouldn't return with time / timezone info respectively",
                "// Line 268:      */",
                "// Line 269:     processDates(payloads: Partial<Record<string, any>>[], action: Action): Partial<Record<string, any>>[] {",
                "// Line 270:         const fieldsInCollection = Object.entries(this.schema.collections[this.collection]!.fields);",
                "// Line 271: ",
                "// Line 272:         const dateColumns = fieldsInCollection.filter(([_name, field]) =>",
                "// Line 273:             ['dateTime', 'date', 'timestamp'].includes(field.type),",
                "// vulnerable line: 274: );",
                "// Line 275: ",
                "// Line 276:         const timeColumns = fieldsInCollection.filter(([_name, field]) => {",
                "// Line 277:             return field.type === 'time';",
                "// Line 278:         });",
                "// Line 279: ",
                "// Line 280:         if (dateColumns.length === 0 && timeColumns.length === 0) return payloads;",
                "// Line 281: ",
                "// Line 282:         for (const [name, dateColumn] of dateColumns) {",
                "// Line 283:             for (const payload of payloads) {",
                "// Line 284:                 let value: number | string | Date = payload[name];",
                "// Line 640:                 }",
                "// Line 641: ",
                "// Line 642:                 savedPrimaryKeys.push(",
                "// Line 643:                     ...(await itemsService.upsertMany(recordsToUpsert, {",
                "// Line 644:                         onRevisionCreate: (pk) => revisions.push(pk),",
                "// Line 645:                         bypassEmitAction: (params) =>",
                "// Line 646:                             opts?.bypassEmitAction ? opts.bypassEmitAction(params) : nestedActionEvents.push(params),",
                "// Line 647:                         emitEvents: opts?.emitEvents,",
                "// Line 648:                         mutationTracker: opts?.mutationTracker,",
                "// Line 649:                     })),",
                "// vulnerable line: 650: );",
                "// Line 651: ",
                "// Line 652:                 const query: Query = {",
                "// Line 653:                     filter: {",
                "// Line 654:                         _and: [",
                "// Line 655:                             {",
                "// Line 656:                                 [relation.field]: {",
                "// Line 657:                                     _eq: parent,",
                "// Line 658:                                 },",
                "// Line 659:                             },",
                "// Line 660:                             {",
                "// Line 679:                     await itemsService.updateByQuery(",
                "// Line 680:                         query,",
                "// Line 681:                         { [relation.field]: null },",
                "// Line 682:                         {",
                "// Line 683:                             onRevisionCreate: (pk) => revisions.push(pk),",
                "// Line 684:                             bypassEmitAction: (params) =>",
                "// Line 685:                                 opts?.bypassEmitAction ? opts.bypassEmitAction(params) : nestedActionEvents.push(params),",
                "// Line 686:                             emitEvents: opts?.emitEvents,",
                "// Line 687:                             mutationTracker: opts?.mutationTracker,",
                "// Line 688:                         },",
                "// vulnerable line: 689: );",
                "// Line 690:                 }",
                "// Line 691:             }",
                "// Line 692:             // \"Updates\" object w/ create/update/delete",
                "// Line 693:             else {",
                "// Line 694:                 const alterations = field as Alterations;",
                "// Line 695:                 const { error } = nestedUpdateSchema.validate(alterations);",
                "// Line 696:                 if (error) throw new InvalidPayloadError({ reason: `Invalid one-to-many update structure: ${error.message}` });",
                "// Line 697: ",
                "// Line 698:                 if (alterations.create) {",
                "// Line 699:                     const sortField = relation.meta.sort_field;",
                "// Line 747:                                 ...item,",
                "// Line 748:                                 [relation.field]: parent || payload[currentPrimaryKeyField],",
                "// Line 749:                             },",
                "// Line 750:                             {",
                "// Line 751:                                 onRevisionCreate: (pk) => revisions.push(pk),",
                "// Line 752:                                 bypassEmitAction: (params) =>",
                "// Line 753:                                     opts?.bypassEmitAction ? opts.bypassEmitAction(params) : nestedActionEvents.push(params),",
                "// Line 754:                                 emitEvents: opts?.emitEvents,",
                "// Line 755:                                 mutationTracker: opts?.mutationTracker,",
                "// Line 756:                             },",
                "// vulnerable line: 757: );",
                "// Line 758:                     }",
                "// Line 759:                 }",
                "// Line 760: ",
                "// Line 761:                 if (alterations.delete) {",
                "// Line 762:                     const query: Query = {",
                "// Line 763:                         filter: {",
                "// Line 764:                             _and: [",
                "// Line 765:                                 {",
                "// Line 766:                                     [relation.field]: {",
                "// Line 767:                                         _eq: parent,",
                "// Line 787:                         await itemsService.updateByQuery(",
                "// Line 788:                             query,",
                "// Line 789:                             { [relation.field]: null },",
                "// Line 790:                             {",
                "// Line 791:                                 onRevisionCreate: (pk) => revisions.push(pk),",
                "// Line 792:                                 bypassEmitAction: (params) =>",
                "// Line 793:                                     opts?.bypassEmitAction ? opts.bypassEmitAction(params) : nestedActionEvents.push(params),",
                "// Line 794:                                 emitEvents: opts?.emitEvents,",
                "// Line 795:                                 mutationTracker: opts?.mutationTracker,",
                "// Line 796:                             },",
                "// vulnerable line: 797: );",
                "// Line 798:                     }",
                "// Line 799:                 }",
                "// Line 800:             }",
                "// Line 801:         }",
                "// Line 802: ",
                "// Line 803:         return { revisions, nestedActionEvents };",
                "// Line 804:     }",
                "// Line 805: ",
                "// Line 806:     /**",
                "// Line 807:      * Transforms the input partial payload to match the output structure, to have consistency"
            ]
        },
        {
            "filename_of_changes": "run-ast.ts",
            "code_language": "TypeScript",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 77: ",
                "// Line 78:         // The actual knex query builder instance. This is a promise that resolves with the raw items from the db",
                "// Line 79:         const dbQuery = await getDBQuery(schema, knex, collection, fieldNodes, query);",
                "// Line 80: ",
                "// Line 81:         const rawItems: Item | Item[] = await dbQuery;",
                "// Line 82: ",
                "// Line 83:         if (!rawItems) return null;",
                "// Line 84: ",
                "// Line 85:         // Run the items through the special transforms",
                "// Line 86:         const payloadService = new PayloadService(collection, { knex, schema });",
                "// vulnerable line: 87: let items: null | Item | Item[] = await payloadService.processValues('read', rawItems);",
                "// Line 88: ",
                "// Line 89:         if (!items || (Array.isArray(items) && items.length === 0)) return items;",
                "// Line 90: ",
                "// Line 91:         // Apply the `_in` filters to the nested collection batches",
                "// Line 92:         const nestedNodes = applyParentFilters(schema, nestedCollectionNodes, items);",
                "// Line 93: ",
                "// Line 94:         for (const nestedNode of nestedNodes) {",
                "// Line 95:             let nestedItems: Item[] | null = [];",
                "// Line 96: ",
                "// Line 97:             if (nestedNode.type === 'o2m') {"
            ]
        }
    ]
}