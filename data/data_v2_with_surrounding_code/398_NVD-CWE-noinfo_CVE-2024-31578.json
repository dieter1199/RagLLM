{
    "cve_id": "CVE-2024-31578",
    "cve_description": "FFmpeg version n6.1.1 was discovered to contain a heap use-after-free via the av_hwframe_ctx_init function.",
    "cve_publish_date": "2024-04-17T14:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "avutil/hwcontext: Don't assume frames_uninit is reentrant\n\nFix heap use after free when vulkan_frames_init failed.\n\nSigned-off-by: Zhao Zhili <zhilizhao@tencent.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "hwcontext.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 159:     }",
                "// Line 160:     if (!hw_type)",
                "// Line 161:         return NULL;",
                "// Line 162: ",
                "// Line 163:     ctx = av_mallocz(sizeof(*ctx));",
                "// Line 164:     if (!ctx)",
                "// Line 165:         return NULL;",
                "// Line 166: ",
                "// Line 167:     ctx->internal = av_mallocz(sizeof(*ctx->internal));",
                "// Line 168:     if (!ctx->internal)",
                "// vulnerable line: 169: goto fail;",
                "// Line 170: ",
                "// Line 171:     if (hw_type->device_priv_size) {",
                "// Line 172:         ctx->internal->priv = av_mallocz(hw_type->device_priv_size);",
                "// Line 173:         if (!ctx->internal->priv)",
                "// vulnerable line: 174: goto fail;",
                "// Line 175:     }",
                "// Line 176: ",
                "// Line 177:     if (hw_type->device_hwctx_size) {",
                "// Line 178:         ctx->hwctx = av_mallocz(hw_type->device_hwctx_size);",
                "// Line 179:         if (!ctx->hwctx)",
                "// vulnerable line: 180: goto fail;",
                "// Line 181:     }",
                "// Line 182: ",
                "// Line 183:     buf = av_buffer_create((uint8_t*)ctx, sizeof(*ctx),",
                "// Line 184:                            hwdevice_ctx_free, NULL,",
                "// Line 185:                            AV_BUFFER_FLAG_READONLY);",
                "// Line 186:     if (!buf)",
                "// vulnerable line: 187: goto fail;",
                "// Line 188: ",
                "// Line 189:     ctx->type     = type;",
                "// Line 190:     ctx->av_class = &hwdevice_ctx_class;",
                "// Line 191: ",
                "// Line 192:     ctx->internal->hw_type = hw_type;",
                "// Line 193: ",
                "// Line 194:     return buf;",
                "// Line 195: ",
                "// vulnerable line: 196: fail:",
                "// Line 197:     if (ctx->internal)",
                "// Line 198:         av_freep(&ctx->internal->priv);",
                "// Line 199:     av_freep(&ctx->internal);",
                "// Line 200:     av_freep(&ctx->hwctx);",
                "// Line 201:     av_freep(&ctx);",
                "// Line 202:     return NULL;",
                "// Line 203: }",
                "// Line 204: ",
                "// Line 205: int av_hwdevice_ctx_init(AVBufferRef *ref)",
                "// Line 206: {",
                "// Line 207:     AVHWDeviceContext *ctx = (AVHWDeviceContext*)ref->data;",
                "// Line 208:     int ret = 0;",
                "// Line 209: ",
                "// Line 210:     if (ctx->internal->hw_type->device_init)",
                "// Line 211:         ret = ctx->internal->hw_type->device_init(ctx);",
                "// Line 212: ",
                "// vulnerable line: 213: return ret;",
                "// Line 214: }",
                "// Line 215: ",
                "// Line 216: static const AVClass hwframe_ctx_class = {",
                "// Line 217:     .class_name = \"AVHWFramesContext\",",
                "// Line 218:     .item_name  = av_default_item_name,",
                "// Line 219:     .version    = LIBAVUTIL_VERSION_INT,",
                "// Line 220: };",
                "// Line 221: ",
                "// Line 222: static void hwframe_ctx_free(void *opaque, uint8_t *data)",
                "// Line 223: {",
                "// Line 224:     AVHWFramesContext *ctx = (AVHWFramesContext*)data;",
                "// Line 225: ",
                "// Line 226:     if (ctx->internal->pool_internal)",
                "// Line 227:         av_buffer_pool_uninit(&ctx->internal->pool_internal);",
                "// Line 228: ",
                "// vulnerable line: 229: if (ctx->internal->hw_type->frames_uninit)",
                "// vulnerable line: 230: ctx->internal->hw_type->frames_uninit(ctx);",
                "// Line 231: ",
                "// Line 232:     if (ctx->free)",
                "// Line 233:         ctx->free(ctx);",
                "// Line 234: ",
                "// Line 235:     av_buffer_unref(&ctx->internal->source_frames);",
                "// Line 236: ",
                "// Line 237:     av_buffer_unref(&ctx->device_ref);",
                "// Line 238: ",
                "// Line 239:     av_freep(&ctx->hwctx);",
                "// Line 240:     av_freep(&ctx->internal->priv);",
                "// Line 248:     const HWContextType  *hw_type = device_ctx->internal->hw_type;",
                "// Line 249:     AVHWFramesContext *ctx;",
                "// Line 250:     AVBufferRef *buf, *device_ref = NULL;",
                "// Line 251: ",
                "// Line 252:     ctx = av_mallocz(sizeof(*ctx));",
                "// Line 253:     if (!ctx)",
                "// Line 254:         return NULL;",
                "// Line 255: ",
                "// Line 256:     ctx->internal = av_mallocz(sizeof(*ctx->internal));",
                "// Line 257:     if (!ctx->internal)",
                "// vulnerable line: 258: goto fail;",
                "// Line 259: ",
                "// Line 260:     if (hw_type->frames_priv_size) {",
                "// Line 261:         ctx->internal->priv = av_mallocz(hw_type->frames_priv_size);",
                "// Line 262:         if (!ctx->internal->priv)",
                "// vulnerable line: 263: goto fail;",
                "// Line 264:     }",
                "// Line 265: ",
                "// Line 266:     if (hw_type->frames_hwctx_size) {",
                "// Line 267:         ctx->hwctx = av_mallocz(hw_type->frames_hwctx_size);",
                "// Line 268:         if (!ctx->hwctx)",
                "// vulnerable line: 269: goto fail;",
                "// Line 270:     }",
                "// Line 271: ",
                "// Line 272:     device_ref = av_buffer_ref(device_ref_in);",
                "// Line 273:     if (!device_ref)",
                "// vulnerable line: 274: goto fail;",
                "// Line 275: ",
                "// Line 276:     buf = av_buffer_create((uint8_t*)ctx, sizeof(*ctx),",
                "// Line 277:                            hwframe_ctx_free, NULL,",
                "// Line 278:                            AV_BUFFER_FLAG_READONLY);",
                "// Line 279:     if (!buf)",
                "// vulnerable line: 280: goto fail;",
                "// Line 281: ",
                "// Line 282:     ctx->av_class   = &hwframe_ctx_class;",
                "// Line 283:     ctx->device_ref = device_ref;",
                "// Line 284:     ctx->device_ctx = device_ctx;",
                "// Line 285:     ctx->format     = AV_PIX_FMT_NONE;",
                "// Line 286:     ctx->sw_format  = AV_PIX_FMT_NONE;",
                "// Line 287: ",
                "// Line 288:     ctx->internal->hw_type = hw_type;",
                "// Line 289: ",
                "// Line 290:     return buf;",
                "// Line 291: ",
                "// vulnerable line: 292: fail:",
                "// Line 293:     av_buffer_unref(&device_ref);",
                "// Line 294:     if (ctx->internal)",
                "// Line 295:         av_freep(&ctx->internal->priv);",
                "// Line 296:     av_freep(&ctx->internal);",
                "// Line 297:     av_freep(&ctx->hwctx);",
                "// Line 298:     av_freep(&ctx);",
                "// Line 299:     return NULL;",
                "// Line 300: }",
                "// Line 301: ",
                "// Line 302: static int hwframe_pool_prealloc(AVBufferRef *ref)",
                "// Line 305:     AVFrame **frames;",
                "// Line 306:     int i, ret = 0;",
                "// Line 307: ",
                "// Line 308:     frames = av_calloc(ctx->initial_pool_size, sizeof(*frames));",
                "// Line 309:     if (!frames)",
                "// Line 310:         return AVERROR(ENOMEM);",
                "// Line 311: ",
                "// Line 312:     for (i = 0; i < ctx->initial_pool_size; i++) {",
                "// Line 313:         frames[i] = av_frame_alloc();",
                "// Line 314:         if (!frames[i])",
                "// vulnerable line: 315: goto fail;",
                "// Line 316: ",
                "// Line 317:         ret = av_hwframe_get_buffer(ref, frames[i], 0);",
                "// Line 318:         if (ret < 0)",
                "// vulnerable line: 319: goto fail;",
                "// Line 320:     }",
                "// Line 321: ",
                "// vulnerable line: 322: fail:",
                "// Line 323:     for (i = 0; i < ctx->initial_pool_size; i++)",
                "// Line 324:         av_frame_free(&frames[i]);",
                "// Line 325:     av_freep(&frames);",
                "// Line 326: ",
                "// vulnerable line: 327: return ret;",
                "// Line 328: }",
                "// Line 329: ",
                "// Line 330: int av_hwframe_ctx_init(AVBufferRef *ref)",
                "// Line 331: {",
                "// Line 332:     AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;",
                "// Line 333:     const enum AVPixelFormat *pix_fmt;",
                "// Line 334:     int ret;",
                "// Line 335: ",
                "// Line 336:     if (ctx->internal->source_frames) {",
                "// Line 337:         /* A derived frame context is already initialised. */",
                "// Line 347:         av_log(ctx, AV_LOG_ERROR,",
                "// Line 348:                \"The hardware pixel format '%s' is not supported by the device type '%s'",
                "// Line 349: \",",
                "// Line 350:                av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);",
                "// Line 351:         return AVERROR(ENOSYS);",
                "// Line 352:     }",
                "// Line 353: ",
                "// Line 354:     /* validate the dimensions */",
                "// Line 355:     ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);",
                "// Line 356:     if (ret < 0)",
                "// vulnerable line: 357: return ret;",
                "// Line 358: ",
                "// Line 359:     /* format-specific init */",
                "// Line 360:     if (ctx->internal->hw_type->frames_init) {",
                "// Line 361:         ret = ctx->internal->hw_type->frames_init(ctx);",
                "// Line 362:         if (ret < 0)",
                "// vulnerable line: 363: goto fail;",
                "// Line 364:     }",
                "// Line 365: ",
                "// Line 366:     if (ctx->internal->pool_internal && !ctx->pool)",
                "// Line 367:         ctx->pool = ctx->internal->pool_internal;",
                "// Line 368: ",
                "// Line 369:     /* preallocate the frames in the pool, if requested */",
                "// Line 370:     if (ctx->initial_pool_size > 0) {",
                "// Line 371:         ret = hwframe_pool_prealloc(ref);",
                "// Line 372:         if (ret < 0)",
                "// vulnerable line: 373: goto fail;",
                "// Line 374:     }",
                "// Line 375: ",
                "// Line 376:     return 0;",
                "// vulnerable line: 377: fail:",
                "// vulnerable line: 378: if (ctx->internal->hw_type->frames_uninit)",
                "// vulnerable line: 379: ctx->internal->hw_type->frames_uninit(ctx);",
                "// vulnerable line: 380: return ret;",
                "// Line 381: }",
                "// Line 382: ",
                "// Line 383: int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ref,",
                "// Line 384:                                     enum AVHWFrameTransferDirection dir,",
                "// Line 385:                                     enum AVPixelFormat **formats, int flags)",
                "// Line 386: {",
                "// Line 387:     AVHWFramesContext *ctx = (AVHWFramesContext*)hwframe_ref->data;",
                "// Line 388: ",
                "// Line 389:     if (!ctx->internal->hw_type->transfer_get_formats)",
                "// Line 390:         return AVERROR(ENOSYS);",
                "// Line 410:      * otherwise pick the first supported one */",
                "// Line 411:     if (dst->format >= 0) {",
                "// Line 412:         frame_tmp->format = dst->format;",
                "// Line 413:     } else {",
                "// Line 414:         enum AVPixelFormat *formats;",
                "// Line 415: ",
                "// Line 416:         ret = av_hwframe_transfer_get_formats(src->hw_frames_ctx,",
                "// Line 417:                                               AV_HWFRAME_TRANSFER_DIRECTION_FROM,",
                "// Line 418:                                               &formats, 0);",
                "// Line 419:         if (ret < 0)",
                "// vulnerable line: 420: goto fail;",
                "// Line 421:         frame_tmp->format = formats[0];",
                "// Line 422:         av_freep(&formats);",
                "// Line 423:     }",
                "// Line 424:     frame_tmp->width  = ctx->width;",
                "// Line 425:     frame_tmp->height = ctx->height;",
                "// Line 426: ",
                "// Line 427:     ret = av_frame_get_buffer(frame_tmp, 0);",
                "// Line 428:     if (ret < 0)",
                "// vulnerable line: 429: goto fail;",
                "// Line 430: ",
                "// Line 431:     ret = av_hwframe_transfer_data(frame_tmp, src, flags);",
                "// Line 432:     if (ret < 0)",
                "// vulnerable line: 433: goto fail;",
                "// Line 434: ",
                "// Line 435:     frame_tmp->width  = src->width;",
                "// Line 436:     frame_tmp->height = src->height;",
                "// Line 437: ",
                "// Line 438:     av_frame_move_ref(dst, frame_tmp);",
                "// Line 439: ",
                "// vulnerable line: 440: fail:",
                "// Line 441:     av_frame_free(&frame_tmp);",
                "// vulnerable line: 442: return ret;",
                "// Line 443: }",
                "// Line 444: ",
                "// Line 445: int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)",
                "// Line 446: {",
                "// Line 447:     AVHWFramesContext *ctx;",
                "// Line 448:     int ret;",
                "// Line 449: ",
                "// Line 450:     if (!dst->buf[0])",
                "// Line 451:         return transfer_data_alloc(dst, src, flags);",
                "// Line 452: ",
                "// Line 473:             av_log(src_ctx, AV_LOG_ERROR,",
                "// Line 474:                    \"A device with a derived frame context cannot be used as \"",
                "// Line 475:                    \"the destination of a HW -> HW transfer.\");",
                "// Line 476:             return AVERROR(ENOSYS);",
                "// Line 477:         }",
                "// Line 478: ",
                "// Line 479:         ret = src_ctx->internal->hw_type->transfer_data_from(src_ctx, dst, src);",
                "// Line 480:         if (ret == AVERROR(ENOSYS))",
                "// Line 481:             ret = dst_ctx->internal->hw_type->transfer_data_to(dst_ctx, dst, src);",
                "// Line 482:         if (ret < 0)",
                "// vulnerable line: 483: return ret;",
                "// Line 484:     } else {",
                "// Line 485:         if (src->hw_frames_ctx) {",
                "// Line 486:             ctx = (AVHWFramesContext*)src->hw_frames_ctx->data;",
                "// Line 487: ",
                "// Line 488:             ret = ctx->internal->hw_type->transfer_data_from(ctx, dst, src);",
                "// Line 489:             if (ret < 0)",
                "// vulnerable line: 490: return ret;",
                "// Line 491:         } else if (dst->hw_frames_ctx) {",
                "// Line 492:             ctx = (AVHWFramesContext*)dst->hw_frames_ctx->data;",
                "// Line 493: ",
                "// Line 494:             ret = ctx->internal->hw_type->transfer_data_to(ctx, dst, src);",
                "// Line 495:             if (ret < 0)",
                "// vulnerable line: 496: return ret;",
                "// Line 497:         } else {",
                "// Line 498:             return AVERROR(ENOSYS);",
                "// Line 499:         }",
                "// Line 500:     }",
                "// Line 501:     return 0;",
                "// Line 502: }",
                "// Line 503: ",
                "// Line 504: int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)",
                "// Line 505: {",
                "// Line 506:     AVHWFramesContext *ctx = (AVHWFramesContext*)hwframe_ref->data;",
                "// Line 517:             return AVERROR(ENOMEM);",
                "// Line 518: ",
                "// Line 519:         src_frame = av_frame_alloc();",
                "// Line 520:         if (!src_frame)",
                "// Line 521:             return AVERROR(ENOMEM);",
                "// Line 522: ",
                "// Line 523:         ret = av_hwframe_get_buffer(ctx->internal->source_frames,",
                "// Line 524:                                     src_frame, 0);",
                "// Line 525:         if (ret < 0) {",
                "// Line 526:             av_frame_free(&src_frame);",
                "// vulnerable line: 527: return ret;",
                "// Line 528:         }",
                "// Line 529: ",
                "// Line 530:         ret = av_hwframe_map(frame, src_frame,",
                "// Line 531:                              ctx->internal->source_allocation_map_flags);",
                "// Line 532:         if (ret) {",
                "// Line 533:             av_log(ctx, AV_LOG_ERROR, \"Failed to map frame into derived \"",
                "// Line 534:                    \"frame context: %d.",
                "// Line 535: \", ret);",
                "// Line 536:             av_frame_free(&src_frame);",
                "// vulnerable line: 537: return ret;",
                "// Line 538:         }",
                "// Line 539: ",
                "// Line 540:         // Free the source frame immediately - the mapped frame still",
                "// Line 541:         // contains a reference to it.",
                "// Line 542:         av_frame_free(&src_frame);",
                "// Line 543: ",
                "// Line 544:         return 0;",
                "// Line 545:     }",
                "// Line 546: ",
                "// Line 547:     if (!ctx->internal->hw_type->frames_get_buffer)",
                "// Line 550:     if (!ctx->pool)",
                "// Line 551:         return AVERROR(EINVAL);",
                "// Line 552: ",
                "// Line 553:     frame->hw_frames_ctx = av_buffer_ref(hwframe_ref);",
                "// Line 554:     if (!frame->hw_frames_ctx)",
                "// Line 555:         return AVERROR(ENOMEM);",
                "// Line 556: ",
                "// Line 557:     ret = ctx->internal->hw_type->frames_get_buffer(ctx, frame);",
                "// Line 558:     if (ret < 0) {",
                "// Line 559:         av_buffer_unref(&frame->hw_frames_ctx);",
                "// vulnerable line: 560: return ret;",
                "// Line 561:     }",
                "// Line 562: ",
                "// Line 563:     frame->extended_data = frame->data;",
                "// Line 564: ",
                "// Line 565:     return 0;",
                "// Line 566: }",
                "// Line 567: ",
                "// Line 568: void *av_hwdevice_hwconfig_alloc(AVBufferRef *ref)",
                "// Line 569: {",
                "// Line 570:     AVHWDeviceContext *ctx = (AVHWDeviceContext*)ref->data;",
                "// Line 613: int av_hwdevice_ctx_create(AVBufferRef **pdevice_ref, enum AVHWDeviceType type,",
                "// Line 614:                            const char *device, AVDictionary *opts, int flags)",
                "// Line 615: {",
                "// Line 616:     AVBufferRef *device_ref = NULL;",
                "// Line 617:     AVHWDeviceContext *device_ctx;",
                "// Line 618:     int ret = 0;",
                "// Line 619: ",
                "// Line 620:     device_ref = av_hwdevice_ctx_alloc(type);",
                "// Line 621:     if (!device_ref) {",
                "// Line 622:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 623: goto fail;",
                "// Line 624:     }",
                "// Line 625:     device_ctx = (AVHWDeviceContext*)device_ref->data;",
                "// Line 626: ",
                "// Line 627:     if (!device_ctx->internal->hw_type->device_create) {",
                "// Line 628:         ret = AVERROR(ENOSYS);",
                "// vulnerable line: 629: goto fail;",
                "// Line 630:     }",
                "// Line 631: ",
                "// Line 632:     ret = device_ctx->internal->hw_type->device_create(device_ctx, device,",
                "// Line 633:                                                        opts, flags);",
                "// Line 634:     if (ret < 0)",
                "// vulnerable line: 635: goto fail;",
                "// Line 636: ",
                "// Line 637:     ret = av_hwdevice_ctx_init(device_ref);",
                "// Line 638:     if (ret < 0)",
                "// vulnerable line: 639: goto fail;",
                "// Line 640: ",
                "// Line 641:     *pdevice_ref = device_ref;",
                "// Line 642:     return 0;",
                "// vulnerable line: 643: fail:",
                "// Line 644:     av_buffer_unref(&device_ref);",
                "// Line 645:     *pdevice_ref = NULL;",
                "// vulnerable line: 646: return ret;",
                "// Line 647: }",
                "// Line 648: ",
                "// Line 649: int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ref_ptr,",
                "// Line 650:                                         enum AVHWDeviceType type,",
                "// Line 651:                                         AVBufferRef *src_ref,",
                "// Line 652:                                         AVDictionary *options, int flags)",
                "// Line 653: {",
                "// Line 654:     AVBufferRef *dst_ref = NULL, *tmp_ref;",
                "// Line 655:     AVHWDeviceContext *dst_ctx, *tmp_ctx;",
                "// Line 656:     int ret = 0;",
                "// Line 657: ",
                "// Line 658:     tmp_ref = src_ref;",
                "// Line 659:     while (tmp_ref) {",
                "// Line 660:         tmp_ctx = (AVHWDeviceContext*)tmp_ref->data;",
                "// Line 661:         if (tmp_ctx->type == type) {",
                "// Line 662:             dst_ref = av_buffer_ref(tmp_ref);",
                "// Line 663:             if (!dst_ref) {",
                "// Line 664:                 ret = AVERROR(ENOMEM);",
                "// vulnerable line: 665: goto fail;",
                "// Line 666:             }",
                "// Line 667:             goto done;",
                "// Line 668:         }",
                "// Line 669:         tmp_ref = tmp_ctx->internal->source_device;",
                "// Line 670:     }",
                "// Line 671: ",
                "// Line 672:     dst_ref = av_hwdevice_ctx_alloc(type);",
                "// Line 673:     if (!dst_ref) {",
                "// Line 674:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 675: goto fail;",
                "// Line 676:     }",
                "// Line 677:     dst_ctx = (AVHWDeviceContext*)dst_ref->data;",
                "// Line 678: ",
                "// Line 679:     tmp_ref = src_ref;",
                "// Line 680:     while (tmp_ref) {",
                "// Line 681:         tmp_ctx = (AVHWDeviceContext*)tmp_ref->data;",
                "// Line 682:         if (dst_ctx->internal->hw_type->device_derive) {",
                "// Line 683:             ret = dst_ctx->internal->hw_type->device_derive(dst_ctx,",
                "// Line 684:                                                             tmp_ctx,",
                "// Line 685:                                                             options,",
                "// Line 686:                                                             flags);",
                "// Line 687:             if (ret == 0) {",
                "// Line 688:                 dst_ctx->internal->source_device = av_buffer_ref(src_ref);",
                "// Line 689:                 if (!dst_ctx->internal->source_device) {",
                "// Line 690:                     ret = AVERROR(ENOMEM);",
                "// vulnerable line: 691: goto fail;",
                "// Line 692:                 }",
                "// Line 693:                 ret = av_hwdevice_ctx_init(dst_ref);",
                "// Line 694:                 if (ret < 0)",
                "// vulnerable line: 695: goto fail;",
                "// Line 696:                 goto done;",
                "// Line 697:             }",
                "// Line 698:             if (ret != AVERROR(ENOSYS))",
                "// vulnerable line: 699: goto fail;",
                "// Line 700:         }",
                "// Line 701:         tmp_ref = tmp_ctx->internal->source_device;",
                "// Line 702:     }",
                "// Line 703: ",
                "// Line 704:     ret = AVERROR(ENOSYS);",
                "// vulnerable line: 705: goto fail;",
                "// Line 706: ",
                "// Line 707: done:",
                "// Line 708:     *dst_ref_ptr = dst_ref;",
                "// Line 709:     return 0;",
                "// Line 710: ",
                "// vulnerable line: 711: fail:",
                "// Line 712:     av_buffer_unref(&dst_ref);",
                "// Line 713:     *dst_ref_ptr = NULL;",
                "// vulnerable line: 714: return ret;",
                "// Line 715: }",
                "// Line 716: ",
                "// Line 717: int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ref_ptr,",
                "// Line 718:                                    enum AVHWDeviceType type,",
                "// Line 719:                                    AVBufferRef *src_ref, int flags)",
                "// Line 720: {",
                "// Line 721:     return av_hwdevice_ctx_create_derived_opts(dst_ref_ptr, type, src_ref,",
                "// Line 722:                                                NULL, flags);",
                "// Line 723: }",
                "// Line 724: ",
                "// Line 743:                                         HWMapDescriptor *hwmap),",
                "// Line 744:                           void *priv)",
                "// Line 745: {",
                "// Line 746:     AVHWFramesContext *ctx = (AVHWFramesContext*)hwframe_ref->data;",
                "// Line 747:     HWMapDescriptor *hwmap;",
                "// Line 748:     int ret;",
                "// Line 749: ",
                "// Line 750:     hwmap = av_mallocz(sizeof(*hwmap));",
                "// Line 751:     if (!hwmap) {",
                "// Line 752:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 753: goto fail;",
                "// Line 754:     }",
                "// Line 755: ",
                "// Line 756:     hwmap->source = av_frame_alloc();",
                "// Line 757:     if (!hwmap->source) {",
                "// Line 758:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 759: goto fail;",
                "// Line 760:     }",
                "// Line 761:     ret = av_frame_ref(hwmap->source, src);",
                "// Line 762:     if (ret < 0)",
                "// vulnerable line: 763: goto fail;",
                "// Line 764: ",
                "// Line 765:     hwmap->hw_frames_ctx = av_buffer_ref(hwframe_ref);",
                "// Line 766:     if (!hwmap->hw_frames_ctx) {",
                "// Line 767:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 768: goto fail;",
                "// Line 769:     }",
                "// Line 770: ",
                "// Line 771:     hwmap->unmap = unmap;",
                "// Line 772:     hwmap->priv  = priv;",
                "// Line 773: ",
                "// Line 774:     dst->buf[0] = av_buffer_create((uint8_t*)hwmap, sizeof(*hwmap),",
                "// Line 775:                                    &ff_hwframe_unmap, ctx, 0);",
                "// Line 776:     if (!dst->buf[0]) {",
                "// Line 777:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 778: goto fail;",
                "// Line 779:     }",
                "// Line 780: ",
                "// Line 781:     return 0;",
                "// Line 782: ",
                "// vulnerable line: 783: fail:",
                "// Line 784:     if (hwmap) {",
                "// Line 785:         av_buffer_unref(&hwmap->hw_frames_ctx);",
                "// Line 786:         av_frame_free(&hwmap->source);",
                "// Line 787:     }",
                "// Line 788:     av_free(hwmap);",
                "// vulnerable line: 789: return ret;",
                "// Line 790: }",
                "// Line 791: ",
                "// Line 792: int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)",
                "// Line 793: {",
                "// Line 794:     AVBufferRef    *orig_dst_frames = dst->hw_frames_ctx;",
                "// Line 795:     enum AVPixelFormat orig_dst_fmt = dst->format;",
                "// Line 796:     AVHWFramesContext *src_frames, *dst_frames;",
                "// Line 797:     HWMapDescriptor *hwmap;",
                "// Line 798:     int ret;",
                "// Line 799: ",
                "// Line 823:     }",
                "// Line 824: ",
                "// Line 825:     if (src->hw_frames_ctx) {",
                "// Line 826:         src_frames = (AVHWFramesContext*)src->hw_frames_ctx->data;",
                "// Line 827: ",
                "// Line 828:         if (src_frames->format == src->format &&",
                "// Line 829:             src_frames->internal->hw_type->map_from) {",
                "// Line 830:             ret = src_frames->internal->hw_type->map_from(src_frames,",
                "// Line 831:                                                           dst, src, flags);",
                "// Line 832:             if (ret >= 0)",
                "// vulnerable line: 833: return ret;",
                "// Line 834:             else if (ret != AVERROR(ENOSYS))",
                "// vulnerable line: 835: goto fail;",
                "// Line 836:         }",
                "// Line 837:     }",
                "// Line 838: ",
                "// Line 839:     if (dst->hw_frames_ctx) {",
                "// Line 840:         dst_frames = (AVHWFramesContext*)dst->hw_frames_ctx->data;",
                "// Line 841: ",
                "// Line 842:         if (dst_frames->format == dst->format &&",
                "// Line 843:             dst_frames->internal->hw_type->map_to) {",
                "// Line 844:             ret = dst_frames->internal->hw_type->map_to(dst_frames,",
                "// Line 845:                                                         dst, src, flags);",
                "// Line 846:             if (ret >= 0)",
                "// vulnerable line: 847: return ret;",
                "// Line 848:             else if (ret != AVERROR(ENOSYS))",
                "// vulnerable line: 849: goto fail;",
                "// Line 850:         }",
                "// Line 851:     }",
                "// Line 852: ",
                "// Line 853:     return AVERROR(ENOSYS);",
                "// Line 854: ",
                "// vulnerable line: 855: fail:",
                "// Line 856:     // if the caller provided dst frames context, it should be preserved",
                "// Line 857:     // by this function",
                "// Line 858:     av_assert0(orig_dst_frames == NULL ||",
                "// Line 859:                orig_dst_frames == dst->hw_frames_ctx);",
                "// Line 860: ",
                "// Line 861:     // preserve user-provided dst frame fields, but clean",
                "// Line 862:     // anything we might have set",
                "// Line 863:     dst->hw_frames_ctx = NULL;",
                "// Line 864:     av_frame_unref(dst);",
                "// Line 865: ",
                "// Line 866:     dst->hw_frames_ctx = orig_dst_frames;",
                "// Line 867:     dst->format        = orig_dst_fmt;",
                "// Line 868: ",
                "// vulnerable line: 869: return ret;",
                "// Line 870: }",
                "// Line 871: ",
                "// Line 872: int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx,",
                "// Line 873:                                   enum AVPixelFormat format,",
                "// Line 874:                                   AVBufferRef *derived_device_ctx,",
                "// Line 875:                                   AVBufferRef *source_frame_ctx,",
                "// Line 876:                                   int flags)",
                "// Line 877: {",
                "// Line 878:     AVBufferRef   *dst_ref = NULL;",
                "// Line 879:     AVHWFramesContext *dst = NULL;",
                "// Line 886:         AVHWDeviceContext *dst_dev =",
                "// Line 887:             (AVHWDeviceContext*)derived_device_ctx->data;",
                "// Line 888: ",
                "// Line 889:         if (src_src->device_ctx == dst_dev) {",
                "// Line 890:             // This is actually an unmapping, so we just return a",
                "// Line 891:             // reference to the source frame context.",
                "// Line 892:             *derived_frame_ctx =",
                "// Line 893:                 av_buffer_ref(src->internal->source_frames);",
                "// Line 894:             if (!*derived_frame_ctx) {",
                "// Line 895:                 ret = AVERROR(ENOMEM);",
                "// vulnerable line: 896: goto fail;",
                "// Line 897:             }",
                "// Line 898:             return 0;",
                "// Line 899:         }",
                "// Line 900:     }",
                "// Line 901: ",
                "// Line 902:     dst_ref = av_hwframe_ctx_alloc(derived_device_ctx);",
                "// Line 903:     if (!dst_ref) {",
                "// Line 904:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 905: goto fail;",
                "// Line 906:     }",
                "// Line 907: ",
                "// Line 908:     dst = (AVHWFramesContext*)dst_ref->data;",
                "// Line 909: ",
                "// Line 910:     dst->format    = format;",
                "// Line 911:     dst->sw_format = src->sw_format;",
                "// Line 912:     dst->width     = src->width;",
                "// Line 913:     dst->height    = src->height;",
                "// Line 914: ",
                "// Line 915:     dst->internal->source_frames = av_buffer_ref(source_frame_ctx);",
                "// Line 916:     if (!dst->internal->source_frames) {",
                "// Line 917:         ret = AVERROR(ENOMEM);",
                "// vulnerable line: 918: goto fail;",
                "// Line 919:     }",
                "// Line 920: ",
                "// Line 921:     dst->internal->source_allocation_map_flags =",
                "// Line 922:         flags & (AV_HWFRAME_MAP_READ      |",
                "// Line 923:                  AV_HWFRAME_MAP_WRITE     |",
                "// Line 924:                  AV_HWFRAME_MAP_OVERWRITE |",
                "// Line 925:                  AV_HWFRAME_MAP_DIRECT);",
                "// Line 926: ",
                "// Line 927:     ret = AVERROR(ENOSYS);",
                "// Line 928:     if (src->internal->hw_type->frames_derive_from)",
                "// Line 929:         ret = src->internal->hw_type->frames_derive_from(dst, src, flags);",
                "// Line 930:     if (ret == AVERROR(ENOSYS) &&",
                "// Line 931:         dst->internal->hw_type->frames_derive_to)",
                "// Line 932:         ret = dst->internal->hw_type->frames_derive_to(dst, src, flags);",
                "// Line 933:     if (ret == AVERROR(ENOSYS))",
                "// Line 934:         ret = 0;",
                "// Line 935:     if (ret)",
                "// vulnerable line: 936: goto fail;",
                "// Line 937: ",
                "// Line 938:     *derived_frame_ctx = dst_ref;",
                "// Line 939:     return 0;",
                "// Line 940: ",
                "// vulnerable line: 941: fail:",
                "// Line 942:     if (dst)",
                "// Line 943:         av_buffer_unref(&dst->internal->source_frames);",
                "// Line 944:     av_buffer_unref(&dst_ref);",
                "// vulnerable line: 945: return ret;",
                "// Line 946: }",
                "// Line 947: ",
                "// Line 948: int ff_hwframe_map_replace(AVFrame *dst, const AVFrame *src)",
                "// Line 949: {",
                "// Line 950:     HWMapDescriptor *hwmap = (HWMapDescriptor*)dst->buf[0]->data;",
                "// Line 951:     return av_frame_replace(hwmap->source, src);",
                "// Line 952: }"
            ]
        }
    ]
}