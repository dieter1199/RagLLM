{
    "cve_id": "CVE-2024-21512",
    "cve_description": "Versions of the package mysql2 before 3.9.8 are vulnerable to Prototype Pollution due to improper user input sanitization passed to fields and tables when using nestTables.",
    "cve_publish_date": "2024-05-29T05:16Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix(security): sanitize fields and tables when using nestTables (#2702)\n\n* fix(security): sanitize fields and tables when using nestTables\r\n\r\n* chore: undone `nestTables` validation for `rowsAsArray`",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "binary_parser.js",
            "code_language": "JavaScript",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "14",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 2: ",
                "// Line 3: const FieldFlags = require('../constants/field_flags.js');",
                "// Line 4: const Charsets = require('../constants/charsets.js');",
                "// Line 5: const Types = require('../constants/types.js');",
                "// Line 6: const helpers = require('../helpers');",
                "// Line 7: const genFunc = require('generate-function');",
                "// Line 8: const parserCache = require('./parser_cache.js');",
                "// Line 9: const typeNames = [];",
                "// Line 10: for (const t in Types) {",
                "// Line 11:   typeNames[Types[t]] = t;",
                "// vulnerable line: 12: }",
                "// Line 13: ",
                "// Line 14: function readCodeFor(field, config, options, fieldNum) {",
                "// Line 15:   const supportBigNumbers = Boolean(",
                "// Line 16:     options.supportBigNumbers || config.supportBigNumbers,",
                "// vulnerable line: 17: );",
                "// Line 18:   const bigNumberStrings = Boolean(",
                "// Line 19:     options.bigNumberStrings || config.bigNumberStrings,",
                "// vulnerable line: 20: );",
                "// Line 21:   const timezone = options.timezone || config.timezone;",
                "// Line 22:   const dateStrings = options.dateStrings || config.dateStrings;",
                "// Line 23:   const unsigned = field.flags & FieldFlags.UNSIGNED;",
                "// Line 24:   switch (field.columnType) {",
                "// Line 25:     case Types.TINY:",
                "// Line 26:       return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';",
                "// Line 27:     case Types.SHORT:",
                "// Line 28:       return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';",
                "// Line 29:     case Types.LONG:",
                "// Line 30:     case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32",
                "// Line 36:     case Types.DOUBLE:",
                "// Line 37:       return 'packet.readDouble();';",
                "// Line 38:     case Types.NULL:",
                "// Line 39:       return 'null;';",
                "// Line 40:     case Types.DATE:",
                "// Line 41:     case Types.DATETIME:",
                "// Line 42:     case Types.TIMESTAMP:",
                "// Line 43:     case Types.NEWDATE:",
                "// Line 44:       if (helpers.typeMatch(field.columnType, dateStrings, Types)) {",
                "// Line 45:         return `packet.readDateTimeString(${parseInt(field.decimals, 10)});`;",
                "// vulnerable line: 46: }",
                "// Line 47:       return `packet.readDateTime(${helpers.srcEscape(timezone)});`;",
                "// Line 48:     case Types.TIME:",
                "// Line 49:       return 'packet.readTimeString()';",
                "// Line 50:     case Types.DECIMAL:",
                "// Line 51:     case Types.NEWDECIMAL:",
                "// Line 52:       if (config.decimalNumbers) {",
                "// Line 53:         return 'packet.parseLengthCodedFloat();';",
                "// vulnerable line: 54: }",
                "// Line 55:       return 'packet.readLengthCodedString(\"ascii\");';",
                "// Line 56:     case Types.GEOMETRY:",
                "// Line 57:       return 'packet.parseGeometryValue();';",
                "// Line 58:     case Types.JSON:",
                "// Line 59:       // Since for JSON columns mysql always returns charset 63 (BINARY),",
                "// Line 60:       // we have to handle it according to JSON specs and use \"utf8\",",
                "// Line 61:       // see https://github.com/sidorares/node-mysql2/issues/409",
                "// Line 62:       return 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';",
                "// Line 63:     case Types.LONGLONG:",
                "// Line 64:       if (!supportBigNumbers) {",
                "// Line 65:         return unsigned",
                "// Line 66:           ? 'packet.readInt64JSNumber();'",
                "// Line 67:           : 'packet.readSInt64JSNumber();';",
                "// vulnerable line: 68: }",
                "// Line 69:       if (bigNumberStrings) {",
                "// Line 70:         return unsigned",
                "// Line 71:           ? 'packet.readInt64String();'",
                "// Line 72:           : 'packet.readSInt64String();';",
                "// vulnerable line: 73: }",
                "// Line 74:       return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';",
                "// Line 75: ",
                "// Line 76:     default:",
                "// Line 77:       if (field.characterSet === Charsets.BINARY) {",
                "// Line 78:         return 'packet.readLengthCodedBuffer();';",
                "// vulnerable line: 79: }",
                "// Line 80:       return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;",
                "// vulnerable line: 81: }",
                "// vulnerable line: 82: }",
                "// Line 83: ",
                "// Line 84: function compile(fields, options, config) {",
                "// Line 85:   const parserFn = genFunc();",
                "// Line 86:   const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);",
                "// Line 87: ",
                "// Line 88:   function wrap(field, packet) {",
                "// Line 89:     return {",
                "// Line 90:       type: typeNames[field.columnType],",
                "// Line 91:       length: field.columnLength,",
                "// Line 92:       db: field.schema,",
                "// Line 93:       table: field.table,",
                "// Line 94:       name: field.name,",
                "// Line 95:       string: function (encoding = field.encoding) {",
                "// Line 96:         if (field.columnType === Types.JSON && encoding === field.encoding) {",
                "// Line 97:           // Since for JSON columns mysql always returns charset 63 (BINARY),",
                "// Line 98:           // we have to handle it according to JSON specs and use \"utf8\",",
                "// Line 99:           // see https://github.com/sidorares/node-mysql2/issues/1661",
                "// Line 100:           console.warn(",
                "// Line 101:             `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``,",
                "// vulnerable line: 102: );",
                "// vulnerable line: 103: }",
                "// Line 104: ",
                "// Line 105:         return packet.readLengthCodedString(encoding);",
                "// Line 106:       },",
                "// Line 107:       buffer: function () {",
                "// Line 108:         return packet.readLengthCodedBuffer();",
                "// Line 109:       },",
                "// Line 110:       geometry: function () {",
                "// Line 111:         return packet.parseGeometryValue();",
                "// Line 112:       },",
                "// Line 113:     };",
                "// vulnerable line: 114: }",
                "// Line 115: ",
                "// Line 116:   parserFn('(function(){');",
                "// Line 117:   parserFn('return class BinaryRow {');",
                "// Line 118:   parserFn('constructor() {');",
                "// Line 119:   parserFn('}');",
                "// Line 120: ",
                "// Line 121:   parserFn('next(packet, fields, options) {');",
                "// Line 122:   if (options.rowsAsArray) {",
                "// Line 123:     parserFn(`const result = new Array(${fields.length});`);",
                "// Line 124:   } else {",
                "// Line 125:     parserFn('const result = {};');",
                "// vulnerable line: 126: }",
                "// Line 127: ",
                "// Line 128:   // Global typeCast",
                "// Line 129:   if (",
                "// Line 130:     typeof config.typeCast === 'function' &&",
                "// Line 131:     typeof options.typeCast !== 'function'",
                "// Line 132:   ) {",
                "// Line 133:     options.typeCast = config.typeCast;",
                "// vulnerable line: 134: }",
                "// Line 135: ",
                "// Line 136:   parserFn('packet.readInt8();'); // status byte",
                "// Line 137:   for (let i = 0; i < nullBitmapLength; ++i) {",
                "// Line 138:     parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);",
                "// vulnerable line: 139: }",
                "// Line 140: ",
                "// Line 141:   let lvalue = '';",
                "// Line 142:   let currentFieldNullBit = 4;",
                "// Line 143:   let nullByteIndex = 0;",
                "// Line 144:   let fieldName = '';",
                "// Line 145:   let tableName = '';",
                "// Line 146: ",
                "// Line 147:   for (let i = 0; i < fields.length; i++) {",
                "// vulnerable line: 148: fieldName = helpers.srcEscape(fields[i].name);",
                "// Line 149: ",
                "// vulnerable line: 150: if (helpers.privateObjectProps.has(fields[i].name)) {",
                "// vulnerable line: 151: throw new Error(",
                "// vulnerable line: 152: `The field name (${fieldName}) can't be the same as an object's private property.`,",
                "// vulnerable line: 153: );",
                "// vulnerable line: 154: }",
                "// Line 155: ",
                "// vulnerable line: 156: parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);",
                "// Line 157: ",
                "// Line 158:     if (typeof options.nestTables === 'string') {",
                "// vulnerable line: 159: lvalue = `result[${helpers.srcEscape(",
                "// vulnerable line: 160: fields[i].table + options.nestTables + fields[i].name,",
                "// vulnerable line: 161: )}]`;",
                "// Line 162:     } else if (options.nestTables === true) {",
                "// vulnerable line: 163: tableName = helpers.srcEscape(fields[i].table);",
                "// Line 164:       parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);",
                "// Line 165:       lvalue = `result[${tableName}][${fieldName}]`;",
                "// Line 166:     } else if (options.rowsAsArray) {",
                "// Line 167:       lvalue = `result[${i.toString(10)}]`;",
                "// Line 168:     } else {",
                "// Line 169:       lvalue = `result[${fieldName}]`;",
                "// vulnerable line: 170: }",
                "// Line 171: ",
                "// Line 172:     parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);",
                "// Line 173:     parserFn(`${lvalue} = null;`);",
                "// Line 174:     parserFn('else {');",
                "// Line 175: ",
                "// Line 176:     if (options.typeCast === false) {",
                "// Line 177:       parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);",
                "// Line 178:     } else {",
                "// Line 179:       const fieldWrapperVar = `fieldWrapper${i}`;",
                "// Line 180:       parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);",
                "// Line 181:       const readCode = readCodeFor(fields[i], config, options, i);",
                "// Line 182: ",
                "// Line 183:       if (typeof options.typeCast === 'function') {",
                "// Line 184:         parserFn(",
                "// Line 185:           `${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`,",
                "// vulnerable line: 186: );",
                "// Line 187:       } else {",
                "// Line 188:         parserFn(`${lvalue} = ${readCode};`);",
                "// vulnerable line: 189: }",
                "// vulnerable line: 190: }",
                "// Line 191:     parserFn('}');",
                "// Line 192: ",
                "// Line 193: ",
                "// Line 194:     currentFieldNullBit *= 2;",
                "// Line 195:     if (currentFieldNullBit === 0x100) {",
                "// Line 196:       currentFieldNullBit = 1;",
                "// Line 197:       nullByteIndex++;",
                "// vulnerable line: 198: }",
                "// vulnerable line: 199: }",
                "// Line 200: ",
                "// Line 201:   parserFn('return result;');",
                "// Line 202:   parserFn('}');",
                "// Line 203:   parserFn('};')('})()');",
                "// Line 204: ",
                "// Line 205:   if (config.debug) {",
                "// Line 206:     helpers.printDebugWithCode(",
                "// Line 207:       'Compiled binary protocol row parser',",
                "// Line 208:       parserFn.toString(),",
                "// vulnerable line: 209: );",
                "// vulnerable line: 210: }",
                "// Line 211:   return parserFn.toFunction({ wrap });",
                "// vulnerable line: 212: }",
                "// Line 213: ",
                "// Line 214: function getBinaryParser(fields, options, config) {",
                "// Line 215:   return parserCache.getParser('binary', fields, options, config, compile);",
                "// vulnerable line: 216: }",
                "// Line 217: ",
                "// Line 218: module.exports = getBinaryParser;"
            ]
        },
        {
            "filename_of_changes": "helpers.js",
            "code_language": "JavaScript",
            "number_of_lines_added_for_mitigation": "12",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "text_parser.js",
            "code_language": "JavaScript",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "13",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 2: ",
                "// Line 3: const Types = require('../constants/types.js');",
                "// Line 4: const Charsets = require('../constants/charsets.js');",
                "// Line 5: const helpers = require('../helpers');",
                "// Line 6: const genFunc = require('generate-function');",
                "// Line 7: const parserCache = require('./parser_cache.js');",
                "// Line 8: ",
                "// Line 9: const typeNames = [];",
                "// Line 10: for (const t in Types) {",
                "// Line 11:   typeNames[Types[t]] = t;",
                "// vulnerable line: 12: }",
                "// Line 13: ",
                "// Line 14: function readCodeFor(type, charset, encodingExpr, config, options) {",
                "// Line 15:   const supportBigNumbers = Boolean(",
                "// Line 16:     options.supportBigNumbers || config.supportBigNumbers,",
                "// vulnerable line: 17: );",
                "// Line 18:   const bigNumberStrings = Boolean(",
                "// Line 19:     options.bigNumberStrings || config.bigNumberStrings,",
                "// vulnerable line: 20: );",
                "// Line 21:   const timezone = options.timezone || config.timezone;",
                "// Line 22:   const dateStrings = options.dateStrings || config.dateStrings;",
                "// Line 23: ",
                "// Line 24:   switch (type) {",
                "// Line 25:     case Types.TINY:",
                "// Line 26:     case Types.SHORT:",
                "// Line 27:     case Types.LONG:",
                "// Line 28:     case Types.INT24:",
                "// Line 29:     case Types.YEAR:",
                "// Line 30:       return 'packet.parseLengthCodedIntNoBigCheck()';",
                "// Line 31:     case Types.LONGLONG:",
                "// Line 32:       if (supportBigNumbers && bigNumberStrings) {",
                "// Line 33:         return 'packet.parseLengthCodedIntString()';",
                "// vulnerable line: 34: }",
                "// Line 35:       return `packet.parseLengthCodedInt(${supportBigNumbers})`;",
                "// Line 36:     case Types.FLOAT:",
                "// Line 37:     case Types.DOUBLE:",
                "// Line 38:       return 'packet.parseLengthCodedFloat()';",
                "// Line 39:     case Types.NULL:",
                "// Line 40:       return 'packet.readLengthCodedNumber()';",
                "// Line 41:     case Types.DECIMAL:",
                "// Line 42:     case Types.NEWDECIMAL:",
                "// Line 43:       if (config.decimalNumbers) {",
                "// Line 44:         return 'packet.parseLengthCodedFloat()';",
                "// vulnerable line: 45: }",
                "// Line 46:       return 'packet.readLengthCodedString(\"ascii\")';",
                "// Line 47:     case Types.DATE:",
                "// Line 48:       if (helpers.typeMatch(type, dateStrings, Types)) {",
                "// Line 49:         return 'packet.readLengthCodedString(\"ascii\")';",
                "// vulnerable line: 50: }",
                "// Line 51:       return `packet.parseDate(${helpers.srcEscape(timezone)})`;",
                "// Line 52:     case Types.DATETIME:",
                "// Line 53:     case Types.TIMESTAMP:",
                "// Line 54:       if (helpers.typeMatch(type, dateStrings, Types)) {",
                "// Line 55:         return 'packet.readLengthCodedString(\"ascii\")';",
                "// vulnerable line: 56: }",
                "// Line 57:       return `packet.parseDateTime(${helpers.srcEscape(timezone)})`;",
                "// Line 58:     case Types.TIME:",
                "// Line 59:       return 'packet.readLengthCodedString(\"ascii\")';",
                "// Line 60:     case Types.GEOMETRY:",
                "// Line 61:       return 'packet.parseGeometryValue()';",
                "// Line 62:     case Types.JSON:",
                "// Line 63:       // Since for JSON columns mysql always returns charset 63 (BINARY),",
                "// Line 64:       // we have to handle it according to JSON specs and use \"utf8\",",
                "// Line 65:       // see https://github.com/sidorares/node-mysql2/issues/409",
                "// Line 66:       return 'JSON.parse(packet.readLengthCodedString(\"utf8\"))';",
                "// Line 67:     default:",
                "// Line 68:       if (charset === Charsets.BINARY) {",
                "// Line 69:         return 'packet.readLengthCodedBuffer()';",
                "// vulnerable line: 70: }",
                "// Line 71:       return `packet.readLengthCodedString(${encodingExpr})`;",
                "// vulnerable line: 72: }",
                "// vulnerable line: 73: }",
                "// Line 74: ",
                "// Line 75: function compile(fields, options, config) {",
                "// Line 76:   // use global typeCast if current query doesn't specify one",
                "// Line 77:   if (",
                "// Line 78:     typeof config.typeCast === 'function' &&",
                "// Line 79:     typeof options.typeCast !== 'function'",
                "// Line 80:   ) {",
                "// Line 81:     options.typeCast = config.typeCast;",
                "// vulnerable line: 82: }",
                "// Line 83: ",
                "// Line 84:   function wrap(field, _this) {",
                "// Line 85:     return {",
                "// Line 86:       type: typeNames[field.columnType],",
                "// Line 87:       length: field.columnLength,",
                "// Line 88:       db: field.schema,",
                "// Line 89:       table: field.table,",
                "// Line 90:       name: field.name,",
                "// Line 91:       string: function (encoding = field.encoding) {",
                "// Line 92:         if (field.columnType === Types.JSON && encoding === field.encoding) {",
                "// Line 93:           // Since for JSON columns mysql always returns charset 63 (BINARY),",
                "// Line 94:           // we have to handle it according to JSON specs and use \"utf8\",",
                "// Line 95:           // see https://github.com/sidorares/node-mysql2/issues/1661",
                "// Line 96:           console.warn(",
                "// Line 97:             `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``,",
                "// vulnerable line: 98: );",
                "// vulnerable line: 99: }",
                "// Line 100: ",
                "// Line 101:         return _this.packet.readLengthCodedString(encoding);",
                "// Line 102:       },",
                "// Line 103:       buffer: function () {",
                "// Line 104:         return _this.packet.readLengthCodedBuffer();",
                "// Line 105:       },",
                "// Line 106:       geometry: function () {",
                "// Line 107:         return _this.packet.parseGeometryValue();",
                "// Line 108:       },",
                "// Line 109:     };",
                "// vulnerable line: 110: }",
                "// Line 111: ",
                "// Line 112:   const parserFn = genFunc();",
                "// Line 113: ",
                "// Line 114:   parserFn('(function () {')('return class TextRow {');",
                "// Line 115: ",
                "// Line 116:   // constructor method",
                "// Line 117:   parserFn('constructor(fields) {');",
                "// Line 118:   // node-mysql typeCast compatibility wrapper",
                "// Line 119:   // see https://github.com/mysqljs/mysql/blob/96fdd0566b654436624e2375c7b6604b1f50f825/lib/protocol/packets/Field.js",
                "// Line 120:   if (typeof options.typeCast === 'function') {",
                "// Line 121:     parserFn('const _this = this;');",
                "// Line 122:     parserFn('for(let i=0; i<fields.length; ++i) {');",
                "// Line 123:     parserFn('this[`wrap${i}`] = wrap(fields[i], _this);');",
                "// Line 124:     parserFn('}');",
                "// vulnerable line: 125: }",
                "// Line 126:   parserFn('}');",
                "// Line 127: ",
                "// Line 128:   // next method",
                "// Line 129:   parserFn('next(packet, fields, options) {');",
                "// Line 130:   parserFn('this.packet = packet;');",
                "// Line 131:   if (options.rowsAsArray) {",
                "// Line 132:     parserFn(`const result = new Array(${fields.length});`);",
                "// Line 133:   } else {",
                "// Line 134:     parserFn('const result = {};');",
                "// vulnerable line: 135: }",
                "// Line 136: ",
                "// Line 137:   const resultTables = {};",
                "// Line 138:   let resultTablesArray = [];",
                "// Line 139: ",
                "// Line 140:   if (options.nestTables === true) {",
                "// Line 141:     for (let i = 0; i < fields.length; i++) {",
                "// Line 142:       resultTables[fields[i].table] = 1;",
                "// vulnerable line: 143: }",
                "// Line 144:     resultTablesArray = Object.keys(resultTables);",
                "// Line 145:     for (let i = 0; i < resultTablesArray.length; i++) {",
                "// vulnerable line: 146: parserFn(`result[${helpers.srcEscape(resultTablesArray[i])}] = {};`);",
                "// vulnerable line: 147: }",
                "// vulnerable line: 148: }",
                "// Line 149: ",
                "// Line 150:   let lvalue = '';",
                "// Line 151:   let fieldName = '';",
                "// Line 152:   for (let i = 0; i < fields.length; i++) {",
                "// vulnerable line: 153: fieldName = helpers.srcEscape(fields[i].name);",
                "// Line 154: ",
                "// vulnerable line: 155: if (helpers.privateObjectProps.has(fields[i].name)) {",
                "// vulnerable line: 156: throw new Error(",
                "// vulnerable line: 157: `The field name (${fieldName}) can't be the same as an object's private property.`,",
                "// vulnerable line: 158: );",
                "// vulnerable line: 159: }",
                "// Line 160: ",
                "// vulnerable line: 161: parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);",
                "// Line 162:     if (typeof options.nestTables === 'string') {",
                "// vulnerable line: 163: lvalue = `result[${helpers.srcEscape(",
                "// vulnerable line: 164: fields[i].table + options.nestTables + fields[i].name,",
                "// vulnerable line: 165: )}]`;",
                "// Line 166:     } else if (options.nestTables === true) {",
                "// vulnerable line: 167: lvalue = `result[${helpers.srcEscape(fields[i].table)}][${fieldName}]`;",
                "// Line 168:     } else if (options.rowsAsArray) {",
                "// Line 169:       lvalue = `result[${i.toString(10)}]`;",
                "// Line 170:     } else {",
                "// Line 171:       lvalue = `result[${fieldName}]`;",
                "// vulnerable line: 172: }",
                "// Line 173:     if (options.typeCast === false) {",
                "// Line 174:       parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);",
                "// Line 175:     } else {",
                "// Line 176:       const encodingExpr = `fields[${i}].encoding`;",
                "// Line 177:       const readCode = readCodeFor(",
                "// Line 178:         fields[i].columnType,",
                "// Line 179:         fields[i].characterSet,",
                "// Line 180:         encodingExpr,",
                "// Line 181:         config,",
                "// Line 182:         options,",
                "// vulnerable line: 183: );",
                "// Line 184:       if (typeof options.typeCast === 'function') {",
                "// Line 185:         parserFn(",
                "// Line 186:           `${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`,",
                "// vulnerable line: 187: );",
                "// Line 188:       } else {",
                "// Line 189:         parserFn(`${lvalue} = ${readCode};`);",
                "// vulnerable line: 190: }",
                "// vulnerable line: 191: }",
                "// vulnerable line: 192: }",
                "// Line 193: ",
                "// Line 194:   parserFn('return result;');",
                "// Line 195:   parserFn('}');",
                "// Line 196:   parserFn('};')('})()');",
                "// Line 197: ",
                "// Line 198:   if (config.debug) {",
                "// Line 199:     helpers.printDebugWithCode(",
                "// Line 200:       'Compiled text protocol row parser',",
                "// Line 201:       parserFn.toString(),",
                "// vulnerable line: 202: );",
                "// vulnerable line: 203: }",
                "// Line 204:   if (typeof options.typeCast === 'function') {",
                "// Line 205:     return parserFn.toFunction({ wrap });",
                "// vulnerable line: 206: }",
                "// Line 207:   return parserFn.toFunction();",
                "// vulnerable line: 208: }",
                "// Line 209: ",
                "// Line 210: function getTextParser(fields, options, config) {",
                "// Line 211:   return parserCache.getParser('text', fields, options, config, compile);",
                "// vulnerable line: 212: }",
                "// Line 213: ",
                "// Line 214: module.exports = getTextParser;"
            ]
        }
    ]
}