{
    "cve_id": "CVE-2024-24750",
    "cve_description": "Undici is an HTTP/1.1 client, written from scratch for Node.js. In affected versions calling `fetch(url)` and not consuming the incoming body ((or consuming it very slowing) will lead to a memory leak. This issue has been addressed in version 6.6.1. Users are advised to upgrade. Users unable to upgrade should make sure to always consume the incoming body.",
    "cve_publish_date": "2024-02-16T22:15Z",
    "cwe_id": "CWE-400",
    "cwe_name": "Uncontrolled Resource Consumption",
    "cwe_description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "commit_message": "Merge pull request from GHSA-9f24-jqhm-jfcw\n\n* fetch: pull don't push\n\nSigned-off-by: Matteo Collina <hello@matteocollina.com>\n\n* added tests\n\nSigned-off-by: Matteo Collina <hello@matteocollina.com>\n\n---------\n\nSigned-off-by: Matteo Collina <hello@matteocollina.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "index.js",
            "code_language": "JavaScript",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1092:         controller.enqueue(chunk)",
                "// Line 1093:       },",
                "// Line 1094:       flush: processResponseEndOfBody",
                "// Line 1095:     })",
                "// Line 1096: ",
                "// Line 1097:     // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.",
                "// Line 1098:     internalResponse.body.stream.pipeThrough(transformStream)",
                "// Line 1099: ",
                "// Line 1100:     const byteStream = new ReadableStream({",
                "// Line 1101:       readableStream: transformStream.readable,",
                "// vulnerable line: 1102: async start (controller) {",
                "// Line 1103:         const reader = this.readableStream.getReader()",
                "// Line 1104: ",
                "// vulnerable line: 1105: while (true) {",
                "// Line 1106:           const { done, value } = await reader.read()",
                "// Line 1107: ",
                "// Line 1108:           if (done) {",
                "// Line 1109:             queueMicrotask(() => readableStreamClose(controller))",
                "// Line 1110:             break",
                "// Line 1111:           }",
                "// Line 1112: ",
                "// Line 1113:           controller.enqueue(value)",
                "// Line 1114:         }",
                "// Line 1115:       },",
                "// vulnerable line: 1116: type: 'bytes'",
                "// Line 1117:     })",
                "// Line 1118: ",
                "// Line 1119:     internalResponse.body.stream = byteStream",
                "// Line 1120:   }",
                "// Line 1121: }",
                "// Line 1122: ",
                "// Line 1123: // https://fetch.spec.whatwg.org/#http-fetch",
                "// Line 1124: async function httpFetch (fetchParams) {",
                "// Line 1125:   // 1. Let request be fetchParams’s request.",
                "// Line 1126:   const request = fetchParams.request",
                "// Line 1920: ",
                "// Line 1921:   // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object",
                "// Line 1922:   // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.",
                "// Line 1923:   // TODO",
                "// Line 1924: ",
                "// Line 1925:   // 15. Let stream be a new ReadableStream.",
                "// Line 1926:   // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,",
                "// Line 1927:   //     cancelAlgorithm set to cancelAlgorithm.",
                "// Line 1928:   const stream = new ReadableStream(",
                "// Line 1929:     {",
                "// vulnerable line: 1930: async start (controller) {",
                "// Line 1931:         fetchParams.controller.controller = controller",
                "// Line 1932:       },",
                "// Line 1933:       async pull (controller) {",
                "// Line 1934:         await pullAlgorithm(controller)",
                "// Line 1935:       },",
                "// Line 1936:       async cancel (reason) {",
                "// Line 1937:         await cancelAlgorithm(reason)",
                "// Line 1938:       },",
                "// vulnerable line: 1939: type: 'bytes'",
                "// Line 1940:     }",
                "// Line 1941:   )",
                "// Line 1942: ",
                "// Line 1943:   // 17. Run these steps, but abort when the ongoing fetch is terminated:",
                "// Line 1944: ",
                "// Line 1945:   //    1. Set response’s body to a new body whose stream is stream.",
                "// Line 1946:   response.body = { stream }",
                "// Line 1947: ",
                "// Line 1948:   //    2. If response is not a network error and request’s cache mode is",
                "// Line 1949:   //    not \"no-store\", then update response in httpCache for request.",
                "// Line 1958: ",
                "// Line 1959:   // 18. If aborted, then:",
                "// Line 1960:   // TODO",
                "// Line 1961: ",
                "// Line 1962:   // 19. Run these steps in parallel:",
                "// Line 1963: ",
                "// Line 1964:   //    1. Run these steps, but abort when fetchParams is canceled:",
                "// Line 1965:   fetchParams.controller.on('terminated', onAborted)",
                "// Line 1966:   fetchParams.controller.resume = async () => {",
                "// Line 1967:     // 1. While true",
                "// vulnerable line: 1968: while (true) {",
                "// Line 1969:       // 1-3. See onData...",
                "// Line 1970: ",
                "// Line 1971:       // 4. Set bytes to the result of handling content codings given",
                "// Line 1972:       // codings and bytes.",
                "// Line 1973:       let bytes",
                "// Line 1974:       let isFailure",
                "// Line 1975:       try {",
                "// Line 1976:         const { done, value } = await fetchParams.controller.next()",
                "// Line 1977: ",
                "// Line 1978:         if (isAborted(fetchParams)) {"
            ]
        }
    ]
}