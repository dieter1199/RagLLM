{
    "cve_id": "CVE-2024-35176",
    "cve_description": " REXML is an XML toolkit for Ruby. The REXML gem before 3.2.6 has a denial of service vulnerability when it parses an XML that has many `<`s in an attribute value. Those who need to parse untrusted XMLs may be impacted to this vulnerability. The REXML gem 3.2.7 or later include the patch to fix this vulnerability. As a workaround, don't parse untrusted XMLs.",
    "cve_publish_date": "2024-05-16T16:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Read quoted attributes in chunks (#126)",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "Gemfile",
            "code_language": "Ruby",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "baseparser.rb",
            "code_language": "Ruby",
            "number_of_lines_added_for_mitigation": "10",
            "number_of_lines_deleted_vulnerable_to_cve": "10",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 115: ",
                "// Line 116:       module Private",
                "// Line 117:         INSTRUCTION_END = /#{NAME}(\\s+.*?)?\\?>/um",
                "// Line 118:         TAG_PATTERN = /((?>#{QNAME_STR}))\\s*/um",
                "// Line 119:         CLOSE_PATTERN = /(#{QNAME_STR})\\s*>/um",
                "// Line 120:         ATTLISTDECL_END = /\\s+#{NAME}(?:#{ATTDEF})*\\s*>/um",
                "// Line 121:         NAME_PATTERN = /\\s*#{NAME}/um",
                "// Line 122:         GEDECL_PATTERN = \"\\s+#{NAME}\\s+#{ENTITYDEF}\\s*>\"",
                "// Line 123:         PEDECL_PATTERN = \"\\s+(%)\\s+#{NAME}\\s+#{PEDEF}\\s*>\"",
                "// Line 124:         ENTITYDECL_PATTERN = /(?:#{GEDECL_PATTERN})|(?:#{PEDECL_PATTERN})/um",
                "// vulnerable line: 125: end",
                "// Line 126:       private_constant :Private",
                "// Line 127:       include Private",
                "// Line 128: ",
                "// Line 129:       def initialize( source )",
                "// Line 130:         self.stream = source",
                "// Line 131:         @listeners = []",
                "// vulnerable line: 132: end",
                "// Line 133: ",
                "// Line 134:       def add_listener( listener )",
                "// Line 135:         @listeners << listener",
                "// vulnerable line: 136: end",
                "// Line 137: ",
                "// Line 138:       attr_reader :source",
                "// Line 139: ",
                "// Line 140:       def stream=( source )",
                "// Line 141:         @source = SourceFactory.create_from( source )",
                "// Line 142:         @closed = nil",
                "// Line 143:         @document_status = nil",
                "// Line 144:         @tags = []",
                "// Line 145:         @stack = []",
                "// Line 146:         @entities = []",
                "// Line 147:         @nsstack = []",
                "// vulnerable line: 148: end",
                "// Line 149: ",
                "// Line 150:       def position",
                "// Line 151:         if @source.respond_to? :position",
                "// Line 152:           @source.position",
                "// vulnerable line: 153: else",
                "// Line 154:           # FIXME",
                "// Line 155:           0",
                "// vulnerable line: 156: end",
                "// vulnerable line: 157: end",
                "// Line 158: ",
                "// Line 159:       # Returns true if there are no more events",
                "// Line 160:       def empty?",
                "// Line 161:         return (@source.empty? and @stack.empty?)",
                "// vulnerable line: 162: end",
                "// Line 163: ",
                "// Line 164:       # Returns true if there are more events.  Synonymous with !empty?",
                "// Line 165:       def has_next?",
                "// Line 166:         return !(@source.empty? and @stack.empty?)",
                "// vulnerable line: 167: end",
                "// Line 168: ",
                "// Line 169:       # Push an event back on the head of the stream.  This method",
                "// Line 170:       # has (theoretically) infinite depth.",
                "// Line 171:       def unshift token",
                "// Line 172:         @stack.unshift(token)",
                "// vulnerable line: 173: end",
                "// Line 174: ",
                "// Line 175:       # Peek at the +depth+ event in the stack.  The first element on the stack",
                "// Line 176:       # is at depth 0.  If +depth+ is -1, will parse to the end of the input",
                "// Line 177:       # stream and return the last event, which is always :end_document.",
                "// Line 178:       # Be aware that this causes the stream to be parsed up to the +depth+",
                "// Line 179:       # event, so you can effectively pre-parse the entire document (pull the",
                "// Line 180:       # entire thing into memory) using this method.",
                "// Line 181:       def peek depth=0",
                "// Line 182:         raise %Q[Illegal argument \"#{depth}\"] if depth < -1",
                "// Line 183:         temp = []",
                "// Line 184:         if depth == -1",
                "// Line 185:           temp.push(pull()) until empty?",
                "// vulnerable line: 186: else",
                "// Line 187:           while @stack.size+temp.size < depth+1",
                "// Line 188:             temp.push(pull())",
                "// vulnerable line: 189: end",
                "// vulnerable line: 190: end",
                "// Line 191:         @stack += temp if temp.size > 0",
                "// Line 192:         @stack[depth]",
                "// vulnerable line: 193: end",
                "// Line 194: ",
                "// Line 195:       # Returns the next event.  This is a +PullEvent+ object.",
                "// Line 196:       def pull",
                "// Line 197:         pull_event.tap do |event|",
                "// Line 198:           @listeners.each do |listener|",
                "// Line 199:             listener.receive event",
                "// vulnerable line: 200: end",
                "// vulnerable line: 201: end",
                "// vulnerable line: 202: end",
                "// Line 203: ",
                "// Line 204:       def pull_event",
                "// Line 205:         if @closed",
                "// Line 206:           x, @closed = @closed, nil",
                "// Line 207:           return [ :end_element, x ]",
                "// vulnerable line: 208: end",
                "// Line 209:         return [ :end_document ] if empty?",
                "// Line 210:         return @stack.shift if @stack.size > 0",
                "// Line 211:         #STDERR.puts @source.encoding",
                "// Line 212:         #STDERR.puts \"BUFFER = #{@source.buffer.inspect}\"",
                "// Line 213: ",
                "// Line 214:         @source.ensure_buffer",
                "// Line 215:         if @document_status == nil",
                "// Line 216:           start_position = @source.position",
                "// Line 217:           if @source.match(\"<?\", true)",
                "// Line 218:             return process_instruction(start_position)",
                "// Line 219:           elsif @source.match(\"<!\", true)",
                "// Line 220:             if @source.match(\"--\", true)",
                "// Line 221:               return [ :comment, @source.match(/(.*?)-->/um, true)[1] ]",
                "// Line 222:             elsif @source.match(\"DOCTYPE\", true)",
                "// Line 223:               base_error_message = \"Malformed DOCTYPE\"",
                "// Line 224:               unless @source.match(/\\s+/um, true)",
                "// Line 225:                 if @source.match(\">\")",
                "// Line 226:                   message = \"#{base_error_message}: name is missing\"",
                "// vulnerable line: 227: else",
                "// Line 228:                   message = \"#{base_error_message}: invalid name\"",
                "// vulnerable line: 229: end",
                "// Line 230:                 @source.position = start_position",
                "// vulnerable line: 231: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 232: end",
                "// Line 233:               @nsstack.unshift(curr_ns=Set.new)",
                "// Line 234:               name = parse_name(base_error_message)",
                "// Line 235:               if @source.match(/\\s*\\[/um, true)",
                "// Line 236:                 id = [nil, nil, nil]",
                "// Line 237:                 @document_status = :in_doctype",
                "// Line 238:               elsif @source.match(/\\s*>/um, true)",
                "// Line 239:                 id = [nil, nil, nil]",
                "// Line 240:                 @document_status = :after_doctype",
                "// Line 241:                 @source.ensure_buffer",
                "// vulnerable line: 242: else",
                "// Line 243:                 id = parse_id(base_error_message,",
                "// Line 244:                               accept_external_id: true,",
                "// Line 245:                               accept_public_id: false)",
                "// Line 246:                 if id[0] == \"SYSTEM\"",
                "// Line 247:                   # For backward compatibility",
                "// Line 248:                   id[1], id[2] = id[2], nil",
                "// vulnerable line: 249: end",
                "// Line 250:                 if @source.match(/\\s*\\[/um, true)",
                "// Line 251:                   @document_status = :in_doctype",
                "// Line 252:                 elsif @source.match(/\\s*>/um, true)",
                "// Line 253:                   @document_status = :after_doctype",
                "// Line 254:                   @source.ensure_buffer",
                "// vulnerable line: 255: else",
                "// Line 256:                   message = \"#{base_error_message}: garbage after external ID\"",
                "// vulnerable line: 257: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 258: end",
                "// vulnerable line: 259: end",
                "// Line 260:               args = [:start_doctype, name, *id]",
                "// Line 261:               if @document_status == :after_doctype",
                "// Line 262:                 @source.match(/\\s*/um, true)",
                "// Line 263:                 @stack << [ :end_doctype ]",
                "// vulnerable line: 264: end",
                "// Line 265:               return args",
                "// vulnerable line: 266: else",
                "// Line 267:               message = \"Invalid XML\"",
                "// vulnerable line: 268: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 269: end",
                "// vulnerable line: 270: end",
                "// vulnerable line: 271: end",
                "// Line 272:         if @document_status == :in_doctype",
                "// Line 273:           @source.match(/\\s*/um, true) # skip spaces",
                "// Line 274:           start_position = @source.position",
                "// Line 275:           if @source.match(\"<!\", true)",
                "// Line 276:             if @source.match(\"ELEMENT\", true)",
                "// Line 277:               md = @source.match(/(.*?)>/um, true)",
                "// Line 278:               raise REXML::ParseException.new( \"Bad ELEMENT declaration!\", @source ) if md.nil?",
                "// Line 279:               return [ :elementdecl, \"<!ELEMENT\" + md[1] ]",
                "// Line 280:             elsif @source.match(\"ENTITY\", true)",
                "// Line 281:               match = [:entitydecl, *@source.match(ENTITYDECL_PATTERN, true).captures.compact]",
                "// Line 282:               ref = false",
                "// Line 283:               if match[1] == '%'",
                "// Line 284:                 ref = true",
                "// Line 285:                 match.delete_at 1",
                "// vulnerable line: 286: end",
                "// Line 287:               # Now we have to sort out what kind of entity reference this is",
                "// Line 288:               if match[2] == 'SYSTEM'",
                "// Line 289:                 # External reference",
                "// Line 290:                 match[3] = match[3][1..-2] # PUBID",
                "// Line 291:                 match.delete_at(4) if match.size > 4 # Chop out NDATA decl",
                "// Line 292:                 # match is [ :entity, name, SYSTEM, pubid(, ndata)? ]",
                "// Line 293:               elsif match[2] == 'PUBLIC'",
                "// Line 294:                 # External reference",
                "// Line 295:                 match[3] = match[3][1..-2] # PUBID",
                "// Line 296:                 match[4] = match[4][1..-2] # HREF",
                "// Line 297:                 match.delete_at(5) if match.size > 5 # Chop out NDATA decl",
                "// Line 298:                 # match is [ :entity, name, PUBLIC, pubid, href(, ndata)? ]",
                "// vulnerable line: 299: else",
                "// Line 300:                 match[2] = match[2][1..-2]",
                "// Line 301:                 match.pop if match.size == 4",
                "// Line 302:                 # match is [ :entity, name, value ]",
                "// vulnerable line: 303: end",
                "// Line 304:               match << '%' if ref",
                "// Line 305:               return match",
                "// Line 306:             elsif @source.match(\"ATTLIST\", true)",
                "// Line 307:               md = @source.match(ATTLISTDECL_END, true)",
                "// Line 308:               raise REXML::ParseException.new( \"Bad ATTLIST declaration!\", @source ) if md.nil?",
                "// Line 309:               element = md[1]",
                "// Line 310:               contents = md[0]",
                "// Line 311: ",
                "// Line 312:               pairs = {}",
                "// Line 313:               values = md[0].scan( ATTDEF_RE )",
                "// Line 314:               values.each do |attdef|",
                "// Line 315:                 unless attdef[3] == \"#IMPLIED\"",
                "// Line 316:                   attdef.compact!",
                "// Line 317:                   val = attdef[3]",
                "// Line 318:                   val = attdef[4] if val == \"#FIXED \"",
                "// Line 319:                   pairs[attdef[0]] = val",
                "// Line 320:                   if attdef[0] =~ /^xmlns:(.*)/",
                "// Line 321:                     @nsstack[0] << $1",
                "// vulnerable line: 322: end",
                "// vulnerable line: 323: end",
                "// vulnerable line: 324: end",
                "// Line 325:               return [ :attlistdecl, element, pairs, contents ]",
                "// Line 326:             elsif @source.match(\"NOTATION\", true)",
                "// Line 327:               base_error_message = \"Malformed notation declaration\"",
                "// Line 328:               unless @source.match(/\\s+/um, true)",
                "// Line 329:                 if @source.match(\">\")",
                "// Line 330:                   message = \"#{base_error_message}: name is missing\"",
                "// vulnerable line: 331: else",
                "// Line 332:                   message = \"#{base_error_message}: invalid name\"",
                "// vulnerable line: 333: end",
                "// Line 334:                 @source.position = start_position",
                "// vulnerable line: 335: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 336: end",
                "// Line 337:               name = parse_name(base_error_message)",
                "// Line 338:               id = parse_id(base_error_message,",
                "// Line 339:                             accept_external_id: true,",
                "// Line 340:                             accept_public_id: true)",
                "// Line 341:               unless @source.match(/\\s*>/um, true)",
                "// Line 342:                 message = \"#{base_error_message}: garbage before end >\"",
                "// vulnerable line: 343: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 344: end",
                "// Line 345:               return [:notationdecl, name, *id]",
                "// Line 346:             elsif md = @source.match(/--(.*?)-->/um, true)",
                "// Line 347:               case md[1]",
                "// Line 348:               when /--/, /-\\z/",
                "// Line 349:                 raise REXML::ParseException.new(\"Malformed comment\", @source)",
                "// vulnerable line: 350: end",
                "// Line 351:               return [ :comment, md[1] ] if md",
                "// vulnerable line: 352: end",
                "// Line 353:           elsif match = @source.match(/(%.*?;)\\s*/um, true)",
                "// Line 354:             return [ :externalentity, match[1] ]",
                "// Line 355:           elsif @source.match(/\\]\\s*>/um, true)",
                "// Line 356:             @document_status = :after_doctype",
                "// Line 357:             return [ :end_doctype ]",
                "// vulnerable line: 358: end",
                "// vulnerable line: 359: end",
                "// Line 360:         if @document_status == :after_doctype",
                "// Line 361:           @source.match(/\\s*/um, true)",
                "// vulnerable line: 362: end",
                "// Line 363:         begin",
                "// Line 364:           start_position = @source.position",
                "// Line 365:           if @source.match(\"<\", true)",
                "// Line 366:             if @source.match(\"/\", true)",
                "// Line 367:               @nsstack.shift",
                "// Line 368:               last_tag = @tags.pop",
                "// Line 369:               md = @source.match(CLOSE_PATTERN, true)",
                "// Line 370:               if md and !last_tag",
                "// Line 371:                 message = \"Unexpected top-level end tag (got '#{md[1]}')\"",
                "// vulnerable line: 372: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 373: end",
                "// Line 374:               if md.nil? or last_tag != md[1]",
                "// Line 375:                 message = \"Missing end tag for '#{last_tag}'\"",
                "// Line 376:                 message += \" (got '#{md[1]}')\" if md",
                "// Line 377:                 @source.position = start_position if md.nil?",
                "// vulnerable line: 378: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 379: end",
                "// Line 380:               return [ :end_element, last_tag ]",
                "// Line 381:             elsif @source.match(\"!\", true)",
                "// Line 382:               md = @source.match(/([^>]*>)/um)",
                "// Line 383:               #STDERR.puts \"SOURCE BUFFER = #{source.buffer}, #{source.buffer.size}\"",
                "// Line 384:               raise REXML::ParseException.new(\"Malformed node\", @source) unless md",
                "// Line 385:               if md[0][0] == ?-",
                "// Line 386:                 md = @source.match(/--(.*?)-->/um, true)",
                "// Line 387: ",
                "// Line 388:                 case md[1]",
                "// Line 389:                 when /--/, /-\\z/",
                "// Line 390:                   raise REXML::ParseException.new(\"Malformed comment\", @source)",
                "// vulnerable line: 391: end",
                "// Line 392: ",
                "// Line 393:                 return [ :comment, md[1] ] if md",
                "// vulnerable line: 394: else",
                "// Line 395:                 md = @source.match(/\\[CDATA\\[(.*?)\\]\\]>/um, true)",
                "// Line 396:                 return [ :cdata, md[1] ] if md",
                "// vulnerable line: 397: end",
                "// Line 398:               raise REXML::ParseException.new( \"Declarations can only occur \"+",
                "// Line 399:                 \"in the doctype declaration.\", @source)",
                "// Line 400:             elsif @source.match(\"?\", true)",
                "// Line 401:               return process_instruction(start_position)",
                "// vulnerable line: 402: else",
                "// Line 403:               # Get the next tag",
                "// Line 404:               md = @source.match(TAG_PATTERN, true)",
                "// Line 405:               unless md",
                "// Line 406:                 @source.position = start_position",
                "// Line 407:                 raise REXML::ParseException.new(\"malformed XML: missing tag start\", @source)",
                "// vulnerable line: 408: end",
                "// Line 409:               tag = md[1]",
                "// Line 410:               @document_status = :in_element",
                "// Line 411:               prefixes = Set.new",
                "// Line 412:               prefixes << md[2] if md[2]",
                "// Line 413:               @nsstack.unshift(curr_ns=Set.new)",
                "// Line 414:               attributes, closed = parse_attributes(prefixes, curr_ns)",
                "// Line 415:               # Verify that all of the prefixes have been defined",
                "// Line 416:               for prefix in prefixes",
                "// Line 417:                 unless @nsstack.find{|k| k.member?(prefix)}",
                "// Line 418:                   raise UndefinedNamespaceException.new(prefix,@source,self)",
                "// vulnerable line: 419: end",
                "// vulnerable line: 420: end",
                "// Line 421: ",
                "// Line 422:               if closed",
                "// Line 423:                 @closed = tag",
                "// Line 424:                 @nsstack.shift",
                "// vulnerable line: 425: else",
                "// Line 426:                 @tags.push( tag )",
                "// vulnerable line: 427: end",
                "// Line 428:               return [ :start_element, tag, attributes ]",
                "// vulnerable line: 429: end",
                "// vulnerable line: 430: else",
                "// Line 431:             md = @source.match(/([^<]*)/um, true)",
                "// Line 432:             text = md[1]",
                "// Line 433:             return [ :text, text ]",
                "// vulnerable line: 434: end",
                "// Line 435:         rescue REXML::UndefinedNamespaceException",
                "// Line 436:           raise",
                "// Line 437:         rescue REXML::ParseException",
                "// Line 438:           raise",
                "// Line 439:         rescue => error",
                "// Line 440:           raise REXML::ParseException.new( \"Exception parsing\",",
                "// Line 441:             @source, self, (error ? error : $!) )",
                "// vulnerable line: 442: end",
                "// Line 443:         return [ :dummy ]",
                "// vulnerable line: 444: end",
                "// Line 445:       private :pull_event",
                "// Line 446: ",
                "// Line 447:       def entity( reference, entities )",
                "// Line 448:         value = nil",
                "// Line 449:         value = entities[ reference ] if entities",
                "// Line 450:         if not value",
                "// Line 451:           value = DEFAULT_ENTITIES[ reference ]",
                "// Line 452:           value = value[2] if value",
                "// vulnerable line: 453: end",
                "// Line 454:         unnormalize( value, entities ) if value",
                "// vulnerable line: 455: end",
                "// Line 456: ",
                "// Line 457:       # Escapes all possible entities",
                "// Line 458:       def normalize( input, entities=nil, entity_filter=nil )",
                "// Line 459:         copy = input.clone",
                "// Line 460:         # Doing it like this rather than in a loop improves the speed",
                "// Line 461:         copy.gsub!( EREFERENCE, '&amp;' )",
                "// Line 462:         entities.each do |key, value|",
                "// Line 463:           copy.gsub!( value, \"&#{key};\" ) unless entity_filter and",
                "// Line 464:                                       entity_filter.include?(entity)",
                "// Line 465:         end if entities",
                "// Line 466:         copy.gsub!( EREFERENCE, '&amp;' )",
                "// Line 467:         DEFAULT_ENTITIES.each do |key, value|",
                "// Line 468:           copy.gsub!( value[3], value[1] )",
                "// vulnerable line: 469: end",
                "// Line 470:         copy",
                "// vulnerable line: 471: end",
                "// Line 472: ",
                "// Line 473:       # Unescapes all possible entities",
                "// Line 474:       def unnormalize( string, entities=nil, filter=nil )",
                "// Line 475:         rv = string.gsub( /",
                "// Line 476: ?/, \"",
                "// Line 477: \" )",
                "// Line 478:         matches = rv.scan( REFERENCE_RE )",
                "// Line 479:         return rv if matches.size == 0",
                "// Line 480:         rv.gsub!( /&#0*((?:\\d+)|(?:x[a-fA-F0-9]+));/ ) {",
                "// Line 481:           m=$1",
                "// Line 483:           [Integer(m)].pack('U*')",
                "// Line 484:         }",
                "// Line 485:         matches.collect!{|x|x[0]}.compact!",
                "// Line 486:         if matches.size > 0",
                "// Line 487:           matches.each do |entity_reference|",
                "// Line 488:             unless filter and filter.include?(entity_reference)",
                "// Line 489:               entity_value = entity( entity_reference, entities )",
                "// Line 490:               if entity_value",
                "// Line 491:                 re = /&#{entity_reference};/",
                "// Line 492:                 rv.gsub!( re, entity_value )",
                "// vulnerable line: 493: else",
                "// Line 494:                 er = DEFAULT_ENTITIES[entity_reference]",
                "// Line 495:                 rv.gsub!( er[0], er[2] ) if er",
                "// vulnerable line: 496: end",
                "// vulnerable line: 497: end",
                "// vulnerable line: 498: end",
                "// Line 499:           rv.gsub!( /&amp;/, '&' )",
                "// vulnerable line: 500: end",
                "// Line 501:         rv",
                "// vulnerable line: 502: end",
                "// Line 503: ",
                "// Line 504:       private",
                "// Line 505:       def need_source_encoding_update?(xml_declaration_encoding)",
                "// Line 506:         return false if xml_declaration_encoding.nil?",
                "// Line 507:         return false if /\\AUTF-16\\z/i =~ xml_declaration_encoding",
                "// Line 508:         true",
                "// vulnerable line: 509: end",
                "// Line 510: ",
                "// Line 511:       def parse_name(base_error_message)",
                "// Line 512:         md = @source.match(NAME_PATTERN, true)",
                "// Line 513:         unless md",
                "// Line 514:           if @source.match(/\\s*\\S/um)",
                "// Line 515:             message = \"#{base_error_message}: invalid name\"",
                "// vulnerable line: 516: else",
                "// Line 517:             message = \"#{base_error_message}: name is missing\"",
                "// vulnerable line: 518: end",
                "// vulnerable line: 519: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 520: end",
                "// Line 521:         md[1]",
                "// vulnerable line: 522: end",
                "// Line 523: ",
                "// Line 524:       def parse_id(base_error_message,",
                "// Line 525:                    accept_external_id:,",
                "// Line 526:                    accept_public_id:)",
                "// Line 527:         if accept_external_id and (md = @source.match(EXTERNAL_ID_PUBLIC, true))",
                "// Line 528:           pubid = system = nil",
                "// Line 529:           pubid_literal = md[1]",
                "// Line 530:           pubid = pubid_literal[1..-2] if pubid_literal # Remove quote",
                "// Line 531:           system_literal = md[2]",
                "// Line 532:           system = system_literal[1..-2] if system_literal # Remove quote",
                "// Line 534:         elsif accept_public_id and (md = @source.match(PUBLIC_ID, true))",
                "// Line 535:           pubid = system = nil",
                "// Line 536:           pubid_literal = md[1]",
                "// Line 537:           pubid = pubid_literal[1..-2] if pubid_literal # Remove quote",
                "// Line 538:           [\"PUBLIC\", pubid, nil]",
                "// Line 539:         elsif accept_external_id and (md = @source.match(EXTERNAL_ID_SYSTEM, true))",
                "// Line 540:           system = nil",
                "// Line 541:           system_literal = md[1]",
                "// Line 542:           system = system_literal[1..-2] if system_literal # Remove quote",
                "// Line 543:           [\"SYSTEM\", nil, system]",
                "// vulnerable line: 544: else",
                "// Line 545:           details = parse_id_invalid_details(accept_external_id: accept_external_id,",
                "// Line 546:                                              accept_public_id: accept_public_id)",
                "// Line 547:           message = \"#{base_error_message}: #{details}\"",
                "// vulnerable line: 548: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 549: end",
                "// vulnerable line: 550: end",
                "// Line 551: ",
                "// Line 552:       def parse_id_invalid_details(accept_external_id:,",
                "// Line 553:                                    accept_public_id:)",
                "// Line 554:         public = /\\A\\s*PUBLIC/um",
                "// Line 555:         system = /\\A\\s*SYSTEM/um",
                "// Line 556:         if (accept_external_id or accept_public_id) and @source.match(/#{public}/um)",
                "// Line 557:           if @source.match(/#{public}(?:\\s+[^'\"]|\\s*[\\[>])/um)",
                "// Line 558:             return \"public ID literal is missing\"",
                "// vulnerable line: 559: end",
                "// Line 560:           unless @source.match(/#{public}\\s+#{PUBIDLITERAL}/um)",
                "// Line 561:             return \"invalid public ID literal\"",
                "// vulnerable line: 562: end",
                "// Line 563:           if accept_public_id",
                "// Line 564:             if @source.match(/#{public}\\s+#{PUBIDLITERAL}\\s+[^'\"]/um)",
                "// Line 565:               return \"system ID literal is missing\"",
                "// vulnerable line: 566: end",
                "// Line 567:             unless @source.match(/#{public}\\s+#{PUBIDLITERAL}\\s+#{SYSTEMLITERAL}/um)",
                "// Line 568:               return \"invalid system literal\"",
                "// vulnerable line: 569: end",
                "// Line 570:             \"garbage after system literal\"",
                "// vulnerable line: 571: else",
                "// Line 572:             \"garbage after public ID literal\"",
                "// vulnerable line: 573: end",
                "// Line 574:         elsif accept_external_id and @source.match(/#{system}/um)",
                "// Line 575:           if @source.match(/#{system}(?:\\s+[^'\"]|\\s*[\\[>])/um)",
                "// Line 576:             return \"system literal is missing\"",
                "// vulnerable line: 577: end",
                "// Line 578:           unless @source.match(/#{system}\\s+#{SYSTEMLITERAL}/um)",
                "// Line 579:             return \"invalid system literal\"",
                "// vulnerable line: 580: end",
                "// Line 581:           \"garbage after system literal\"",
                "// vulnerable line: 582: else",
                "// Line 583:           unless @source.match(/\\A\\s*(?:PUBLIC|SYSTEM)\\s/um)",
                "// Line 584:             return \"invalid ID type\"",
                "// vulnerable line: 585: end",
                "// Line 586:           \"ID type is missing\"",
                "// vulnerable line: 587: end",
                "// vulnerable line: 588: end",
                "// Line 589: ",
                "// Line 590:       def process_instruction(start_position)",
                "// Line 591:         match_data = @source.match(INSTRUCTION_END, true)",
                "// Line 592:         unless match_data",
                "// Line 593:           message = \"Invalid processing instruction node\"",
                "// Line 594:           @source.position = start_position",
                "// vulnerable line: 595: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 596: end",
                "// Line 597:         if @document_status.nil? and match_data[1] == \"xml\"",
                "// Line 598:           content = match_data[2]",
                "// Line 599:           version = VERSION.match(content)",
                "// Line 600:           version = version[1] unless version.nil?",
                "// Line 601:           encoding = ENCODING.match(content)",
                "// Line 602:           encoding = encoding[1] unless encoding.nil?",
                "// Line 603:           if need_source_encoding_update?(encoding)",
                "// Line 604:             @source.encoding = encoding",
                "// vulnerable line: 605: end",
                "// Line 606:           if encoding.nil? and /\\AUTF-16(?:BE|LE)\\z/i =~ @source.encoding",
                "// Line 607:             encoding = \"UTF-16\"",
                "// vulnerable line: 608: end",
                "// Line 609:           standalone = STANDALONE.match(content)",
                "// Line 610:           standalone = standalone[1] unless standalone.nil?",
                "// Line 611:           return [ :xmldecl, version, encoding, standalone ]",
                "// vulnerable line: 612: end",
                "// Line 613:         [:processing_instruction, match_data[1], match_data[2]]",
                "// vulnerable line: 614: end",
                "// Line 615: ",
                "// Line 616:       def parse_attributes(prefixes, curr_ns)",
                "// Line 617:         attributes = {}",
                "// Line 618:         closed = false",
                "// Line 619:         while true",
                "// Line 620:           if @source.match(\">\", true)",
                "// Line 621:             return attributes, closed",
                "// Line 622:           elsif @source.match(\"/>\", true)",
                "// Line 623:             closed = true",
                "// Line 624:             return attributes, closed",
                "// Line 625:           elsif match = @source.match(QNAME, true)",
                "// Line 626:             name = match[1]",
                "// Line 627:             prefix = match[2]",
                "// Line 628:             local_part = match[3]",
                "// Line 629: ",
                "// Line 630:             unless @source.match(/\\s*=\\s*/um, true)",
                "// Line 631:               message = \"Missing attribute equal: <#{name}>\"",
                "// vulnerable line: 632: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 633: end",
                "// Line 634:             unless match = @source.match(/(['\"])(.*?)\u0001\\s*/um, true)",
                "// vulnerable line: 635: if match = @source.match(/(['\"])/, true)",
                "// vulnerable line: 636: message =",
                "// vulnerable line: 637: \"Missing attribute value end quote: <#{name}>: <#{match[1]}>\"",
                "// vulnerable line: 638: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 639: else",
                "// vulnerable line: 640: message = \"Missing attribute value start quote: <#{name}>\"",
                "// vulnerable line: 641: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 642: end",
                "// vulnerable line: 643: end",
                "// vulnerable line: 644: value = match[2]",
                "// Line 645:             if prefix == \"xmlns\"",
                "// Line 646:               if local_part == \"xml\"",
                "// Line 647:                 if value != \"http://www.w3.org/XML/1998/namespace\"",
                "// Line 648:                   msg = \"The 'xml' prefix must not be bound to any other namespace \"+",
                "// Line 649:                     \"(http://www.w3.org/TR/REC-xml-names/#ns-decl)\"",
                "// Line 650:                   raise REXML::ParseException.new( msg, @source, self )",
                "// vulnerable line: 651: end",
                "// Line 652:               elsif local_part == \"xmlns\"",
                "// Line 653:                 msg = \"The 'xmlns' prefix must not be declared \"+",
                "// Line 654:                   \"(http://www.w3.org/TR/REC-xml-names/#ns-decl)\"",
                "// Line 655:                 raise REXML::ParseException.new( msg, @source, self)",
                "// vulnerable line: 656: end",
                "// Line 657:               curr_ns << local_part",
                "// Line 658:             elsif prefix",
                "// Line 659:               prefixes << prefix unless prefix == \"xml\"",
                "// vulnerable line: 660: end",
                "// Line 661: ",
                "// Line 662:             if attributes[name]",
                "// Line 663:               msg = \"Duplicate attribute #{name.inspect}\"",
                "// Line 664:               raise REXML::ParseException.new(msg, @source, self)",
                "// vulnerable line: 665: end",
                "// Line 666: ",
                "// Line 667:             attributes[name] = value",
                "// vulnerable line: 668: else",
                "// Line 669:             message = \"Invalid attribute name: <#{@source.buffer.split(%r{[/>\\s]}).first}>\"",
                "// vulnerable line: 670: raise REXML::ParseException.new(message, @source)",
                "// vulnerable line: 671: end",
                "// vulnerable line: 672: end",
                "// vulnerable line: 673: end",
                "// vulnerable line: 674: end",
                "// vulnerable line: 675: end",
                "// vulnerable line: 676: end",
                "// Line 677: ",
                "// Line 678: =begin",
                "// Line 679:   case event[0]",
                "// Line 680:   when :start_element",
                "// Line 681:   when :text",
                "// Line 682:   when :end_element",
                "// Line 683:   when :processing_instruction",
                "// Line 684:   when :cdata",
                "// Line 685:   when :comment",
                "// Line 686:   when :xmldecl",
                "// Line 687:   when :start_doctype",
                "// Line 688:   when :end_doctype",
                "// Line 689:   when :externalentity",
                "// Line 690:   when :elementdecl",
                "// Line 691:   when :entity",
                "// Line 692:   when :attlistdecl",
                "// Line 693:   when :notationdecl",
                "// Line 694:   when :end_doctype",
                "// vulnerable line: 695: end",
                "// Line 696: =end"
            ]
        },
        {
            "filename_of_changes": "source.rb",
            "code_language": "Ruby",
            "number_of_lines_added_for_mitigation": "24",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 59:       @scanner.string.force_encoding(encoding)",
                "// Line 60:     end",
                "// Line 61: ",
                "// Line 62:     # Inherited from Encoding",
                "// Line 63:     # Overridden to support optimized en/decoding",
                "// Line 64:     def encoding=(enc)",
                "// Line 65:       return unless super",
                "// Line 66:       encoding_updated",
                "// Line 67:     end",
                "// Line 68: ",
                "// vulnerable line: 69: def read",
                "// Line 70:     end",
                "// Line 71: ",
                "// Line 72:     def ensure_buffer",
                "// Line 73:     end",
                "// Line 74: ",
                "// Line 75:     def match(pattern, cons=false)",
                "// Line 76:       if cons",
                "// Line 77:         @scanner.scan(pattern).nil? ? nil : @scanner",
                "// Line 78:       else",
                "// Line 79:         @scanner.check(pattern).nil? ? nil : @scanner",
                "// Line 152:       if !@to_utf and",
                "// Line 153:           @orig.respond_to?(:force_encoding) and",
                "// Line 154:           @source.respond_to?(:external_encoding) and",
                "// Line 155:           @source.external_encoding != ::Encoding::UTF_8",
                "// Line 156:         @force_utf8 = true",
                "// Line 157:       else",
                "// Line 158:         @force_utf8 = false",
                "// Line 159:       end",
                "// Line 160:     end",
                "// Line 161: ",
                "// vulnerable line: 162: def read",
                "// Line 163:       begin",
                "// vulnerable line: 164: @scanner << readline",
                "// Line 165:         true",
                "// Line 166:       rescue Exception, NameError",
                "// Line 167:         @source = nil",
                "// Line 168:         false",
                "// Line 169:       end",
                "// Line 170:     end",
                "// Line 171: ",
                "// Line 172:     def ensure_buffer",
                "// Line 173:       read if @scanner.eos? && @source",
                "// Line 174:     end",
                "// Line 213:         end",
                "// Line 214:         @er_source.seek(pos)",
                "// Line 215:       rescue IOError",
                "// Line 216:         pos = -1",
                "// Line 217:         line = -1",
                "// Line 218:       end",
                "// Line 219:       [pos, lineno, line]",
                "// Line 220:     end",
                "// Line 221: ",
                "// Line 222:     private",
                "// vulnerable line: 223: def readline",
                "// vulnerable line: 224: str = @source.readline(@line_break)",
                "// Line 225:       if @pending_buffer",
                "// Line 226:         if str.nil?",
                "// Line 227:           str = @pending_buffer",
                "// Line 228:         else",
                "// Line 229:           str = @pending_buffer + str",
                "// Line 230:         end",
                "// Line 231:         @pending_buffer = nil",
                "// Line 232:       end",
                "// Line 233:       return nil if str.nil?",
                "// Line 234: "
            ]
        },
        {
            "filename_of_changes": "test_document.rb",
            "code_language": "Ruby",
            "number_of_lines_added_for_mitigation": "11",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}