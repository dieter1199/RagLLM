{
    "cve_id": "CVE-2024-38372",
    "cve_description": "Undici is an HTTP/1.1 client, written from scratch for Node.js. Depending on network and process conditions of a `fetch()` request, `response.arrayBuffer()` might include portion of memory from the Node.js process. This has been patched in v6.19.2.",
    "cve_publish_date": "2024-07-08T21:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "perf: avoid unnecessary clone (#3117)\n\n* perf(fetch): improve body mixin methods\r\n\r\n* perf: avoid unnecessary clone",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "body.js",
            "code_language": "JavaScript",
            "number_of_lines_added_for_mitigation": "11",
            "number_of_lines_deleted_vulnerable_to_cve": "9",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 316: ",
                "// Line 317:         if (mimeType === null) {",
                "// Line 318:           mimeType = ''",
                "// Line 319:         } else if (mimeType) {",
                "// Line 320:           mimeType = serializeAMimeType(mimeType)",
                "// Line 321:         }",
                "// Line 322: ",
                "// Line 323:         // Return a Blob whose contents are bytes and type attribute",
                "// Line 324:         // is mimeType.",
                "// Line 325:         return new Blob([bytes], { type: mimeType })",
                "// vulnerable line: 326: }, instance)",
                "// Line 327:     },",
                "// Line 328: ",
                "// Line 329:     arrayBuffer () {",
                "// Line 330:       // The arrayBuffer() method steps are to return the result",
                "// Line 331:       // of running consume body with this and the following step",
                "// Line 332:       // given a byte sequence bytes: return a new ArrayBuffer",
                "// Line 333:       // whose contents are bytes.",
                "// Line 334:       return consumeBody(this, (bytes) => {",
                "// vulnerable line: 335: return new Uint8Array(bytes).buffer",
                "// vulnerable line: 336: }, instance)",
                "// Line 337:     },",
                "// Line 338: ",
                "// Line 339:     text () {",
                "// Line 340:       // The text() method steps are to return the result of running",
                "// Line 341:       // consume body with this and UTF-8 decode.",
                "// vulnerable line: 342: return consumeBody(this, utf8DecodeBytes, instance)",
                "// Line 343:     },",
                "// Line 344: ",
                "// Line 345:     json () {",
                "// Line 346:       // The json() method steps are to return the result of running",
                "// Line 347:       // consume body with this and parse JSON from bytes.",
                "// vulnerable line: 348: return consumeBody(this, parseJSONFromBytes, instance)",
                "// Line 349:     },",
                "// Line 350: ",
                "// Line 351:     formData () {",
                "// Line 352:       // The formData() method steps are to return the result of running",
                "// Line 353:       // consume body with this and the following step given a byte sequence bytes:",
                "// Line 354:       return consumeBody(this, (value) => {",
                "// Line 355:         // 1. Let mimeType be the result of get the MIME type with this.",
                "// Line 356:         const mimeType = bodyMimeType(this)",
                "// Line 357: ",
                "// Line 358:         // 2. If mimeType is non-null, then switch on mimeType’s essence and run",
                "// Line 390: ",
                "// Line 391:               return fd",
                "// Line 392:             }",
                "// Line 393:           }",
                "// Line 394:         }",
                "// Line 395: ",
                "// Line 396:         // 3. Throw a TypeError.",
                "// Line 397:         throw new TypeError(",
                "// Line 398:           'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'",
                "// Line 399:         )",
                "// vulnerable line: 400: }, instance)",
                "// Line 401:     }",
                "// Line 402:   }",
                "// Line 403: ",
                "// Line 404:   return methods",
                "// Line 405: }",
                "// Line 406: ",
                "// Line 407: function mixinBody (prototype) {",
                "// Line 408:   Object.assign(prototype.prototype, bodyMixinMethods(prototype))",
                "// Line 409: }",
                "// Line 410: ",
                "// Line 411: /**",
                "// Line 412:  * @see https://fetch.spec.whatwg.org/#concept-body-consume-body",
                "// Line 413:  * @param {Response|Request} object",
                "// Line 414:  * @param {(value: unknown) => unknown} convertBytesToJSValue",
                "// Line 415:  * @param {Response|Request} instance",
                "// Line 416:  */",
                "// vulnerable line: 417: async function consumeBody (object, convertBytesToJSValue, instance) {",
                "// Line 418:   webidl.brandCheck(object, instance)",
                "// Line 419: ",
                "// Line 420:   // 1. If object is unusable, then return a promise rejected",
                "// Line 421:   //    with a TypeError.",
                "// Line 422:   if (bodyUnusable(object[kState].body)) {",
                "// Line 423:     throw new TypeError('Body is unusable')",
                "// Line 424:   }",
                "// Line 425: ",
                "// Line 426:   throwIfAborted(object[kState])",
                "// Line 427: ",
                "// Line 439:     try {",
                "// Line 440:       promise.resolve(convertBytesToJSValue(data))",
                "// Line 441:     } catch (e) {",
                "// Line 442:       errorSteps(e)",
                "// Line 443:     }",
                "// Line 444:   }",
                "// Line 445: ",
                "// Line 446:   // 5. If object’s body is null, then run successSteps with an",
                "// Line 447:   //    empty byte sequence.",
                "// Line 448:   if (object[kState].body == null) {",
                "// vulnerable line: 449: successSteps(new Uint8Array())",
                "// Line 450:     return promise.promise",
                "// Line 451:   }",
                "// Line 452: ",
                "// Line 453:   // 6. Otherwise, fully read object’s body given successSteps,",
                "// Line 454:   //    errorSteps, and object’s relevant global object.",
                "// vulnerable line: 455: await fullyReadBody(object[kState].body, successSteps, errorSteps)",
                "// Line 456: ",
                "// Line 457:   // 7. Return promise.",
                "// Line 458:   return promise.promise",
                "// Line 459: }",
                "// Line 460: ",
                "// Line 461: // https://fetch.spec.whatwg.org/#body-unusable",
                "// Line 462: function bodyUnusable (body) {",
                "// Line 463:   // An object including the Body interface mixin is",
                "// Line 464:   // said to be unusable if its body is non-null and",
                "// Line 465:   // its body’s stream is disturbed or locked."
            ]
        },
        {
            "filename_of_changes": "util.js",
            "code_language": "JavaScript",
            "number_of_lines_added_for_mitigation": "11",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1038:       enumerable: false,",
                "// Line 1039:       configurable: true,",
                "// Line 1040:       value: properties.entries.value",
                "// Line 1041:     }",
                "// Line 1042:   })",
                "// Line 1043: }",
                "// Line 1044: ",
                "// Line 1045: /**",
                "// Line 1046:  * @see https://fetch.spec.whatwg.org/#body-fully-read",
                "// Line 1047:  */",
                "// vulnerable line: 1048: async function fullyReadBody (body, processBody, processBodyError) {",
                "// Line 1049:   // 1. If taskDestination is null, then set taskDestination to",
                "// Line 1050:   //    the result of starting a new parallel queue.",
                "// Line 1051: ",
                "// Line 1052:   // 2. Let successSteps given a byte sequence bytes be to queue a",
                "// Line 1053:   //    fetch task to run processBody given bytes, with taskDestination.",
                "// Line 1054:   const successSteps = processBody",
                "// Line 1055: ",
                "// Line 1056:   // 3. Let errorSteps be to queue a fetch task to run processBodyError,",
                "// Line 1057:   //    with taskDestination.",
                "// Line 1058:   const errorSteps = processBodyError",
                "// Line 1064: ",
                "// Line 1065:   try {",
                "// Line 1066:     reader = body.stream.getReader()",
                "// Line 1067:   } catch (e) {",
                "// Line 1068:     errorSteps(e)",
                "// Line 1069:     return",
                "// Line 1070:   }",
                "// Line 1071: ",
                "// Line 1072:   // 5. Read all bytes from reader, given successSteps and errorSteps.",
                "// Line 1073:   try {",
                "// vulnerable line: 1074: const result = await readAllBytes(reader)",
                "// vulnerable line: 1075: successSteps(result)",
                "// Line 1076:   } catch (e) {",
                "// Line 1077:     errorSteps(e)",
                "// Line 1078:   }",
                "// Line 1079: }",
                "// Line 1080: ",
                "// Line 1081: function isReadableStreamLike (stream) {",
                "// Line 1082:   return stream instanceof ReadableStream || (",
                "// Line 1083:     stream[Symbol.toStringTag] === 'ReadableStream' &&",
                "// Line 1084:     typeof stream.tee === 'function'",
                "// Line 1085:   )",
                "// Line 1114:   //    point length and whose bytes have the same values as the",
                "// Line 1115:   //    values of input’s code points, in the same order",
                "// Line 1116:   return input",
                "// Line 1117: }",
                "// Line 1118: ",
                "// Line 1119: /**",
                "// Line 1120:  * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes",
                "// Line 1121:  * @see https://streams.spec.whatwg.org/#read-loop",
                "// Line 1122:  * @param {ReadableStreamDefaultReader} reader",
                "// Line 1123:  */",
                "// vulnerable line: 1124: async function readAllBytes (reader) {",
                "// Line 1125:   const bytes = []",
                "// Line 1126:   let byteLength = 0",
                "// Line 1127: ",
                "// Line 1128:   while (true) {",
                "// Line 1129:     const { done, value: chunk } = await reader.read()",
                "// Line 1130: ",
                "// Line 1131:     if (done) {",
                "// Line 1132:       // 1. Call successSteps with bytes.",
                "// Line 1133:       return Buffer.concat(bytes, byteLength)",
                "// Line 1134:     }"
            ]
        }
    ]
}