{
    "cve_id": "CVE-2024-36107",
    "cve_description": "MinIO is a High Performance Object Storage released under GNU Affero General Public License v3.0. `If-Modified-Since` and `If-Unmodified-Since` headers when used with anonymous requests by sending a random object name requests can be used to determine if an object exists or not on the server on a specific bucket and also gain access to some amount of\ninformation such as  `Last-Modified (of the latest version)`, `Etag (of the latest version)`, `x-amz-version-id (of the latest version)`, `Expires (metadata value of the latest version)`, `Cache-Control (metadata value of the latest version)`. This conditional check was being honored before validating if the anonymous access is indeed allowed on the metadata of an object. This issue has been addressed in commit `e0fe7cc3917`. Users must upgrade to RELEASE.2024-05-27T19-17-46Z for the fix. There are no known workarounds for this issue.",
    "cve_publish_date": "2024-05-28T19:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix: information disclosure bug in preconditions GET (#19810)\n\nprecondition check was being honored before, validating\r\nif anonymous access is allowed on the metadata of an\r\nobject, leading to metadata disclosure of the following\r\nheaders.\r\n\r\n```\r\nLast-Modified\r\nEtag\r\nx-amz-version-id\r\nExpires:\r\nCache-Control:\r\n```\r\n\r\nalthough the information presented is minimal in nature,\r\nand of opaque nature. It still simply discloses that an\r\nobject by a specific name exists or not without even having\r\nenough permissions.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "go.mod",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: module github.com/minio/minio/docs/debugging/inspect",
                "// Line 2: ",
                "// vulnerable line: 3: go 1.19",
                "// Line 4: ",
                "// Line 5: require (",
                "// Line 6:     github.com/klauspost/compress v1.17.4",
                "// Line 7:     github.com/klauspost/filepathx v1.1.1",
                "// Line 8:     github.com/minio/colorjson v1.0.6",
                "// Line 9:     github.com/minio/madmin-go/v3 v3.0.36",
                "// Line 10:     github.com/secure-io/sio-go v0.3.1",
                "// Line 11:     github.com/tinylib/msgp v1.1.9",
                "// Line 12: )",
                "// Line 13: "
            ]
        },
        {
            "filename_of_changes": "go.mod",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: module github.com/minio/minio/docs/debugging/xattr",
                "// Line 2: ",
                "// vulnerable line: 3: go 1.19",
                "// Line 4: ",
                "// Line 5: require (",
                "// Line 6:     github.com/olekukonko/tablewriter v0.0.5",
                "// Line 7:     github.com/pkg/xattr v0.4.9",
                "// Line 8: )",
                "// Line 9: ",
                "// Line 10: require (",
                "// Line 11:     github.com/mattn/go-runewidth v0.0.15 // indirect",
                "// Line 12:     github.com/rivo/uniseg v0.4.4 // indirect",
                "// Line 13:     golang.org/x/sys v0.15.0 // indirect"
            ]
        },
        {
            "filename_of_changes": "object-handlers.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "9",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 69: )",
                "// Line 70: ",
                "// Line 71: // supportedHeadGetReqParams - supported request parameters for GET and HEAD presigned request.",
                "// Line 72: var supportedHeadGetReqParams = map[string]string{",
                "// Line 73:     \"response-expires\":             xhttp.Expires,",
                "// Line 74:     \"response-content-type\":        xhttp.ContentType,",
                "// Line 75:     \"response-cache-control\":       xhttp.CacheControl,",
                "// Line 76:     \"response-content-encoding\":    xhttp.ContentEncoding,",
                "// Line 77:     \"response-content-language\":    xhttp.ContentLanguage,",
                "// Line 78:     \"response-content-disposition\": xhttp.ContentDisposition,",
                "// vulnerable line: 79: }",
                "// Line 80: ",
                "// Line 81: const (",
                "// Line 82:     compressionAlgorithmV1 = \"golang/snappy/LZ77\"",
                "// Line 83:     compressionAlgorithmV2 = \"klauspost/compress/s2\"",
                "// Line 84: ",
                "// Line 85:     // When an upload exceeds encryptBufferThreshold ...",
                "// Line 86:     encryptBufferThreshold = 1 << 20",
                "// Line 87:     // add an input buffer of this size.",
                "// Line 88:     encryptBufferSize = 1 << 20",
                "// Line 89: ",
                "// Line 90:     // minCompressibleSize is the minimum size at which we enable compression.",
                "// Line 91:     minCompressibleSize = 4096",
                "// Line 92: )",
                "// Line 93: ",
                "// Line 94: // setHeadGetRespHeaders - set any requested parameters as response headers.",
                "// Line 95: func setHeadGetRespHeaders(w http.ResponseWriter, reqParams url.Values) {",
                "// Line 96:     for k, v := range reqParams {",
                "// Line 97:         if header, ok := supportedHeadGetReqParams[strings.ToLower(k)]; ok {",
                "// Line 98:             w.Header()[header] = []string{strings.Join(v, \",\")}",
                "// vulnerable line: 99: }",
                "// vulnerable line: 100: }",
                "// vulnerable line: 101: }",
                "// Line 102: ",
                "// Line 103: // SelectObjectContentHandler - GET Object?select",
                "// Line 104: // ----------",
                "// Line 105: // This implementation of the GET operation retrieves object content based",
                "// Line 106: // on an SQL expression. In the request, along with the sql expression, you must",
                "// Line 107: // also specify a data serialization format (JSON, CSV) of the object.",
                "// Line 108: func (api objectAPIHandlers) SelectObjectContentHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 109:     ctx := newContext(r, w, \"SelectObject\")",
                "// Line 110: ",
                "// Line 111:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 112: ",
                "// Line 113:     // Fetch object stat info.",
                "// Line 114:     objectAPI := api.ObjectAPI()",
                "// Line 115:     if objectAPI == nil {",
                "// Line 116:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 117: return",
                "// vulnerable line: 118: }",
                "// Line 119: ",
                "// Line 120:     if crypto.S3.IsRequested(r.Header) || crypto.S3KMS.IsRequested(r.Header) { // If SSE-S3 or SSE-KMS present -> AWS fails with undefined error",
                "// Line 121:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrBadRequest), r.URL)",
                "// vulnerable line: 122: return",
                "// vulnerable line: 123: }",
                "// Line 124: ",
                "// Line 125:     vars := mux.Vars(r)",
                "// Line 126:     bucket := vars[\"bucket\"]",
                "// Line 127:     object, err := unescapePath(vars[\"object\"])",
                "// Line 128:     if err != nil {",
                "// Line 129:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 130: return",
                "// vulnerable line: 131: }",
                "// Line 132: ",
                "// Line 133:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 134:     if err != nil {",
                "// Line 135:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 136: return",
                "// vulnerable line: 137: }",
                "// Line 138: ",
                "// Line 139:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 140: ",
                "// Line 141:     // Check for auth type to return S3 compatible error.",
                "// Line 142:     // type to return the correct error (NoSuchKey vs AccessDenied)",
                "// Line 143:     if s3Error := checkRequestAuthType(ctx, r, policy.GetObjectAction, bucket, object); s3Error != ErrNone {",
                "// Line 144:         if getRequestAuthType(r) == authTypeAnonymous {",
                "// Line 145:             // As per \"Permission\" section in",
                "// Line 146:             // https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html",
                "// Line 147:             // If the object you request does not exist,",
                "// Line 157:             //   status code 403 (\"access denied\") error.`",
                "// Line 158:             if globalPolicySys.IsAllowed(policy.BucketPolicyArgs{",
                "// Line 159:                 Action:          policy.ListBucketAction,",
                "// Line 160:                 BucketName:      bucket,",
                "// Line 161:                 ConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),",
                "// Line 162:                 IsOwner:         false,",
                "// Line 163:             }) {",
                "// Line 164:                 _, err = getObjectInfo(ctx, bucket, object, opts)",
                "// Line 165:                 if toAPIError(ctx, err).Code == \"NoSuchKey\" {",
                "// Line 166:                     s3Error = ErrNoSuchKey",
                "// vulnerable line: 167: }",
                "// vulnerable line: 168: }",
                "// vulnerable line: 169: }",
                "// vulnerable line: 170: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 171: return",
                "// vulnerable line: 172: }",
                "// Line 173: ",
                "// Line 174:     // Get request range.",
                "// Line 175:     rangeHeader := r.Header.Get(xhttp.Range)",
                "// Line 176:     if rangeHeader != \"\" {",
                "// Line 177:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrUnsupportedRangeHeader), r.URL)",
                "// vulnerable line: 178: return",
                "// vulnerable line: 179: }",
                "// Line 180: ",
                "// Line 181:     if r.ContentLength <= 0 {",
                "// Line 182:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrEmptyRequestBody), r.URL)",
                "// vulnerable line: 183: return",
                "// vulnerable line: 184: }",
                "// Line 185: ",
                "// Line 186:     // Take read lock on object, here so subsequent lower-level",
                "// Line 187:     // calls do not need to.",
                "// Line 188:     lock := objectAPI.NewNSLock(bucket, object)",
                "// Line 189:     lkctx, err := lock.GetRLock(ctx, globalOperationTimeout)",
                "// Line 190:     if err != nil {",
                "// Line 191:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 192: return",
                "// vulnerable line: 193: }",
                "// Line 194:     ctx = lkctx.Context()",
                "// Line 195:     defer lock.RUnlock(lkctx)",
                "// Line 196: ",
                "// Line 197:     getObjectNInfo := objectAPI.GetObjectNInfo",
                "// Line 198: ",
                "// Line 199:     gopts := opts",
                "// Line 200:     gopts.NoLock = true // We already have a lock, we can live with it.",
                "// Line 201:     objInfo, err := getObjectInfo(ctx, bucket, object, gopts)",
                "// Line 202:     if err != nil {",
                "// Line 203:         // Versioning enabled quite possibly object is deleted might be delete-marker",
                "// Line 204:         // if present set the headers, no idea why AWS S3 sets these headers.",
                "// Line 205:         if objInfo.VersionID != \"\" && objInfo.DeleteMarker {",
                "// Line 206:             w.Header()[xhttp.AmzVersionID] = []string{objInfo.VersionID}",
                "// Line 207:             w.Header()[xhttp.AmzDeleteMarker] = []string{strconv.FormatBool(objInfo.DeleteMarker)}",
                "// vulnerable line: 208: }",
                "// Line 209:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 210: return",
                "// vulnerable line: 211: }",
                "// Line 212: ",
                "// Line 213:     // filter object lock metadata if permission does not permit",
                "// Line 214:     getRetPerms := checkRequestAuthType(ctx, r, policy.GetObjectRetentionAction, bucket, object)",
                "// Line 215:     legalHoldPerms := checkRequestAuthType(ctx, r, policy.GetObjectLegalHoldAction, bucket, object)",
                "// Line 216: ",
                "// Line 217:     // filter object lock metadata if permission does not permit",
                "// Line 218:     objInfo.UserDefined = objectlock.FilterObjectLockMetadata(objInfo.UserDefined, getRetPerms != ErrNone, legalHoldPerms != ErrNone)",
                "// Line 219: ",
                "// Line 220:     if _, err = DecryptObjectInfo(&objInfo, r); err != nil {",
                "// Line 221:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 222: return",
                "// vulnerable line: 223: }",
                "// Line 224: ",
                "// Line 225:     actualSize, err := objInfo.GetActualSize()",
                "// Line 226:     if err != nil {",
                "// Line 227:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 228: return",
                "// vulnerable line: 229: }",
                "// Line 230: ",
                "// Line 231:     objectRSC := s3select.NewObjectReadSeekCloser(",
                "// Line 232:         func(offset int64) (io.ReadCloser, error) {",
                "// Line 233:             rs := &HTTPRangeSpec{",
                "// Line 234:                 IsSuffixLength: false,",
                "// Line 235:                 Start:          offset,",
                "// Line 236:                 End:            -1,",
                "// vulnerable line: 237: }",
                "// Line 238:             opts.NoLock = true",
                "// Line 239:             return getObjectNInfo(ctx, bucket, object, rs, r.Header, opts)",
                "// Line 240:         },",
                "// Line 241:         actualSize,",
                "// Line 242:     )",
                "// Line 243:     defer objectRSC.Close()",
                "// Line 244:     s3Select, err := s3select.NewS3Select(r.Body)",
                "// Line 245:     if err != nil {",
                "// Line 246:         if serr, ok := err.(s3select.SelectError); ok {",
                "// Line 247:             encodedErrorResponse := encodeResponse(APIErrorResponse{",
                "// Line 249:                 Message:    serr.ErrorMessage(),",
                "// Line 250:                 BucketName: bucket,",
                "// Line 251:                 Key:        object,",
                "// Line 252:                 Resource:   r.URL.Path,",
                "// Line 253:                 RequestID:  w.Header().Get(xhttp.AmzRequestID),",
                "// Line 254:                 HostID:     globalDeploymentID(),",
                "// Line 255:             })",
                "// Line 256:             writeResponse(w, serr.HTTPStatusCode(), encodedErrorResponse, mimeXML)",
                "// Line 257:         } else {",
                "// Line 258:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 259: }",
                "// vulnerable line: 260: return",
                "// vulnerable line: 261: }",
                "// Line 262:     defer s3Select.Close()",
                "// Line 263: ",
                "// Line 264:     if err = s3Select.Open(objectRSC); err != nil {",
                "// Line 265:         if serr, ok := err.(s3select.SelectError); ok {",
                "// Line 266:             encodedErrorResponse := encodeResponse(APIErrorResponse{",
                "// Line 267:                 Code:       serr.ErrorCode(),",
                "// Line 268:                 Message:    serr.ErrorMessage(),",
                "// Line 269:                 BucketName: bucket,",
                "// Line 270:                 Key:        object,",
                "// Line 271:                 Resource:   r.URL.Path,",
                "// Line 272:                 RequestID:  w.Header().Get(xhttp.AmzRequestID),",
                "// Line 273:                 HostID:     globalDeploymentID(),",
                "// Line 274:             })",
                "// Line 275:             writeResponse(w, serr.HTTPStatusCode(), encodedErrorResponse, mimeXML)",
                "// Line 276:         } else {",
                "// Line 277:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 278: }",
                "// vulnerable line: 279: return",
                "// vulnerable line: 280: }",
                "// Line 281: ",
                "// Line 282:     // Set encryption response headers",
                "// Line 283:     switch kind, _ := crypto.IsEncrypted(objInfo.UserDefined); kind {",
                "// Line 284:     case crypto.S3:",
                "// Line 285:         w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)",
                "// Line 286:     case crypto.S3KMS:",
                "// Line 287:         w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionKMS)",
                "// Line 288:         w.Header().Set(xhttp.AmzServerSideEncryptionKmsID, objInfo.KMSKeyID())",
                "// Line 289:         if kmsCtx, ok := objInfo.UserDefined[crypto.MetaContext]; ok {",
                "// Line 290:             w.Header().Set(xhttp.AmzServerSideEncryptionKmsContext, kmsCtx)",
                "// vulnerable line: 291: }",
                "// Line 292:     case crypto.SSEC:",
                "// Line 293:         // Validate the SSE-C Key set in the header.",
                "// Line 294:         if _, err = crypto.SSEC.UnsealObjectKey(r.Header, objInfo.UserDefined, bucket, object); err != nil {",
                "// Line 295:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 296: return",
                "// vulnerable line: 297: }",
                "// Line 298:         w.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))",
                "// Line 299:         w.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))",
                "// vulnerable line: 300: }",
                "// Line 301: ",
                "// Line 302:     s3Select.Evaluate(w)",
                "// Line 303: ",
                "// Line 304:     // Notify object accessed via a GET request.",
                "// Line 305:     sendEvent(eventArgs{",
                "// Line 306:         EventName:    event.ObjectAccessedGet,",
                "// Line 307:         BucketName:   bucket,",
                "// Line 308:         Object:       objInfo,",
                "// Line 309:         ReqParams:    extractReqParams(r),",
                "// Line 310:         RespElements: extractRespElements(w),",
                "// Line 311:         UserAgent:    r.UserAgent(),",
                "// Line 312:         Host:         handlers.GetSourceIP(r),",
                "// Line 313:     })",
                "// vulnerable line: 314: }",
                "// Line 315: ",
                "// Line 316: func (api objectAPIHandlers) getObjectHandler(ctx context.Context, objectAPI ObjectLayer, bucket, object string, w http.ResponseWriter, r *http.Request) {",
                "// Line 317:     if crypto.S3.IsRequested(r.Header) || crypto.S3KMS.IsRequested(r.Header) { // If SSE-S3 or SSE-KMS present -> AWS fails with undefined error",
                "// Line 318:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrBadRequest), r.URL)",
                "// vulnerable line: 319: return",
                "// vulnerable line: 320: }",
                "// Line 321: ",
                "// Line 322:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 323:     if err != nil {",
                "// Line 324:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 325: return",
                "// vulnerable line: 326: }",
                "// Line 327: ",
                "// Line 328:     // Check for auth type to return S3 compatible error.",
                "// Line 329:     // type to return the correct error (NoSuchKey vs AccessDenied)",
                "// Line 330:     if s3Error := authenticateRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// Line 331:         if getRequestAuthType(r) == authTypeAnonymous {",
                "// Line 332:             // As per \"Permission\" section in",
                "// Line 333:             // https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html",
                "// Line 334:             // If the object you request does not exist,",
                "// Line 335:             // the error Amazon S3 returns depends on",
                "// Line 336:             // whether you also have the s3:ListBucket",
                "// Line 346:                 Action:          policy.ListBucketAction,",
                "// Line 347:                 BucketName:      bucket,",
                "// Line 348:                 ConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),",
                "// Line 349:                 IsOwner:         false,",
                "// Line 350:             }) {",
                "// Line 351:                 getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 352: ",
                "// Line 353:                 _, err = getObjectInfo(ctx, bucket, object, opts)",
                "// Line 354:                 if toAPIError(ctx, err).Code == \"NoSuchKey\" {",
                "// Line 355:                     s3Error = ErrNoSuchKey",
                "// vulnerable line: 356: }",
                "// vulnerable line: 357: }",
                "// vulnerable line: 358: }",
                "// vulnerable line: 359: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 360: return",
                "// vulnerable line: 361: }",
                "// Line 362: ",
                "// Line 363:     getObjectNInfo := objectAPI.GetObjectNInfo",
                "// Line 364: ",
                "// Line 365:     // Get request range.",
                "// Line 366:     var rs *HTTPRangeSpec",
                "// Line 367:     var rangeErr error",
                "// Line 368:     rangeHeader := r.Header.Get(xhttp.Range)",
                "// Line 369:     if rangeHeader != \"\" {",
                "// Line 370:         // Both 'Range' and 'partNumber' cannot be specified at the same time",
                "// Line 371:         if opts.PartNumber > 0 {",
                "// Line 372:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidRangePartNumber), r.URL)",
                "// vulnerable line: 373: return",
                "// vulnerable line: 374: }",
                "// Line 375: ",
                "// Line 376:         rs, rangeErr = parseRequestRangeSpec(rangeHeader)",
                "// Line 377:         // Handle only errInvalidRange. Ignore other",
                "// Line 378:         // parse error and treat it as regular Get",
                "// Line 379:         // request like Amazon S3.",
                "// Line 380:         if errors.Is(rangeErr, errInvalidRange) {",
                "// Line 381:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidRange), r.URL)",
                "// vulnerable line: 382: return",
                "// vulnerable line: 383: }",
                "// vulnerable line: 384: }",
                "// Line 385: ",
                "// Line 386:     cachedResult := globalCacheConfig.Enabled() && opts.VersionID == \"\"",
                "// Line 387: ",
                "// Line 388:     var update bool",
                "// Line 389:     if cachedResult {",
                "// Line 390:         rc := &cache.CondCheck{}",
                "// Line 391:         h := r.Header.Clone()",
                "// Line 392:         if opts.PartNumber > 0 {",
                "// Line 393:             h.Set(xhttp.PartNumber, strconv.Itoa(opts.PartNumber))",
                "// vulnerable line: 394: }",
                "// Line 395:         rc.Init(bucket, object, h)",
                "// Line 396: ",
                "// Line 397:         ci, err := globalCacheConfig.Get(rc)",
                "// Line 398:         if ci != nil {",
                "// Line 399:             tgs, ok := ci.Metadata[xhttp.AmzObjectTagging]",
                "// Line 400:             if ok {",
                "// Line 401:                 // Set this such that authorization policies can be applied on the object tags.",
                "// Line 402:                 r.Header.Set(xhttp.AmzObjectTagging, tgs)",
                "// vulnerable line: 403: }",
                "// Line 404: ",
                "// vulnerable line: 405: if s3Error := authorizeRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// Line 406:                 writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(s3Error))",
                "// vulnerable line: 407: return",
                "// vulnerable line: 408: }",
                "// Line 409: ",
                "// Line 410:             okSt := (ci.StatusCode == http.StatusOK || ci.StatusCode == http.StatusPartialContent ||",
                "// Line 411:                 ci.StatusCode == http.StatusPreconditionFailed || ci.StatusCode == http.StatusNotModified)",
                "// Line 412:             if okSt {",
                "// Line 413:                 ci.WriteHeaders(w, func() {",
                "// Line 414:                     // set common headers",
                "// Line 415:                     setCommonHeaders(w)",
                "// Line 416:                 }, func() {",
                "// Line 417:                     okSt := (ci.StatusCode == http.StatusOK || ci.StatusCode == http.StatusPartialContent)",
                "// Line 418:                     if okSt && len(ci.Data) > 0 {",
                "// Line 419:                         for k, v := range ci.Metadata {",
                "// Line 420:                             w.Header().Set(k, v)",
                "// vulnerable line: 421: }",
                "// Line 422: ",
                "// Line 423:                         if opts.PartNumber > 0 && strings.Contains(ci.ETag, \"-\") {",
                "// Line 424:                             w.Header()[xhttp.AmzMpPartsCount] = []string{",
                "// Line 425:                                 strings.TrimLeftFunc(ci.ETag, func(r rune) bool {",
                "// Line 426:                                     return !unicode.IsNumber(r)",
                "// Line 427:                                 }),",
                "// vulnerable line: 428: }",
                "// vulnerable line: 429: }",
                "// Line 430: ",
                "// Line 431:                         // For providing ranged content",
                "// Line 432:                         start, rangeLen, err := rs.GetOffsetLength(ci.Size)",
                "// Line 433:                         if err != nil {",
                "// Line 434:                             start, rangeLen = 0, ci.Size",
                "// vulnerable line: 435: }",
                "// Line 436: ",
                "// Line 437:                         // Set content length.",
                "// Line 438:                         w.Header().Set(xhttp.ContentLength, strconv.FormatInt(rangeLen, 10))",
                "// Line 439:                         if rs != nil {",
                "// Line 440:                             contentRange := fmt.Sprintf(\"bytes %d-%d/%d\", start, start+rangeLen-1, ci.Size)",
                "// Line 441:                             w.Header().Set(xhttp.ContentRange, contentRange)",
                "// vulnerable line: 442: }",
                "// Line 443: ",
                "// Line 444:                         io.Copy(w, bytes.NewReader(ci.Data))",
                "// vulnerable line: 445: return",
                "// vulnerable line: 446: }",
                "// Line 447:                     if ci.StatusCode == http.StatusPreconditionFailed {",
                "// Line 448:                         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrPreconditionFailed), r.URL)",
                "// vulnerable line: 449: return",
                "// Line 450:                     } else if ci.StatusCode == http.StatusNotModified {",
                "// Line 451:                         w.WriteHeader(ci.StatusCode)",
                "// vulnerable line: 452: return",
                "// vulnerable line: 453: }",
                "// Line 454: ",
                "// Line 455:                     // We did not satisfy any requirement from the cache, update the cache.",
                "// Line 456:                     // this basically means that we do not have the Data for the object",
                "// Line 457:                     // cached yet",
                "// Line 458:                     update = true",
                "// Line 459:                 })",
                "// Line 460:                 if !update {",
                "// Line 461:                     // No update is needed means we have written already to the client just return here.",
                "// vulnerable line: 462: return",
                "// vulnerable line: 463: }",
                "// vulnerable line: 464: }",
                "// vulnerable line: 465: }",
                "// Line 466: ",
                "// Line 467:         if errors.Is(err, cache.ErrKeyMissing) {",
                "// Line 468:             update = true",
                "// vulnerable line: 469: }",
                "// vulnerable line: 470: }",
                "// Line 471: ",
                "// Line 472:     // Validate pre-conditions if any.",
                "// Line 473:     opts.CheckPrecondFn = func(oi ObjectInfo) bool {",
                "// Line 474:         if _, err := DecryptObjectInfo(&oi, r); err != nil {",
                "// Line 475:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// Line 476:             return true",
                "// vulnerable line: 477: }",
                "// Line 478: ",
                "// Line 479:         return checkPreconditions(ctx, w, r, oi, opts)",
                "// vulnerable line: 480: }",
                "// Line 481: ",
                "// Line 482:     opts.FastGetObjInfo = true",
                "// Line 483: ",
                "// Line 484:     var proxy proxyResult",
                "// Line 485:     gr, err := getObjectNInfo(ctx, bucket, object, rs, r.Header, opts)",
                "// Line 486:     if err != nil {",
                "// Line 487:         var (",
                "// Line 488:             reader *GetObjectReader",
                "// Line 489:             perr   error",
                "// Line 490:         )",
                "// Line 494:             if !proxytgts.Empty() {",
                "// Line 495:                 globalReplicationStats.incProxy(bucket, getObjectAPI, false)",
                "// Line 496:                 // proxy to replication target if active-active replication is in place.",
                "// Line 497:                 reader, proxy, perr = proxyGetToReplicationTarget(ctx, bucket, object, rs, r.Header, opts, proxytgts)",
                "// Line 498:                 if perr != nil {",
                "// Line 499:                     globalReplicationStats.incProxy(bucket, getObjectAPI, true)",
                "// Line 500:                     proxyGetErr := ErrorRespToObjectError(perr, bucket, object)",
                "// Line 501:                     if !isErrBucketNotFound(proxyGetErr) && !isErrObjectNotFound(proxyGetErr) && !isErrVersionNotFound(proxyGetErr) &&",
                "// Line 502:                         !isErrPreconditionFailed(proxyGetErr) && !isErrInvalidRange(proxyGetErr) {",
                "// Line 503:                         replLogIf(ctx, fmt.Errorf(\"Proxying request (replication) failed for %s/%s(%s) - %w\", bucket, object, opts.VersionID, perr))",
                "// vulnerable line: 504: }",
                "// vulnerable line: 505: }",
                "// Line 506:                 if reader != nil && proxy.Proxy && perr == nil {",
                "// Line 507:                     gr = reader",
                "// vulnerable line: 508: }",
                "// vulnerable line: 509: }",
                "// vulnerable line: 510: }",
                "// Line 511:         if reader == nil || !proxy.Proxy {",
                "// Line 512:             // validate if the request indeed was authorized, if it wasn't we need to return \"ErrAccessDenied\"",
                "// Line 513:             // instead of any namespace related error.",
                "// vulnerable line: 514: if s3Error := authorizeRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// vulnerable line: 515: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 516: return",
                "// vulnerable line: 517: }",
                "// Line 518:             if isErrPreconditionFailed(err) {",
                "// vulnerable line: 519: return",
                "// vulnerable line: 520: }",
                "// Line 521:             if proxy.Err != nil {",
                "// Line 522:                 writeErrorResponse(ctx, w, toAPIError(ctx, proxy.Err), r.URL)",
                "// vulnerable line: 523: return",
                "// vulnerable line: 524: }",
                "// Line 525:             if gr != nil {",
                "// Line 526:                 if !gr.ObjInfo.VersionPurgeStatus.Empty() {",
                "// Line 527:                     // Shows the replication status of a permanent delete of a version",
                "// Line 528:                     w.Header()[xhttp.MinIODeleteReplicationStatus] = []string{string(gr.ObjInfo.VersionPurgeStatus)}",
                "// vulnerable line: 529: }",
                "// Line 530:                 if !gr.ObjInfo.ReplicationStatus.Empty() && gr.ObjInfo.DeleteMarker {",
                "// Line 531:                     w.Header()[xhttp.MinIODeleteMarkerReplicationStatus] = []string{string(gr.ObjInfo.ReplicationStatus)}",
                "// vulnerable line: 532: }",
                "// Line 533: ",
                "// Line 534:                 // Versioning enabled quite possibly object is deleted might be delete-marker",
                "// Line 535:                 // if present set the headers, no idea why AWS S3 sets these headers.",
                "// Line 536:                 if gr.ObjInfo.VersionID != \"\" && gr.ObjInfo.DeleteMarker {",
                "// Line 537:                     w.Header()[xhttp.AmzVersionID] = []string{gr.ObjInfo.VersionID}",
                "// Line 538:                     w.Header()[xhttp.AmzDeleteMarker] = []string{strconv.FormatBool(gr.ObjInfo.DeleteMarker)}",
                "// vulnerable line: 539: }",
                "// Line 540:                 QueueReplicationHeal(ctx, bucket, gr.ObjInfo, 0)",
                "// vulnerable line: 541: }",
                "// Line 542:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 543: return",
                "// vulnerable line: 544: }",
                "// vulnerable line: 545: }",
                "// Line 546:     defer gr.Close()",
                "// Line 547: ",
                "// Line 548:     objInfo := gr.ObjInfo",
                "// Line 549: ",
                "// vulnerable line: 550: if objInfo.UserTags != \"\" {",
                "// vulnerable line: 551: r.Header.Set(xhttp.AmzObjectTagging, objInfo.UserTags)",
                "// vulnerable line: 552: }",
                "// Line 553: ",
                "// vulnerable line: 554: if s3Error := authorizeRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// vulnerable line: 555: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 556: return",
                "// vulnerable line: 557: }",
                "// Line 558: ",
                "// Line 559:     if !proxy.Proxy { // apply lifecycle rules only for local requests",
                "// Line 560:         // Automatically remove the object/version if an expiry lifecycle rule can be applied",
                "// Line 561:         if lc, err := globalLifecycleSys.Get(bucket); err == nil {",
                "// Line 562:             rcfg, err := globalBucketObjectLockSys.Get(bucket)",
                "// Line 563:             if err != nil {",
                "// Line 564:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 565: return",
                "// vulnerable line: 566: }",
                "// Line 567:             replcfg, err := getReplicationConfig(ctx, bucket)",
                "// Line 568:             if err != nil {",
                "// Line 569:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 570: return",
                "// vulnerable line: 571: }",
                "// Line 572:             event := evalActionFromLifecycle(ctx, *lc, rcfg, replcfg, objInfo)",
                "// Line 573:             if event.Action.Delete() {",
                "// Line 574:                 // apply whatever the expiry rule is.",
                "// Line 575:                 applyExpiryRule(event, lcEventSrc_s3GetObject, objInfo)",
                "// Line 576:                 if !event.Action.DeleteRestored() {",
                "// Line 577:                     // If the ILM action is not on restored object return error.",
                "// Line 578:                     writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrNoSuchKey), r.URL)",
                "// vulnerable line: 579: return",
                "// vulnerable line: 580: }",
                "// vulnerable line: 581: }",
                "// vulnerable line: 582: }",
                "// Line 583: ",
                "// Line 584:         QueueReplicationHeal(ctx, bucket, gr.ObjInfo, 0)",
                "// vulnerable line: 585: }",
                "// Line 586: ",
                "// Line 587:     // filter object lock metadata if permission does not permit",
                "// Line 588:     getRetPerms := checkRequestAuthType(ctx, r, policy.GetObjectRetentionAction, bucket, object)",
                "// Line 589:     legalHoldPerms := checkRequestAuthType(ctx, r, policy.GetObjectLegalHoldAction, bucket, object)",
                "// Line 590: ",
                "// Line 591:     // filter object lock metadata if permission does not permit",
                "// Line 592:     objInfo.UserDefined = objectlock.FilterObjectLockMetadata(objInfo.UserDefined, getRetPerms != ErrNone, legalHoldPerms != ErrNone)",
                "// Line 593: ",
                "// Line 594:     // Set encryption response headers",
                "// Line 595:     if kind, isEncrypted := crypto.IsEncrypted(objInfo.UserDefined); isEncrypted {",
                "// Line 596:         switch kind {",
                "// Line 597:         case crypto.S3:",
                "// Line 598:             w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)",
                "// Line 599:         case crypto.S3KMS:",
                "// Line 600:             w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionKMS)",
                "// Line 601:             w.Header().Set(xhttp.AmzServerSideEncryptionKmsID, objInfo.KMSKeyID())",
                "// Line 602:             if kmsCtx, ok := objInfo.UserDefined[crypto.MetaContext]; ok {",
                "// Line 603:                 w.Header().Set(xhttp.AmzServerSideEncryptionKmsContext, kmsCtx)",
                "// vulnerable line: 604: }",
                "// Line 605:         case crypto.SSEC:",
                "// Line 606:             w.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))",
                "// Line 607:             w.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))",
                "// vulnerable line: 608: }",
                "// Line 609:         objInfo.ETag = getDecryptedETag(r.Header, objInfo, false)",
                "// vulnerable line: 610: }",
                "// Line 611: ",
                "// Line 612:     if r.Header.Get(xhttp.AmzChecksumMode) == \"ENABLED\" && rs == nil {",
                "// Line 613:         // AWS S3 silently drops checksums on range requests.",
                "// Line 614:         hash.AddChecksumHeader(w, objInfo.decryptChecksums(opts.PartNumber))",
                "// vulnerable line: 615: }",
                "// Line 616: ",
                "// Line 617:     var buf *bytebufferpool.ByteBuffer",
                "// Line 618:     if update {",
                "// Line 619:         if globalCacheConfig.MatchesSize(objInfo.Size) {",
                "// Line 620:             buf = bytebufferpool.Get()",
                "// Line 621:             defer bytebufferpool.Put(buf)",
                "// vulnerable line: 622: }",
                "// Line 623:         defer func() {",
                "// Line 624:             var data []byte",
                "// Line 625:             if buf != nil {",
                "// Line 626:                 data = buf.Bytes()",
                "// vulnerable line: 627: }",
                "// Line 628: ",
                "// Line 629:             asize, err := objInfo.GetActualSize()",
                "// Line 630:             if err != nil {",
                "// Line 631:                 asize = objInfo.Size",
                "// vulnerable line: 632: }",
                "// Line 633: ",
                "// Line 634:             globalCacheConfig.Set(&cache.ObjectInfo{",
                "// Line 635:                 Key:          objInfo.Name,",
                "// Line 636:                 Bucket:       objInfo.Bucket,",
                "// Line 637:                 ETag:         objInfo.ETag,",
                "// Line 638:                 ModTime:      objInfo.ModTime,",
                "// Line 639:                 Expires:      objInfo.ExpiresStr(),",
                "// Line 640:                 CacheControl: objInfo.CacheControl,",
                "// Line 641:                 Metadata:     cleanReservedKeys(objInfo.UserDefined),",
                "// Line 642:                 Range:        rangeHeader,",
                "// Line 643:                 PartNumber:   opts.PartNumber,",
                "// Line 644:                 Size:         asize,",
                "// Line 645:                 Data:         data,",
                "// Line 646:             })",
                "// Line 647:         }()",
                "// vulnerable line: 648: }",
                "// Line 649: ",
                "// Line 650:     if err = setObjectHeaders(ctx, w, objInfo, rs, opts); err != nil {",
                "// Line 651:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 652: return",
                "// vulnerable line: 653: }",
                "// Line 654: ",
                "// Line 655:     // Set Parts Count Header",
                "// Line 656:     if opts.PartNumber > 0 && len(objInfo.Parts) > 0 {",
                "// Line 657:         setPartsCountHeaders(w, objInfo)",
                "// vulnerable line: 658: }",
                "// Line 659: ",
                "// Line 660:     setHeadGetRespHeaders(w, r.Form)",
                "// Line 661: ",
                "// Line 662:     var iw io.Writer",
                "// Line 663:     iw = w",
                "// Line 664:     if buf != nil {",
                "// Line 665:         iw = io.MultiWriter(w, buf)",
                "// vulnerable line: 666: }",
                "// Line 667: ",
                "// Line 668:     statusCodeWritten := false",
                "// Line 669:     httpWriter := xioutil.WriteOnClose(iw)",
                "// Line 670:     if rs != nil || opts.PartNumber > 0 {",
                "// Line 671:         statusCodeWritten = true",
                "// Line 672:         w.WriteHeader(http.StatusPartialContent)",
                "// vulnerable line: 673: }",
                "// Line 674: ",
                "// Line 675:     // Write object content to response body",
                "// Line 676:     if _, err = xioutil.Copy(httpWriter, gr); err != nil {",
                "// Line 677:         if !httpWriter.HasWritten() && !statusCodeWritten {",
                "// Line 678:             // write error response only if no data or headers has been written to client yet",
                "// Line 679:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 680: return",
                "// vulnerable line: 681: }",
                "// vulnerable line: 682: return",
                "// vulnerable line: 683: }",
                "// Line 684: ",
                "// Line 685:     if err = httpWriter.Close(); err != nil {",
                "// Line 686:         if !httpWriter.HasWritten() && !statusCodeWritten { // write error response only if no data or headers has been written to client yet",
                "// Line 687:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 688: return",
                "// vulnerable line: 689: }",
                "// vulnerable line: 690: return",
                "// vulnerable line: 691: }",
                "// Line 692: ",
                "// Line 693:     // Notify object accessed via a GET request.",
                "// Line 694:     sendEvent(eventArgs{",
                "// Line 695:         EventName:    event.ObjectAccessedGet,",
                "// Line 696:         BucketName:   bucket,",
                "// Line 697:         Object:       objInfo,",
                "// Line 698:         ReqParams:    extractReqParams(r),",
                "// Line 699:         RespElements: extractRespElements(w),",
                "// Line 700:         UserAgent:    r.UserAgent(),",
                "// Line 701:         Host:         handlers.GetSourceIP(r),",
                "// Line 702:     })",
                "// vulnerable line: 703: }",
                "// Line 704: ",
                "// Line 705: // GetObjectAttributes ...",
                "// Line 706: func (api objectAPIHandlers) getObjectAttributesHandler(ctx context.Context, objectAPI ObjectLayer, bucket, object string, w http.ResponseWriter, r *http.Request) {",
                "// Line 707:     opts, valid := getAndValidateAttributesOpts(ctx, w, r, bucket, object)",
                "// Line 708:     if !valid {",
                "// vulnerable line: 709: return",
                "// vulnerable line: 710: }",
                "// Line 711: ",
                "// Line 712:     var s3Error APIErrorCode",
                "// Line 713:     if opts.VersionID != \"\" {",
                "// Line 714:         s3Error = checkRequestAuthType(ctx, r, policy.GetObjectVersionAttributesAction, bucket, object)",
                "// Line 715:         if s3Error == ErrNone {",
                "// Line 716:             s3Error = checkRequestAuthType(ctx, r, policy.GetObjectVersionAction, bucket, object)",
                "// vulnerable line: 717: }",
                "// Line 718:     } else {",
                "// Line 719:         s3Error = checkRequestAuthType(ctx, r, policy.GetObjectAttributesAction, bucket, object)",
                "// Line 720:         if s3Error == ErrNone {",
                "// Line 721:             s3Error = checkRequestAuthType(ctx, r, policy.GetObjectAction, bucket, object)",
                "// vulnerable line: 722: }",
                "// vulnerable line: 723: }",
                "// Line 724: ",
                "// Line 725:     if s3Error != ErrNone {",
                "// vulnerable line: 726: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 727: return",
                "// vulnerable line: 728: }",
                "// Line 729: ",
                "// Line 730:     objInfo, err := objectAPI.GetObjectInfo(ctx, bucket, object, opts)",
                "// Line 731:     if err != nil {",
                "// Line 732:         s3Error = checkRequestAuthType(ctx, r, policy.ListBucketAction, bucket, object)",
                "// Line 733:         if s3Error == ErrNone {",
                "// Line 734:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 735: return",
                "// vulnerable line: 736: }",
                "// Line 737:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)",
                "// vulnerable line: 738: return",
                "// vulnerable line: 739: }",
                "// Line 740: ",
                "// Line 741:     if _, err = DecryptObjectInfo(&objInfo, r); err != nil {",
                "// Line 742:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 743: return",
                "// vulnerable line: 744: }",
                "// Line 745: ",
                "// Line 746:     if checkPreconditions(ctx, w, r, objInfo, opts) {",
                "// vulnerable line: 747: return",
                "// vulnerable line: 748: }",
                "// Line 749: ",
                "// Line 750:     OA := new(getObjectAttributesResponse)",
                "// Line 751: ",
                "// Line 752:     if opts.Versioned {",
                "// Line 753:         w.Header().Set(xhttp.AmzVersionID, objInfo.VersionID)",
                "// vulnerable line: 754: }",
                "// Line 755: ",
                "// Line 756:     lastModified := objInfo.ModTime.UTC().Format(http.TimeFormat)",
                "// Line 757:     w.Header().Set(xhttp.LastModified, lastModified)",
                "// Line 758:     w.Header().Del(xhttp.ContentType)",
                "// Line 759: ",
                "// Line 760:     if _, ok := opts.ObjectAttributes[xhttp.Checksum]; ok {",
                "// Line 761:         chkSums := objInfo.decryptChecksums(0)",
                "// Line 762:         // AWS does not appear to append part number on this API call.",
                "// Line 763:         switch {",
                "// Line 764:         case chkSums[\"CRC32\"] != \"\":",
                "// Line 766:             OA.Checksum.ChecksumCRC32 = strings.Split(chkSums[\"CRC32\"], \"-\")[0]",
                "// Line 767:         case chkSums[\"CRC32C\"] != \"\":",
                "// Line 768:             OA.Checksum = new(objectAttributesChecksum)",
                "// Line 769:             OA.Checksum.ChecksumCRC32C = strings.Split(chkSums[\"CRC32C\"], \"-\")[0]",
                "// Line 770:         case chkSums[\"SHA256\"] != \"\":",
                "// Line 771:             OA.Checksum = new(objectAttributesChecksum)",
                "// Line 772:             OA.Checksum.ChecksumSHA1 = strings.Split(chkSums[\"SHA1\"], \"-\")[0]",
                "// Line 773:         case chkSums[\"SHA1\"] != \"\":",
                "// Line 774:             OA.Checksum = new(objectAttributesChecksum)",
                "// Line 775:             OA.Checksum.ChecksumSHA256 = strings.Split(chkSums[\"SHA256\"], \"-\")[0]",
                "// vulnerable line: 776: }",
                "// Line 777: ",
                "// vulnerable line: 778: }",
                "// Line 779: ",
                "// Line 780:     if _, ok := opts.ObjectAttributes[xhttp.ETag]; ok {",
                "// Line 781:         OA.ETag = objInfo.ETag",
                "// vulnerable line: 782: }",
                "// Line 783: ",
                "// Line 784:     if _, ok := opts.ObjectAttributes[xhttp.ObjectSize]; ok {",
                "// Line 785:         OA.ObjectSize, _ = objInfo.GetActualSize()",
                "// vulnerable line: 786: }",
                "// Line 787: ",
                "// Line 788:     if _, ok := opts.ObjectAttributes[xhttp.StorageClass]; ok {",
                "// Line 789:         OA.StorageClass = filterStorageClass(ctx, objInfo.StorageClass)",
                "// vulnerable line: 790: }",
                "// Line 791: ",
                "// Line 792:     objInfo.decryptPartsChecksums()",
                "// Line 793: ",
                "// Line 794:     if _, ok := opts.ObjectAttributes[xhttp.ObjectParts]; ok {",
                "// Line 795:         OA.ObjectParts = new(objectAttributesParts)",
                "// Line 796:         OA.ObjectParts.PartNumberMarker = opts.PartNumberMarker",
                "// Line 797: ",
                "// Line 798:         OA.ObjectParts.MaxParts = opts.MaxParts",
                "// Line 799:         partsLength := len(objInfo.Parts)",
                "// Line 800:         OA.ObjectParts.PartsCount = partsLength",
                "// Line 801: ",
                "// Line 802:         if opts.MaxParts > -1 {",
                "// Line 803:             for i, v := range objInfo.Parts {",
                "// Line 804:                 if v.Number <= opts.PartNumberMarker {",
                "// Line 805:                     continue",
                "// vulnerable line: 806: }",
                "// Line 807: ",
                "// Line 808:                 if len(OA.ObjectParts.Parts) == opts.MaxParts {",
                "// Line 809:                     break",
                "// vulnerable line: 810: }",
                "// Line 811: ",
                "// Line 812:                 OA.ObjectParts.NextPartNumberMarker = v.Number",
                "// Line 813:                 OA.ObjectParts.Parts = append(OA.ObjectParts.Parts, &objectAttributesPart{",
                "// Line 814:                     ChecksumSHA1:   objInfo.Parts[i].Checksums[\"SHA1\"],",
                "// Line 815:                     ChecksumSHA256: objInfo.Parts[i].Checksums[\"SHA256\"],",
                "// Line 816:                     ChecksumCRC32:  objInfo.Parts[i].Checksums[\"CRC32\"],",
                "// Line 817:                     ChecksumCRC32C: objInfo.Parts[i].Checksums[\"CRC32C\"],",
                "// Line 818:                     PartNumber:     objInfo.Parts[i].Number,",
                "// Line 819:                     Size:           objInfo.Parts[i].Size,",
                "// Line 820:                 })",
                "// vulnerable line: 821: }",
                "// vulnerable line: 822: }",
                "// Line 823: ",
                "// Line 824:         if OA.ObjectParts.NextPartNumberMarker != partsLength {",
                "// Line 825:             OA.ObjectParts.IsTruncated = true",
                "// vulnerable line: 826: }",
                "// vulnerable line: 827: }",
                "// Line 828: ",
                "// Line 829:     writeSuccessResponseXML(w, encodeResponse(OA))",
                "// Line 830: ",
                "// Line 831:     sendEvent(eventArgs{",
                "// Line 832:         EventName:    event.ObjectAccessedAttributes,",
                "// Line 833:         BucketName:   bucket,",
                "// Line 834:         Object:       objInfo,",
                "// Line 835:         ReqParams:    extractReqParams(r),",
                "// Line 836:         RespElements: extractRespElements(w),",
                "// Line 837:         UserAgent:    r.UserAgent(),",
                "// Line 838:         Host:         handlers.GetSourceIP(r),",
                "// Line 839:     })",
                "// Line 840: ",
                "// vulnerable line: 841: return",
                "// vulnerable line: 842: }",
                "// Line 843: ",
                "// Line 844: // GetObjectHandler - GET Object",
                "// Line 845: // ----------",
                "// Line 846: // This implementation of the GET operation retrieves object. To use GET,",
                "// Line 847: // you must have READ access to the object.",
                "// Line 848: func (api objectAPIHandlers) GetObjectHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 849:     ctx := newContext(r, w, \"GetObject\")",
                "// Line 850: ",
                "// Line 851:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 852: ",
                "// Line 853:     objectAPI := api.ObjectAPI()",
                "// Line 854:     if objectAPI == nil {",
                "// Line 855:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 856: return",
                "// vulnerable line: 857: }",
                "// Line 858: ",
                "// Line 859:     vars := mux.Vars(r)",
                "// Line 860:     bucket := vars[\"bucket\"]",
                "// Line 861:     object, err := unescapePath(vars[\"object\"])",
                "// Line 862:     if err != nil {",
                "// Line 863:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 864: return",
                "// vulnerable line: 865: }",
                "// Line 866:     if !globalAPIConfig.shouldGzipObjects() {",
                "// Line 867:         w.Header().Set(gzhttp.HeaderNoCompression, \"true\")",
                "// vulnerable line: 868: }",
                "// Line 869: ",
                "// Line 870:     if r.Header.Get(xMinIOExtract) == \"true\" && strings.Contains(object, archivePattern) {",
                "// Line 871:         api.getObjectInArchiveFileHandler(ctx, objectAPI, bucket, object, w, r)",
                "// Line 872:     } else {",
                "// Line 873:         api.getObjectHandler(ctx, objectAPI, bucket, object, w, r)",
                "// vulnerable line: 874: }",
                "// vulnerable line: 875: }",
                "// Line 876: ",
                "// Line 877: func (api objectAPIHandlers) headObjectHandler(ctx context.Context, objectAPI ObjectLayer, bucket, object string, w http.ResponseWriter, r *http.Request) {",
                "// Line 878:     if crypto.S3.IsRequested(r.Header) || crypto.S3KMS.IsRequested(r.Header) { // If SSE-S3 or SSE-KMS present -> AWS fails with undefined error",
                "// Line 879:         writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrBadRequest))",
                "// vulnerable line: 880: return",
                "// vulnerable line: 881: }",
                "// Line 882: ",
                "// Line 883:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 884: ",
                "// Line 885:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 886:     if err != nil {",
                "// Line 887:         writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 888: return",
                "// vulnerable line: 889: }",
                "// Line 890: ",
                "// Line 891:     // Check for auth type to return S3 compatible error.",
                "// Line 892:     // type to return the correct error (NoSuchKey vs AccessDenied)",
                "// Line 893:     if s3Error := authenticateRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// Line 894:         if getRequestAuthType(r) == authTypeAnonymous {",
                "// Line 895:             // As per \"Permission\" section in",
                "// Line 896:             // https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectHEAD.html",
                "// Line 897:             // If the object you request does not exist,",
                "// Line 898:             // the error Amazon S3 returns depends on",
                "// Line 899:             // whether you also have the s3:ListBucket",
                "// Line 909:                 Action:          policy.ListBucketAction,",
                "// Line 910:                 BucketName:      bucket,",
                "// Line 911:                 ConditionValues: getConditionValues(r, \"\", auth.AnonymousCredentials),",
                "// Line 912:                 IsOwner:         false,",
                "// Line 913:             }) {",
                "// Line 914:                 getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 915: ",
                "// Line 916:                 _, err = getObjectInfo(ctx, bucket, object, opts)",
                "// Line 917:                 if toAPIError(ctx, err).Code == \"NoSuchKey\" {",
                "// Line 918:                     s3Error = ErrNoSuchKey",
                "// vulnerable line: 919: }",
                "// vulnerable line: 920: }",
                "// vulnerable line: 921: }",
                "// Line 922:         writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(s3Error))",
                "// vulnerable line: 923: return",
                "// vulnerable line: 924: }",
                "// Line 925: ",
                "// Line 926:     // Get request range.",
                "// Line 927:     var rs *HTTPRangeSpec",
                "// Line 928:     rangeHeader := r.Header.Get(xhttp.Range)",
                "// Line 929:     if rangeHeader != \"\" {",
                "// Line 930:         rs, _ = parseRequestRangeSpec(rangeHeader)",
                "// vulnerable line: 931: }",
                "// Line 932: ",
                "// Line 933:     if rangeHeader != \"\" {",
                "// Line 934:         // Both 'Range' and 'partNumber' cannot be specified at the same time",
                "// Line 935:         if opts.PartNumber > 0 {",
                "// Line 936:             writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrInvalidRangePartNumber))",
                "// vulnerable line: 937: return",
                "// vulnerable line: 938: }",
                "// Line 939: ",
                "// Line 940:         if rs, err = parseRequestRangeSpec(rangeHeader); err != nil {",
                "// Line 941:             // Handle only errInvalidRange. Ignore other",
                "// Line 942:             // parse error and treat it as regular Get",
                "// Line 943:             // request like Amazon S3.",
                "// Line 944:             if errors.Is(err, errInvalidRange) {",
                "// Line 945:                 writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrInvalidRange))",
                "// vulnerable line: 946: return",
                "// vulnerable line: 947: }",
                "// vulnerable line: 948: }",
                "// vulnerable line: 949: }",
                "// Line 950: ",
                "// Line 951:     cachedResult := globalCacheConfig.Enabled() && opts.VersionID == \"\"",
                "// Line 952: ",
                "// Line 953:     var update bool",
                "// Line 954:     if cachedResult {",
                "// Line 955:         rc := &cache.CondCheck{}",
                "// Line 956:         h := r.Header.Clone()",
                "// Line 957:         if opts.PartNumber > 0 {",
                "// Line 958:             h.Set(xhttp.PartNumber, strconv.Itoa(opts.PartNumber))",
                "// vulnerable line: 959: }",
                "// Line 960:         rc.Init(bucket, object, h)",
                "// Line 961: ",
                "// Line 962:         ci, err := globalCacheConfig.Get(rc)",
                "// Line 963:         if ci != nil {",
                "// Line 964:             tgs, ok := ci.Metadata[xhttp.AmzObjectTagging]",
                "// Line 965:             if ok {",
                "// Line 966:                 // Set this such that authorization policies can be applied on the object tags.",
                "// Line 967:                 r.Header.Set(xhttp.AmzObjectTagging, tgs)",
                "// vulnerable line: 968: }",
                "// Line 969: ",
                "// vulnerable line: 970: if s3Error := authorizeRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// Line 971:                 writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(s3Error))",
                "// vulnerable line: 972: return",
                "// vulnerable line: 973: }",
                "// Line 974: ",
                "// Line 975:             okSt := (ci.StatusCode == http.StatusOK || ci.StatusCode == http.StatusPartialContent ||",
                "// Line 976:                 ci.StatusCode == http.StatusPreconditionFailed || ci.StatusCode == http.StatusNotModified)",
                "// Line 977:             if okSt {",
                "// Line 978:                 ci.WriteHeaders(w, func() {",
                "// Line 979:                     // set common headers",
                "// Line 980:                     setCommonHeaders(w)",
                "// Line 981:                 }, func() {",
                "// Line 982:                     okSt := (ci.StatusCode == http.StatusOK || ci.StatusCode == http.StatusPartialContent)",
                "// Line 983:                     if okSt {",
                "// Line 984:                         for k, v := range ci.Metadata {",
                "// Line 985:                             w.Header().Set(k, v)",
                "// vulnerable line: 986: }",
                "// Line 987: ",
                "// Line 988:                         // For providing ranged content",
                "// Line 989:                         start, rangeLen, err := rs.GetOffsetLength(ci.Size)",
                "// Line 990:                         if err != nil {",
                "// Line 991:                             start, rangeLen = 0, ci.Size",
                "// vulnerable line: 992: }",
                "// Line 993: ",
                "// Line 994:                         if opts.PartNumber > 0 && strings.Contains(ci.ETag, \"-\") {",
                "// Line 995:                             w.Header()[xhttp.AmzMpPartsCount] = []string{",
                "// Line 996:                                 strings.TrimLeftFunc(ci.ETag, func(r rune) bool {",
                "// Line 997:                                     return !unicode.IsNumber(r)",
                "// Line 998:                                 }),",
                "// vulnerable line: 999: }",
                "// vulnerable line: 1000: }",
                "// Line 1001: ",
                "// Line 1002:                         // Set content length for the range.",
                "// Line 1003:                         w.Header().Set(xhttp.ContentLength, strconv.FormatInt(rangeLen, 10))",
                "// Line 1004:                         if rs != nil {",
                "// Line 1005:                             contentRange := fmt.Sprintf(\"bytes %d-%d/%d\", start, start+rangeLen-1, ci.Size)",
                "// Line 1006:                             w.Header().Set(xhttp.ContentRange, contentRange)",
                "// vulnerable line: 1007: }",
                "// Line 1008: ",
                "// vulnerable line: 1009: return",
                "// vulnerable line: 1010: }",
                "// Line 1011:                     if ci.StatusCode == http.StatusPreconditionFailed {",
                "// Line 1012:                         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrPreconditionFailed), r.URL)",
                "// vulnerable line: 1013: return",
                "// vulnerable line: 1014: }",
                "// Line 1015: ",
                "// Line 1016:                     w.WriteHeader(ci.StatusCode)",
                "// Line 1017:                 })",
                "// vulnerable line: 1018: return",
                "// vulnerable line: 1019: }",
                "// vulnerable line: 1020: }",
                "// Line 1021:         if errors.Is(err, cache.ErrKeyMissing) {",
                "// Line 1022:             update = true",
                "// vulnerable line: 1023: }",
                "// vulnerable line: 1024: }",
                "// Line 1025: ",
                "// Line 1026:     opts.FastGetObjInfo = true",
                "// Line 1027: ",
                "// Line 1028:     objInfo, err := getObjectInfo(ctx, bucket, object, opts)",
                "// Line 1029:     var proxy proxyResult",
                "// Line 1030:     if err != nil && !objInfo.DeleteMarker && !isErrMethodNotAllowed(err) {",
                "// Line 1031:         // proxy HEAD to replication target if active-active replication configured on bucket",
                "// Line 1032:         proxytgts := getProxyTargets(ctx, bucket, object, opts)",
                "// Line 1033:         if !proxytgts.Empty() {",
                "// Line 1034:             globalReplicationStats.incProxy(bucket, headObjectAPI, false)",
                "// Line 1035:             var oi ObjectInfo",
                "// Line 1036:             oi, proxy = proxyHeadToReplicationTarget(ctx, bucket, object, rs, opts, proxytgts)",
                "// Line 1037:             if proxy.Proxy {",
                "// Line 1038:                 objInfo = oi",
                "// vulnerable line: 1039: }",
                "// Line 1040:             if proxy.Err != nil {",
                "// Line 1041:                 globalReplicationStats.incProxy(bucket, headObjectAPI, true)",
                "// Line 1042:                 writeErrorResponseHeadersOnly(w, toAPIError(ctx, proxy.Err))",
                "// vulnerable line: 1043: return",
                "// vulnerable line: 1044: }",
                "// vulnerable line: 1045: }",
                "// vulnerable line: 1046: }",
                "// Line 1047: ",
                "// vulnerable line: 1048: if objInfo.UserTags != \"\" {",
                "// Line 1049:         // Set this such that authorization policies can be applied on the object tags.",
                "// vulnerable line: 1050: r.Header.Set(xhttp.AmzObjectTagging, objInfo.UserTags)",
                "// vulnerable line: 1051: }",
                "// Line 1052: ",
                "// vulnerable line: 1053: if s3Error := authorizeRequest(ctx, r, policy.GetObjectAction); s3Error != ErrNone {",
                "// Line 1054:         writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(s3Error))",
                "// vulnerable line: 1055: return",
                "// vulnerable line: 1056: }",
                "// Line 1057: ",
                "// Line 1058:     if err != nil && !proxy.Proxy {",
                "// Line 1059:         switch {",
                "// Line 1060:         case !objInfo.VersionPurgeStatus.Empty():",
                "// Line 1061:             w.Header()[xhttp.MinIODeleteReplicationStatus] = []string{string(objInfo.VersionPurgeStatus)}",
                "// Line 1062:         case !objInfo.ReplicationStatus.Empty() && objInfo.DeleteMarker:",
                "// Line 1063:             w.Header()[xhttp.MinIODeleteMarkerReplicationStatus] = []string{string(objInfo.ReplicationStatus)}",
                "// vulnerable line: 1064: }",
                "// Line 1065:         // Versioning enabled quite possibly object is deleted might be delete-marker",
                "// Line 1066:         // if present set the headers, no idea why AWS S3 sets these headers.",
                "// Line 1067:         if objInfo.VersionID != \"\" && objInfo.DeleteMarker {",
                "// Line 1068:             w.Header()[xhttp.AmzVersionID] = []string{objInfo.VersionID}",
                "// Line 1069:             w.Header()[xhttp.AmzDeleteMarker] = []string{strconv.FormatBool(objInfo.DeleteMarker)}",
                "// vulnerable line: 1070: }",
                "// Line 1071: ",
                "// Line 1072:         QueueReplicationHeal(ctx, bucket, objInfo, 0)",
                "// Line 1073:         // do an additional verification whether object exists when object is deletemarker and request",
                "// Line 1074:         // is from replication",
                "// Line 1075:         if opts.CheckDMReplicationReady {",
                "// Line 1076:             topts := opts",
                "// Line 1077:             topts.VersionID = \"\"",
                "// Line 1078:             goi, gerr := getObjectInfo(ctx, bucket, object, topts)",
                "// Line 1079:             if gerr == nil || goi.VersionID != \"\" { // object layer returned more info because object is deleted",
                "// Line 1080:                 w.Header().Set(xhttp.MinIOTargetReplicationReady, \"true\")",
                "// vulnerable line: 1081: }",
                "// vulnerable line: 1082: }",
                "// Line 1083: ",
                "// Line 1084:         writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 1085: return",
                "// vulnerable line: 1086: }",
                "// Line 1087: ",
                "// Line 1088:     if !proxy.Proxy { // apply lifecycle rules only locally not for proxied requests",
                "// Line 1089:         // Automatically remove the object/version if an expiry lifecycle rule can be applied",
                "// Line 1090:         if lc, err := globalLifecycleSys.Get(bucket); err == nil {",
                "// Line 1091:             rcfg, err := globalBucketObjectLockSys.Get(bucket)",
                "// Line 1092:             if err != nil {",
                "// Line 1093:                 writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 1094: return",
                "// vulnerable line: 1095: }",
                "// Line 1096:             replcfg, err := getReplicationConfig(ctx, bucket)",
                "// Line 1097:             if err != nil {",
                "// Line 1098:                 writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 1099: return",
                "// vulnerable line: 1100: }",
                "// Line 1101:             event := evalActionFromLifecycle(ctx, *lc, rcfg, replcfg, objInfo)",
                "// Line 1102:             if event.Action.Delete() {",
                "// Line 1103:                 // apply whatever the expiry rule is.",
                "// Line 1104:                 applyExpiryRule(event, lcEventSrc_s3HeadObject, objInfo)",
                "// Line 1105:                 if !event.Action.DeleteRestored() {",
                "// Line 1106:                     // If the ILM action is not on restored object return error.",
                "// Line 1107:                     writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrNoSuchKey))",
                "// vulnerable line: 1108: return",
                "// vulnerable line: 1109: }",
                "// vulnerable line: 1110: }",
                "// vulnerable line: 1111: }",
                "// Line 1112:         QueueReplicationHeal(ctx, bucket, objInfo, 0)",
                "// vulnerable line: 1113: }",
                "// Line 1114: ",
                "// Line 1115:     // filter object lock metadata if permission does not permit",
                "// Line 1116:     getRetPerms := checkRequestAuthType(ctx, r, policy.GetObjectRetentionAction, bucket, object)",
                "// Line 1117:     legalHoldPerms := checkRequestAuthType(ctx, r, policy.GetObjectLegalHoldAction, bucket, object)",
                "// Line 1118: ",
                "// Line 1119:     // filter object lock metadata if permission does not permit",
                "// Line 1120:     objInfo.UserDefined = objectlock.FilterObjectLockMetadata(objInfo.UserDefined, getRetPerms != ErrNone, legalHoldPerms != ErrNone)",
                "// Line 1121: ",
                "// Line 1122:     if _, err = DecryptObjectInfo(&objInfo, r); err != nil {",
                "// Line 1123:         writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 1124: return",
                "// vulnerable line: 1125: }",
                "// Line 1126: ",
                "// Line 1127:     if update {",
                "// Line 1128:         asize, err := objInfo.GetActualSize()",
                "// Line 1129:         if err != nil {",
                "// Line 1130:             asize = objInfo.Size",
                "// vulnerable line: 1131: }",
                "// Line 1132: ",
                "// Line 1133:         defer globalCacheConfig.Set(&cache.ObjectInfo{",
                "// Line 1134:             Key:          objInfo.Name,",
                "// Line 1135:             Bucket:       objInfo.Bucket,",
                "// Line 1136:             ETag:         objInfo.ETag,",
                "// Line 1137:             ModTime:      objInfo.ModTime,",
                "// Line 1138:             Expires:      objInfo.ExpiresStr(),",
                "// Line 1139:             CacheControl: objInfo.CacheControl,",
                "// Line 1140:             Size:         asize,",
                "// Line 1141:             Metadata:     cleanReservedKeys(objInfo.UserDefined),",
                "// Line 1142:         })",
                "// vulnerable line: 1143: }",
                "// Line 1144: ",
                "// Line 1145:     // Validate pre-conditions if any.",
                "// Line 1146:     if checkPreconditions(ctx, w, r, objInfo, opts) {",
                "// vulnerable line: 1147: return",
                "// vulnerable line: 1148: }",
                "// Line 1149: ",
                "// Line 1150:     // Set encryption response headers",
                "// Line 1151:     switch kind, _ := crypto.IsEncrypted(objInfo.UserDefined); kind {",
                "// Line 1152:     case crypto.S3:",
                "// Line 1153:         w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)",
                "// Line 1154:     case crypto.S3KMS:",
                "// Line 1155:         w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionKMS)",
                "// Line 1156:         w.Header().Set(xhttp.AmzServerSideEncryptionKmsID, objInfo.KMSKeyID())",
                "// Line 1157:         if kmsCtx, ok := objInfo.UserDefined[crypto.MetaContext]; ok {",
                "// Line 1158:             w.Header().Set(xhttp.AmzServerSideEncryptionKmsContext, kmsCtx)",
                "// vulnerable line: 1159: }",
                "// Line 1160:     case crypto.SSEC:",
                "// Line 1161:         // Validate the SSE-C Key set in the header.",
                "// Line 1162:         if _, err = crypto.SSEC.UnsealObjectKey(r.Header, objInfo.UserDefined, bucket, object); err != nil {",
                "// Line 1163:             writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 1164: return",
                "// vulnerable line: 1165: }",
                "// Line 1166:         w.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))",
                "// Line 1167:         w.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))",
                "// vulnerable line: 1168: }",
                "// Line 1169: ",
                "// Line 1170:     if r.Header.Get(xhttp.AmzChecksumMode) == \"ENABLED\" && rs == nil {",
                "// Line 1171:         // AWS S3 silently drops checksums on range requests.",
                "// Line 1172:         hash.AddChecksumHeader(w, objInfo.decryptChecksums(opts.PartNumber))",
                "// vulnerable line: 1173: }",
                "// Line 1174: ",
                "// Line 1175:     // Set standard object headers.",
                "// Line 1176:     if err = setObjectHeaders(ctx, w, objInfo, rs, opts); err != nil {",
                "// Line 1177:         writeErrorResponseHeadersOnly(w, toAPIError(ctx, err))",
                "// vulnerable line: 1178: return",
                "// vulnerable line: 1179: }",
                "// Line 1180: ",
                "// Line 1181:     // Set Parts Count Header",
                "// Line 1182:     if opts.PartNumber > 0 && len(objInfo.Parts) > 0 {",
                "// Line 1183:         setPartsCountHeaders(w, objInfo)",
                "// vulnerable line: 1184: }",
                "// Line 1185: ",
                "// Line 1186:     // Set any additional requested response headers.",
                "// Line 1187:     setHeadGetRespHeaders(w, r.Form)",
                "// Line 1188: ",
                "// Line 1189:     // Successful response.",
                "// Line 1190:     if rs != nil || opts.PartNumber > 0 {",
                "// Line 1191:         w.WriteHeader(http.StatusPartialContent)",
                "// Line 1192:     } else {",
                "// Line 1193:         w.WriteHeader(http.StatusOK)",
                "// vulnerable line: 1194: }",
                "// Line 1195: ",
                "// Line 1196:     // Notify object accessed via a HEAD request.",
                "// Line 1197:     sendEvent(eventArgs{",
                "// Line 1198:         EventName:    event.ObjectAccessedHead,",
                "// Line 1199:         BucketName:   bucket,",
                "// Line 1200:         Object:       objInfo,",
                "// Line 1201:         ReqParams:    extractReqParams(r),",
                "// Line 1202:         RespElements: extractRespElements(w),",
                "// Line 1203:         UserAgent:    r.UserAgent(),",
                "// Line 1204:         Host:         handlers.GetSourceIP(r),",
                "// Line 1205:     })",
                "// vulnerable line: 1206: }",
                "// Line 1207: ",
                "// Line 1208: // GetObjectAttributesHandles - GET Object",
                "// Line 1209: // -----------",
                "// Line 1210: // This operation retrieves metadata and part metadata from an object without returning the object itself.",
                "// Line 1211: func (api objectAPIHandlers) GetObjectAttributesHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 1212:     ctx := newContext(r, w, \"GetObjectAttributes\")",
                "// Line 1213:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 1214: ",
                "// Line 1215:     objectAPI := api.ObjectAPI()",
                "// Line 1216:     if objectAPI == nil {",
                "// Line 1217:         writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrServerNotInitialized))",
                "// vulnerable line: 1218: return",
                "// vulnerable line: 1219: }",
                "// Line 1220: ",
                "// Line 1221:     vars := mux.Vars(r)",
                "// Line 1222:     bucket := vars[\"bucket\"]",
                "// Line 1223:     object, err := unescapePath(vars[\"object\"])",
                "// Line 1224:     if err != nil {",
                "// Line 1225:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1226: return",
                "// vulnerable line: 1227: }",
                "// Line 1228: ",
                "// Line 1229:     api.getObjectAttributesHandler(ctx, objectAPI, bucket, object, w, r)",
                "// vulnerable line: 1230: }",
                "// Line 1231: ",
                "// Line 1232: // HeadObjectHandler - HEAD Object",
                "// Line 1233: // -----------",
                "// Line 1234: // The HEAD operation retrieves metadata from an object without returning the object itself.",
                "// Line 1235: func (api objectAPIHandlers) HeadObjectHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 1236:     ctx := newContext(r, w, \"HeadObject\")",
                "// Line 1237:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 1238: ",
                "// Line 1239:     objectAPI := api.ObjectAPI()",
                "// Line 1240:     if objectAPI == nil {",
                "// Line 1241:         writeErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrServerNotInitialized))",
                "// vulnerable line: 1242: return",
                "// vulnerable line: 1243: }",
                "// Line 1244: ",
                "// Line 1245:     vars := mux.Vars(r)",
                "// Line 1246:     bucket := vars[\"bucket\"]",
                "// Line 1247:     object, err := unescapePath(vars[\"object\"])",
                "// Line 1248:     if err != nil {",
                "// Line 1249:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1250: return",
                "// vulnerable line: 1251: }",
                "// Line 1252: ",
                "// Line 1253:     if r.Header.Get(xMinIOExtract) == \"true\" && strings.Contains(object, archivePattern) {",
                "// Line 1254:         api.headObjectInArchiveFileHandler(ctx, objectAPI, bucket, object, w, r)",
                "// Line 1255:     } else {",
                "// Line 1256:         api.headObjectHandler(ctx, objectAPI, bucket, object, w, r)",
                "// vulnerable line: 1257: }",
                "// vulnerable line: 1258: }",
                "// Line 1259: ",
                "// Line 1260: // Extract metadata relevant for an CopyObject operation based on conditional",
                "// Line 1261: // header values specified in X-Amz-Metadata-Directive.",
                "// Line 1262: func getCpObjMetadataFromHeader(ctx context.Context, r *http.Request, userMeta map[string]string) (map[string]string, error) {",
                "// Line 1263:     // Make a copy of the supplied metadata to avoid",
                "// Line 1264:     // to change the original one.",
                "// Line 1265:     defaultMeta := make(map[string]string, len(userMeta))",
                "// Line 1266:     for k, v := range userMeta {",
                "// Line 1267:         // skip tier metadata when copying metadata from source object",
                "// Line 1268:         switch k {",
                "// Line 1269:         case metaTierName, metaTierStatus, metaTierObjName, metaTierVersionID:",
                "// Line 1270:             continue",
                "// vulnerable line: 1271: }",
                "// Line 1272:         defaultMeta[k] = v",
                "// vulnerable line: 1273: }",
                "// Line 1274: ",
                "// Line 1275:     // remove SSE Headers from source info",
                "// Line 1276:     crypto.RemoveSSEHeaders(defaultMeta)",
                "// Line 1277: ",
                "// Line 1278:     // Storage class is special, it can be replaced regardless of the",
                "// Line 1279:     // metadata directive, if set should be preserved and replaced",
                "// Line 1280:     // to the destination metadata.",
                "// Line 1281:     sc := r.Header.Get(xhttp.AmzStorageClass)",
                "// Line 1282:     if sc == \"\" {",
                "// Line 1283:         sc = r.Form.Get(xhttp.AmzStorageClass)",
                "// vulnerable line: 1284: }",
                "// Line 1285: ",
                "// Line 1286:     // if x-amz-metadata-directive says REPLACE then",
                "// Line 1287:     // we extract metadata from the input headers.",
                "// Line 1288:     if isDirectiveReplace(r.Header.Get(xhttp.AmzMetadataDirective)) {",
                "// Line 1289:         emetadata, err := extractMetadataFromReq(ctx, r)",
                "// Line 1290:         if err != nil {",
                "// Line 1291:             return nil, err",
                "// vulnerable line: 1292: }",
                "// Line 1293:         if sc != \"\" {",
                "// Line 1294:             emetadata[xhttp.AmzStorageClass] = sc",
                "// vulnerable line: 1295: }",
                "// Line 1296:         return emetadata, nil",
                "// vulnerable line: 1297: }",
                "// Line 1298: ",
                "// Line 1299:     if sc != \"\" {",
                "// Line 1300:         defaultMeta[xhttp.AmzStorageClass] = sc",
                "// vulnerable line: 1301: }",
                "// Line 1302: ",
                "// Line 1303:     // if x-amz-metadata-directive says COPY then we",
                "// Line 1304:     // return the default metadata.",
                "// Line 1305:     if isDirectiveCopy(r.Header.Get(xhttp.AmzMetadataDirective)) {",
                "// Line 1306:         return defaultMeta, nil",
                "// vulnerable line: 1307: }",
                "// Line 1308: ",
                "// Line 1309:     // Copy is default behavior if not x-amz-metadata-directive is set.",
                "// Line 1310:     return defaultMeta, nil",
                "// vulnerable line: 1311: }",
                "// Line 1312: ",
                "// Line 1313: // getRemoteInstanceTransport contains a roundtripper for external (not peers) servers",
                "// Line 1314: var remoteInstanceTransport atomic.Value",
                "// Line 1315: ",
                "// Line 1316: func setRemoteInstanceTransport(tr http.RoundTripper) {",
                "// Line 1317:     remoteInstanceTransport.Store(tr)",
                "// vulnerable line: 1318: }",
                "// Line 1319: ",
                "// Line 1320: func getRemoteInstanceTransport() http.RoundTripper {",
                "// Line 1321:     rt, ok := remoteInstanceTransport.Load().(http.RoundTripper)",
                "// Line 1322:     if ok {",
                "// Line 1323:         return rt",
                "// vulnerable line: 1324: }",
                "// Line 1325:     return nil",
                "// vulnerable line: 1326: }",
                "// Line 1327: ",
                "// Line 1328: // Returns a minio-go Client configured to access remote host described by destDNSRecord",
                "// Line 1329: // Applicable only in a federated deployment",
                "// Line 1330: var getRemoteInstanceClient = func(r *http.Request, host string) (*miniogo.Core, error) {",
                "// Line 1331:     cred := getReqAccessCred(r, globalSite.Region())",
                "// Line 1332:     // In a federated deployment, all the instances share config files",
                "// Line 1333:     // and hence expected to have same credentials.",
                "// Line 1334:     core, err := miniogo.NewCore(host, &miniogo.Options{",
                "// Line 1335:         Creds:     credentials.NewStaticV4(cred.AccessKey, cred.SecretKey, \"\"),",
                "// Line 1336:         Secure:    globalIsTLS,",
                "// Line 1337:         Transport: getRemoteInstanceTransport(),",
                "// Line 1338:     })",
                "// Line 1339:     if err != nil {",
                "// Line 1340:         return nil, err",
                "// vulnerable line: 1341: }",
                "// Line 1342:     core.SetAppInfo(\"minio-federated\", ReleaseTag)",
                "// Line 1343:     return core, nil",
                "// vulnerable line: 1344: }",
                "// Line 1345: ",
                "// Line 1346: // Check if the destination bucket is on a remote site, this code only gets executed",
                "// Line 1347: // when federation is enabled, ie when globalDNSConfig is non 'nil'.",
                "// Line 1348: //",
                "// Line 1349: // This function is similar to isRemoteCallRequired but specifically for COPY object API",
                "// Line 1350: // if destination and source are same we do not need to check for destination bucket",
                "// Line 1351: // to exist locally.",
                "// Line 1352: func isRemoteCopyRequired(ctx context.Context, srcBucket, dstBucket string, objAPI ObjectLayer) bool {",
                "// Line 1353:     if srcBucket == dstBucket {",
                "// Line 1354:         return false",
                "// vulnerable line: 1355: }",
                "// Line 1356:     return isRemoteCallRequired(ctx, dstBucket, objAPI)",
                "// vulnerable line: 1357: }",
                "// Line 1358: ",
                "// Line 1359: // Check if the bucket is on a remote site, this code only gets executed when federation is enabled.",
                "// Line 1360: func isRemoteCallRequired(ctx context.Context, bucket string, objAPI ObjectLayer) bool {",
                "// Line 1361:     if globalDNSConfig == nil {",
                "// Line 1362:         return false",
                "// vulnerable line: 1363: }",
                "// Line 1364:     if globalBucketFederation {",
                "// Line 1365:         _, err := objAPI.GetBucketInfo(ctx, bucket, BucketOptions{})",
                "// Line 1366:         return err == toObjectErr(errVolumeNotFound, bucket)",
                "// vulnerable line: 1367: }",
                "// Line 1368:     return false",
                "// vulnerable line: 1369: }",
                "// Line 1370: ",
                "// Line 1371: // CopyObjectHandler - Copy Object",
                "// Line 1372: // ----------",
                "// Line 1373: // This implementation of the PUT operation adds an object to a bucket",
                "// Line 1374: // while reading the object from another source.",
                "// Line 1375: // Notice: The S3 client can send secret keys in headers for encryption related jobs,",
                "// Line 1376: // the handler should ensure to remove these keys before sending them to the object layer.",
                "// Line 1377: // Currently these keys are:",
                "// Line 1378: //   - X-Amz-Server-Side-Encryption-Customer-Key",
                "// Line 1379: //   - X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key",
                "// Line 1380: func (api objectAPIHandlers) CopyObjectHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 1381:     ctx := newContext(r, w, \"CopyObject\")",
                "// Line 1382: ",
                "// Line 1383:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 1384: ",
                "// Line 1385:     objectAPI := api.ObjectAPI()",
                "// Line 1386:     if objectAPI == nil {",
                "// Line 1387:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 1388: return",
                "// vulnerable line: 1389: }",
                "// Line 1390: ",
                "// Line 1391:     vars := mux.Vars(r)",
                "// Line 1392:     dstBucket := vars[\"bucket\"]",
                "// Line 1393:     dstObject, err := unescapePath(vars[\"object\"])",
                "// Line 1394:     if err != nil {",
                "// Line 1395:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1396: return",
                "// vulnerable line: 1397: }",
                "// Line 1398: ",
                "// Line 1399:     if s3Error := checkRequestAuthType(ctx, r, policy.PutObjectAction, dstBucket, dstObject); s3Error != ErrNone {",
                "// vulnerable line: 1400: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 1401: return",
                "// vulnerable line: 1402: }",
                "// Line 1403: ",
                "// Line 1404:     // Read escaped copy source path to check for parameters.",
                "// Line 1405:     cpSrcPath := r.Header.Get(xhttp.AmzCopySource)",
                "// Line 1406:     var vid string",
                "// Line 1407:     if u, err := url.Parse(cpSrcPath); err == nil {",
                "// Line 1408:         vid = strings.TrimSpace(u.Query().Get(xhttp.VersionID))",
                "// Line 1409:         // Note that url.Parse does the unescaping",
                "// Line 1410:         cpSrcPath = u.Path",
                "// vulnerable line: 1411: }",
                "// Line 1412: ",
                "// Line 1413:     srcBucket, srcObject := path2BucketObject(cpSrcPath)",
                "// Line 1414:     // If source object is empty or bucket is empty, reply back invalid copy source.",
                "// Line 1415:     if srcObject == \"\" || srcBucket == \"\" {",
                "// Line 1416:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidCopySource), r.URL)",
                "// vulnerable line: 1417: return",
                "// vulnerable line: 1418: }",
                "// Line 1419: ",
                "// Line 1420:     if vid != \"\" && vid != nullVersionID {",
                "// Line 1421:         _, err := uuid.Parse(vid)",
                "// Line 1422:         if err != nil {",
                "// Line 1423:             writeErrorResponse(ctx, w, toAPIError(ctx, VersionNotFound{",
                "// Line 1424:                 Bucket:    srcBucket,",
                "// Line 1425:                 Object:    srcObject,",
                "// Line 1426:                 VersionID: vid,",
                "// Line 1427:             }), r.URL)",
                "// vulnerable line: 1428: return",
                "// vulnerable line: 1429: }",
                "// vulnerable line: 1430: }",
                "// Line 1431: ",
                "// Line 1432:     if s3Error := checkRequestAuthType(ctx, r, policy.GetObjectAction, srcBucket, srcObject); s3Error != ErrNone {",
                "// vulnerable line: 1433: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 1434: return",
                "// vulnerable line: 1435: }",
                "// Line 1436: ",
                "// Line 1437:     // Check if metadata directive is valid.",
                "// Line 1438:     if !isDirectiveValid(r.Header.Get(xhttp.AmzMetadataDirective)) {",
                "// Line 1439:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidMetadataDirective), r.URL)",
                "// vulnerable line: 1440: return",
                "// vulnerable line: 1441: }",
                "// Line 1442: ",
                "// Line 1443:     // check if tag directive is valid",
                "// Line 1444:     if !isDirectiveValid(r.Header.Get(xhttp.AmzTagDirective)) {",
                "// Line 1445:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidTagDirective), r.URL)",
                "// vulnerable line: 1446: return",
                "// vulnerable line: 1447: }",
                "// Line 1448: ",
                "// Line 1449:     // Validate storage class metadata if present",
                "// Line 1450:     dstSc := r.Header.Get(xhttp.AmzStorageClass)",
                "// Line 1451:     if dstSc != \"\" && !storageclass.IsValid(dstSc) {",
                "// Line 1452:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidStorageClass), r.URL)",
                "// vulnerable line: 1453: return",
                "// vulnerable line: 1454: }",
                "// Line 1455: ",
                "// Line 1456:     // Check if bucket encryption is enabled",
                "// Line 1457:     sseConfig, _ := globalBucketSSEConfigSys.Get(dstBucket)",
                "// Line 1458:     sseConfig.Apply(r.Header, sse.ApplyOptions{",
                "// Line 1459:         AutoEncrypt: globalAutoEncryption,",
                "// Line 1460:     })",
                "// Line 1461: ",
                "// Line 1462:     var srcOpts, dstOpts ObjectOptions",
                "// Line 1463:     srcOpts, err = copySrcOpts(ctx, r, srcBucket, srcObject)",
                "// Line 1464:     if err != nil {",
                "// Line 1465:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1466: return",
                "// vulnerable line: 1467: }",
                "// Line 1468:     srcOpts.VersionID = vid",
                "// Line 1469: ",
                "// Line 1470:     // convert copy src encryption options for GET calls",
                "// Line 1471:     getOpts := ObjectOptions{",
                "// Line 1472:         VersionID:        srcOpts.VersionID,",
                "// Line 1473:         Versioned:        srcOpts.Versioned,",
                "// Line 1474:         VersionSuspended: srcOpts.VersionSuspended,",
                "// vulnerable line: 1475: }",
                "// Line 1476:     getSSE := encrypt.SSE(srcOpts.ServerSideEncryption)",
                "// Line 1477:     if getSSE != srcOpts.ServerSideEncryption {",
                "// Line 1478:         getOpts.ServerSideEncryption = getSSE",
                "// vulnerable line: 1479: }",
                "// Line 1480: ",
                "// Line 1481:     dstOpts, err = copyDstOpts(ctx, r, dstBucket, dstObject, nil)",
                "// Line 1482:     if err != nil {",
                "// Line 1483:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1484: return",
                "// vulnerable line: 1485: }",
                "// Line 1486:     cpSrcDstSame := isStringEqual(pathJoin(srcBucket, srcObject), pathJoin(dstBucket, dstObject))",
                "// Line 1487: ",
                "// Line 1488:     getObjectNInfo := objectAPI.GetObjectNInfo",
                "// Line 1489: ",
                "// Line 1490:     checkCopyPrecondFn := func(o ObjectInfo) bool {",
                "// Line 1491:         if _, err := DecryptObjectInfo(&o, r); err != nil {",
                "// Line 1492:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// Line 1493:             return true",
                "// vulnerable line: 1494: }",
                "// Line 1495:         return checkCopyObjectPreconditions(ctx, w, r, o)",
                "// vulnerable line: 1496: }",
                "// Line 1497:     getOpts.CheckPrecondFn = checkCopyPrecondFn",
                "// Line 1498:     if cpSrcDstSame {",
                "// Line 1499:         getOpts.NoLock = true",
                "// vulnerable line: 1500: }",
                "// Line 1501: ",
                "// Line 1502:     var rs *HTTPRangeSpec",
                "// Line 1503:     gr, err := getObjectNInfo(ctx, srcBucket, srcObject, rs, r.Header, getOpts)",
                "// Line 1504:     if err != nil {",
                "// Line 1505:         if isErrPreconditionFailed(err) {",
                "// vulnerable line: 1506: return",
                "// vulnerable line: 1507: }",
                "// Line 1508: ",
                "// Line 1509:         // Versioning enabled quite possibly object is deleted might be delete-marker",
                "// Line 1510:         // if present set the headers, no idea why AWS S3 sets these headers.",
                "// Line 1511:         if gr != nil && gr.ObjInfo.VersionID != \"\" && gr.ObjInfo.DeleteMarker {",
                "// Line 1512:             w.Header()[xhttp.AmzVersionID] = []string{gr.ObjInfo.VersionID}",
                "// Line 1513:             w.Header()[xhttp.AmzDeleteMarker] = []string{strconv.FormatBool(gr.ObjInfo.DeleteMarker)}",
                "// vulnerable line: 1514: }",
                "// Line 1515: ",
                "// Line 1516:         // Update context bucket & object names for correct S3 XML error response",
                "// Line 1517:         reqInfo := logger.GetReqInfo(ctx)",
                "// Line 1518:         reqInfo.BucketName = srcBucket",
                "// Line 1519:         reqInfo.ObjectName = srcObject",
                "// Line 1520:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1521: return",
                "// vulnerable line: 1522: }",
                "// Line 1523:     defer gr.Close()",
                "// Line 1524:     srcInfo := gr.ObjInfo",
                "// Line 1525: ",
                "// Line 1526:     // maximum Upload size for object in a single CopyObject operation.",
                "// Line 1527:     if isMaxObjectSize(srcInfo.Size) {",
                "// Line 1528:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)",
                "// vulnerable line: 1529: return",
                "// vulnerable line: 1530: }",
                "// Line 1531: ",
                "// Line 1532:     // We have to copy metadata only if source and destination are same.",
                "// Line 1533:     // this changes for encryption which can be observed below.",
                "// Line 1534:     if cpSrcDstSame {",
                "// Line 1535:         srcInfo.metadataOnly = true",
                "// vulnerable line: 1536: }",
                "// Line 1537: ",
                "// Line 1538:     var chStorageClass bool",
                "// Line 1539:     if dstSc != \"\" && dstSc != srcInfo.StorageClass {",
                "// Line 1540:         chStorageClass = true",
                "// Line 1541:         srcInfo.metadataOnly = false",
                "// Line 1542:     } // no changes in storage-class expected so its a metadataonly operation.",
                "// Line 1543: ",
                "// Line 1544:     var reader io.Reader = gr",
                "// Line 1545: ",
                "// Line 1546:     // Set the actual size to the compressed/decrypted size if encrypted.",
                "// Line 1547:     actualSize, err := srcInfo.GetActualSize()",
                "// Line 1548:     if err != nil {",
                "// Line 1549:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1550: return",
                "// vulnerable line: 1551: }",
                "// Line 1552:     length := actualSize",
                "// Line 1553: ",
                "// Line 1554:     if !cpSrcDstSame {",
                "// Line 1555:         if err := enforceBucketQuotaHard(ctx, dstBucket, actualSize); err != nil {",
                "// Line 1556:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1557: return",
                "// vulnerable line: 1558: }",
                "// vulnerable line: 1559: }",
                "// Line 1560: ",
                "// Line 1561:     // Check if either the source is encrypted or the destination will be encrypted.",
                "// Line 1562:     objectEncryption := crypto.Requested(r.Header)",
                "// Line 1563:     objectEncryption = objectEncryption || crypto.IsSourceEncrypted(srcInfo.UserDefined)",
                "// Line 1564: ",
                "// Line 1565:     var compressMetadata map[string]string",
                "// Line 1566:     // No need to compress for remote etcd calls",
                "// Line 1567:     // Pass the decompressed stream to such calls.",
                "// Line 1568:     isDstCompressed := isCompressible(r.Header, dstObject) &&",
                "// Line 1569:         length > minCompressibleSize &&",
                "// Line 1578:         wantEncryption := crypto.Requested(r.Header)",
                "// Line 1579:         s2c, cb := newS2CompressReader(reader, actualSize, wantEncryption)",
                "// Line 1580:         dstOpts.IndexCB = cb",
                "// Line 1581:         defer s2c.Close()",
                "// Line 1582:         reader = etag.Wrap(s2c, reader)",
                "// Line 1583:         length = -1",
                "// Line 1584:     } else {",
                "// Line 1585:         delete(srcInfo.UserDefined, ReservedMetadataPrefix+\"compression\")",
                "// Line 1586:         delete(srcInfo.UserDefined, ReservedMetadataPrefix+\"actual-size\")",
                "// Line 1587:         reader = gr",
                "// vulnerable line: 1588: }",
                "// Line 1589: ",
                "// Line 1590:     srcInfo.Reader, err = hash.NewReader(ctx, reader, length, \"\", \"\", actualSize)",
                "// Line 1591:     if err != nil {",
                "// Line 1592:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1593: return",
                "// vulnerable line: 1594: }",
                "// Line 1595: ",
                "// Line 1596:     pReader := NewPutObjReader(srcInfo.Reader)",
                "// Line 1597: ",
                "// Line 1598:     // Handle encryption",
                "// Line 1599:     encMetadata := make(map[string]string)",
                "// Line 1600:     // Encryption parameters not applicable for this object.",
                "// Line 1601:     if _, ok := crypto.IsEncrypted(srcInfo.UserDefined); !ok && crypto.SSECopy.IsRequested(r.Header) {",
                "// Line 1602:         writeErrorResponse(ctx, w, toAPIError(ctx, errInvalidEncryptionParameters), r.URL)",
                "// vulnerable line: 1603: return",
                "// vulnerable line: 1604: }",
                "// Line 1605:     // Encryption parameters not present for this object.",
                "// Line 1606:     if crypto.SSEC.IsEncrypted(srcInfo.UserDefined) && !crypto.SSECopy.IsRequested(r.Header) {",
                "// Line 1607:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidSSECustomerAlgorithm), r.URL)",
                "// vulnerable line: 1608: return",
                "// vulnerable line: 1609: }",
                "// Line 1610: ",
                "// Line 1611:     var oldKey, newKey []byte",
                "// Line 1612:     var newKeyID string",
                "// Line 1613:     var kmsCtx kms.Context",
                "// Line 1614:     var objEncKey crypto.ObjectKey",
                "// Line 1615:     sseCopyKMS := crypto.S3KMS.IsEncrypted(srcInfo.UserDefined)",
                "// Line 1616:     sseCopyS3 := crypto.S3.IsEncrypted(srcInfo.UserDefined)",
                "// Line 1617:     sseCopyC := crypto.SSEC.IsEncrypted(srcInfo.UserDefined) && crypto.SSECopy.IsRequested(r.Header)",
                "// Line 1618:     sseC := crypto.SSEC.IsRequested(r.Header)",
                "// Line 1619:     sseS3 := crypto.S3.IsRequested(r.Header)",
                "// Line 1620:     sseKMS := crypto.S3KMS.IsRequested(r.Header)",
                "// Line 1621: ",
                "// Line 1622:     isSourceEncrypted := sseCopyC || sseCopyS3 || sseCopyKMS",
                "// Line 1623:     isTargetEncrypted := sseC || sseS3 || sseKMS",
                "// Line 1624: ",
                "// Line 1625:     if sseC {",
                "// Line 1626:         newKey, err = ParseSSECustomerRequest(r)",
                "// Line 1627:         if err != nil {",
                "// Line 1628:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1629: return",
                "// vulnerable line: 1630: }",
                "// vulnerable line: 1631: }",
                "// Line 1632:     if crypto.S3KMS.IsRequested(r.Header) {",
                "// Line 1633:         newKeyID, kmsCtx, err = crypto.S3KMS.ParseHTTP(r.Header)",
                "// Line 1634:         if err != nil {",
                "// Line 1635:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1636: return",
                "// vulnerable line: 1637: }",
                "// vulnerable line: 1638: }",
                "// Line 1639: ",
                "// Line 1640:     // If src == dst and either",
                "// Line 1641:     // - the object is encrypted using SSE-C and two different SSE-C keys are present",
                "// Line 1642:     // - the object is encrypted using SSE-S3 and the SSE-S3 header is present",
                "// Line 1643:     // - the object storage class is not changing",
                "// Line 1644:     // then execute a key rotation.",
                "// Line 1645:     if cpSrcDstSame && (sseCopyC && sseC) && !chStorageClass {",
                "// Line 1646:         oldKey, err = ParseSSECopyCustomerRequest(r.Header, srcInfo.UserDefined)",
                "// Line 1647:         if err != nil {",
                "// Line 1648:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1649: return",
                "// vulnerable line: 1650: }",
                "// Line 1651: ",
                "// Line 1652:         for k, v := range srcInfo.UserDefined {",
                "// Line 1653:             if stringsHasPrefixFold(k, ReservedMetadataPrefixLower) {",
                "// Line 1654:                 encMetadata[k] = v",
                "// vulnerable line: 1655: }",
                "// vulnerable line: 1656: }",
                "// Line 1657: ",
                "// Line 1658:         if err = rotateKey(ctx, oldKey, newKeyID, newKey, srcBucket, srcObject, encMetadata, kmsCtx); err != nil {",
                "// Line 1659:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1660: return",
                "// vulnerable line: 1661: }",
                "// Line 1662: ",
                "// Line 1663:         // Since we are rotating the keys, make sure to update the metadata.",
                "// Line 1664:         srcInfo.metadataOnly = true",
                "// Line 1665:         srcInfo.keyRotation = true",
                "// Line 1666:     } else {",
                "// Line 1667:         if isSourceEncrypted || isTargetEncrypted {",
                "// Line 1668:             // We are not only copying just metadata instead",
                "// Line 1669:             // we are creating a new object at this point, even",
                "// Line 1670:             // if source and destination are same objects.",
                "// Line 1671:             if !srcInfo.keyRotation {",
                "// Line 1672:                 srcInfo.metadataOnly = false",
                "// vulnerable line: 1673: }",
                "// vulnerable line: 1674: }",
                "// Line 1675: ",
                "// Line 1676:         // Calculate the size of the target object",
                "// Line 1677:         var targetSize int64",
                "// Line 1678: ",
                "// Line 1679:         switch {",
                "// Line 1680:         case isDstCompressed:",
                "// Line 1681:             targetSize = -1",
                "// Line 1682:         case !isSourceEncrypted && !isTargetEncrypted:",
                "// Line 1683:             targetSize, _ = srcInfo.GetActualSize()",
                "// Line 1684:         case isSourceEncrypted && isTargetEncrypted:",
                "// Line 1685:             objInfo := ObjectInfo{Size: actualSize}",
                "// Line 1686:             targetSize = objInfo.EncryptedSize()",
                "// Line 1687:         case !isSourceEncrypted && isTargetEncrypted:",
                "// Line 1688:             targetSize = srcInfo.EncryptedSize()",
                "// Line 1689:         case isSourceEncrypted && !isTargetEncrypted:",
                "// Line 1690:             targetSize, _ = srcInfo.DecryptedSize()",
                "// vulnerable line: 1691: }",
                "// Line 1692: ",
                "// Line 1693:         if isTargetEncrypted {",
                "// Line 1694:             var encReader io.Reader",
                "// Line 1695:             kind, _ := crypto.IsRequested(r.Header)",
                "// Line 1696:             encReader, objEncKey, err = newEncryptReader(ctx, srcInfo.Reader, kind, newKeyID, newKey, dstBucket, dstObject, encMetadata, kmsCtx)",
                "// Line 1697:             if err != nil {",
                "// Line 1698:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1699: return",
                "// vulnerable line: 1700: }",
                "// Line 1701:             reader = etag.Wrap(encReader, srcInfo.Reader)",
                "// vulnerable line: 1702: }",
                "// Line 1703: ",
                "// Line 1704:         if isSourceEncrypted {",
                "// Line 1705:             // Remove all source encrypted related metadata to",
                "// Line 1706:             // avoid copying them in target object.",
                "// Line 1707:             crypto.RemoveInternalEntries(srcInfo.UserDefined)",
                "// vulnerable line: 1708: }",
                "// Line 1709: ",
                "// Line 1710:         // do not try to verify encrypted content",
                "// Line 1711:         srcInfo.Reader, err = hash.NewReader(ctx, reader, targetSize, \"\", \"\", actualSize)",
                "// Line 1712:         if err != nil {",
                "// Line 1713:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1714: return",
                "// vulnerable line: 1715: }",
                "// Line 1716: ",
                "// Line 1717:         if isTargetEncrypted {",
                "// Line 1718:             pReader, err = pReader.WithEncryption(srcInfo.Reader, &objEncKey)",
                "// Line 1719:             if err != nil {",
                "// Line 1720:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1721: return",
                "// vulnerable line: 1722: }",
                "// Line 1723:             if dstOpts.IndexCB != nil {",
                "// Line 1724:                 dstOpts.IndexCB = compressionIndexEncrypter(objEncKey, dstOpts.IndexCB)",
                "// vulnerable line: 1725: }",
                "// vulnerable line: 1726: }",
                "// vulnerable line: 1727: }",
                "// Line 1728: ",
                "// Line 1729:     srcInfo.PutObjReader = pReader",
                "// Line 1730: ",
                "// Line 1731:     srcInfo.UserDefined, err = getCpObjMetadataFromHeader(ctx, r, srcInfo.UserDefined)",
                "// Line 1732:     if err != nil {",
                "// Line 1733:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1734: return",
                "// vulnerable line: 1735: }",
                "// Line 1736: ",
                "// Line 1737:     objTags := srcInfo.UserTags",
                "// Line 1738:     // If x-amz-tagging-directive header is REPLACE, get passed tags.",
                "// Line 1739:     if isDirectiveReplace(r.Header.Get(xhttp.AmzTagDirective)) {",
                "// Line 1740:         objTags = r.Header.Get(xhttp.AmzObjectTagging)",
                "// Line 1741:         if _, err := tags.ParseObjectTags(objTags); err != nil {",
                "// Line 1742:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1743: return",
                "// vulnerable line: 1744: }",
                "// vulnerable line: 1745: }",
                "// Line 1746: ",
                "// Line 1747:     if objTags != \"\" {",
                "// Line 1748:         lastTaggingTimestamp := srcInfo.UserDefined[ReservedMetadataPrefixLower+TaggingTimestamp]",
                "// Line 1749:         if dstOpts.ReplicationRequest {",
                "// Line 1750:             srcTimestamp := dstOpts.ReplicationSourceTaggingTimestamp",
                "// Line 1751:             if !srcTimestamp.IsZero() {",
                "// Line 1752:                 ondiskTimestamp, err := time.Parse(time.RFC3339Nano, lastTaggingTimestamp)",
                "// Line 1753:                 // update tagging metadata only if replica  timestamp is newer than what's on disk",
                "// Line 1754:                 if err != nil || (err == nil && ondiskTimestamp.Before(srcTimestamp)) {",
                "// Line 1755:                     srcInfo.UserDefined[ReservedMetadataPrefixLower+TaggingTimestamp] = srcTimestamp.UTC().Format(time.RFC3339Nano)",
                "// Line 1756:                     srcInfo.UserDefined[xhttp.AmzObjectTagging] = objTags",
                "// vulnerable line: 1757: }",
                "// vulnerable line: 1758: }",
                "// Line 1759:         } else {",
                "// Line 1760:             srcInfo.UserDefined[xhttp.AmzObjectTagging] = objTags",
                "// Line 1761:             srcInfo.UserDefined[ReservedMetadataPrefixLower+TaggingTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// vulnerable line: 1762: }",
                "// Line 1763: ",
                "// vulnerable line: 1764: }",
                "// Line 1765: ",
                "// Line 1766:     srcInfo.UserDefined = filterReplicationStatusMetadata(srcInfo.UserDefined)",
                "// Line 1767:     srcInfo.UserDefined = objectlock.FilterObjectLockMetadata(srcInfo.UserDefined, true, true)",
                "// Line 1768:     retPerms := isPutActionAllowed(ctx, getRequestAuthType(r), dstBucket, dstObject, r, policy.PutObjectRetentionAction)",
                "// Line 1769:     holdPerms := isPutActionAllowed(ctx, getRequestAuthType(r), dstBucket, dstObject, r, policy.PutObjectLegalHoldAction)",
                "// Line 1770:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 1771: ",
                "// Line 1772:     // apply default bucket configuration/governance headers for dest side.",
                "// Line 1773:     retentionMode, retentionDate, legalHold, s3Err := checkPutObjectLockAllowed(ctx, r, dstBucket, dstObject, getObjectInfo, retPerms, holdPerms)",
                "// Line 1774:     if s3Err == ErrNone && retentionMode.Valid() {",
                "// Line 1775:         lastretentionTimestamp := srcInfo.UserDefined[ReservedMetadataPrefixLower+ObjectLockRetentionTimestamp]",
                "// Line 1776:         if dstOpts.ReplicationRequest {",
                "// Line 1777:             srcTimestamp := dstOpts.ReplicationSourceRetentionTimestamp",
                "// Line 1778:             if !srcTimestamp.IsZero() {",
                "// Line 1779:                 ondiskTimestamp, err := time.Parse(time.RFC3339Nano, lastretentionTimestamp)",
                "// Line 1780:                 // update retention metadata only if replica  timestamp is newer than what's on disk",
                "// Line 1781:                 if err != nil || (err == nil && ondiskTimestamp.Before(srcTimestamp)) {",
                "// Line 1782:                     srcInfo.UserDefined[strings.ToLower(xhttp.AmzObjectLockMode)] = string(retentionMode)",
                "// Line 1783:                     srcInfo.UserDefined[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = amztime.ISO8601Format(retentionDate.UTC())",
                "// Line 1784:                     srcInfo.UserDefined[ReservedMetadataPrefixLower+ObjectLockRetentionTimestamp] = srcTimestamp.UTC().Format(time.RFC3339Nano)",
                "// vulnerable line: 1785: }",
                "// vulnerable line: 1786: }",
                "// Line 1787:         } else {",
                "// Line 1788:             srcInfo.UserDefined[strings.ToLower(xhttp.AmzObjectLockMode)] = string(retentionMode)",
                "// Line 1789:             srcInfo.UserDefined[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = amztime.ISO8601Format(retentionDate.UTC())",
                "// Line 1790:             srcInfo.UserDefined[ReservedMetadataPrefixLower+ObjectLockRetentionTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// vulnerable line: 1791: }",
                "// vulnerable line: 1792: }",
                "// Line 1793: ",
                "// Line 1794:     if s3Err == ErrNone && legalHold.Status.Valid() {",
                "// Line 1795:         lastLegalHoldTimestamp := srcInfo.UserDefined[ReservedMetadataPrefixLower+ObjectLockLegalHoldTimestamp]",
                "// Line 1796:         if dstOpts.ReplicationRequest {",
                "// Line 1797:             srcTimestamp := dstOpts.ReplicationSourceLegalholdTimestamp",
                "// Line 1798:             if !srcTimestamp.IsZero() {",
                "// Line 1799:                 ondiskTimestamp, err := time.Parse(time.RFC3339Nano, lastLegalHoldTimestamp)",
                "// Line 1800:                 // update legalhold metadata only if replica timestamp is newer than what's on disk",
                "// Line 1801:                 if err != nil || (err == nil && ondiskTimestamp.Before(srcTimestamp)) {",
                "// Line 1802:                     srcInfo.UserDefined[strings.ToLower(xhttp.AmzObjectLockLegalHold)] = string(legalHold.Status)",
                "// Line 1803:                     srcInfo.UserDefined[ReservedMetadataPrefixLower+ObjectLockRetentionTimestamp] = srcTimestamp.Format(time.RFC3339Nano)",
                "// vulnerable line: 1804: }",
                "// vulnerable line: 1805: }",
                "// Line 1806:         } else {",
                "// Line 1807:             srcInfo.UserDefined[strings.ToLower(xhttp.AmzObjectLockLegalHold)] = string(legalHold.Status)",
                "// vulnerable line: 1808: }",
                "// vulnerable line: 1809: }",
                "// Line 1810:     if s3Err != ErrNone {",
                "// Line 1811:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 1812: return",
                "// vulnerable line: 1813: }",
                "// Line 1814:     if rs := r.Header.Get(xhttp.AmzBucketReplicationStatus); rs != \"\" {",
                "// Line 1815:         srcInfo.UserDefined[ReservedMetadataPrefixLower+ReplicaStatus] = replication.Replica.String()",
                "// Line 1816:         srcInfo.UserDefined[ReservedMetadataPrefixLower+ReplicaTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 1817:         srcInfo.UserDefined[xhttp.AmzBucketReplicationStatus] = rs",
                "// vulnerable line: 1818: }",
                "// Line 1819: ",
                "// Line 1820:     op := replication.ObjectReplicationType",
                "// Line 1821:     if srcInfo.metadataOnly {",
                "// Line 1822:         op = replication.MetadataReplicationType",
                "// vulnerable line: 1823: }",
                "// Line 1824:     if dsc := mustReplicate(ctx, dstBucket, dstObject, srcInfo.getMustReplicateOptions(op, dstOpts)); dsc.ReplicateAny() {",
                "// Line 1825:         srcInfo.UserDefined[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// Line 1826:         srcInfo.UserDefined[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// vulnerable line: 1827: }",
                "// Line 1828:     // Store the preserved compression metadata.",
                "// Line 1829:     for k, v := range compressMetadata {",
                "// Line 1830:         srcInfo.UserDefined[k] = v",
                "// vulnerable line: 1831: }",
                "// Line 1832: ",
                "// Line 1833:     // We need to preserve the encryption headers set in EncryptRequest,",
                "// Line 1834:     // so we do not want to override them, copy them instead.",
                "// Line 1835:     for k, v := range encMetadata {",
                "// Line 1836:         srcInfo.UserDefined[k] = v",
                "// vulnerable line: 1837: }",
                "// Line 1838: ",
                "// Line 1839:     // Ensure that metadata does not contain sensitive information",
                "// Line 1840:     crypto.RemoveSensitiveEntries(srcInfo.UserDefined)",
                "// Line 1841: ",
                "// Line 1842:     // If we see legacy source, metadataOnly we have to overwrite the content.",
                "// Line 1843:     if srcInfo.Legacy {",
                "// Line 1844:         srcInfo.metadataOnly = false",
                "// vulnerable line: 1845: }",
                "// Line 1846: ",
                "// Line 1847:     // Check if x-amz-metadata-directive or x-amz-tagging-directive was not set to REPLACE and source,",
                "// Line 1848:     // destination are same objects. Apply this restriction also when",
                "// Line 1849:     // metadataOnly is true indicating that we are not overwriting the object.",
                "// Line 1850:     // if encryption is enabled we do not need explicit \"REPLACE\" metadata to",
                "// Line 1851:     // be enabled as well - this is to allow for key-rotation.",
                "// Line 1852:     if !isDirectiveReplace(r.Header.Get(xhttp.AmzMetadataDirective)) && !isDirectiveReplace(r.Header.Get(xhttp.AmzTagDirective)) &&",
                "// Line 1853:         srcInfo.metadataOnly && srcOpts.VersionID == \"\" && !objectEncryption {",
                "// Line 1854:         // If x-amz-metadata-directive is not set to REPLACE then we need",
                "// Line 1855:         // to error out if source and destination are same.",
                "// Line 1856:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidCopyDest), r.URL)",
                "// vulnerable line: 1857: return",
                "// vulnerable line: 1858: }",
                "// Line 1859: ",
                "// Line 1860:     remoteCallRequired := isRemoteCopyRequired(ctx, srcBucket, dstBucket, objectAPI)",
                "// Line 1861: ",
                "// Line 1862:     var objInfo ObjectInfo",
                "// Line 1863:     var os *objSweeper",
                "// Line 1864:     if remoteCallRequired {",
                "// Line 1865:         var dstRecords []dns.SrvRecord",
                "// Line 1866:         dstRecords, err = globalDNSConfig.Get(dstBucket)",
                "// Line 1867:         if err != nil {",
                "// Line 1868:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1869: return",
                "// vulnerable line: 1870: }",
                "// Line 1871: ",
                "// Line 1872:         // Send PutObject request to appropriate instance (in federated deployment)",
                "// Line 1873:         core, rerr := getRemoteInstanceClient(r, getHostFromSrv(dstRecords))",
                "// Line 1874:         if rerr != nil {",
                "// Line 1875:             writeErrorResponse(ctx, w, toAPIError(ctx, rerr), r.URL)",
                "// vulnerable line: 1876: return",
                "// vulnerable line: 1877: }",
                "// Line 1878:         tag, err := tags.ParseObjectTags(objTags)",
                "// Line 1879:         if err != nil {",
                "// Line 1880:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1881: return",
                "// vulnerable line: 1882: }",
                "// Line 1883:         // Remove the metadata for remote calls.",
                "// Line 1884:         delete(srcInfo.UserDefined, ReservedMetadataPrefix+\"compression\")",
                "// Line 1885:         delete(srcInfo.UserDefined, ReservedMetadataPrefix+\"actual-size\")",
                "// Line 1886:         opts := miniogo.PutObjectOptions{",
                "// Line 1887:             UserMetadata:         srcInfo.UserDefined,",
                "// Line 1888:             ServerSideEncryption: dstOpts.ServerSideEncryption,",
                "// Line 1889:             UserTags:             tag.ToMap(),",
                "// vulnerable line: 1890: }",
                "// Line 1891:         remoteObjInfo, rerr := core.PutObject(ctx, dstBucket, dstObject, srcInfo.Reader,",
                "// Line 1892:             srcInfo.Size, \"\", \"\", opts)",
                "// Line 1893:         if rerr != nil {",
                "// Line 1894:             writeErrorResponse(ctx, w, toAPIError(ctx, rerr), r.URL)",
                "// vulnerable line: 1895: return",
                "// vulnerable line: 1896: }",
                "// Line 1897:         objInfo.UserDefined = cloneMSS(opts.UserMetadata)",
                "// Line 1898:         objInfo.ETag = remoteObjInfo.ETag",
                "// Line 1899:         objInfo.ModTime = remoteObjInfo.LastModified",
                "// Line 1900:     } else {",
                "// Line 1901:         os = newObjSweeper(dstBucket, dstObject).WithVersioning(dstOpts.Versioned, dstOpts.VersionSuspended)",
                "// Line 1902:         // Get appropriate object info to identify the remote object to delete",
                "// Line 1903:         if !srcInfo.metadataOnly {",
                "// Line 1904:             goiOpts := os.GetOpts()",
                "// Line 1905:             if !globalTierConfigMgr.Empty() {",
                "// Line 1906:                 if goi, gerr := getObjectInfo(ctx, dstBucket, dstObject, goiOpts); gerr == nil {",
                "// Line 1907:                     os.SetTransitionState(goi.TransitionedObject)",
                "// vulnerable line: 1908: }",
                "// vulnerable line: 1909: }",
                "// vulnerable line: 1910: }",
                "// Line 1911: ",
                "// Line 1912:         copyObjectFn := objectAPI.CopyObject",
                "// Line 1913: ",
                "// Line 1914:         // Copy source object to destination, if source and destination",
                "// Line 1915:         // object is same then only metadata is updated.",
                "// Line 1916:         objInfo, err = copyObjectFn(ctx, srcBucket, srcObject, dstBucket, dstObject, srcInfo, srcOpts, dstOpts)",
                "// Line 1917:         if err != nil {",
                "// Line 1918:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 1919: return",
                "// vulnerable line: 1920: }",
                "// vulnerable line: 1921: }",
                "// Line 1922: ",
                "// Line 1923:     origETag := objInfo.ETag",
                "// Line 1924:     objInfo.ETag = getDecryptedETag(r.Header, objInfo, false)",
                "// Line 1925:     response := generateCopyObjectResponse(objInfo.ETag, objInfo.ModTime)",
                "// Line 1926:     encodedSuccessResponse := encodeResponse(response)",
                "// Line 1927: ",
                "// Line 1928:     if dsc := mustReplicate(ctx, dstBucket, dstObject, objInfo.getMustReplicateOptions(replication.ObjectReplicationType, dstOpts)); dsc.ReplicateAny() {",
                "// Line 1929:         scheduleReplication(ctx, objInfo, objectAPI, dsc, replication.ObjectReplicationType)",
                "// vulnerable line: 1930: }",
                "// Line 1931: ",
                "// Line 1932:     setPutObjHeaders(w, objInfo, false)",
                "// Line 1933:     // We must not use the http.Header().Set method here because some (broken)",
                "// Line 1934:     // clients expect the x-amz-copy-source-version-id header key to be literally",
                "// Line 1935:     // \"x-amz-copy-source-version-id\"- not in canonicalized form, preserve it.",
                "// Line 1936:     if srcOpts.VersionID != \"\" {",
                "// Line 1937:         w.Header()[strings.ToLower(xhttp.AmzCopySourceVersionID)] = []string{srcOpts.VersionID}",
                "// vulnerable line: 1938: }",
                "// Line 1939: ",
                "// Line 1940:     // Write success response.",
                "// Line 1941:     writeSuccessResponseXML(w, encodedSuccessResponse)",
                "// Line 1942: ",
                "// Line 1943:     // Notify object created event.",
                "// Line 1944:     sendEvent(eventArgs{",
                "// Line 1945:         EventName:    event.ObjectCreatedCopy,",
                "// Line 1946:         BucketName:   dstBucket,",
                "// Line 1947:         Object:       objInfo,",
                "// Line 1948:         ReqParams:    extractReqParams(r),",
                "// Line 1949:         RespElements: extractRespElements(w),",
                "// Line 1950:         UserAgent:    r.UserAgent(),",
                "// Line 1951:         Host:         handlers.GetSourceIP(r),",
                "// Line 1952:     })",
                "// Line 1953: ",
                "// Line 1954:     asize, err := objInfo.GetActualSize()",
                "// Line 1955:     if err != nil {",
                "// Line 1956:         asize = objInfo.Size",
                "// vulnerable line: 1957: }",
                "// Line 1958: ",
                "// Line 1959:     defer globalCacheConfig.Set(&cache.ObjectInfo{",
                "// Line 1960:         Key:          objInfo.Name,",
                "// Line 1961:         Bucket:       objInfo.Bucket,",
                "// Line 1962:         ETag:         objInfo.ETag,",
                "// Line 1963:         ModTime:      objInfo.ModTime,",
                "// Line 1964:         Expires:      objInfo.ExpiresStr(),",
                "// Line 1965:         CacheControl: objInfo.CacheControl,",
                "// Line 1966:         Size:         asize,",
                "// Line 1967:         Metadata:     cleanReservedKeys(objInfo.UserDefined),",
                "// Line 1968:     })",
                "// Line 1969: ",
                "// Line 1970:     if !remoteCallRequired && !globalTierConfigMgr.Empty() {",
                "// Line 1971:         // Schedule object for immediate transition if eligible.",
                "// Line 1972:         objInfo.ETag = origETag",
                "// Line 1973:         enqueueTransitionImmediate(objInfo, lcEventSrc_s3CopyObject)",
                "// Line 1974:         // Remove the transitioned object whose object version is being overwritten.",
                "// Line 1975:         os.Sweep()",
                "// vulnerable line: 1976: }",
                "// vulnerable line: 1977: }",
                "// Line 1978: ",
                "// Line 1979: // PutObjectHandler - PUT Object",
                "// Line 1980: // ----------",
                "// Line 1981: // This implementation of the PUT operation adds an object to a bucket.",
                "// Line 1982: // Notice: The S3 client can send secret keys in headers for encryption related jobs,",
                "// Line 1983: // the handler should ensure to remove these keys before sending them to the object layer.",
                "// Line 1984: // Currently these keys are:",
                "// Line 1985: //   - X-Amz-Server-Side-Encryption-Customer-Key",
                "// Line 1986: //   - X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key",
                "// Line 1987: func (api objectAPIHandlers) PutObjectHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 1988:     ctx := newContext(r, w, \"PutObject\")",
                "// Line 1989:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 1990: ",
                "// Line 1991:     objectAPI := api.ObjectAPI()",
                "// Line 1992:     if objectAPI == nil {",
                "// Line 1993:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 1994: return",
                "// vulnerable line: 1995: }",
                "// Line 1996: ",
                "// Line 1997:     vars := mux.Vars(r)",
                "// Line 1998:     bucket := vars[\"bucket\"]",
                "// Line 1999:     object, err := unescapePath(vars[\"object\"])",
                "// Line 2000:     if err != nil {",
                "// Line 2001:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2002: return",
                "// vulnerable line: 2003: }",
                "// Line 2004: ",
                "// Line 2005:     // X-Amz-Copy-Source shouldn't be set for this call.",
                "// Line 2006:     if _, ok := r.Header[xhttp.AmzCopySource]; ok {",
                "// Line 2007:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidCopySource), r.URL)",
                "// vulnerable line: 2008: return",
                "// vulnerable line: 2009: }",
                "// Line 2010: ",
                "// Line 2011:     // Validate storage class metadata if present",
                "// Line 2012:     if sc := r.Header.Get(xhttp.AmzStorageClass); sc != \"\" {",
                "// Line 2013:         if !storageclass.IsValid(sc) {",
                "// Line 2014:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidStorageClass), r.URL)",
                "// vulnerable line: 2015: return",
                "// vulnerable line: 2016: }",
                "// vulnerable line: 2017: }",
                "// Line 2018: ",
                "// Line 2019:     clientETag, err := etag.FromContentMD5(r.Header)",
                "// Line 2020:     if err != nil {",
                "// Line 2021:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidDigest), r.URL)",
                "// vulnerable line: 2022: return",
                "// vulnerable line: 2023: }",
                "// Line 2024: ",
                "// Line 2025:     // if Content-Length is unknown/missing, deny the request",
                "// Line 2026:     size := r.ContentLength",
                "// Line 2027:     rAuthType := getRequestAuthType(r)",
                "// Line 2028:     switch rAuthType {",
                "// Line 2029:     // Check signature types that must have content length",
                "// Line 2030:     case authTypeStreamingSigned, authTypeStreamingSignedTrailer, authTypeStreamingUnsignedTrailer:",
                "// Line 2031:         if sizeStr, ok := r.Header[xhttp.AmzDecodedContentLength]; ok {",
                "// Line 2032:             if sizeStr[0] == \"\" {",
                "// Line 2033:                 writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)",
                "// vulnerable line: 2034: return",
                "// vulnerable line: 2035: }",
                "// Line 2036:             size, err = strconv.ParseInt(sizeStr[0], 10, 64)",
                "// Line 2037:             if err != nil {",
                "// Line 2038:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2039: return",
                "// vulnerable line: 2040: }",
                "// vulnerable line: 2041: }",
                "// vulnerable line: 2042: }",
                "// Line 2043:     if size == -1 {",
                "// Line 2044:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)",
                "// vulnerable line: 2045: return",
                "// vulnerable line: 2046: }",
                "// Line 2047: ",
                "// Line 2048:     // maximum Upload size for objects in a single operation",
                "// Line 2049:     if isMaxObjectSize(size) {",
                "// Line 2050:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)",
                "// vulnerable line: 2051: return",
                "// vulnerable line: 2052: }",
                "// Line 2053: ",
                "// Line 2054:     metadata, err := extractMetadataFromReq(ctx, r)",
                "// Line 2055:     if err != nil {",
                "// Line 2056:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2057: return",
                "// vulnerable line: 2058: }",
                "// Line 2059: ",
                "// Line 2060:     if objTags := r.Header.Get(xhttp.AmzObjectTagging); objTags != \"\" {",
                "// Line 2061:         if _, err := tags.ParseObjectTags(objTags); err != nil {",
                "// Line 2062:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2063: return",
                "// vulnerable line: 2064: }",
                "// Line 2065: ",
                "// Line 2066:         metadata[xhttp.AmzObjectTagging] = objTags",
                "// vulnerable line: 2067: }",
                "// Line 2068: ",
                "// Line 2069:     var (",
                "// Line 2070:         md5hex              = clientETag.String()",
                "// Line 2071:         sha256hex           = \"\"",
                "// Line 2072:         rd        io.Reader = r.Body",
                "// Line 2073:         s3Err     APIErrorCode",
                "// Line 2074:         putObject = objectAPI.PutObject",
                "// Line 2075:     )",
                "// Line 2076: ",
                "// Line 2077:     // Check if put is allowed",
                "// Line 2078:     if s3Err = isPutActionAllowed(ctx, rAuthType, bucket, object, r, policy.PutObjectAction); s3Err != ErrNone {",
                "// Line 2079:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2080: return",
                "// vulnerable line: 2081: }",
                "// Line 2082: ",
                "// Line 2083:     switch rAuthType {",
                "// Line 2084:     case authTypeStreamingSigned, authTypeStreamingSignedTrailer:",
                "// Line 2085:         // Initialize stream signature verifier.",
                "// Line 2086:         rd, s3Err = newSignV4ChunkedReader(r, rAuthType == authTypeStreamingSignedTrailer)",
                "// Line 2087:         if s3Err != ErrNone {",
                "// Line 2088:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2089: return",
                "// vulnerable line: 2090: }",
                "// Line 2091:     case authTypeStreamingUnsignedTrailer:",
                "// Line 2092:         // Initialize stream chunked reader with optional trailers.",
                "// Line 2093:         rd, s3Err = newUnsignedV4ChunkedReader(r, true)",
                "// Line 2094:         if s3Err != ErrNone {",
                "// Line 2095:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2096: return",
                "// vulnerable line: 2097: }",
                "// Line 2098:     case authTypeSignedV2, authTypePresignedV2:",
                "// Line 2099:         s3Err = isReqAuthenticatedV2(r)",
                "// Line 2100:         if s3Err != ErrNone {",
                "// Line 2101:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2102: return",
                "// vulnerable line: 2103: }",
                "// Line 2104: ",
                "// Line 2105:     case authTypePresigned, authTypeSigned:",
                "// Line 2106:         if s3Err = reqSignatureV4Verify(r, globalSite.Region(), serviceS3); s3Err != ErrNone {",
                "// Line 2107:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2108: return",
                "// vulnerable line: 2109: }",
                "// Line 2110:         if !skipContentSha256Cksum(r) {",
                "// Line 2111:             sha256hex = getContentSha256Cksum(r, serviceS3)",
                "// vulnerable line: 2112: }",
                "// vulnerable line: 2113: }",
                "// Line 2114: ",
                "// Line 2115:     if _, ok := r.Header[xhttp.MinIOSourceReplicationCheck]; ok {",
                "// Line 2116:         // requests to just validate replication settings and permissions are not allowed to write data",
                "// Line 2117:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrReplicationPermissionCheckError), r.URL)",
                "// vulnerable line: 2118: return",
                "// vulnerable line: 2119: }",
                "// Line 2120: ",
                "// Line 2121:     if err := enforceBucketQuotaHard(ctx, bucket, size); err != nil {",
                "// Line 2122:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2123: return",
                "// vulnerable line: 2124: }",
                "// Line 2125:     if r.Header.Get(xhttp.AmzBucketReplicationStatus) == replication.Replica.String() {",
                "// Line 2126:         if s3Err = isPutActionAllowed(ctx, getRequestAuthType(r), bucket, object, r, policy.ReplicateObjectAction); s3Err != ErrNone {",
                "// Line 2127:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2128: return",
                "// vulnerable line: 2129: }",
                "// Line 2130:         metadata[ReservedMetadataPrefixLower+ReplicaStatus] = replication.Replica.String()",
                "// Line 2131:         metadata[ReservedMetadataPrefixLower+ReplicaTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 2132:         defer globalReplicationStats.UpdateReplicaStat(bucket, size)",
                "// vulnerable line: 2133: }",
                "// Line 2134: ",
                "// Line 2135:     // Check if bucket encryption is enabled",
                "// Line 2136:     sseConfig, _ := globalBucketSSEConfigSys.Get(bucket)",
                "// Line 2137:     sseConfig.Apply(r.Header, sse.ApplyOptions{",
                "// Line 2138:         AutoEncrypt: globalAutoEncryption,",
                "// Line 2139:     })",
                "// Line 2140: ",
                "// Line 2141:     var buf *bytebufferpool.ByteBuffer",
                "// Line 2142:     if globalCacheConfig.MatchesSize(size) {",
                "// Line 2143:         buf = bytebufferpool.Get()",
                "// Line 2144:         defer bytebufferpool.Put(buf)",
                "// vulnerable line: 2145: }",
                "// Line 2146: ",
                "// Line 2147:     var reader io.Reader",
                "// Line 2148:     reader = rd",
                "// Line 2149:     if buf != nil {",
                "// Line 2150:         reader = io.TeeReader(rd, buf)",
                "// vulnerable line: 2151: }",
                "// Line 2152: ",
                "// Line 2153:     actualSize := size",
                "// Line 2154:     var idxCb func() []byte",
                "// Line 2155:     if isCompressible(r.Header, object) && size > minCompressibleSize {",
                "// Line 2156:         // Storing the compression metadata.",
                "// Line 2157:         metadata[ReservedMetadataPrefix+\"compression\"] = compressionAlgorithmV2",
                "// Line 2158:         metadata[ReservedMetadataPrefix+\"actual-size\"] = strconv.FormatInt(size, 10)",
                "// Line 2159: ",
                "// Line 2160:         actualReader, err := hash.NewReader(ctx, reader, size, md5hex, sha256hex, actualSize)",
                "// Line 2161:         if err != nil {",
                "// Line 2162:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2163: return",
                "// vulnerable line: 2164: }",
                "// Line 2165:         if err = actualReader.AddChecksum(r, false); err != nil {",
                "// Line 2166:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidChecksum), r.URL)",
                "// vulnerable line: 2167: return",
                "// vulnerable line: 2168: }",
                "// Line 2169:         // Set compression metrics.",
                "// Line 2170:         var s2c io.ReadCloser",
                "// Line 2171:         wantEncryption := crypto.Requested(r.Header)",
                "// Line 2172:         s2c, idxCb = newS2CompressReader(actualReader, actualSize, wantEncryption)",
                "// Line 2173:         defer s2c.Close()",
                "// Line 2174: ",
                "// Line 2175:         reader = etag.Wrap(s2c, actualReader)",
                "// Line 2176:         size = -1   // Since compressed size is un-predictable.",
                "// Line 2177:         md5hex = \"\" // Do not try to verify the content.",
                "// Line 2178:         sha256hex = \"\"",
                "// vulnerable line: 2179: }",
                "// Line 2180: ",
                "// Line 2181:     var forceMD5 []byte",
                "// Line 2182:     // Optimization: If SSE-KMS and SSE-C did not request Content-Md5. Use uuid as etag. Optionally enable this also",
                "// Line 2183:     // for server that is started with `--no-compat`.",
                "// Line 2184:     if !etag.ContentMD5Requested(r.Header) && (crypto.S3KMS.IsRequested(r.Header) || crypto.SSEC.IsRequested(r.Header) || !globalServerCtxt.StrictS3Compat) {",
                "// Line 2185:         forceMD5 = mustGetUUIDBytes()",
                "// vulnerable line: 2186: }",
                "// Line 2187:     hashReader, err := hash.NewReaderWithOpts(ctx, reader, hash.Options{",
                "// Line 2188:         Size:       size,",
                "// Line 2189:         MD5Hex:     md5hex,",
                "// Line 2190:         SHA256Hex:  sha256hex,",
                "// Line 2191:         ActualSize: actualSize,",
                "// Line 2192:         DisableMD5: false,",
                "// Line 2193:         ForceMD5:   forceMD5,",
                "// Line 2194:     })",
                "// Line 2195:     if err != nil {",
                "// Line 2196:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2197: return",
                "// vulnerable line: 2198: }",
                "// Line 2199:     if err := hashReader.AddChecksum(r, size < 0); err != nil {",
                "// Line 2200:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidChecksum), r.URL)",
                "// vulnerable line: 2201: return",
                "// vulnerable line: 2202: }",
                "// Line 2203: ",
                "// Line 2204:     rawReader := hashReader",
                "// Line 2205:     pReader := NewPutObjReader(rawReader)",
                "// Line 2206: ",
                "// Line 2207:     var opts ObjectOptions",
                "// Line 2208:     opts, err = putOptsFromReq(ctx, r, bucket, object, metadata)",
                "// Line 2209:     if err != nil {",
                "// Line 2210:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2211: return",
                "// vulnerable line: 2212: }",
                "// Line 2213:     opts.IndexCB = idxCb",
                "// Line 2214: ",
                "// Line 2215:     if opts.PreserveETag != \"\" ||",
                "// Line 2216:         r.Header.Get(xhttp.IfMatch) != \"\" ||",
                "// Line 2217:         r.Header.Get(xhttp.IfNoneMatch) != \"\" {",
                "// Line 2218:         opts.CheckPrecondFn = func(oi ObjectInfo) bool {",
                "// Line 2219:             if _, err := DecryptObjectInfo(&oi, r); err != nil {",
                "// Line 2220:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// Line 2221:                 return true",
                "// vulnerable line: 2222: }",
                "// Line 2223:             return checkPreconditionsPUT(ctx, w, r, oi, opts)",
                "// vulnerable line: 2224: }",
                "// vulnerable line: 2225: }",
                "// Line 2226: ",
                "// Line 2227:     retPerms := isPutActionAllowed(ctx, getRequestAuthType(r), bucket, object, r, policy.PutObjectRetentionAction)",
                "// Line 2228:     holdPerms := isPutActionAllowed(ctx, getRequestAuthType(r), bucket, object, r, policy.PutObjectLegalHoldAction)",
                "// Line 2229: ",
                "// Line 2230:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 2231: ",
                "// Line 2232:     retentionMode, retentionDate, legalHold, s3Err := checkPutObjectLockAllowed(ctx, r, bucket, object, getObjectInfo, retPerms, holdPerms)",
                "// Line 2233:     if s3Err == ErrNone && retentionMode.Valid() {",
                "// Line 2234:         metadata[strings.ToLower(xhttp.AmzObjectLockMode)] = string(retentionMode)",
                "// Line 2235:         metadata[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = amztime.ISO8601Format(retentionDate.UTC())",
                "// vulnerable line: 2236: }",
                "// Line 2237:     if s3Err == ErrNone && legalHold.Status.Valid() {",
                "// Line 2238:         metadata[strings.ToLower(xhttp.AmzObjectLockLegalHold)] = string(legalHold.Status)",
                "// vulnerable line: 2239: }",
                "// Line 2240:     if s3Err != ErrNone {",
                "// Line 2241:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2242: return",
                "// vulnerable line: 2243: }",
                "// Line 2244:     if dsc := mustReplicate(ctx, bucket, object, getMustReplicateOptions(metadata, \"\", \"\", replication.ObjectReplicationType, opts)); dsc.ReplicateAny() {",
                "// Line 2245:         metadata[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 2246:         metadata[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// vulnerable line: 2247: }",
                "// Line 2248:     var objectEncryptionKey crypto.ObjectKey",
                "// Line 2249:     if crypto.Requested(r.Header) {",
                "// Line 2250:         if crypto.SSECopy.IsRequested(r.Header) {",
                "// Line 2251:             writeErrorResponse(ctx, w, toAPIError(ctx, errInvalidEncryptionParameters), r.URL)",
                "// vulnerable line: 2252: return",
                "// vulnerable line: 2253: }",
                "// Line 2254: ",
                "// Line 2255:         if crypto.SSEC.IsRequested(r.Header) && crypto.S3.IsRequested(r.Header) {",
                "// Line 2256:             writeErrorResponse(ctx, w, toAPIError(ctx, crypto.ErrIncompatibleEncryptionMethod), r.URL)",
                "// vulnerable line: 2257: return",
                "// vulnerable line: 2258: }",
                "// Line 2259: ",
                "// Line 2260:         if crypto.SSEC.IsRequested(r.Header) && crypto.S3KMS.IsRequested(r.Header) {",
                "// Line 2261:             writeErrorResponse(ctx, w, toAPIError(ctx, crypto.ErrIncompatibleEncryptionMethod), r.URL)",
                "// vulnerable line: 2262: return",
                "// vulnerable line: 2263: }",
                "// Line 2264: ",
                "// Line 2265:         if crypto.SSEC.IsRequested(r.Header) && isCompressible(r.Header, object) {",
                "// Line 2266:             writeErrorResponse(ctx, w, toAPIError(ctx, crypto.ErrIncompatibleEncryptionWithCompression), r.URL)",
                "// vulnerable line: 2267: return",
                "// vulnerable line: 2268: }",
                "// Line 2269: ",
                "// Line 2270:         reader, objectEncryptionKey, err = EncryptRequest(hashReader, r, bucket, object, metadata)",
                "// Line 2271:         if err != nil {",
                "// Line 2272:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2273: return",
                "// vulnerable line: 2274: }",
                "// Line 2275: ",
                "// Line 2276:         wantSize := int64(-1)",
                "// Line 2277:         if size >= 0 {",
                "// Line 2278:             info := ObjectInfo{Size: size}",
                "// Line 2279:             wantSize = info.EncryptedSize()",
                "// vulnerable line: 2280: }",
                "// Line 2281: ",
                "// Line 2282:         // do not try to verify encrypted content",
                "// Line 2283:         hashReader, err = hash.NewReader(ctx, etag.Wrap(reader, hashReader), wantSize, \"\", \"\", actualSize)",
                "// Line 2284:         if err != nil {",
                "// Line 2285:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2286: return",
                "// vulnerable line: 2287: }",
                "// Line 2288:         pReader, err = pReader.WithEncryption(hashReader, &objectEncryptionKey)",
                "// Line 2289:         if err != nil {",
                "// Line 2290:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2291: return",
                "// vulnerable line: 2292: }",
                "// Line 2293:         if opts.IndexCB != nil {",
                "// Line 2294:             opts.IndexCB = compressionIndexEncrypter(objectEncryptionKey, opts.IndexCB)",
                "// vulnerable line: 2295: }",
                "// Line 2296:         opts.EncryptFn = metadataEncrypter(objectEncryptionKey)",
                "// vulnerable line: 2297: }",
                "// Line 2298: ",
                "// Line 2299:     // Ensure that metadata does not contain sensitive information",
                "// Line 2300:     crypto.RemoveSensitiveEntries(metadata)",
                "// Line 2301: ",
                "// Line 2302:     os := newObjSweeper(bucket, object).WithVersioning(opts.Versioned, opts.VersionSuspended)",
                "// Line 2303:     if !globalTierConfigMgr.Empty() {",
                "// Line 2304:         // Get appropriate object info to identify the remote object to delete",
                "// Line 2305:         goiOpts := os.GetOpts()",
                "// Line 2306:         if goi, gerr := getObjectInfo(ctx, bucket, object, goiOpts); gerr == nil {",
                "// Line 2307:             os.SetTransitionState(goi.TransitionedObject)",
                "// vulnerable line: 2308: }",
                "// vulnerable line: 2309: }",
                "// Line 2310: ",
                "// Line 2311:     // Create the object..",
                "// Line 2312:     objInfo, err := putObject(ctx, bucket, object, pReader, opts)",
                "// Line 2313:     if err != nil {",
                "// Line 2314:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2315: return",
                "// vulnerable line: 2316: }",
                "// Line 2317: ",
                "// Line 2318:     if r.Header.Get(xMinIOExtract) == \"true\" && HasSuffix(object, archiveExt) {",
                "// Line 2319:         opts := ObjectOptions{VersionID: objInfo.VersionID, MTime: objInfo.ModTime}",
                "// Line 2320:         if _, err := updateObjectMetadataWithZipInfo(ctx, objectAPI, bucket, object, opts); err != nil {",
                "// Line 2321:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2322: return",
                "// vulnerable line: 2323: }",
                "// vulnerable line: 2324: }",
                "// Line 2325: ",
                "// Line 2326:     origETag := objInfo.ETag",
                "// Line 2327:     if kind, encrypted := crypto.IsEncrypted(objInfo.UserDefined); encrypted {",
                "// Line 2328:         switch kind {",
                "// Line 2329:         case crypto.S3:",
                "// Line 2330:             w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)",
                "// Line 2331:             objInfo.ETag, _ = DecryptETag(objectEncryptionKey, ObjectInfo{ETag: objInfo.ETag})",
                "// Line 2332:         case crypto.S3KMS:",
                "// Line 2333:             w.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionKMS)",
                "// Line 2334:             w.Header().Set(xhttp.AmzServerSideEncryptionKmsID, objInfo.KMSKeyID())",
                "// Line 2335:             if kmsCtx, ok := objInfo.UserDefined[crypto.MetaContext]; ok {",
                "// Line 2336:                 w.Header().Set(xhttp.AmzServerSideEncryptionKmsContext, kmsCtx)",
                "// vulnerable line: 2337: }",
                "// Line 2338:             if len(objInfo.ETag) >= 32 && strings.Count(objInfo.ETag, \"-\") != 1 {",
                "// Line 2339:                 objInfo.ETag = objInfo.ETag[len(objInfo.ETag)-32:]",
                "// vulnerable line: 2340: }",
                "// Line 2341:         case crypto.SSEC:",
                "// Line 2342:             w.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))",
                "// Line 2343:             w.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))",
                "// Line 2344: ",
                "// Line 2345:             if len(objInfo.ETag) >= 32 && strings.Count(objInfo.ETag, \"-\") != 1 {",
                "// Line 2346:                 objInfo.ETag = objInfo.ETag[len(objInfo.ETag)-32:]",
                "// vulnerable line: 2347: }",
                "// vulnerable line: 2348: }",
                "// vulnerable line: 2349: }",
                "// Line 2350:     if dsc := mustReplicate(ctx, bucket, object, getMustReplicateOptions(metadata, \"\", \"\", replication.ObjectReplicationType, opts)); dsc.ReplicateAny() {",
                "// Line 2351:         scheduleReplication(ctx, objInfo, objectAPI, dsc, replication.ObjectReplicationType)",
                "// vulnerable line: 2352: }",
                "// Line 2353: ",
                "// Line 2354:     setPutObjHeaders(w, objInfo, false)",
                "// Line 2355: ",
                "// Line 2356:     defer func() {",
                "// Line 2357:         var data []byte",
                "// Line 2358:         if buf != nil {",
                "// Line 2359:             data = buf.Bytes()",
                "// vulnerable line: 2360: }",
                "// Line 2361: ",
                "// Line 2362:         asize, err := objInfo.GetActualSize()",
                "// Line 2363:         if err != nil {",
                "// Line 2364:             asize = objInfo.Size",
                "// vulnerable line: 2365: }",
                "// Line 2366: ",
                "// Line 2367:         globalCacheConfig.Set(&cache.ObjectInfo{",
                "// Line 2368:             Key:          objInfo.Name,",
                "// Line 2369:             Bucket:       objInfo.Bucket,",
                "// Line 2370:             ETag:         objInfo.ETag,",
                "// Line 2371:             ModTime:      objInfo.ModTime,",
                "// Line 2372:             Expires:      objInfo.ExpiresStr(),",
                "// Line 2373:             CacheControl: objInfo.CacheControl,",
                "// Line 2374:             Size:         asize,",
                "// Line 2375:             Metadata:     cleanReservedKeys(objInfo.UserDefined),",
                "// Line 2379: ",
                "// Line 2380:     // Notify object created event.",
                "// Line 2381:     evt := eventArgs{",
                "// Line 2382:         EventName:    event.ObjectCreatedPut,",
                "// Line 2383:         BucketName:   bucket,",
                "// Line 2384:         Object:       objInfo,",
                "// Line 2385:         ReqParams:    extractReqParams(r),",
                "// Line 2386:         RespElements: extractRespElements(w),",
                "// Line 2387:         UserAgent:    r.UserAgent(),",
                "// Line 2388:         Host:         handlers.GetSourceIP(r),",
                "// vulnerable line: 2389: }",
                "// Line 2390:     sendEvent(evt)",
                "// Line 2391:     if objInfo.NumVersions > int(scannerExcessObjectVersions.Load()) {",
                "// Line 2392:         evt.EventName = event.ObjectManyVersions",
                "// Line 2393:         sendEvent(evt)",
                "// Line 2394: ",
                "// Line 2395:         auditLogInternal(context.Background(), AuditLogOptions{",
                "// Line 2396:             Event:     \"scanner:manyversions\",",
                "// Line 2397:             APIName:   \"PutObject\",",
                "// Line 2398:             Bucket:    objInfo.Bucket,",
                "// Line 2399:             Object:    objInfo.Name,",
                "// Line 2400:             VersionID: objInfo.VersionID,",
                "// Line 2401:             Status:    http.StatusText(http.StatusOK),",
                "// Line 2402:         })",
                "// vulnerable line: 2403: }",
                "// Line 2404: ",
                "// Line 2405:     // Do not send checksums in events to avoid leaks.",
                "// Line 2406:     hash.TransferChecksumHeader(w, r)",
                "// Line 2407:     writeSuccessResponseHeadersOnly(w)",
                "// Line 2408: ",
                "// Line 2409:     // Remove the transitioned object whose object version is being overwritten.",
                "// Line 2410:     if !globalTierConfigMgr.Empty() {",
                "// Line 2411:         // Schedule object for immediate transition if eligible.",
                "// Line 2412:         objInfo.ETag = origETag",
                "// Line 2413:         enqueueTransitionImmediate(objInfo, lcEventSrc_s3PutObject)",
                "// Line 2414:         os.Sweep()",
                "// vulnerable line: 2415: }",
                "// vulnerable line: 2416: }",
                "// Line 2417: ",
                "// Line 2418: // PutObjectExtractHandler - PUT Object extract is an extended API",
                "// Line 2419: // based off from AWS Snowball feature to auto extract compressed",
                "// Line 2420: // stream will be extracted in the same directory it is stored in",
                "// Line 2421: // and the folder structures will be built out accordingly.",
                "// Line 2422: func (api objectAPIHandlers) PutObjectExtractHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 2423:     ctx := newContext(r, w, \"PutObjectExtract\")",
                "// Line 2424:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 2425: ",
                "// Line 2426:     objectAPI := api.ObjectAPI()",
                "// Line 2427:     if objectAPI == nil {",
                "// Line 2428:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 2429: return",
                "// vulnerable line: 2430: }",
                "// Line 2431: ",
                "// Line 2432:     if crypto.S3KMS.IsRequested(r.Header) { // SSE-KMS is not supported",
                "// Line 2433:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrNotImplemented), r.URL)",
                "// vulnerable line: 2434: return",
                "// vulnerable line: 2435: }",
                "// Line 2436: ",
                "// Line 2437:     vars := mux.Vars(r)",
                "// Line 2438:     bucket := vars[\"bucket\"]",
                "// Line 2439:     object, err := unescapePath(vars[\"object\"])",
                "// Line 2440:     if err != nil {",
                "// Line 2441:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2442: return",
                "// vulnerable line: 2443: }",
                "// Line 2444: ",
                "// Line 2445:     // X-Amz-Copy-Source shouldn't be set for this call.",
                "// Line 2446:     if _, ok := r.Header[xhttp.AmzCopySource]; ok {",
                "// Line 2447:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidCopySource), r.URL)",
                "// vulnerable line: 2448: return",
                "// vulnerable line: 2449: }",
                "// Line 2450: ",
                "// Line 2451:     // Validate storage class metadata if present",
                "// Line 2452:     sc := r.Header.Get(xhttp.AmzStorageClass)",
                "// Line 2453:     if sc != \"\" {",
                "// Line 2454:         if !storageclass.IsValid(sc) {",
                "// Line 2455:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidStorageClass), r.URL)",
                "// vulnerable line: 2456: return",
                "// vulnerable line: 2457: }",
                "// vulnerable line: 2458: }",
                "// Line 2459: ",
                "// Line 2460:     clientETag, err := etag.FromContentMD5(r.Header)",
                "// Line 2461:     if err != nil {",
                "// Line 2462:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidDigest), r.URL)",
                "// vulnerable line: 2463: return",
                "// vulnerable line: 2464: }",
                "// Line 2465: ",
                "// Line 2466:     // if Content-Length is unknown/missing, deny the request",
                "// Line 2467:     size := r.ContentLength",
                "// Line 2468:     rAuthType := getRequestAuthType(r)",
                "// Line 2469:     if rAuthType == authTypeStreamingSigned || rAuthType == authTypeStreamingSignedTrailer {",
                "// Line 2470:         if sizeStr, ok := r.Header[xhttp.AmzDecodedContentLength]; ok {",
                "// Line 2471:             if sizeStr[0] == \"\" {",
                "// Line 2472:                 writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)",
                "// vulnerable line: 2473: return",
                "// vulnerable line: 2474: }",
                "// Line 2475:             size, err = strconv.ParseInt(sizeStr[0], 10, 64)",
                "// Line 2476:             if err != nil {",
                "// Line 2477:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2478: return",
                "// vulnerable line: 2479: }",
                "// vulnerable line: 2480: }",
                "// vulnerable line: 2481: }",
                "// Line 2482: ",
                "// Line 2483:     if size == -1 {",
                "// Line 2484:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)",
                "// vulnerable line: 2485: return",
                "// vulnerable line: 2486: }",
                "// Line 2487: ",
                "// Line 2488:     // maximum Upload size for objects in a single operation",
                "// Line 2489:     if isMaxObjectSize(size) {",
                "// Line 2490:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)",
                "// vulnerable line: 2491: return",
                "// vulnerable line: 2492: }",
                "// Line 2493: ",
                "// Line 2494:     var (",
                "// Line 2495:         md5hex              = clientETag.String()",
                "// Line 2496:         sha256hex           = \"\"",
                "// Line 2497:         reader    io.Reader = r.Body",
                "// Line 2498:         s3Err     APIErrorCode",
                "// Line 2499:         putObject = objectAPI.PutObject",
                "// Line 2500:     )",
                "// Line 2501: ",
                "// Line 2502:     // Check if put is allowed",
                "// Line 2503:     if s3Err = isPutActionAllowed(ctx, rAuthType, bucket, object, r, policy.PutObjectAction); s3Err != ErrNone {",
                "// Line 2504:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2505: return",
                "// vulnerable line: 2506: }",
                "// Line 2507: ",
                "// Line 2508:     switch rAuthType {",
                "// Line 2509:     case authTypeStreamingSigned, authTypeStreamingSignedTrailer:",
                "// Line 2510:         // Initialize stream signature verifier.",
                "// Line 2511:         reader, s3Err = newSignV4ChunkedReader(r, rAuthType == authTypeStreamingSignedTrailer)",
                "// Line 2512:         if s3Err != ErrNone {",
                "// Line 2513:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2514: return",
                "// vulnerable line: 2515: }",
                "// Line 2516:     case authTypeSignedV2, authTypePresignedV2:",
                "// Line 2517:         s3Err = isReqAuthenticatedV2(r)",
                "// Line 2518:         if s3Err != ErrNone {",
                "// Line 2519:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2520: return",
                "// vulnerable line: 2521: }",
                "// Line 2522: ",
                "// Line 2523:     case authTypePresigned, authTypeSigned:",
                "// Line 2524:         if s3Err = reqSignatureV4Verify(r, globalSite.Region(), serviceS3); s3Err != ErrNone {",
                "// Line 2525:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 2526: return",
                "// vulnerable line: 2527: }",
                "// Line 2528:         if !skipContentSha256Cksum(r) {",
                "// Line 2529:             sha256hex = getContentSha256Cksum(r, serviceS3)",
                "// vulnerable line: 2530: }",
                "// vulnerable line: 2531: }",
                "// Line 2532: ",
                "// Line 2533:     hreader, err := hash.NewReader(ctx, reader, size, md5hex, sha256hex, size)",
                "// Line 2534:     if err != nil {",
                "// Line 2535:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2536: return",
                "// vulnerable line: 2537: }",
                "// Line 2538:     if err = hreader.AddChecksum(r, false); err != nil {",
                "// Line 2539:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidChecksum), r.URL)",
                "// vulnerable line: 2540: return",
                "// vulnerable line: 2541: }",
                "// Line 2542: ",
                "// Line 2543:     if err := enforceBucketQuotaHard(ctx, bucket, size); err != nil {",
                "// Line 2544:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2545: return",
                "// vulnerable line: 2546: }",
                "// Line 2547: ",
                "// Line 2548:     // Check if bucket encryption is enabled",
                "// Line 2549:     sseConfig, _ := globalBucketSSEConfigSys.Get(bucket)",
                "// Line 2550:     sseConfig.Apply(r.Header, sse.ApplyOptions{",
                "// Line 2551:         AutoEncrypt: globalAutoEncryption,",
                "// Line 2552:     })",
                "// Line 2553: ",
                "// Line 2554:     retPerms := isPutActionAllowed(ctx, getRequestAuthType(r), bucket, object, r, policy.PutObjectRetentionAction)",
                "// Line 2555:     holdPerms := isPutActionAllowed(ctx, getRequestAuthType(r), bucket, object, r, policy.PutObjectLegalHoldAction)",
                "// Line 2556: ",
                "// Line 2557:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 2558: ",
                "// Line 2559:     // These are static for all objects extracted.",
                "// Line 2560:     reqParams := extractReqParams(r)",
                "// Line 2561:     respElements := map[string]string{",
                "// Line 2562:         \"requestId\": w.Header().Get(xhttp.AmzRequestID),",
                "// Line 2563:         \"nodeId\":    w.Header().Get(xhttp.AmzRequestHostID),",
                "// vulnerable line: 2564: }",
                "// Line 2565:     if sc == \"\" {",
                "// Line 2566:         sc = storageclass.STANDARD",
                "// vulnerable line: 2567: }",
                "// Line 2568: ",
                "// Line 2569:     putObjectTar := func(reader io.Reader, info os.FileInfo, object string) error {",
                "// Line 2570:         size := info.Size()",
                "// Line 2571: ",
                "// Line 2572:         metadata := map[string]string{",
                "// Line 2573:             xhttp.AmzStorageClass: sc, // save same storage-class as incoming stream.",
                "// vulnerable line: 2574: }",
                "// Line 2575: ",
                "// Line 2576:         actualSize := size",
                "// Line 2577:         var idxCb func() []byte",
                "// Line 2578:         if isCompressible(r.Header, object) && size > minCompressibleSize {",
                "// Line 2579:             // Storing the compression metadata.",
                "// Line 2580:             metadata[ReservedMetadataPrefix+\"compression\"] = compressionAlgorithmV2",
                "// Line 2581:             metadata[ReservedMetadataPrefix+\"actual-size\"] = strconv.FormatInt(size, 10)",
                "// Line 2582: ",
                "// Line 2583:             actualReader, err := hash.NewReader(ctx, reader, size, \"\", \"\", actualSize)",
                "// Line 2584:             if err != nil {",
                "// Line 2585:                 return err",
                "// vulnerable line: 2586: }",
                "// Line 2587: ",
                "// Line 2588:             // Set compression metrics.",
                "// Line 2589:             wantEncryption := crypto.Requested(r.Header)",
                "// Line 2590:             s2c, cb := newS2CompressReader(actualReader, actualSize, wantEncryption)",
                "// Line 2591:             defer s2c.Close()",
                "// Line 2592:             idxCb = cb",
                "// Line 2593:             reader = etag.Wrap(s2c, actualReader)",
                "// Line 2594:             size = -1 // Since compressed size is un-predictable.",
                "// vulnerable line: 2595: }",
                "// Line 2596: ",
                "// Line 2597:         hashReader, err := hash.NewReader(ctx, reader, size, \"\", \"\", actualSize)",
                "// Line 2598:         if err != nil {",
                "// Line 2599:             return err",
                "// vulnerable line: 2600: }",
                "// Line 2601: ",
                "// Line 2602:         rawReader := hashReader",
                "// Line 2603:         pReader := NewPutObjReader(rawReader)",
                "// Line 2604: ",
                "// Line 2605:         if r.Header.Get(xhttp.AmzBucketReplicationStatus) == replication.Replica.String() {",
                "// Line 2606:             if s3Err = isPutActionAllowed(ctx, getRequestAuthType(r), bucket, object, r, policy.ReplicateObjectAction); s3Err != ErrNone {",
                "// Line 2607:                 return err",
                "// vulnerable line: 2608: }",
                "// Line 2609:             metadata[ReservedMetadataPrefixLower+ReplicaStatus] = replication.Replica.String()",
                "// Line 2610:             metadata[ReservedMetadataPrefixLower+ReplicaTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// vulnerable line: 2611: }",
                "// Line 2612: ",
                "// Line 2613:         var (",
                "// Line 2614:             versionID string",
                "// Line 2615:             hdrs      http.Header",
                "// Line 2616:         )",
                "// Line 2617: ",
                "// Line 2618:         if tarHdrs, ok := info.Sys().(*tar.Header); ok && len(tarHdrs.PAXRecords) > 0 {",
                "// Line 2619:             versionID = tarHdrs.PAXRecords[\"minio.versionId\"]",
                "// Line 2620:             hdrs = make(http.Header)",
                "// Line 2621:             for k, v := range tarHdrs.PAXRecords {",
                "// Line 2622:                 if k == \"minio.versionId\" {",
                "// Line 2623:                     continue",
                "// vulnerable line: 2624: }",
                "// Line 2625:                 if strings.HasPrefix(k, \"minio.metadata.\") {",
                "// Line 2626:                     k = strings.TrimPrefix(k, \"minio.metadata.\")",
                "// Line 2627:                     hdrs.Set(k, v)",
                "// vulnerable line: 2628: }",
                "// vulnerable line: 2629: }",
                "// Line 2630:             m, err := extractMetadata(ctx, textproto.MIMEHeader(hdrs))",
                "// Line 2631:             if err != nil {",
                "// Line 2632:                 return err",
                "// vulnerable line: 2633: }",
                "// Line 2634:             for k, v := range m {",
                "// Line 2635:                 metadata[k] = v",
                "// vulnerable line: 2636: }",
                "// Line 2637:         } else {",
                "// Line 2638:             versionID = r.Form.Get(xhttp.VersionID)",
                "// Line 2639:             hdrs = r.Header",
                "// vulnerable line: 2640: }",
                "// Line 2641: ",
                "// Line 2642:         opts, err := putOpts(ctx, bucket, object, versionID, hdrs, metadata)",
                "// Line 2643:         if err != nil {",
                "// Line 2644:             return err",
                "// vulnerable line: 2645: }",
                "// Line 2646: ",
                "// Line 2647:         opts.MTime = info.ModTime()",
                "// Line 2648:         if opts.MTime.Unix() <= 0 {",
                "// Line 2649:             opts.MTime = UTCNow()",
                "// vulnerable line: 2650: }",
                "// Line 2651:         opts.IndexCB = idxCb",
                "// Line 2652: ",
                "// Line 2653:         retentionMode, retentionDate, legalHold, s3err := checkPutObjectLockAllowed(ctx, r, bucket, object, getObjectInfo, retPerms, holdPerms)",
                "// Line 2654:         if s3err == ErrNone && retentionMode.Valid() {",
                "// Line 2655:             metadata[strings.ToLower(xhttp.AmzObjectLockMode)] = string(retentionMode)",
                "// Line 2656:             metadata[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = amztime.ISO8601Format(retentionDate.UTC())",
                "// vulnerable line: 2657: }",
                "// Line 2658: ",
                "// Line 2659:         if s3err == ErrNone && legalHold.Status.Valid() {",
                "// Line 2660:             metadata[strings.ToLower(xhttp.AmzObjectLockLegalHold)] = string(legalHold.Status)",
                "// vulnerable line: 2661: }",
                "// Line 2662: ",
                "// Line 2663:         if s3err != ErrNone {",
                "// Line 2664:             s3Err = s3err",
                "// Line 2665:             return ObjectLocked{}",
                "// vulnerable line: 2666: }",
                "// Line 2667: ",
                "// Line 2668:         if dsc := mustReplicate(ctx, bucket, object, getMustReplicateOptions(metadata, \"\", \"\", replication.ObjectReplicationType, opts)); dsc.ReplicateAny() {",
                "// Line 2669:             metadata[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 2670:             metadata[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// Line 2671: ",
                "// vulnerable line: 2672: }",
                "// Line 2673: ",
                "// Line 2674:         var objectEncryptionKey crypto.ObjectKey",
                "// Line 2675:         if crypto.Requested(r.Header) {",
                "// Line 2676:             if crypto.SSECopy.IsRequested(r.Header) {",
                "// Line 2677:                 return errInvalidEncryptionParameters",
                "// vulnerable line: 2678: }",
                "// Line 2679: ",
                "// Line 2680:             reader, objectEncryptionKey, err = EncryptRequest(hashReader, r, bucket, object, metadata)",
                "// Line 2681:             if err != nil {",
                "// Line 2682:                 return err",
                "// vulnerable line: 2683: }",
                "// Line 2684: ",
                "// Line 2685:             wantSize := int64(-1)",
                "// Line 2686:             if size >= 0 {",
                "// Line 2687:                 info := ObjectInfo{Size: size}",
                "// Line 2688:                 wantSize = info.EncryptedSize()",
                "// vulnerable line: 2689: }",
                "// Line 2690: ",
                "// Line 2691:             // do not try to verify encrypted content",
                "// Line 2692:             hashReader, err = hash.NewReader(ctx, etag.Wrap(reader, hashReader), wantSize, \"\", \"\", actualSize)",
                "// Line 2693:             if err != nil {",
                "// Line 2694:                 return err",
                "// vulnerable line: 2695: }",
                "// Line 2696: ",
                "// Line 2697:             pReader, err = pReader.WithEncryption(hashReader, &objectEncryptionKey)",
                "// Line 2698:             if err != nil {",
                "// Line 2699:                 return err",
                "// vulnerable line: 2700: }",
                "// vulnerable line: 2701: }",
                "// Line 2702:         if opts.IndexCB != nil {",
                "// Line 2703:             opts.IndexCB = compressionIndexEncrypter(objectEncryptionKey, opts.IndexCB)",
                "// vulnerable line: 2704: }",
                "// Line 2705: ",
                "// Line 2706:         // Ensure that metadata does not contain sensitive information",
                "// Line 2707:         crypto.RemoveSensitiveEntries(metadata)",
                "// Line 2708: ",
                "// Line 2709:         os := newObjSweeper(bucket, object).WithVersioning(opts.Versioned, opts.VersionSuspended)",
                "// Line 2710:         if !globalTierConfigMgr.Empty() {",
                "// Line 2711:             // Get appropriate object info to identify the remote object to delete",
                "// Line 2712:             goiOpts := os.GetOpts()",
                "// Line 2713:             if goi, gerr := getObjectInfo(ctx, bucket, object, goiOpts); gerr == nil {",
                "// Line 2714:                 os.SetTransitionState(goi.TransitionedObject)",
                "// vulnerable line: 2715: }",
                "// vulnerable line: 2716: }",
                "// Line 2717: ",
                "// Line 2718:         // Create the object..",
                "// Line 2719:         objInfo, err := putObject(ctx, bucket, object, pReader, opts)",
                "// Line 2720:         if err != nil {",
                "// Line 2721:             return err",
                "// vulnerable line: 2722: }",
                "// Line 2723: ",
                "// Line 2724:         origETag := objInfo.ETag",
                "// Line 2725:         objInfo.ETag = getDecryptedETag(r.Header, objInfo, false)",
                "// Line 2726: ",
                "// Line 2727:         if dsc := mustReplicate(ctx, bucket, object, getMustReplicateOptions(metadata, \"\", \"\", replication.ObjectReplicationType, opts)); dsc.ReplicateAny() {",
                "// Line 2728:             scheduleReplication(ctx, objInfo, objectAPI, dsc, replication.ObjectReplicationType)",
                "// vulnerable line: 2729: }",
                "// Line 2730: ",
                "// Line 2731:         asize, err := objInfo.GetActualSize()",
                "// Line 2732:         if err != nil {",
                "// Line 2733:             asize = objInfo.Size",
                "// vulnerable line: 2734: }",
                "// Line 2735: ",
                "// Line 2736:         defer globalCacheConfig.Set(&cache.ObjectInfo{",
                "// Line 2737:             Key:          objInfo.Name,",
                "// Line 2738:             Bucket:       objInfo.Bucket,",
                "// Line 2739:             ETag:         objInfo.ETag,",
                "// Line 2740:             ModTime:      objInfo.ModTime,",
                "// Line 2741:             Expires:      objInfo.ExpiresStr(),",
                "// Line 2742:             CacheControl: objInfo.CacheControl,",
                "// Line 2743:             Size:         asize,",
                "// Line 2744:             Metadata:     cleanReservedKeys(objInfo.UserDefined),",
                "// Line 2746: ",
                "// Line 2747:         // Notify object created event.",
                "// Line 2748:         evt := eventArgs{",
                "// Line 2749:             EventName:    event.ObjectCreatedPut,",
                "// Line 2750:             BucketName:   bucket,",
                "// Line 2751:             Object:       objInfo,",
                "// Line 2752:             ReqParams:    reqParams,",
                "// Line 2753:             RespElements: respElements,",
                "// Line 2754:             UserAgent:    r.UserAgent(),",
                "// Line 2755:             Host:         handlers.GetSourceIP(r),",
                "// vulnerable line: 2756: }",
                "// Line 2757:         sendEvent(evt)",
                "// Line 2758: ",
                "// Line 2759:         // Remove the transitioned object whose object version is being overwritten.",
                "// Line 2760:         if !globalTierConfigMgr.Empty() {",
                "// Line 2761:             objInfo.ETag = origETag",
                "// Line 2762:             // Schedule object for immediate transition if eligible.",
                "// Line 2763:             enqueueTransitionImmediate(objInfo, lcEventSrc_s3PutObject)",
                "// Line 2764:             os.Sweep()",
                "// vulnerable line: 2765: }",
                "// Line 2766: ",
                "// Line 2767:         return nil",
                "// vulnerable line: 2768: }",
                "// Line 2769: ",
                "// Line 2770:     var opts untarOptions",
                "// Line 2771:     opts.ignoreDirs = strings.EqualFold(r.Header.Get(xhttp.MinIOSnowballIgnoreDirs), \"true\")",
                "// Line 2772:     opts.ignoreErrs = strings.EqualFold(r.Header.Get(xhttp.MinIOSnowballIgnoreErrors), \"true\")",
                "// Line 2773:     opts.prefixAll = r.Header.Get(xhttp.MinIOSnowballPrefix)",
                "// Line 2774:     if opts.prefixAll != \"\" {",
                "// Line 2775:         opts.prefixAll = trimLeadingSlash(pathJoin(opts.prefixAll, slashSeparator))",
                "// vulnerable line: 2776: }",
                "// Line 2777: ",
                "// Line 2778:     if err = untar(ctx, hreader, putObjectTar, opts); err != nil {",
                "// Line 2779:         apiErr := errorCodes.ToAPIErr(s3Err)",
                "// Line 2780:         // If not set, convert or use BadRequest",
                "// Line 2781:         if s3Err == ErrNone {",
                "// Line 2782:             apiErr = toAPIError(ctx, err)",
                "// Line 2783:             if apiErr.Code == \"InternalError\" {",
                "// Line 2784:                 // Convert generic internal errors to bad requests.",
                "// Line 2785:                 apiErr = APIError{",
                "// Line 2786:                     Code:           \"BadRequest\",",
                "// Line 2787:                     Description:    err.Error(),",
                "// Line 2788:                     HTTPStatusCode: http.StatusBadRequest,",
                "// vulnerable line: 2789: }",
                "// vulnerable line: 2790: }",
                "// vulnerable line: 2791: }",
                "// Line 2792:         writeErrorResponse(ctx, w, apiErr, r.URL)",
                "// vulnerable line: 2793: return",
                "// vulnerable line: 2794: }",
                "// Line 2795: ",
                "// Line 2796:     w.Header()[xhttp.ETag] = []string{`\"` + hex.EncodeToString(hreader.MD5Current()) + `\"`}",
                "// Line 2797:     hash.TransferChecksumHeader(w, r)",
                "// Line 2798:     writeSuccessResponseHeadersOnly(w)",
                "// vulnerable line: 2799: }",
                "// Line 2800: ",
                "// Line 2801: // Delete objectAPIHandlers",
                "// Line 2802: ",
                "// Line 2803: // DeleteObjectHandler - delete an object",
                "// Line 2804: func (api objectAPIHandlers) DeleteObjectHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 2805:     ctx := newContext(r, w, \"DeleteObject\")",
                "// Line 2806: ",
                "// Line 2807:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 2808: ",
                "// Line 2809:     vars := mux.Vars(r)",
                "// Line 2810:     bucket := vars[\"bucket\"]",
                "// Line 2811:     object, err := unescapePath(vars[\"object\"])",
                "// Line 2812:     if err != nil {",
                "// Line 2813:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2814: return",
                "// vulnerable line: 2815: }",
                "// Line 2816: ",
                "// Line 2817:     objectAPI := api.ObjectAPI()",
                "// Line 2818:     if objectAPI == nil {",
                "// Line 2819:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 2820: return",
                "// vulnerable line: 2821: }",
                "// Line 2822: ",
                "// Line 2823:     if s3Error := checkRequestAuthType(ctx, r, policy.DeleteObjectAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 2824: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 2825: return",
                "// vulnerable line: 2826: }",
                "// Line 2827:     if _, ok := r.Header[xhttp.MinIOSourceReplicationCheck]; ok {",
                "// Line 2828:         // requests to just validate replication settings and permissions are not allowed to delete data",
                "// Line 2829:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrReplicationPermissionCheckError), r.URL)",
                "// vulnerable line: 2830: return",
                "// vulnerable line: 2831: }",
                "// Line 2832: ",
                "// Line 2833:     replica := r.Header.Get(xhttp.AmzBucketReplicationStatus) == replication.Replica.String()",
                "// Line 2834:     if replica {",
                "// Line 2835:         if s3Error := checkRequestAuthType(ctx, r, policy.ReplicateDeleteAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 2836: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 2837: return",
                "// vulnerable line: 2838: }",
                "// vulnerable line: 2839: }",
                "// Line 2840: ",
                "// Line 2841:     if globalDNSConfig != nil {",
                "// Line 2842:         _, err := globalDNSConfig.Get(bucket)",
                "// Line 2843:         if err != nil && err != dns.ErrNotImplemented {",
                "// Line 2844:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2845: return",
                "// vulnerable line: 2846: }",
                "// vulnerable line: 2847: }",
                "// Line 2848: ",
                "// Line 2849:     opts, err := delOpts(ctx, r, bucket, object)",
                "// Line 2850:     if err != nil {",
                "// Line 2851:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2852: return",
                "// vulnerable line: 2853: }",
                "// Line 2854: ",
                "// Line 2855:     rcfg, _ := globalBucketObjectLockSys.Get(bucket)",
                "// Line 2856:     if rcfg.LockEnabled && opts.DeletePrefix {",
                "// Line 2857:         apiErr := toAPIError(ctx, errInvalidArgument)",
                "// Line 2858:         apiErr.Description = \"force-delete is forbidden on Object Locking enabled buckets\"",
                "// Line 2859:         writeErrorResponse(ctx, w, apiErr, r.URL)",
                "// vulnerable line: 2860: return",
                "// vulnerable line: 2861: }",
                "// Line 2862: ",
                "// Line 2863:     os := newObjSweeper(bucket, object).WithVersion(opts.VersionID).WithVersioning(opts.Versioned, opts.VersionSuspended)",
                "// Line 2864: ",
                "// Line 2865:     opts.SetEvalMetadataFn(func(oi *ObjectInfo, gerr error) (dsc ReplicateDecision, err error) {",
                "// Line 2866:         if replica { // no need to check replication on receiver",
                "// Line 2867:             return dsc, nil",
                "// vulnerable line: 2868: }",
                "// Line 2869:         dsc = checkReplicateDelete(ctx, bucket, ObjectToDelete{",
                "// Line 2870:             ObjectV: ObjectV{",
                "// Line 2871:                 ObjectName: object,",
                "// Line 2872:                 VersionID:  opts.VersionID,",
                "// Line 2873:             },",
                "// Line 2874:         }, *oi, opts, gerr)",
                "// Line 2875:         // Mutations of objects on versioning suspended buckets",
                "// Line 2876:         // affect its null version. Through opts below we select",
                "// Line 2877:         // the null version's remote object to delete if",
                "// Line 2878:         // transitioned.",
                "// Line 2879:         if gerr == nil {",
                "// Line 2880:             os.SetTransitionState(oi.TransitionedObject)",
                "// vulnerable line: 2881: }",
                "// Line 2882:         return dsc, nil",
                "// Line 2883:     })",
                "// Line 2884: ",
                "// Line 2885:     vID := opts.VersionID",
                "// Line 2886:     if replica {",
                "// Line 2887:         opts.SetReplicaStatus(replication.Replica)",
                "// Line 2888:         if opts.VersionPurgeStatus().Empty() {",
                "// Line 2889:             // opts.VersionID holds delete marker version ID to replicate and not yet present on disk",
                "// Line 2890:             vID = \"\"",
                "// vulnerable line: 2891: }",
                "// vulnerable line: 2892: }",
                "// Line 2893:     opts.SetEvalRetentionBypassFn(func(goi ObjectInfo, gerr error) (err error) {",
                "// Line 2894:         err = nil",
                "// Line 2895:         if vID != \"\" {",
                "// Line 2896:             err := enforceRetentionBypassForDelete(ctx, r, bucket, ObjectToDelete{",
                "// Line 2897:                 ObjectV: ObjectV{",
                "// Line 2898:                     ObjectName: object,",
                "// Line 2899:                     VersionID:  vID,",
                "// Line 2900:                 },",
                "// Line 2901:             }, goi, gerr)",
                "// Line 2902:             if err != nil && !isErrObjectNotFound(err) {",
                "// Line 2903:                 return err",
                "// vulnerable line: 2904: }",
                "// vulnerable line: 2905: }",
                "// vulnerable line: 2906: return",
                "// Line 2907:     })",
                "// Line 2908: ",
                "// Line 2909:     deleteObject := objectAPI.DeleteObject",
                "// Line 2910: ",
                "// Line 2911:     // http://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectDELETE.html",
                "// Line 2912:     objInfo, err := deleteObject(ctx, bucket, object, opts)",
                "// Line 2913:     if err != nil {",
                "// Line 2914:         if _, ok := err.(BucketNotFound); ok {",
                "// Line 2915:             // When bucket doesn't exist specially handle it.",
                "// Line 2916:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2917: return",
                "// vulnerable line: 2918: }",
                "// Line 2919:         if isErrObjectNotFound(err) || isErrVersionNotFound(err) {",
                "// Line 2920:             // Send an event when the object is not found",
                "// Line 2921:             objInfo.Name = object",
                "// Line 2922:             objInfo.VersionID = opts.VersionID",
                "// Line 2923:             sendEvent(eventArgs{",
                "// Line 2924:                 EventName:    event.ObjectRemovedNoOP,",
                "// Line 2925:                 BucketName:   bucket,",
                "// Line 2926:                 Object:       objInfo,",
                "// Line 2927:                 ReqParams:    extractReqParams(r),",
                "// Line 2928:                 RespElements: extractRespElements(w),",
                "// Line 2929:                 UserAgent:    r.UserAgent(),",
                "// Line 2930:                 Host:         handlers.GetSourceIP(r),",
                "// Line 2931:             })",
                "// Line 2932:             writeSuccessNoContent(w)",
                "// vulnerable line: 2933: return",
                "// vulnerable line: 2934: }",
                "// Line 2935:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 2936: return",
                "// vulnerable line: 2937: }",
                "// Line 2938: ",
                "// Line 2939:     if objInfo.Name == \"\" {",
                "// Line 2940:         writeSuccessNoContent(w)",
                "// vulnerable line: 2941: return",
                "// vulnerable line: 2942: }",
                "// Line 2943: ",
                "// Line 2944:     defer globalCacheConfig.Delete(bucket, object)",
                "// Line 2945: ",
                "// Line 2946:     setPutObjHeaders(w, objInfo, true)",
                "// Line 2947:     writeSuccessNoContent(w)",
                "// Line 2948: ",
                "// Line 2949:     eventName := event.ObjectRemovedDelete",
                "// Line 2950:     if objInfo.DeleteMarker {",
                "// Line 2951:         eventName = event.ObjectRemovedDeleteMarkerCreated",
                "// vulnerable line: 2952: }",
                "// Line 2953: ",
                "// Line 2954:     // Notify object deleted event.",
                "// Line 2955:     sendEvent(eventArgs{",
                "// Line 2956:         EventName:    eventName,",
                "// Line 2957:         BucketName:   bucket,",
                "// Line 2958:         Object:       objInfo,",
                "// Line 2959:         ReqParams:    extractReqParams(r),",
                "// Line 2960:         RespElements: extractRespElements(w),",
                "// Line 2961:         UserAgent:    r.UserAgent(),",
                "// Line 2962:         Host:         handlers.GetSourceIP(r),",
                "// Line 2963:     })",
                "// Line 2964: ",
                "// Line 2965:     if objInfo.ReplicationStatus == replication.Pending || objInfo.VersionPurgeStatus == Pending {",
                "// Line 2966:         dmVersionID := \"\"",
                "// Line 2967:         versionID := \"\"",
                "// Line 2968:         if objInfo.DeleteMarker {",
                "// Line 2969:             dmVersionID = objInfo.VersionID",
                "// Line 2970:         } else {",
                "// Line 2971:             versionID = objInfo.VersionID",
                "// vulnerable line: 2972: }",
                "// Line 2973:         dobj := DeletedObjectReplicationInfo{",
                "// Line 2974:             DeletedObject: DeletedObject{",
                "// Line 2975:                 ObjectName:            object,",
                "// Line 2976:                 VersionID:             versionID,",
                "// Line 2977:                 DeleteMarkerVersionID: dmVersionID,",
                "// Line 2978:                 DeleteMarkerMTime:     DeleteMarkerMTime{objInfo.ModTime},",
                "// Line 2979:                 DeleteMarker:          objInfo.DeleteMarker,",
                "// Line 2980:                 ReplicationState:      objInfo.ReplicationState(),",
                "// Line 2981:             },",
                "// Line 2982:             Bucket:    bucket,",
                "// Line 2983:             EventType: ReplicateIncomingDelete,",
                "// vulnerable line: 2984: }",
                "// Line 2985:         scheduleReplicationDelete(ctx, dobj, objectAPI)",
                "// vulnerable line: 2986: }",
                "// Line 2987: ",
                "// Line 2988:     // Remove the transitioned object whose object version is being overwritten.",
                "// Line 2989:     if !globalTierConfigMgr.Empty() {",
                "// Line 2990:         os.Sweep()",
                "// vulnerable line: 2991: }",
                "// vulnerable line: 2992: }",
                "// Line 2993: ",
                "// Line 2994: // PutObjectLegalHoldHandler - set legal hold configuration to object,",
                "// Line 2995: func (api objectAPIHandlers) PutObjectLegalHoldHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 2996:     ctx := newContext(r, w, \"PutObjectLegalHold\")",
                "// Line 2997: ",
                "// Line 2998:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 2999: ",
                "// Line 3000:     vars := mux.Vars(r)",
                "// Line 3001:     bucket := vars[\"bucket\"]",
                "// Line 3002:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3003:     if err != nil {",
                "// Line 3004:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3005: return",
                "// vulnerable line: 3006: }",
                "// Line 3007: ",
                "// Line 3008:     objectAPI := api.ObjectAPI()",
                "// Line 3009:     if objectAPI == nil {",
                "// Line 3010:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3011: return",
                "// vulnerable line: 3012: }",
                "// Line 3013: ",
                "// Line 3014:     // Check permissions to perform this legal hold operation",
                "// Line 3015:     if s3Err := checkRequestAuthType(ctx, r, policy.PutObjectLegalHoldAction, bucket, object); s3Err != ErrNone {",
                "// Line 3016:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 3017: return",
                "// vulnerable line: 3018: }",
                "// Line 3019: ",
                "// Line 3020:     if _, err := objectAPI.GetBucketInfo(ctx, bucket, BucketOptions{}); err != nil {",
                "// Line 3021:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3022: return",
                "// vulnerable line: 3023: }",
                "// Line 3024:     if !hasContentMD5(r.Header) {",
                "// Line 3025:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentMD5), r.URL)",
                "// vulnerable line: 3026: return",
                "// vulnerable line: 3027: }",
                "// Line 3028: ",
                "// Line 3029:     if rcfg, _ := globalBucketObjectLockSys.Get(bucket); !rcfg.LockEnabled {",
                "// Line 3030:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidBucketObjectLockConfiguration), r.URL)",
                "// vulnerable line: 3031: return",
                "// vulnerable line: 3032: }",
                "// Line 3033: ",
                "// Line 3034:     legalHold, err := objectlock.ParseObjectLegalHold(io.LimitReader(r.Body, r.ContentLength))",
                "// Line 3035:     if err != nil {",
                "// Line 3036:         apiErr := errorCodes.ToAPIErr(ErrMalformedXML)",
                "// Line 3037:         apiErr.Description = err.Error()",
                "// Line 3038:         writeErrorResponse(ctx, w, apiErr, r.URL)",
                "// vulnerable line: 3039: return",
                "// vulnerable line: 3040: }",
                "// Line 3041: ",
                "// Line 3042:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3043:     if err != nil {",
                "// Line 3044:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3045: return",
                "// vulnerable line: 3046: }",
                "// Line 3047: ",
                "// Line 3048:     popts := ObjectOptions{",
                "// Line 3049:         MTime:     opts.MTime,",
                "// Line 3050:         VersionID: opts.VersionID,",
                "// Line 3051:         EvalMetadataFn: func(oi *ObjectInfo, gerr error) (ReplicateDecision, error) {",
                "// Line 3052:             oi.UserDefined[strings.ToLower(xhttp.AmzObjectLockLegalHold)] = strings.ToUpper(string(legalHold.Status))",
                "// Line 3053:             oi.UserDefined[ReservedMetadataPrefixLower+ObjectLockLegalHoldTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 3054: ",
                "// Line 3055:             dsc := mustReplicate(ctx, bucket, object, oi.getMustReplicateOptions(replication.MetadataReplicationType, opts))",
                "// Line 3056:             if dsc.ReplicateAny() {",
                "// Line 3057:                 oi.UserDefined[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 3058:                 oi.UserDefined[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// vulnerable line: 3059: }",
                "// Line 3060:             return dsc, nil",
                "// Line 3061:         },",
                "// vulnerable line: 3062: }",
                "// Line 3063: ",
                "// Line 3064:     objInfo, err := objectAPI.PutObjectMetadata(ctx, bucket, object, popts)",
                "// Line 3065:     if err != nil {",
                "// Line 3066:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3067: return",
                "// vulnerable line: 3068: }",
                "// Line 3069: ",
                "// Line 3070:     dsc := mustReplicate(ctx, bucket, object, objInfo.getMustReplicateOptions(replication.MetadataReplicationType, opts))",
                "// Line 3071:     if dsc.ReplicateAny() {",
                "// Line 3072:         scheduleReplication(ctx, objInfo, objectAPI, dsc, replication.MetadataReplicationType)",
                "// vulnerable line: 3073: }",
                "// Line 3074: ",
                "// Line 3075:     writeSuccessResponseHeadersOnly(w)",
                "// Line 3076: ",
                "// Line 3077:     // Notify object event.",
                "// Line 3078:     sendEvent(eventArgs{",
                "// Line 3079:         EventName:    event.ObjectCreatedPutLegalHold,",
                "// Line 3080:         BucketName:   bucket,",
                "// Line 3081:         Object:       objInfo,",
                "// Line 3082:         ReqParams:    extractReqParams(r),",
                "// Line 3083:         RespElements: extractRespElements(w),",
                "// Line 3084:         UserAgent:    r.UserAgent(),",
                "// Line 3085:         Host:         handlers.GetSourceIP(r),",
                "// Line 3086:     })",
                "// vulnerable line: 3087: }",
                "// Line 3088: ",
                "// Line 3089: // GetObjectLegalHoldHandler - get legal hold configuration to object,",
                "// Line 3090: func (api objectAPIHandlers) GetObjectLegalHoldHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3091:     ctx := newContext(r, w, \"GetObjectLegalHold\")",
                "// Line 3092: ",
                "// Line 3093:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3094: ",
                "// Line 3095:     vars := mux.Vars(r)",
                "// Line 3096:     bucket := vars[\"bucket\"]",
                "// Line 3097:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3098:     if err != nil {",
                "// Line 3099:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3100: return",
                "// vulnerable line: 3101: }",
                "// Line 3102: ",
                "// Line 3103:     objectAPI := api.ObjectAPI()",
                "// Line 3104:     if objectAPI == nil {",
                "// Line 3105:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3106: return",
                "// vulnerable line: 3107: }",
                "// Line 3108:     if s3Error := checkRequestAuthType(ctx, r, policy.GetObjectLegalHoldAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 3109: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3110: return",
                "// vulnerable line: 3111: }",
                "// Line 3112: ",
                "// Line 3113:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 3114: ",
                "// Line 3115:     if rcfg, _ := globalBucketObjectLockSys.Get(bucket); !rcfg.LockEnabled {",
                "// Line 3116:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidBucketObjectLockConfiguration), r.URL)",
                "// vulnerable line: 3117: return",
                "// vulnerable line: 3118: }",
                "// Line 3119: ",
                "// Line 3120:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3121:     if err != nil {",
                "// Line 3122:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3123: return",
                "// vulnerable line: 3124: }",
                "// Line 3125: ",
                "// Line 3126:     objInfo, err := getObjectInfo(ctx, bucket, object, opts)",
                "// Line 3127:     if err != nil {",
                "// Line 3128:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3129: return",
                "// vulnerable line: 3130: }",
                "// Line 3131: ",
                "// Line 3132:     legalHold := objectlock.GetObjectLegalHoldMeta(objInfo.UserDefined)",
                "// Line 3133:     if legalHold.IsEmpty() {",
                "// Line 3134:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrNoSuchObjectLockConfiguration), r.URL)",
                "// vulnerable line: 3135: return",
                "// vulnerable line: 3136: }",
                "// Line 3137: ",
                "// Line 3138:     writeSuccessResponseXML(w, encodeResponse(legalHold))",
                "// Line 3139:     // Notify object legal hold accessed via a GET request.",
                "// Line 3140:     sendEvent(eventArgs{",
                "// Line 3141:         EventName:    event.ObjectAccessedGetLegalHold,",
                "// Line 3142:         BucketName:   bucket,",
                "// Line 3143:         Object:       objInfo,",
                "// Line 3144:         ReqParams:    extractReqParams(r),",
                "// Line 3145:         RespElements: extractRespElements(w),",
                "// Line 3146:         UserAgent:    r.UserAgent(),",
                "// Line 3147:         Host:         handlers.GetSourceIP(r),",
                "// Line 3148:     })",
                "// vulnerable line: 3149: }",
                "// Line 3150: ",
                "// Line 3151: // PutObjectRetentionHandler - set object hold configuration to object,",
                "// Line 3152: func (api objectAPIHandlers) PutObjectRetentionHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3153:     ctx := newContext(r, w, \"PutObjectRetention\")",
                "// Line 3154: ",
                "// Line 3155:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3156: ",
                "// Line 3157:     vars := mux.Vars(r)",
                "// Line 3158:     bucket := vars[\"bucket\"]",
                "// Line 3159:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3160:     if err != nil {",
                "// Line 3161:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3162: return",
                "// vulnerable line: 3163: }",
                "// Line 3164: ",
                "// Line 3165:     objectAPI := api.ObjectAPI()",
                "// Line 3166:     if objectAPI == nil {",
                "// Line 3167:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3168: return",
                "// vulnerable line: 3169: }",
                "// Line 3170: ",
                "// Line 3171:     cred, owner, s3Err := validateSignature(getRequestAuthType(r), r)",
                "// Line 3172:     if s3Err != ErrNone {",
                "// Line 3173:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)",
                "// vulnerable line: 3174: return",
                "// vulnerable line: 3175: }",
                "// Line 3176: ",
                "// Line 3177:     if _, err := objectAPI.GetBucketInfo(ctx, bucket, BucketOptions{}); err != nil {",
                "// Line 3178:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3179: return",
                "// vulnerable line: 3180: }",
                "// Line 3181: ",
                "// Line 3182:     if !hasContentMD5(r.Header) {",
                "// Line 3183:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrMissingContentMD5), r.URL)",
                "// vulnerable line: 3184: return",
                "// vulnerable line: 3185: }",
                "// Line 3186: ",
                "// Line 3187:     if rcfg, _ := globalBucketObjectLockSys.Get(bucket); !rcfg.LockEnabled {",
                "// Line 3188:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidBucketObjectLockConfiguration), r.URL)",
                "// vulnerable line: 3189: return",
                "// vulnerable line: 3190: }",
                "// Line 3191: ",
                "// Line 3192:     objRetention, err := objectlock.ParseObjectRetention(r.Body)",
                "// Line 3193:     if err != nil {",
                "// Line 3194:         apiErr := errorCodes.ToAPIErr(ErrMalformedXML)",
                "// Line 3195:         apiErr.Description = err.Error()",
                "// Line 3196:         writeErrorResponse(ctx, w, apiErr, r.URL)",
                "// vulnerable line: 3197: return",
                "// vulnerable line: 3198: }",
                "// Line 3199: ",
                "// Line 3200:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3201:     if err != nil {",
                "// Line 3202:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3203: return",
                "// vulnerable line: 3204: }",
                "// Line 3205: ",
                "// Line 3206:     popts := ObjectOptions{",
                "// Line 3207:         MTime:     opts.MTime,",
                "// Line 3208:         VersionID: opts.VersionID,",
                "// Line 3209:         EvalMetadataFn: func(oi *ObjectInfo, gerr error) (dsc ReplicateDecision, err error) {",
                "// Line 3210:             if err := enforceRetentionBypassForPut(ctx, r, *oi, objRetention, cred, owner); err != nil {",
                "// Line 3211:                 return dsc, err",
                "// vulnerable line: 3212: }",
                "// Line 3213:             if objRetention.Mode.Valid() {",
                "// Line 3214:                 oi.UserDefined[strings.ToLower(xhttp.AmzObjectLockMode)] = string(objRetention.Mode)",
                "// Line 3215:                 oi.UserDefined[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = amztime.ISO8601Format(objRetention.RetainUntilDate.UTC())",
                "// Line 3216:             } else {",
                "// Line 3217:                 oi.UserDefined[strings.ToLower(xhttp.AmzObjectLockMode)] = \"\"",
                "// Line 3218:                 oi.UserDefined[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = \"\"",
                "// vulnerable line: 3219: }",
                "// Line 3220:             oi.UserDefined[ReservedMetadataPrefixLower+ObjectLockRetentionTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 3221:             dsc = mustReplicate(ctx, bucket, object, oi.getMustReplicateOptions(replication.MetadataReplicationType, opts))",
                "// Line 3222:             if dsc.ReplicateAny() {",
                "// Line 3223:                 oi.UserDefined[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 3224:                 oi.UserDefined[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// vulnerable line: 3225: }",
                "// Line 3226:             return dsc, nil",
                "// Line 3227:         },",
                "// vulnerable line: 3228: }",
                "// Line 3229: ",
                "// Line 3230:     objInfo, err := objectAPI.PutObjectMetadata(ctx, bucket, object, popts)",
                "// Line 3231:     if err != nil {",
                "// Line 3232:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3233: return",
                "// vulnerable line: 3234: }",
                "// Line 3235: ",
                "// Line 3236:     dsc := mustReplicate(ctx, bucket, object, objInfo.getMustReplicateOptions(replication.MetadataReplicationType, opts))",
                "// Line 3237:     if dsc.ReplicateAny() {",
                "// Line 3238:         scheduleReplication(ctx, objInfo, objectAPI, dsc, replication.MetadataReplicationType)",
                "// vulnerable line: 3239: }",
                "// Line 3240: ",
                "// Line 3241:     writeSuccessResponseHeadersOnly(w)",
                "// Line 3242: ",
                "// Line 3243:     // Notify object  event.",
                "// Line 3244:     sendEvent(eventArgs{",
                "// Line 3245:         EventName:    event.ObjectCreatedPutRetention,",
                "// Line 3246:         BucketName:   bucket,",
                "// Line 3247:         Object:       objInfo,",
                "// Line 3248:         ReqParams:    extractReqParams(r),",
                "// Line 3249:         RespElements: extractRespElements(w),",
                "// Line 3250:         UserAgent:    r.UserAgent(),",
                "// Line 3251:         Host:         handlers.GetSourceIP(r),",
                "// Line 3252:     })",
                "// vulnerable line: 3253: }",
                "// Line 3254: ",
                "// Line 3255: // GetObjectRetentionHandler - get object retention configuration of object,",
                "// Line 3256: func (api objectAPIHandlers) GetObjectRetentionHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3257:     ctx := newContext(r, w, \"GetObjectRetention\")",
                "// Line 3258:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3259: ",
                "// Line 3260:     vars := mux.Vars(r)",
                "// Line 3261:     bucket := vars[\"bucket\"]",
                "// Line 3262:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3263:     if err != nil {",
                "// Line 3264:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3265: return",
                "// vulnerable line: 3266: }",
                "// Line 3267: ",
                "// Line 3268:     objectAPI := api.ObjectAPI()",
                "// Line 3269:     if objectAPI == nil {",
                "// Line 3270:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3271: return",
                "// vulnerable line: 3272: }",
                "// Line 3273:     if s3Error := checkRequestAuthType(ctx, r, policy.GetObjectRetentionAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 3274: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3275: return",
                "// vulnerable line: 3276: }",
                "// Line 3277: ",
                "// Line 3278:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 3279: ",
                "// Line 3280:     if rcfg, _ := globalBucketObjectLockSys.Get(bucket); !rcfg.LockEnabled {",
                "// Line 3281:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidBucketObjectLockConfiguration), r.URL)",
                "// vulnerable line: 3282: return",
                "// vulnerable line: 3283: }",
                "// Line 3284: ",
                "// Line 3285:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3286:     if err != nil {",
                "// Line 3287:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3288: return",
                "// vulnerable line: 3289: }",
                "// Line 3290: ",
                "// Line 3291:     objInfo, err := getObjectInfo(ctx, bucket, object, opts)",
                "// Line 3292:     if err != nil {",
                "// Line 3293:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3294: return",
                "// vulnerable line: 3295: }",
                "// Line 3296: ",
                "// Line 3297:     retention := objectlock.GetObjectRetentionMeta(objInfo.UserDefined)",
                "// Line 3298:     if !retention.Mode.Valid() {",
                "// Line 3299:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrNoSuchObjectLockConfiguration), r.URL)",
                "// vulnerable line: 3300: return",
                "// vulnerable line: 3301: }",
                "// Line 3302: ",
                "// Line 3303:     writeSuccessResponseXML(w, encodeResponse(retention))",
                "// Line 3304:     // Notify object retention accessed via a GET request.",
                "// Line 3305:     sendEvent(eventArgs{",
                "// Line 3306:         EventName:    event.ObjectAccessedGetRetention,",
                "// Line 3307:         BucketName:   bucket,",
                "// Line 3308:         Object:       objInfo,",
                "// Line 3309:         ReqParams:    extractReqParams(r),",
                "// Line 3310:         RespElements: extractRespElements(w),",
                "// Line 3311:         UserAgent:    r.UserAgent(),",
                "// Line 3312:         Host:         handlers.GetSourceIP(r),",
                "// Line 3313:     })",
                "// vulnerable line: 3314: }",
                "// Line 3315: ",
                "// Line 3316: // ObjectTagSet key value tags",
                "// Line 3317: type ObjectTagSet struct {",
                "// Line 3318:     Tags []tags.Tag `xml:\"Tag\"`",
                "// vulnerable line: 3319: }",
                "// Line 3320: ",
                "// Line 3321: type objectTagging struct {",
                "// Line 3322:     XMLName xml.Name      `xml:\"Tagging\"`",
                "// Line 3323:     TagSet  *ObjectTagSet `xml:\"TagSet\"`",
                "// vulnerable line: 3324: }",
                "// Line 3325: ",
                "// Line 3326: // GetObjectTaggingHandler - GET object tagging",
                "// Line 3327: func (api objectAPIHandlers) GetObjectTaggingHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3328:     ctx := newContext(r, w, \"GetObjectTagging\")",
                "// Line 3329:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3330: ",
                "// Line 3331:     vars := mux.Vars(r)",
                "// Line 3332:     bucket := vars[\"bucket\"]",
                "// Line 3333:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3334:     if err != nil {",
                "// Line 3335:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3336: return",
                "// vulnerable line: 3337: }",
                "// Line 3338: ",
                "// Line 3339:     objAPI := api.ObjectAPI()",
                "// Line 3340:     if objAPI == nil {",
                "// Line 3341:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3342: return",
                "// vulnerable line: 3343: }",
                "// Line 3344: ",
                "// Line 3345:     if s3Error := authenticateRequest(ctx, r, policy.GetObjectTaggingAction); s3Error != ErrNone {",
                "// vulnerable line: 3346: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3347: return",
                "// vulnerable line: 3348: }",
                "// Line 3349: ",
                "// Line 3350:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3351:     if err != nil {",
                "// Line 3352:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3353: return",
                "// vulnerable line: 3354: }",
                "// Line 3355: ",
                "// Line 3356:     ot, err := objAPI.GetObjectTags(ctx, bucket, object, opts)",
                "// Line 3357:     if err != nil {",
                "// Line 3358:         // if object/version is not found locally, but exists on peer site - proxy",
                "// Line 3359:         // the tagging request to peer site. The response to client will",
                "// Line 3360:         // return tags from peer site.",
                "// Line 3361:         if isErrObjectNotFound(err) || isErrVersionNotFound(err) {",
                "// Line 3362:             proxytgts := getProxyTargets(ctx, bucket, object, opts)",
                "// Line 3363:             if !proxytgts.Empty() {",
                "// Line 3364:                 globalReplicationStats.incProxy(bucket, getObjectTaggingAPI, false)",
                "// Line 3365:                 // proxy to replication target if site replication is in place.",
                "// Line 3366:                 tags, gerr := proxyGetTaggingToRepTarget(ctx, bucket, object, opts, proxytgts)",
                "// Line 3367:                 if gerr.Err != nil || tags == nil {",
                "// Line 3368:                     globalReplicationStats.incProxy(bucket, getObjectTaggingAPI, true)",
                "// Line 3369:                     writeErrorResponse(ctx, w, toAPIError(ctx, gerr.Err), r.URL)",
                "// vulnerable line: 3370: return",
                "// Line 3371:                 } // overlay tags from peer site.",
                "// Line 3372:                 ot = tags",
                "// Line 3373:                 w.Header()[xhttp.MinIOTaggingProxied] = []string{\"true\"} // indicate that the request was proxied.",
                "// Line 3374:             } else {",
                "// Line 3375:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3376: return",
                "// vulnerable line: 3377: }",
                "// Line 3378:         } else {",
                "// Line 3379:             writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3380: return",
                "// vulnerable line: 3381: }",
                "// vulnerable line: 3382: }",
                "// Line 3383: ",
                "// Line 3384:     // Set this such that authorization policies can be applied on the object tags.",
                "// Line 3385:     if tags := ot.String(); tags != \"\" {",
                "// Line 3386:         r.Header.Set(xhttp.AmzObjectTagging, tags)",
                "// vulnerable line: 3387: }",
                "// Line 3388: ",
                "// Line 3389:     if s3Error := authorizeRequest(ctx, r, policy.GetObjectTaggingAction); s3Error != ErrNone {",
                "// vulnerable line: 3390: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3391: return",
                "// vulnerable line: 3392: }",
                "// Line 3393: ",
                "// Line 3394:     if opts.VersionID != \"\" && opts.VersionID != nullVersionID {",
                "// Line 3395:         w.Header()[xhttp.AmzVersionID] = []string{opts.VersionID}",
                "// vulnerable line: 3396: }",
                "// Line 3397: ",
                "// Line 3398:     otags := &objectTagging{",
                "// Line 3399:         TagSet: &ObjectTagSet{},",
                "// vulnerable line: 3400: }",
                "// Line 3401: ",
                "// Line 3402:     var list []tags.Tag",
                "// Line 3403:     for k, v := range ot.ToMap() {",
                "// Line 3404:         list = append(list, tags.Tag{",
                "// Line 3405:             Key:   k,",
                "// Line 3406:             Value: v,",
                "// Line 3407:         })",
                "// vulnerable line: 3408: }",
                "// Line 3409:     // Always return in sorted order for tags.",
                "// Line 3410:     sort.Slice(list, func(i, j int) bool {",
                "// Line 3411:         return list[i].Key < list[j].Key",
                "// Line 3412:     })",
                "// Line 3413:     otags.TagSet.Tags = list",
                "// Line 3414: ",
                "// Line 3415:     writeSuccessResponseXML(w, encodeResponse(otags))",
                "// vulnerable line: 3416: }",
                "// Line 3417: ",
                "// Line 3418: // PutObjectTaggingHandler - PUT object tagging",
                "// Line 3419: func (api objectAPIHandlers) PutObjectTaggingHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3420:     ctx := newContext(r, w, \"PutObjectTagging\")",
                "// Line 3421:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3422: ",
                "// Line 3423:     vars := mux.Vars(r)",
                "// Line 3424:     bucket := vars[\"bucket\"]",
                "// Line 3425:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3426:     if err != nil {",
                "// Line 3427:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3428: return",
                "// vulnerable line: 3429: }",
                "// Line 3430: ",
                "// Line 3431:     objAPI := api.ObjectAPI()",
                "// Line 3432:     if objAPI == nil {",
                "// Line 3433:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3434: return",
                "// vulnerable line: 3435: }",
                "// Line 3436: ",
                "// Line 3437:     // Tags XML will not be bigger than 1MiB in size, fail if its bigger.",
                "// Line 3438:     tags, err := tags.ParseObjectXML(io.LimitReader(r.Body, 1<<20))",
                "// Line 3439:     if err != nil {",
                "// Line 3440:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3441: return",
                "// vulnerable line: 3442: }",
                "// Line 3443: ",
                "// Line 3444:     // Set this such that authorization policies can be applied on the object tags.",
                "// Line 3445:     r.Header.Set(xhttp.AmzObjectTagging, tags.String())",
                "// Line 3446: ",
                "// Line 3447:     // Allow putObjectTagging if policy action is set",
                "// Line 3448:     if s3Error := checkRequestAuthType(ctx, r, policy.PutObjectTaggingAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 3449: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3450: return",
                "// vulnerable line: 3451: }",
                "// Line 3452: ",
                "// Line 3453:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3454:     if err != nil {",
                "// Line 3455:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3456: return",
                "// vulnerable line: 3457: }",
                "// Line 3458: ",
                "// Line 3459:     objInfo, err := objAPI.GetObjectInfo(ctx, bucket, object, opts)",
                "// Line 3460:     if err != nil {",
                "// Line 3461:         // if object is not found locally, but exists on peer site - proxy",
                "// Line 3462:         // the tagging request to peer site. The response to client will",
                "// Line 3463:         // be 200 with extra header indicating that the request was proxied.",
                "// Line 3464:         if isErrObjectNotFound(err) || isErrVersionNotFound(err) {",
                "// Line 3465:             proxytgts := getProxyTargets(ctx, bucket, object, opts)",
                "// Line 3466:             if !proxytgts.Empty() {",
                "// Line 3467:                 globalReplicationStats.incProxy(bucket, putObjectTaggingAPI, false)",
                "// Line 3468:                 // proxy to replication target if site replication is in place.",
                "// Line 3469:                 perr := proxyTaggingToRepTarget(ctx, bucket, object, tags, opts, proxytgts)",
                "// Line 3470:                 if perr.Err != nil {",
                "// Line 3471:                     globalReplicationStats.incProxy(bucket, putObjectTaggingAPI, true)",
                "// Line 3472:                     writeErrorResponse(ctx, w, toAPIError(ctx, perr.Err), r.URL)",
                "// vulnerable line: 3473: return",
                "// vulnerable line: 3474: }",
                "// Line 3475:                 w.Header()[xhttp.MinIOTaggingProxied] = []string{\"true\"}",
                "// Line 3476:                 writeSuccessResponseHeadersOnly(w)",
                "// Line 3477:                 // when tagging is proxied, the object version is not available to return",
                "// Line 3478:                 // as header in the response, or ObjectInfo in the notification event.",
                "// Line 3479:                 sendEvent(eventArgs{",
                "// Line 3480:                     EventName:    event.ObjectCreatedPutTagging,",
                "// Line 3481:                     BucketName:   bucket,",
                "// Line 3482:                     ReqParams:    extractReqParams(r),",
                "// Line 3483:                     RespElements: extractRespElements(w),",
                "// Line 3484:                     UserAgent:    r.UserAgent(),",
                "// Line 3485:                     Host:         handlers.GetSourceIP(r),",
                "// Line 3486:                 })",
                "// vulnerable line: 3487: return",
                "// vulnerable line: 3488: }",
                "// vulnerable line: 3489: }",
                "// Line 3490:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3491: return",
                "// vulnerable line: 3492: }",
                "// Line 3493:     tagsStr := tags.String()",
                "// Line 3494: ",
                "// Line 3495:     dsc := mustReplicate(ctx, bucket, object, getMustReplicateOptions(objInfo.UserDefined, tagsStr, objInfo.ReplicationStatus, replication.MetadataReplicationType, opts))",
                "// Line 3496:     if dsc.ReplicateAny() {",
                "// Line 3497:         opts.UserDefined = make(map[string]string)",
                "// Line 3498:         opts.UserDefined[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 3499:         opts.UserDefined[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// Line 3500:         opts.UserDefined[ReservedMetadataPrefixLower+TaggingTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// vulnerable line: 3501: }",
                "// Line 3502: ",
                "// Line 3503:     // Put object tags",
                "// Line 3504:     objInfo, err = objAPI.PutObjectTags(ctx, bucket, object, tagsStr, opts)",
                "// Line 3505:     if err != nil {",
                "// Line 3506:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3507: return",
                "// vulnerable line: 3508: }",
                "// Line 3509: ",
                "// Line 3510:     if dsc.ReplicateAny() {",
                "// Line 3511:         scheduleReplication(ctx, objInfo, objAPI, dsc, replication.MetadataReplicationType)",
                "// vulnerable line: 3512: }",
                "// Line 3513: ",
                "// Line 3514:     if objInfo.VersionID != \"\" && objInfo.VersionID != nullVersionID {",
                "// Line 3515:         w.Header()[xhttp.AmzVersionID] = []string{objInfo.VersionID}",
                "// vulnerable line: 3516: }",
                "// Line 3517: ",
                "// Line 3518:     writeSuccessResponseHeadersOnly(w)",
                "// Line 3519: ",
                "// Line 3520:     sendEvent(eventArgs{",
                "// Line 3521:         EventName:    event.ObjectCreatedPutTagging,",
                "// Line 3522:         BucketName:   bucket,",
                "// Line 3523:         Object:       objInfo,",
                "// Line 3524:         ReqParams:    extractReqParams(r),",
                "// Line 3525:         RespElements: extractRespElements(w),",
                "// Line 3526:         UserAgent:    r.UserAgent(),",
                "// Line 3527:         Host:         handlers.GetSourceIP(r),",
                "// Line 3528:     })",
                "// vulnerable line: 3529: }",
                "// Line 3530: ",
                "// Line 3531: // DeleteObjectTaggingHandler - DELETE object tagging",
                "// Line 3532: func (api objectAPIHandlers) DeleteObjectTaggingHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3533:     ctx := newContext(r, w, \"DeleteObjectTagging\")",
                "// Line 3534:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3535: ",
                "// Line 3536:     objAPI := api.ObjectAPI()",
                "// Line 3537:     if objAPI == nil {",
                "// Line 3538:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3539: return",
                "// vulnerable line: 3540: }",
                "// Line 3541: ",
                "// Line 3542:     vars := mux.Vars(r)",
                "// Line 3543:     bucket := vars[\"bucket\"]",
                "// Line 3544:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3545:     if err != nil {",
                "// Line 3546:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3547: return",
                "// vulnerable line: 3548: }",
                "// Line 3549: ",
                "// Line 3550:     opts, err := getOpts(ctx, r, bucket, object)",
                "// Line 3551:     if err != nil {",
                "// Line 3552:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3553: return",
                "// vulnerable line: 3554: }",
                "// Line 3555: ",
                "// Line 3556:     oi, err := objAPI.GetObjectInfo(ctx, bucket, object, opts)",
                "// Line 3557:     if err != nil {",
                "// Line 3558:         // if object is not found locally, but exists on peer site - proxy",
                "// Line 3559:         // the tagging request to peer site. The response to client will",
                "// Line 3560:         // be 200 OK with extra header indicating that the request was proxied.",
                "// Line 3561:         if isErrObjectNotFound(err) || isErrVersionNotFound(err) {",
                "// Line 3562:             proxytgts := getProxyTargets(ctx, bucket, object, opts)",
                "// Line 3563:             if !proxytgts.Empty() {",
                "// Line 3564:                 globalReplicationStats.incProxy(bucket, removeObjectTaggingAPI, false)",
                "// Line 3565:                 // proxy to replication target if active-active replication is in place.",
                "// Line 3566:                 perr := proxyTaggingToRepTarget(ctx, bucket, object, nil, opts, proxytgts)",
                "// Line 3567:                 if perr.Err != nil {",
                "// Line 3568:                     globalReplicationStats.incProxy(bucket, removeObjectTaggingAPI, true)",
                "// Line 3569:                     writeErrorResponse(ctx, w, toAPIError(ctx, perr.Err), r.URL)",
                "// vulnerable line: 3570: return",
                "// vulnerable line: 3571: }",
                "// Line 3572:                 // when delete tagging is proxied, the object version/tags are not available to return",
                "// Line 3573:                 // as header in the response, nor ObjectInfo in the notification event.",
                "// Line 3574:                 w.Header()[xhttp.MinIOTaggingProxied] = []string{\"true\"}",
                "// Line 3575:                 writeSuccessNoContent(w)",
                "// Line 3576:                 sendEvent(eventArgs{",
                "// Line 3577:                     EventName:    event.ObjectCreatedDeleteTagging,",
                "// Line 3578:                     BucketName:   bucket,",
                "// Line 3579:                     Object:       oi,",
                "// Line 3580:                     ReqParams:    extractReqParams(r),",
                "// Line 3581:                     RespElements: extractRespElements(w),",
                "// Line 3582:                     UserAgent:    r.UserAgent(),",
                "// Line 3583:                     Host:         handlers.GetSourceIP(r),",
                "// Line 3584:                 })",
                "// vulnerable line: 3585: return",
                "// vulnerable line: 3586: }",
                "// vulnerable line: 3587: }",
                "// Line 3588:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3589: return",
                "// vulnerable line: 3590: }",
                "// Line 3591: ",
                "// Line 3592:     if userTags := oi.UserTags; userTags != \"\" {",
                "// Line 3593:         // Set this such that authorization policies can be applied on the object tags.",
                "// Line 3594:         r.Header.Set(xhttp.AmzObjectTagging, oi.UserTags)",
                "// vulnerable line: 3595: }",
                "// Line 3596: ",
                "// Line 3597:     // Allow deleteObjectTagging if policy action is set",
                "// Line 3598:     if s3Error := checkRequestAuthType(ctx, r, policy.DeleteObjectTaggingAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 3599: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3600: return",
                "// vulnerable line: 3601: }",
                "// Line 3602: ",
                "// Line 3603:     dsc := mustReplicate(ctx, bucket, object, oi.getMustReplicateOptions(replication.MetadataReplicationType, opts))",
                "// Line 3604:     if dsc.ReplicateAny() {",
                "// Line 3605:         opts.UserDefined = make(map[string]string)",
                "// Line 3606:         opts.UserDefined[ReservedMetadataPrefixLower+ReplicationTimestamp] = UTCNow().Format(time.RFC3339Nano)",
                "// Line 3607:         opts.UserDefined[ReservedMetadataPrefixLower+ReplicationStatus] = dsc.PendingStatus()",
                "// vulnerable line: 3608: }",
                "// Line 3609: ",
                "// Line 3610:     oi, err = objAPI.DeleteObjectTags(ctx, bucket, object, opts)",
                "// Line 3611:     if err != nil {",
                "// Line 3612:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3613: return",
                "// vulnerable line: 3614: }",
                "// Line 3615: ",
                "// Line 3616:     if dsc.ReplicateAny() {",
                "// Line 3617:         scheduleReplication(ctx, oi, objAPI, dsc, replication.MetadataReplicationType)",
                "// vulnerable line: 3618: }",
                "// Line 3619: ",
                "// Line 3620:     if oi.VersionID != \"\" && oi.VersionID != nullVersionID {",
                "// Line 3621:         w.Header()[xhttp.AmzVersionID] = []string{oi.VersionID}",
                "// vulnerable line: 3622: }",
                "// Line 3623:     writeSuccessNoContent(w)",
                "// Line 3624: ",
                "// Line 3625:     sendEvent(eventArgs{",
                "// Line 3626:         EventName:    event.ObjectCreatedDeleteTagging,",
                "// Line 3627:         BucketName:   bucket,",
                "// Line 3628:         Object:       oi,",
                "// Line 3629:         ReqParams:    extractReqParams(r),",
                "// Line 3630:         RespElements: extractRespElements(w),",
                "// Line 3631:         UserAgent:    r.UserAgent(),",
                "// Line 3632:         Host:         handlers.GetSourceIP(r),",
                "// Line 3633:     })",
                "// vulnerable line: 3634: }",
                "// Line 3635: ",
                "// Line 3636: // RestoreObjectHandler - POST restore object handler.",
                "// Line 3637: // ----------",
                "// Line 3638: func (api objectAPIHandlers) PostRestoreObjectHandler(w http.ResponseWriter, r *http.Request) {",
                "// Line 3639:     ctx := newContext(r, w, \"PostRestoreObject\")",
                "// Line 3640:     defer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))",
                "// Line 3641:     vars := mux.Vars(r)",
                "// Line 3642:     bucket := vars[\"bucket\"]",
                "// Line 3643:     object, err := unescapePath(vars[\"object\"])",
                "// Line 3644:     if err != nil {",
                "// Line 3645:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3646: return",
                "// vulnerable line: 3647: }",
                "// Line 3648: ",
                "// Line 3649:     // Fetch object stat info.",
                "// Line 3650:     objectAPI := api.ObjectAPI()",
                "// Line 3651:     if objectAPI == nil {",
                "// Line 3652:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)",
                "// vulnerable line: 3653: return",
                "// vulnerable line: 3654: }",
                "// Line 3655: ",
                "// Line 3656:     getObjectInfo := objectAPI.GetObjectInfo",
                "// Line 3657: ",
                "// Line 3658:     // Check for auth type to return S3 compatible error.",
                "// Line 3659:     if s3Error := checkRequestAuthType(ctx, r, policy.RestoreObjectAction, bucket, object); s3Error != ErrNone {",
                "// vulnerable line: 3660: writeErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Error), r.URL)",
                "// vulnerable line: 3661: return",
                "// vulnerable line: 3662: }",
                "// Line 3663: ",
                "// Line 3664:     if r.ContentLength <= 0 {",
                "// Line 3665:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrEmptyRequestBody), r.URL)",
                "// vulnerable line: 3666: return",
                "// vulnerable line: 3667: }",
                "// Line 3668:     opts, err := postRestoreOpts(ctx, r, bucket, object)",
                "// Line 3669:     if err != nil {",
                "// Line 3670:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3671: return",
                "// vulnerable line: 3672: }",
                "// Line 3673: ",
                "// Line 3674:     objInfo, err := getObjectInfo(ctx, bucket, object, opts)",
                "// Line 3675:     if err != nil {",
                "// Line 3676:         writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3677: return",
                "// vulnerable line: 3678: }",
                "// Line 3679: ",
                "// Line 3680:     if objInfo.TransitionedObject.Status != lifecycle.TransitionComplete {",
                "// Line 3681:         writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidObjectState), r.URL)",
                "// vulnerable line: 3682: return",
                "// vulnerable line: 3683: }",
                "// Line 3684: ",
                "// Line 3685:     rreq, err := parseRestoreRequest(io.LimitReader(r.Body, r.ContentLength))",
                "// Line 3686:     if err != nil {",
                "// Line 3687:         apiErr := errorCodes.ToAPIErr(ErrMalformedXML)",
                "// Line 3688:         apiErr.Description = err.Error()",
                "// Line 3689:         writeErrorResponse(ctx, w, apiErr, r.URL)",
                "// vulnerable line: 3690: return",
                "// vulnerable line: 3691: }",
                "// Line 3692:     // validate the request",
                "// Line 3693:     if err := rreq.validate(ctx, objectAPI); err != nil {",
                "// Line 3694:         apiErr := errorCodes.ToAPIErr(ErrMalformedXML)",
                "// Line 3695:         apiErr.Description = err.Error()",
                "// Line 3696:         writeErrorResponse(ctx, w, apiErr, r.URL)",
                "// vulnerable line: 3697: return",
                "// vulnerable line: 3698: }",
                "// Line 3699:     statusCode := http.StatusOK",
                "// Line 3700:     alreadyRestored := false",
                "// Line 3701:     if err == nil {",
                "// Line 3702:         if objInfo.RestoreOngoing && rreq.Type != SelectRestoreRequest {",
                "// Line 3703:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrObjectRestoreAlreadyInProgress), r.URL)",
                "// vulnerable line: 3704: return",
                "// vulnerable line: 3705: }",
                "// Line 3706:         if !objInfo.RestoreOngoing && !objInfo.RestoreExpires.IsZero() {",
                "// Line 3707:             statusCode = http.StatusAccepted",
                "// Line 3708:             alreadyRestored = true",
                "// vulnerable line: 3709: }",
                "// vulnerable line: 3710: }",
                "// Line 3711:     // set or upgrade restore expiry",
                "// Line 3712:     restoreExpiry := lifecycle.ExpectedExpiryTime(time.Now().UTC(), rreq.Days)",
                "// Line 3713:     metadata := cloneMSS(objInfo.UserDefined)",
                "// Line 3714: ",
                "// Line 3715:     // update self with restore metadata",
                "// Line 3716:     if rreq.Type != SelectRestoreRequest {",
                "// Line 3717:         objInfo.metadataOnly = true // Perform only metadata updates.",
                "// Line 3718:         metadata[xhttp.AmzRestoreExpiryDays] = strconv.Itoa(rreq.Days)",
                "// Line 3719:         metadata[xhttp.AmzRestoreRequestDate] = time.Now().UTC().Format(http.TimeFormat)",
                "// Line 3720:         if alreadyRestored {",
                "// Line 3721:             metadata[xhttp.AmzRestore] = completedRestoreObj(restoreExpiry).String()",
                "// Line 3722:         } else {",
                "// Line 3723:             metadata[xhttp.AmzRestore] = ongoingRestoreObj().String()",
                "// vulnerable line: 3724: }",
                "// Line 3725:         objInfo.UserDefined = metadata",
                "// Line 3726:         if _, err := objectAPI.CopyObject(GlobalContext, bucket, object, bucket, object, objInfo, ObjectOptions{",
                "// Line 3727:             VersionID: objInfo.VersionID,",
                "// Line 3728:         }, ObjectOptions{",
                "// Line 3729:             VersionID: objInfo.VersionID,",
                "// Line 3730:             MTime:     objInfo.ModTime,",
                "// Line 3731:         }); err != nil {",
                "// Line 3732:             writeErrorResponse(ctx, w, errorCodes.ToAPIErr(ErrInvalidObjectState), r.URL)",
                "// vulnerable line: 3733: return",
                "// vulnerable line: 3734: }",
                "// Line 3735:         // for previously restored object, just update the restore expiry",
                "// Line 3736:         if alreadyRestored {",
                "// vulnerable line: 3737: return",
                "// vulnerable line: 3738: }",
                "// vulnerable line: 3739: }",
                "// Line 3740: ",
                "// Line 3741:     restoreObject := mustGetUUID()",
                "// Line 3742:     if rreq.OutputLocation.S3.BucketName != \"\" {",
                "// Line 3743:         w.Header()[xhttp.AmzRestoreOutputPath] = []string{pathJoin(rreq.OutputLocation.S3.BucketName, rreq.OutputLocation.S3.Prefix, restoreObject)}",
                "// vulnerable line: 3744: }",
                "// Line 3745:     w.WriteHeader(statusCode)",
                "// Line 3746:     // Notify object restore started via a POST request.",
                "// Line 3747:     sendEvent(eventArgs{",
                "// Line 3748:         EventName:  event.ObjectRestorePost,",
                "// Line 3749:         BucketName: bucket,",
                "// Line 3750:         Object:     objInfo,",
                "// Line 3751:         ReqParams:  extractReqParams(r),",
                "// Line 3752:         UserAgent:  r.UserAgent(),",
                "// Line 3753:         Host:       handlers.GetSourceIP(r),",
                "// Line 3754:     })",
                "// Line 3755:     // now process the restore in background",
                "// Line 3756:     go func() {",
                "// Line 3757:         rctx := GlobalContext",
                "// Line 3758:         if !rreq.SelectParameters.IsEmpty() {",
                "// Line 3759:             actualSize, err := objInfo.GetActualSize()",
                "// Line 3760:             if err != nil {",
                "// Line 3761:                 writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3762: return",
                "// vulnerable line: 3763: }",
                "// Line 3764: ",
                "// Line 3765:             objectRSC := s3select.NewObjectReadSeekCloser(",
                "// Line 3766:                 func(offset int64) (io.ReadCloser, error) {",
                "// Line 3767:                     rs := &HTTPRangeSpec{",
                "// Line 3768:                         IsSuffixLength: false,",
                "// Line 3769:                         Start:          offset,",
                "// Line 3770:                         End:            -1,",
                "// vulnerable line: 3771: }",
                "// Line 3772:                     return getTransitionedObjectReader(rctx, bucket, object, rs, r.Header,",
                "// Line 3773:                         objInfo, ObjectOptions{VersionID: objInfo.VersionID})",
                "// Line 3774:                 },",
                "// Line 3775:                 actualSize,",
                "// Line 3776:             )",
                "// Line 3777:             defer objectRSC.Close()",
                "// Line 3778:             if err = rreq.SelectParameters.Open(objectRSC); err != nil {",
                "// Line 3779:                 if serr, ok := err.(s3select.SelectError); ok {",
                "// Line 3780:                     encodedErrorResponse := encodeResponse(APIErrorResponse{",
                "// Line 3781:                         Code:       serr.ErrorCode(),",
                "// Line 3782:                         Message:    serr.ErrorMessage(),",
                "// Line 3783:                         BucketName: bucket,",
                "// Line 3784:                         Key:        object,",
                "// Line 3785:                         Resource:   r.URL.Path,",
                "// Line 3786:                         RequestID:  w.Header().Get(xhttp.AmzRequestID),",
                "// Line 3787:                         HostID:     globalDeploymentID(),",
                "// Line 3788:                     })",
                "// Line 3789:                     writeResponse(w, serr.HTTPStatusCode(), encodedErrorResponse, mimeXML)",
                "// Line 3790:                 } else {",
                "// Line 3791:                     writeErrorResponse(ctx, w, toAPIError(ctx, err), r.URL)",
                "// vulnerable line: 3792: }",
                "// vulnerable line: 3793: return",
                "// vulnerable line: 3794: }",
                "// Line 3795:             nr := httptest.NewRecorder()",
                "// Line 3796:             rw := xhttp.NewResponseRecorder(nr)",
                "// Line 3797:             rw.LogErrBody = true",
                "// Line 3798:             rw.LogAllBody = true",
                "// Line 3799:             rreq.SelectParameters.Evaluate(rw)",
                "// Line 3800:             rreq.SelectParameters.Close()",
                "// vulnerable line: 3801: return",
                "// vulnerable line: 3802: }",
                "// Line 3803:         opts := ObjectOptions{",
                "// Line 3804:             Transition: TransitionOptions{",
                "// Line 3805:                 RestoreRequest: rreq,",
                "// Line 3806:                 RestoreExpiry:  restoreExpiry,",
                "// Line 3807:             },",
                "// Line 3808:             VersionID: objInfo.VersionID,",
                "// vulnerable line: 3809: }",
                "// Line 3810:         if err := objectAPI.RestoreTransitionedObject(rctx, bucket, object, opts); err != nil {",
                "// Line 3811:             s3LogIf(ctx, fmt.Errorf(\"Unable to restore transitioned bucket/object %s/%s: %w\", bucket, object, err))",
                "// vulnerable line: 3812: return",
                "// vulnerable line: 3813: }",
                "// Line 3814: ",
                "// Line 3815:         // Notify object restore completed via a POST request.",
                "// Line 3816:         sendEvent(eventArgs{",
                "// Line 3817:             EventName:  event.ObjectRestoreCompleted,",
                "// Line 3818:             BucketName: bucket,",
                "// Line 3819:             Object:     objInfo,",
                "// Line 3820:             ReqParams:  extractReqParams(r),",
                "// Line 3821:             UserAgent:  r.UserAgent(),",
                "// Line 3822:             Host:       handlers.GetSourceIP(r),",
                "// Line 3823:         })",
                "// Line 3824:     }()",
                "// vulnerable line: 3825: }"
            ]
        }
    ]
}