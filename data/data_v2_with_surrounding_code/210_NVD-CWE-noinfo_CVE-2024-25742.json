{
    "cve_id": "CVE-2024-25742",
    "cve_description": "In the Linux kernel before 6.9, an untrusted hypervisor can inject virtual interrupt 29 (#VC) at any point in time and can trigger its handler. This affects AMD SEV-SNP and AMD SEV-ES.",
    "cve_publish_date": "2024-05-17T22:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "x86/sev: Harden #VC instruction emulation somewhat\n\nCompare the opcode bytes at rIP for each #VC exit reason to verify the\ninstruction which raised the #VC exception is actually the right one.\n\nSigned-off-by: Borislav Petkov (AMD) <bp@alien8.de>\nAcked-by: Tom Lendacky <thomas.lendacky@amd.com>\nLink: https://lore.kernel.org/r/20240105101407.11694-1-bp@alien8.de",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "sev.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "sev.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1756:      */",
                "// Line 1757:     ctxt->fi.vector = X86_TRAP_AC;",
                "// Line 1758:     ctxt->fi.error_code = 0;",
                "// Line 1759:     return ES_EXCEPTION;",
                "// Line 1760: }",
                "// Line 1761: ",
                "// Line 1762: static enum es_result vc_handle_exitcode(struct es_em_ctxt *ctxt,",
                "// Line 1763:                      struct ghcb *ghcb,",
                "// Line 1764:                      unsigned long exit_code)",
                "// Line 1765: {",
                "// vulnerable line: 1766: enum es_result result;",
                "// Line 1767: ",
                "// Line 1768:     switch (exit_code) {",
                "// Line 1769:     case SVM_EXIT_READ_DR7:",
                "// Line 1770:         result = vc_handle_dr7_read(ghcb, ctxt);",
                "// Line 1771:         break;",
                "// Line 1772:     case SVM_EXIT_WRITE_DR7:",
                "// Line 1773:         result = vc_handle_dr7_write(ghcb, ctxt);",
                "// Line 1774:         break;",
                "// Line 1775:     case SVM_EXIT_EXCP_BASE + X86_TRAP_AC:",
                "// Line 1776:         result = vc_handle_trap_ac(ghcb, ctxt);",
                "// Line 1866:      * happened, let it proceed to the normal handling routine. This way the",
                "// Line 1867:      * code executing on the VC2 stack can cause #VC exceptions to get handled.",
                "// Line 1868:      */",
                "// Line 1869:     return is_vc2_stack(sp) && !is_vc2_stack(prev_sp);",
                "// Line 1870: }",
                "// Line 1871: ",
                "// Line 1872: static bool vc_raw_handle_exception(struct pt_regs *regs, unsigned long error_code)",
                "// Line 1873: {",
                "// Line 1874:     struct ghcb_state state;",
                "// Line 1875:     struct es_em_ctxt ctxt;",
                "// vulnerable line: 1876: enum es_result result;",
                "// Line 1877:     struct ghcb *ghcb;",
                "// Line 1878:     bool ret = true;",
                "// Line 1879: ",
                "// Line 1880:     ghcb = __sev_get_ghcb(&state);",
                "// Line 1881: ",
                "// Line 1882:     vc_ghcb_invalidate(ghcb);",
                "// Line 1883:     result = vc_init_em_ctxt(&ctxt, regs, error_code);",
                "// Line 1884: ",
                "// Line 1885:     if (result == ES_OK)",
                "// Line 1886:         result = vc_handle_exitcode(&ctxt, ghcb, error_code);",
                "// Line 2015:     }",
                "// Line 2016: ",
                "// Line 2017:     instrumentation_end();",
                "// Line 2018:     irqentry_exit_to_user_mode(regs);",
                "// Line 2019: }",
                "// Line 2020: ",
                "// Line 2021: bool __init handle_vc_boot_ghcb(struct pt_regs *regs)",
                "// Line 2022: {",
                "// Line 2023:     unsigned long exit_code = regs->orig_ax;",
                "// Line 2024:     struct es_em_ctxt ctxt;",
                "// vulnerable line: 2025: enum es_result result;",
                "// Line 2026: ",
                "// Line 2027:     vc_ghcb_invalidate(boot_ghcb);",
                "// Line 2028: ",
                "// Line 2029:     result = vc_init_em_ctxt(&ctxt, regs, exit_code);",
                "// Line 2030:     if (result == ES_OK)",
                "// Line 2031:         result = vc_handle_exitcode(&ctxt, boot_ghcb, exit_code);",
                "// Line 2032: ",
                "// Line 2033:     /* Done - now check the result */",
                "// Line 2034:     switch (result) {",
                "// Line 2035:     case ES_OK:"
            ]
        }
    ]
}