{
    "cve_id": "CVE-2024-24814",
    "cve_description": "mod_auth_openidc is an OpenID Certifiedâ„¢ authentication and authorization module for the Apache 2.x HTTP server that implements the OpenID Connect Relying Party functionality. In affected versions missing input validation on mod_auth_openidc_session_chunks cookie value makes the server vulnerable to a denial of service (DoS) attack. An internal security audit has been conducted and the reviewers found that if they manipulated the value of the mod_auth_openidc_session_chunks cookie to a very large integer, like 99999999, the server struggles with the request for a long time and finally gets back with a 500 error. Making a few requests of this kind caused our server to become unresponsive. Attackers can craft requests that would make the server work very hard (and possibly become unresponsive) and/or crash with minimal effort. This issue has been addressed in version 2.4.15.2. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-02-13T19:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "release 2.4.15.2: fix DoS CVE-2024-24814\n\nfix CVE-2024-24814: DoS when `OIDCSessionType client-cookie` is set and\na crafted Cookie header is supplied\nhttps://github.com/OpenIDC/mod_auth_openidc/security/advisories/GHSA-hxr6-w4gc-7vvv\n\nSigned-off-by: Hans Zandbelt <hans.zandbelt@openidc.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "util.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "17",
            "number_of_lines_deleted_vulnerable_to_cve": "16",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 67: ",
                "// Line 68:     int fd = -1;",
                "// Line 69: ",
                "// Line 70:     do {",
                "// Line 71:         apr_ssize_t rc;",
                "// Line 72: ",
                "// Line 73:         if (fd == -1) {",
                "// Line 74:             fd = open(DEV_RANDOM, O_RDONLY);",
                "// Line 75:             if (fd == -1)",
                "// Line 76:                 return errno;",
                "// vulnerable line: 77: }",
                "// Line 78: ",
                "// Line 79:         do {",
                "// Line 80:             rc = read(fd, buf, length);",
                "// Line 81:         } while (rc == -1 && errno == EINTR);",
                "// Line 82: ",
                "// Line 83:         if (rc < 0) {",
                "// Line 84:             int errnum = errno;",
                "// Line 85:             close(fd);",
                "// Line 86:             return errnum;",
                "// Line 87:         } else if (rc == 0) {",
                "// Line 88:             close(fd);",
                "// Line 89:             fd = -1; /* force open() again */",
                "// vulnerable line: 90: } else {",
                "// Line 91:             buf += rc;",
                "// Line 92:             length -= rc;",
                "// vulnerable line: 93: }",
                "// Line 94:     } while (length > 0);",
                "// Line 95: ",
                "// Line 96:     close(fd);",
                "// Line 97: ",
                "// Line 98:     rv = TRUE;",
                "// Line 99: ",
                "// Line 100: #endif",
                "// Line 101: ",
                "// Line 102:     return rv;",
                "// vulnerable line: 103: }",
                "// Line 104: ",
                "// Line 105: apr_byte_t oidc_util_generate_random_bytes(request_rec *r, unsigned char *buf, apr_size_t length) {",
                "// Line 106:     apr_byte_t rv = TRUE;",
                "// Line 107:     const char *gen = NULL;",
                "// Line 108: #ifndef USE_URANDOM",
                "// Line 109:     gen = \"apr\";",
                "// Line 110: #else",
                "// Line 111:     gen = DEV_RANDOM;",
                "// Line 112: #endif",
                "// Line 113:     oidc_debug(r, \"oidc_util_random_bytes [%s] call for %\" APR_SIZE_T_FMT \" bytes\", gen, length);",
                "// Line 114:     rv = oidc_util_random_bytes(buf, length);",
                "// Line 115:     oidc_debug(r, \"oidc_util_random_bytes returned: %d\", rv);",
                "// Line 116: ",
                "// Line 117:     return rv;",
                "// vulnerable line: 118: }",
                "// Line 119: ",
                "// Line 120: apr_byte_t oidc_proto_generate_random_hex_string(request_rec *r, char **hex_str, int byte_len) {",
                "// Line 121:     unsigned char *bytes = apr_pcalloc(r->pool, byte_len);",
                "// vulnerable line: 122: int i = 0;",
                "// Line 123:     if (oidc_util_generate_random_bytes(r, bytes, byte_len) != TRUE) {",
                "// Line 124:         oidc_error(r, \"oidc_util_generate_random_bytes returned an error\");",
                "// Line 125:         return FALSE;",
                "// vulnerable line: 126: }",
                "// Line 127:     *hex_str = \"\";",
                "// Line 128:     for (i = 0; i < byte_len; i++)",
                "// Line 129:         *hex_str = apr_psprintf(r->pool, \"%s%02x\", *hex_str, bytes[i]);",
                "// Line 130: ",
                "// Line 131:     return TRUE;",
                "// vulnerable line: 132: }",
                "// Line 133: ",
                "// Line 134: /*",
                "// Line 135:  * base64url encode a string",
                "// Line 136:  */",
                "// Line 137: int oidc_base64url_encode(request_rec *r, char **dst, const char *src, int src_len, int remove_padding) {",
                "// Line 138:     if ((src == NULL) || (src_len <= 0)) {",
                "// Line 139:         oidc_error(r, \"not encoding anything; src=NULL and/or src_len<1\");",
                "// Line 140:         return -1;",
                "// vulnerable line: 141: }",
                "// Line 142:     unsigned int enc_len = apr_base64_encode_len(src_len);",
                "// Line 143:     char *enc = apr_palloc(r->pool, enc_len);",
                "// Line 144:     apr_base64_encode(enc, src, src_len);",
                "// Line 145:     unsigned int i = 0;",
                "// Line 146:     while (enc[i] != '\u0000') {",
                "// Line 147:         if (enc[i] == '+')",
                "// Line 148:             enc[i] = '-';",
                "// Line 149:         if (enc[i] == '/')",
                "// Line 150:             enc[i] = '_';",
                "// Line 151:         if (enc[i] == '=')",
                "// Line 152:             enc[i] = ',';",
                "// Line 153:         i++;",
                "// vulnerable line: 154: }",
                "// Line 155:     if (remove_padding) {",
                "// Line 156:         /* remove /0 and padding */",
                "// Line 157:         if (enc_len > 0)",
                "// Line 158:             enc_len--;",
                "// Line 159:         if ((enc_len > 0) && (enc[enc_len - 1] == ','))",
                "// Line 160:             enc_len--;",
                "// Line 161:         if ((enc_len > 0) && (enc[enc_len - 1] == ','))",
                "// Line 162:             enc_len--;",
                "// Line 163:         enc[enc_len] = '\u0000';",
                "// vulnerable line: 164: }",
                "// Line 165:     *dst = enc;",
                "// Line 166:     return enc_len;",
                "// vulnerable line: 167: }",
                "// Line 168: ",
                "// Line 169: /*",
                "// Line 170:  * base64url decode a string",
                "// Line 171:  */",
                "// Line 172: int oidc_base64url_decode(apr_pool_t *pool, char **dst, const char *src) {",
                "// Line 173:     if (src == NULL) {",
                "// Line 174:         return -1;",
                "// vulnerable line: 175: }",
                "// Line 176:     char *dec = apr_pstrdup(pool, src);",
                "// vulnerable line: 177: int i = 0;",
                "// Line 178:     while (dec[i] != '\u0000') {",
                "// Line 179:         if (dec[i] == '-')",
                "// Line 180:             dec[i] = '+';",
                "// Line 181:         if (dec[i] == '_')",
                "// Line 182:             dec[i] = '/';",
                "// Line 183:         if (dec[i] == ',')",
                "// Line 184:             dec[i] = '=';",
                "// Line 185:         i++;",
                "// vulnerable line: 186: }",
                "// Line 187:     switch (_oidc_strlen(dec) % 4) {",
                "// Line 188:     case 0:",
                "// Line 189:         break;",
                "// Line 190:     case 2:",
                "// Line 191:         dec = apr_pstrcat(pool, dec, \"==\", NULL);",
                "// Line 192:         break;",
                "// Line 193:     case 3:",
                "// Line 194:         dec = apr_pstrcat(pool, dec, \"=\", NULL);",
                "// Line 195:         break;",
                "// Line 196:     default:",
                "// Line 197:         return 0;",
                "// vulnerable line: 198: }",
                "// Line 199:     int dlen = apr_base64_decode_len(dec);",
                "// Line 200:     *dst = apr_palloc(pool, dlen);",
                "// Line 201:     return apr_base64_decode(*dst, dec);",
                "// vulnerable line: 202: }",
                "// Line 203: ",
                "// Line 204: static const char *oidc_util_get__oidc_jwt_hdr_dir_a256gcm(request_rec *r, char *input) {",
                "// Line 205:     char *compact_encoded_jwt = NULL;",
                "// Line 206:     char *p = NULL;",
                "// Line 207:     static const char *_oidc_jwt_hdr_dir_a256gcm = NULL;",
                "// Line 208:     static oidc_crypto_passphrase_t passphrase;",
                "// Line 209: ",
                "// Line 210:     if (_oidc_jwt_hdr_dir_a256gcm != NULL)",
                "// Line 211:         return _oidc_jwt_hdr_dir_a256gcm;",
                "// Line 212: ",
                "// Line 213:     if (input == NULL) {",
                "// Line 214:         passphrase.secret1 = \"needs_non_empty_string\";",
                "// Line 215:         passphrase.secret2 = NULL;",
                "// Line 216:         oidc_util_jwt_create(r, &passphrase, \"some_string\", &compact_encoded_jwt);",
                "// vulnerable line: 217: } else {",
                "// Line 218:         compact_encoded_jwt = input;",
                "// vulnerable line: 219: }",
                "// Line 220: ",
                "// Line 221:     p = strstr(compact_encoded_jwt, \"..\");",
                "// Line 222:     if (p) {",
                "// Line 223:         _oidc_jwt_hdr_dir_a256gcm = apr_pstrndup(r->server->process->pconf, compact_encoded_jwt,",
                "// Line 224:                              _oidc_strlen(compact_encoded_jwt) - _oidc_strlen(p) + 2);",
                "// Line 225:         oidc_debug(r, \"saved _oidc_jwt_hdr_dir_a256gcm header: %s\", _oidc_jwt_hdr_dir_a256gcm);",
                "// vulnerable line: 226: }",
                "// Line 227:     return _oidc_jwt_hdr_dir_a256gcm;",
                "// vulnerable line: 228: }",
                "// Line 229: ",
                "// Line 230: static apr_byte_t oidc_util_env_var_override(request_rec *r, const char *env_var_name, apr_byte_t return_when_set) {",
                "// Line 231:     const char *s = NULL;",
                "// Line 232:     if (r->subprocess_env == NULL)",
                "// Line 233:         return !return_when_set;",
                "// Line 234:     s = apr_table_get(r->subprocess_env, env_var_name);",
                "// Line 235:     return (s != NULL) && (_oidc_strcmp(s, \"true\") == 0) ? return_when_set : !return_when_set;",
                "// vulnerable line: 236: }",
                "// Line 237: ",
                "// Line 238: #define OIDC_JWT_INTERNAL_NO_COMPRESS_ENV_VAR \"OIDC_JWT_INTERNAL_NO_COMPRESS\"",
                "// Line 239: ",
                "// Line 240: static apr_byte_t oidc_util_jwt_internal_compress(request_rec *r) {",
                "// Line 241:     // avoid compressing JWTs that need to be compatible with external producers/consumers",
                "// Line 242:     return oidc_util_env_var_override(r, OIDC_JWT_INTERNAL_NO_COMPRESS_ENV_VAR, FALSE);",
                "// vulnerable line: 243: }",
                "// Line 244: ",
                "// Line 245: #define OIDC_JWT_INTERNAL_STRIP_HDR_ENV_VAR \"OIDC_JWT_INTERNAL_STRIP_HDR\"",
                "// Line 246: ",
                "// Line 247: static apr_byte_t oidc_util_jwt_internal_strip_header(request_rec *r) {",
                "// Line 248:     // avoid stripping JWT headers that need to be compatible with external producers/consumers",
                "// Line 249:     return oidc_util_env_var_override(r, OIDC_JWT_INTERNAL_STRIP_HDR_ENV_VAR, TRUE);",
                "// vulnerable line: 250: }",
                "// Line 251: ",
                "// Line 252: apr_byte_t oidc_util_jwt_create(request_rec *r, const oidc_crypto_passphrase_t *passphrase, const char *s_payload,",
                "// Line 253:                 char **compact_encoded_jwt) {",
                "// Line 254: ",
                "// Line 255:     apr_byte_t rv = FALSE;",
                "// Line 256:     oidc_jose_error_t err;",
                "// Line 257:     char *cser = NULL;",
                "// Line 258:     int cser_len = 0;",
                "// Line 259: ",
                "// Line 260:     oidc_jwk_t *jwk = NULL;",
                "// Line 261:     oidc_jwt_t *jwe = NULL;",
                "// Line 262: ",
                "// Line 263:     if (passphrase->secret1 == NULL) {",
                "// Line 264:         oidc_error(r, \"secret is not set\");",
                "// Line 265:         goto end;",
                "// vulnerable line: 266: }",
                "// Line 267: ",
                "// Line 268:     if (oidc_util_create_symmetric_key(r, passphrase->secret1, 0, OIDC_JOSE_ALG_SHA256, FALSE, &jwk) == FALSE)",
                "// Line 269:         goto end;",
                "// Line 270: ",
                "// Line 271:     if (oidc_util_jwt_internal_compress(r)) {",
                "// Line 272:         if (oidc_jose_compress(r->pool, s_payload, _oidc_strlen(s_payload), &cser, &cser_len, &err) == FALSE) {",
                "// Line 273:             oidc_error(r, \"oidc_jose_compress failed: %s\", oidc_jose_e2s(r->pool, err));",
                "// Line 274:             goto end;",
                "// vulnerable line: 275: }",
                "// vulnerable line: 276: } else {",
                "// Line 277:         cser = apr_pstrdup(r->pool, s_payload);",
                "// Line 278:         cser_len = _oidc_strlen(s_payload);",
                "// vulnerable line: 279: }",
                "// Line 280: ",
                "// Line 281:     jwe = oidc_jwt_new(r->pool, TRUE, FALSE);",
                "// Line 282:     if (jwe == NULL) {",
                "// Line 283:         oidc_error(r, \"creating JWE failed\");",
                "// Line 284:         goto end;",
                "// vulnerable line: 285: }",
                "// Line 286: ",
                "// Line 287:     jwe->header.alg = apr_pstrdup(r->pool, CJOSE_HDR_ALG_DIR);",
                "// Line 288:     jwe->header.enc = apr_pstrdup(r->pool, CJOSE_HDR_ENC_A256GCM);",
                "// Line 289:     if (passphrase->secret2 != NULL)",
                "// Line 290:         jwe->header.kid = apr_pstrdup(r->pool, \"1\");",
                "// Line 291: ",
                "// Line 292:     if (oidc_jwt_encrypt(r->pool, jwe, jwk, cser, cser_len, compact_encoded_jwt, &err) == FALSE) {",
                "// Line 293:         oidc_error(r, \"encrypting JWT failed: %s\", oidc_jose_e2s(r->pool, err));",
                "// Line 294:         goto end;",
                "// vulnerable line: 295: }",
                "// Line 296: ",
                "// Line 297:     if ((*compact_encoded_jwt != NULL) && (oidc_util_jwt_internal_strip_header(r)))",
                "// Line 298:         *compact_encoded_jwt += _oidc_strlen(oidc_util_get__oidc_jwt_hdr_dir_a256gcm(r, *compact_encoded_jwt));",
                "// Line 299: ",
                "// Line 300:     rv = TRUE;",
                "// Line 301: ",
                "// Line 302: end:",
                "// Line 303: ",
                "// Line 304:     if (jwe != NULL)",
                "// Line 305:         oidc_jwt_destroy(jwe);",
                "// Line 306:     if (jwk != NULL)",
                "// Line 307:         oidc_jwk_destroy(jwk);",
                "// Line 308: ",
                "// Line 309:     return rv;",
                "// vulnerable line: 310: }",
                "// Line 311: ",
                "// Line 312: apr_byte_t oidc_util_jwt_verify(request_rec *r, const oidc_crypto_passphrase_t *passphrase,",
                "// Line 313:                 const char *compact_encoded_jwt, char **s_payload) {",
                "// Line 314: ",
                "// Line 315:     apr_byte_t rv = FALSE;",
                "// Line 316:     oidc_jose_error_t err;",
                "// Line 317:     oidc_jwk_t *jwk = NULL;",
                "// Line 318:     oidc_jwt_t *jwt = NULL;",
                "// Line 319:     char *payload = NULL;",
                "// Line 320:     int payload_len = 0;",
                "// Line 326:     char *kid = NULL;",
                "// Line 327: ",
                "// Line 328:     if (oidc_util_jwt_internal_strip_header(r))",
                "// Line 329:         compact_encoded_jwt =",
                "// Line 330:             apr_pstrcat(r->pool, oidc_util_get__oidc_jwt_hdr_dir_a256gcm(r, NULL), compact_encoded_jwt, NULL);",
                "// Line 331: ",
                "// Line 332:     oidc_proto_peek_jwt_header(r, compact_encoded_jwt, &alg, &enc, &kid);",
                "// Line 333:     if ((_oidc_strcmp(alg, CJOSE_HDR_ALG_DIR) != 0) || (_oidc_strcmp(enc, CJOSE_HDR_ENC_A256GCM) != 0)) {",
                "// Line 334:         oidc_error(r, \"corrupted JWE header, alg=\"%s\" enc=\"%s\"\", alg, enc);",
                "// Line 335:         goto end;",
                "// vulnerable line: 336: }",
                "// Line 337: ",
                "// Line 338:     keys = apr_hash_make(r->pool);",
                "// Line 339: ",
                "// Line 340:     if ((passphrase->secret2 != NULL) && (kid == NULL)) {",
                "// Line 341:         if (oidc_util_create_symmetric_key(r, passphrase->secret2, 0, OIDC_JOSE_ALG_SHA256, FALSE, &jwk) ==",
                "// Line 342:             FALSE)",
                "// Line 343:             goto end;",
                "// vulnerable line: 344: } else {",
                "// Line 345:         if (oidc_util_create_symmetric_key(r, passphrase->secret1, 0, OIDC_JOSE_ALG_SHA256, FALSE, &jwk) ==",
                "// Line 346:             FALSE)",
                "// Line 347:             goto end;",
                "// vulnerable line: 348: }",
                "// Line 349:     apr_hash_set(keys, \"1\", APR_HASH_KEY_STRING, jwk);",
                "// Line 350: ",
                "// Line 351:     if (oidc_jwe_decrypt(r->pool, compact_encoded_jwt, keys, &plaintext, &plaintext_len, &err, FALSE) == FALSE) {",
                "// Line 352:         oidc_error(r, \"decrypting JWE failed: %s\", oidc_jose_e2s(r->pool, err));",
                "// Line 353:         goto end;",
                "// vulnerable line: 354: }",
                "// Line 355: ",
                "// Line 356:     if (oidc_util_jwt_internal_compress(r)) {",
                "// Line 357: ",
                "// Line 358:         if (oidc_jose_uncompress(r->pool, (char *)plaintext, plaintext_len, &payload, &payload_len, &err) ==",
                "// Line 359:             FALSE) {",
                "// Line 360:             oidc_error(r, \"oidc_jose_uncompress failed: %s\", oidc_jose_e2s(r->pool, err));",
                "// Line 361:             goto end;",
                "// vulnerable line: 362: }",
                "// Line 363: ",
                "// vulnerable line: 364: } else {",
                "// Line 365: ",
                "// Line 366:         payload = plaintext;",
                "// Line 367:         payload_len = plaintext_len;",
                "// vulnerable line: 368: }",
                "// Line 369: ",
                "// Line 370:     *s_payload = apr_pstrndup(r->pool, payload, payload_len);",
                "// Line 371: ",
                "// Line 372:     rv = TRUE;",
                "// Line 373: ",
                "// Line 374: end:",
                "// Line 375: ",
                "// Line 376:     if (jwk != NULL)",
                "// Line 377:         oidc_jwk_destroy(jwk);",
                "// Line 378:     if (jwt != NULL)",
                "// Line 379:         oidc_jwt_destroy(jwt);",
                "// Line 380: ",
                "// Line 381:     return rv;",
                "// vulnerable line: 382: }",
                "// Line 383: ",
                "// Line 384: /*",
                "// Line 385:  * convert a character to an ENVIRONMENT-variable-safe variant",
                "// Line 386:  */",
                "// Line 387: int oidc_char_to_env(int c) {",
                "// Line 388:     return apr_isalnum(c) ? apr_toupper(c) : '_';",
                "// vulnerable line: 389: }",
                "// Line 390: ",
                "// Line 391: /*",
                "// Line 392:  * compare two strings based on how they would be converted to an",
                "// Line 393:  * environment variable, as per oidc_char_to_env. If len is specified",
                "// Line 394:  * as less than zero, then the full strings will be compared. Returns",
                "// Line 395:  * less than, equal to, or greater than zero based on whether the",
                "// Line 396:  * first argument's conversion to an environment variable is less",
                "// Line 397:  * than, equal to, or greater than the second.",
                "// Line 398:  */",
                "// Line 399: int oidc_strnenvcmp(const char *a, const char *b, int len) {",
                "// Line 400:     int d = 0;",
                "// vulnerable line: 401: int i = 0;",
                "// Line 402:     while (1) {",
                "// Line 403:         /* If len < 0 then we don't stop based on length */",
                "// Line 404:         if (len >= 0 && i >= len)",
                "// Line 405:             return 0;",
                "// Line 406: ",
                "// Line 407:         /* If we're at the end of both strings, they're equal */",
                "// Line 408:         if (!*a && !*b)",
                "// Line 409:             return 0;",
                "// Line 410: ",
                "// Line 411:         /* If the second string is shorter, pick it: */",
                "// Line 418: ",
                "// Line 419:         /* Normalize the characters as for conversion to an",
                "// Line 420:          * environment variable. */",
                "// Line 421:         d = oidc_char_to_env(*a) - oidc_char_to_env(*b);",
                "// Line 422:         if (d)",
                "// Line 423:             return d;",
                "// Line 424: ",
                "// Line 425:         a++;",
                "// Line 426:         b++;",
                "// Line 427:         i++;",
                "// vulnerable line: 428: }",
                "// vulnerable line: 429: }",
                "// Line 430: ",
                "// Line 431: /*",
                "// Line 432:  * escape a string",
                "// Line 433:  */",
                "// Line 434: char *oidc_util_escape_string(const request_rec *r, const char *str) {",
                "// Line 435:     CURL *curl = NULL;",
                "// Line 436:     if (str == NULL)",
                "// Line 437:         return \"\";",
                "// Line 438:     curl = curl_easy_init();",
                "// Line 439:     if (curl == NULL) {",
                "// Line 440:         oidc_error(r, \"curl_easy_init() error\");",
                "// Line 441:         return \"\";",
                "// vulnerable line: 442: }",
                "// Line 443:     char *result = curl_easy_escape(curl, str, 0);",
                "// Line 444:     if (result == NULL) {",
                "// Line 445:         oidc_error(r, \"curl_easy_escape() error\");",
                "// Line 446:         return \"\";",
                "// vulnerable line: 447: }",
                "// Line 448:     char *rv = apr_pstrdup(r->pool, result);",
                "// Line 449:     curl_free(result);",
                "// Line 450:     curl_easy_cleanup(curl);",
                "// Line 451:     return rv;",
                "// vulnerable line: 452: }",
                "// Line 453: ",
                "// Line 454: /*",
                "// Line 455:  * escape a string",
                "// Line 456:  */",
                "// Line 457: char *oidc_util_unescape_string(const request_rec *r, const char *str) {",
                "// Line 458:     CURL *curl = NULL;",
                "// Line 459: ",
                "// Line 460:     if (str == NULL)",
                "// Line 461:         return \"\";",
                "// Line 462: ",
                "// Line 463:     curl = curl_easy_init();",
                "// Line 464:     if (curl == NULL) {",
                "// Line 465:         oidc_error(r, \"curl_easy_init() error\");",
                "// Line 466:         return \"\";",
                "// vulnerable line: 467: }",
                "// Line 468:     int counter = 0;",
                "// Line 469:     char *replaced = (char *)str;",
                "// Line 470:     while (str[counter] != '\u0000') {",
                "// Line 471:         if (str[counter] == '+') {",
                "// Line 472:             replaced[counter] = ' ';",
                "// vulnerable line: 473: }",
                "// Line 474:         counter++;",
                "// vulnerable line: 475: }",
                "// Line 476:     char *result = curl_easy_unescape(curl, replaced, 0, 0);",
                "// Line 477:     if (result == NULL) {",
                "// Line 478:         oidc_error(r, \"curl_easy_unescape() error\");",
                "// Line 479:         return \"\";",
                "// vulnerable line: 480: }",
                "// Line 481:     char *rv = apr_pstrdup(r->pool, result);",
                "// Line 482:     curl_free(result);",
                "// Line 483:     curl_easy_cleanup(curl);",
                "// Line 484:     // oidc_debug(r, \"input=\"%s\", output=\"%s\"\", str, rv);",
                "// Line 485:     return rv;",
                "// vulnerable line: 486: }",
                "// Line 487: ",
                "// Line 488: /*",
                "// Line 489:  * HTML escape a string",
                "// Line 490:  */",
                "// Line 491: char *oidc_util_html_escape(apr_pool_t *pool, const char *s) {",
                "// Line 492:     // TODO: this has performance/memory issues for large chunks of HTML",
                "// Line 493:     const char chars[6] = {'&', ''', '\"', '>', '<', '\u0000'};",
                "// Line 494:     const char *const replace[] = {",
                "// Line 495:         \"&amp;\", \"&apos;\", \"&quot;\", \"&gt;\", \"&lt;\",",
                "// Line 496:     };",
                "// Line 503:     unsigned int len = _oidc_strlen(ptr);",
                "// Line 504:     char *r = apr_pcalloc(pool, _oidc_strlen(s) * 6);",
                "// Line 505:     for (i = 0; i < _oidc_strlen(s); i++) {",
                "// Line 506:         for (n = 0; n < len; n++) {",
                "// Line 507:             if (s[i] == chars[n]) {",
                "// Line 508:                 m = (unsigned int)_oidc_strlen(replace[n]);",
                "// Line 509:                 for (k = 0; k < m; k++)",
                "// Line 510:                     r[j + k] = replace[n][k];",
                "// Line 511:                 j += m;",
                "// Line 512:                 break;",
                "// vulnerable line: 513: }",
                "// vulnerable line: 514: }",
                "// Line 515:         if (n == len) {",
                "// Line 516:             r[j] = s[i];",
                "// Line 517:             j++;",
                "// vulnerable line: 518: }",
                "// vulnerable line: 519: }",
                "// Line 520:     r[j] = '\u0000';",
                "// Line 521:     return apr_pstrdup(pool, r);",
                "// vulnerable line: 522: }",
                "// Line 523: ",
                "// Line 524: /*",
                "// Line 525:  * JavaScript escape a string",
                "// Line 526:  */",
                "// Line 527: char *oidc_util_javascript_escape(apr_pool_t *pool, const char *s) {",
                "// Line 528:     const char *cp = NULL;",
                "// Line 529:     char *output = NULL;",
                "// Line 530:     size_t outputlen = 0;",
                "// vulnerable line: 531: int i = 0;",
                "// Line 532: ",
                "// Line 533:     if (s == NULL) {",
                "// Line 534:         return NULL;",
                "// vulnerable line: 535: }",
                "// Line 536: ",
                "// Line 537:     outputlen = 0;",
                "// Line 538:     for (cp = s; *cp; cp++) {",
                "// Line 539:         switch (*cp) {",
                "// Line 540:         case ''':",
                "// Line 541:         case '\"':",
                "// Line 542:         case '':",
                "// Line 543:         case '/':",
                "// Line 544:         case 0x0D:",
                "// Line 545:         case 0x0A:",
                "// Line 546:             outputlen += 2;",
                "// Line 547:             break;",
                "// Line 548:         case '<':",
                "// Line 549:         case '>':",
                "// Line 550:             outputlen += 4;",
                "// Line 551:             break;",
                "// Line 552:         default:",
                "// Line 553:             outputlen += 1;",
                "// Line 554:             break;",
                "// vulnerable line: 555: }",
                "// vulnerable line: 556: }",
                "// Line 557: ",
                "// Line 558:     i = 0;",
                "// Line 559:     output = apr_pcalloc(pool, outputlen + 1);",
                "// Line 560:     for (cp = s; *cp; cp++) {",
                "// Line 561:         switch (*cp) {",
                "// Line 562:         case ''':",
                "// Line 563:             if (i <= outputlen - 2)",
                "// Line 564:                 (void)_oidc_strcpy(&output[i], \"'\");",
                "// Line 565:             i += 2;",
                "// Line 566:             break;",
                "// Line 599:         case '>':",
                "// Line 600:             if (i <= outputlen - 4)",
                "// Line 601:                 (void)_oidc_strcpy(&output[i], \">\");",
                "// Line 602:             i += 4;",
                "// Line 603:             break;",
                "// Line 604:         default:",
                "// Line 605:             if (i <= outputlen - 1)",
                "// Line 606:                 output[i] = *cp;",
                "// Line 607:             i += 1;",
                "// Line 608:             break;",
                "// vulnerable line: 609: }",
                "// vulnerable line: 610: }",
                "// Line 611:     output[i] = '\u0000';",
                "// Line 612:     return output;",
                "// vulnerable line: 613: }",
                "// Line 614: ",
                "// Line 615: const char *oidc_util_strcasestr(const char *s1, const char *s2) {",
                "// Line 616:     const char *s = s1;",
                "// Line 617:     const char *p = s2;",
                "// Line 618:     if ((s == NULL) || (p == NULL))",
                "// Line 619:         return NULL;",
                "// Line 620:     do {",
                "// Line 621:         if (!*p)",
                "// Line 622:             return s1;",
                "// Line 623:         if ((*p == *s) || (tolower(*p) == tolower(*s))) {",
                "// Line 624:             ++p;",
                "// Line 625:             ++s;",
                "// vulnerable line: 626: } else {",
                "// Line 627:             p = s2;",
                "// Line 628:             if (!*s)",
                "// Line 629:                 return NULL;",
                "// Line 630:             s = ++s1;",
                "// vulnerable line: 631: }",
                "// Line 632:     } while (1);",
                "// vulnerable line: 633: }",
                "// Line 634: ",
                "// Line 635: static const char *oidc_util_hdr_forwarded_get(const request_rec *r, const char *elem) {",
                "// Line 636:     const char *value = NULL;",
                "// Line 637:     char *ptr = NULL;",
                "// Line 638:     const char *item = apr_psprintf(r->pool, \"%s=\", elem);",
                "// Line 639:     value = oidc_util_hdr_in_forwarded_get(r);",
                "// Line 640:     value = oidc_util_strcasestr(value, item);",
                "// Line 641:     if (value) {",
                "// Line 642:         value += _oidc_strlen(item);",
                "// Line 643:         ptr = strstr(value, \";\");",
                "// Line 644:         if (ptr)",
                "// Line 645:             *ptr = '\u0000';",
                "// Line 646:         ptr = strstr(value, \" \");",
                "// Line 647:         if (ptr)",
                "// Line 648:             *ptr = '\u0000';",
                "// vulnerable line: 649: }",
                "// Line 650:     return value ? apr_pstrdup(r->pool, value) : NULL;",
                "// vulnerable line: 651: }",
                "// Line 652: ",
                "// Line 653: /*",
                "// Line 654:  * get the URL scheme that is currently being accessed",
                "// Line 655:  */",
                "// Line 656: static const char *oidc_get_current_url_scheme(const request_rec *r, const apr_byte_t x_forwarded_headers) {",
                "// Line 657:     /* first see if there's a proxy/load-balancer in front of us */",
                "// Line 658:     const char *scheme_str = NULL;",
                "// Line 659: ",
                "// Line 660:     if (x_forwarded_headers & OIDC_HDR_FORWARDED)",
                "// Line 661:         scheme_str = oidc_util_hdr_forwarded_get(r, \"proto\");",
                "// Line 662:     else if (x_forwarded_headers & OIDC_HDR_X_FORWARDED_PROTO)",
                "// Line 663:         scheme_str = oidc_util_hdr_in_x_forwarded_proto_get(r);",
                "// Line 664: ",
                "// Line 665:     /* if not we'll determine the scheme used to connect to this server */",
                "// Line 666:     if (scheme_str == NULL) {",
                "// Line 667: #ifdef APACHE2_0",
                "// Line 668:         scheme_str = (char *)ap_http_method(r);",
                "// Line 669: #else",
                "// Line 670:         scheme_str = ap_http_scheme(r);",
                "// Line 671: #endif",
                "// vulnerable line: 672: }",
                "// Line 673:     if ((scheme_str == NULL) ||",
                "// Line 674:         ((_oidc_strcmp(scheme_str, \"http\") != 0) && (_oidc_strcmp(scheme_str, \"https\") != 0))) {",
                "// Line 675:         oidc_warn(r,",
                "// Line 676:               \"detected HTTP scheme \"%s\" is not \"http\" nor \"https\"; perhaps your reverse proxy \"",
                "// Line 677:               \"passes a wrongly configured \"%s\" header: falling back to default \"https\"\",",
                "// Line 678:               scheme_str, OIDC_HTTP_HDR_X_FORWARDED_PROTO);",
                "// Line 679:         scheme_str = \"https\";",
                "// vulnerable line: 680: }",
                "// Line 681:     return scheme_str;",
                "// vulnerable line: 682: }",
                "// Line 683: ",
                "// Line 684: /*",
                "// Line 685:  * get the Port part that is currently being accessed",
                "// Line 686:  */",
                "// Line 687: static const char *oidc_get_port_from_host(const char *host_hdr) {",
                "// Line 688:     char *p = NULL;",
                "// Line 689:     char *i = NULL;",
                "// Line 690: ",
                "// Line 691:     if (host_hdr) {",
                "// Line 692:         if (host_hdr[0] == '[') {",
                "// Line 693:             i = strchr(host_hdr, ']');",
                "// Line 694:             p = strchr(i, OIDC_CHAR_COLON);",
                "// vulnerable line: 695: } else {",
                "// Line 696:             p = strchr(host_hdr, OIDC_CHAR_COLON);",
                "// vulnerable line: 697: }",
                "// vulnerable line: 698: }",
                "// Line 699:     if (p)",
                "// Line 700:         return p;",
                "// Line 701:     else",
                "// Line 702:         return NULL;",
                "// vulnerable line: 703: }",
                "// Line 704: ",
                "// Line 705: /*",
                "// Line 706:  * get the URL port that is currently being accessed",
                "// Line 707:  */",
                "// Line 708: static const char *oidc_get_current_url_port(const request_rec *r, const char *scheme_str,",
                "// Line 709:                          const apr_byte_t x_forwarded_headers) {",
                "// Line 710: ",
                "// Line 711:     const char *host_hdr = NULL;",
                "// Line 712:     const char *port_str = NULL;",
                "// Line 713: ",
                "// Line 730:     if (x_forwarded_headers & OIDC_HDR_FORWARDED)",
                "// Line 731:         host_hdr = oidc_util_hdr_forwarded_get(r, \"host\");",
                "// Line 732:     else if (x_forwarded_headers & OIDC_HDR_X_FORWARDED_HOST)",
                "// Line 733:         host_hdr = oidc_util_hdr_in_x_forwarded_host_get(r);",
                "// Line 734: ",
                "// Line 735:     if (host_hdr) {",
                "// Line 736:         port_str = oidc_get_port_from_host(host_hdr);",
                "// Line 737:         if (port_str)",
                "// Line 738:             port_str++;",
                "// Line 739:         return port_str;",
                "// vulnerable line: 740: }",
                "// Line 741: ",
                "// Line 742:     /*",
                "// Line 743:      * see if we can get the port from the \"Host\" header; if not",
                "// Line 744:      * we'll determine the port locally",
                "// Line 745:      */",
                "// Line 746:     host_hdr = oidc_util_hdr_in_host_get(r);",
                "// Line 747:     if (host_hdr) {",
                "// Line 748:         port_str = oidc_get_port_from_host(host_hdr);",
                "// Line 749:         if (port_str) {",
                "// Line 750:             port_str++;",
                "// Line 751:             return port_str;",
                "// vulnerable line: 752: }",
                "// vulnerable line: 753: }",
                "// Line 754: ",
                "// Line 755:     /*",
                "// Line 756:      * if X-Forwarded-Proto assume the default port otherwise the",
                "// Line 757:      * port should have been set in the X-Forwarded-Port header",
                "// Line 758:      */",
                "// Line 759:     if ((x_forwarded_headers & OIDC_HDR_X_FORWARDED_PROTO) && (oidc_util_hdr_in_x_forwarded_proto_get(r)))",
                "// Line 760:         return NULL;",
                "// Line 761: ",
                "// Line 762:     /*",
                "// Line 763:      * do the same for the Forwarded: proto= header",
                "// Line 770:      * determine the port locally and don't print it when it's the default for the protocol",
                "// Line 771:      */",
                "// Line 772:     const apr_port_t port = r->connection->local_addr->port;",
                "// Line 773:     if ((_oidc_strcmp(scheme_str, \"https\") == 0) && port == 443)",
                "// Line 774:         return NULL;",
                "// Line 775:     else if ((_oidc_strcmp(scheme_str, \"http\") == 0) && port == 80)",
                "// Line 776:         return NULL;",
                "// Line 777: ",
                "// Line 778:     port_str = apr_psprintf(r->pool, \"%u\", port);",
                "// Line 779:     return port_str;",
                "// vulnerable line: 780: }",
                "// Line 781: ",
                "// Line 782: /*",
                "// Line 783:  * get the hostname part of the URL that is currently being accessed",
                "// Line 784:  */",
                "// Line 785: const char *oidc_get_current_url_host(request_rec *r, const apr_byte_t x_forwarded_headers) {",
                "// Line 786:     const char *host_str = NULL;",
                "// Line 787:     char *p = NULL;",
                "// Line 788:     char *i = NULL;",
                "// Line 789: ",
                "// Line 790:     if (x_forwarded_headers & OIDC_HDR_FORWARDED)",
                "// Line 793:         host_str = oidc_util_hdr_in_x_forwarded_host_get(r);",
                "// Line 794: ",
                "// Line 795:     if (host_str == NULL)",
                "// Line 796:         host_str = oidc_util_hdr_in_host_get(r);",
                "// Line 797:     if (host_str) {",
                "// Line 798:         host_str = apr_pstrdup(r->pool, host_str);",
                "// Line 799: ",
                "// Line 800:         if (host_str[0] == '[') {",
                "// Line 801:             i = strchr(host_str, ']');",
                "// Line 802:             p = strchr(i, OIDC_CHAR_COLON);",
                "// vulnerable line: 803: } else {",
                "// Line 804:             p = strchr(host_str, OIDC_CHAR_COLON);",
                "// vulnerable line: 805: }",
                "// Line 806: ",
                "// Line 807:         if (p != NULL)",
                "// Line 808:             *p = '\u0000';",
                "// vulnerable line: 809: } else {",
                "// Line 810:         /* no Host header, HTTP 1.0 */",
                "// Line 811:         host_str = ap_get_server_name(r);",
                "// vulnerable line: 812: }",
                "// Line 813:     return host_str;",
                "// vulnerable line: 814: }",
                "// Line 815: ",
                "// Line 816: /*",
                "// Line 817:  * get the base part of the current URL (scheme + host (+ port))",
                "// Line 818:  */",
                "// Line 819: static const char *oidc_get_current_url_base(request_rec *r, const apr_byte_t x_forwarded_headers) {",
                "// Line 820: ",
                "// Line 821:     const char *scheme_str = NULL;",
                "// Line 822:     const char *host_str = NULL;",
                "// Line 823:     const char *port_str = NULL;",
                "// Line 824: ",
                "// Line 825:     oidc_config_check_x_forwarded(r, x_forwarded_headers);",
                "// Line 826: ",
                "// Line 827:     scheme_str = oidc_get_current_url_scheme(r, x_forwarded_headers);",
                "// Line 828:     host_str = oidc_get_current_url_host(r, x_forwarded_headers);",
                "// Line 829:     port_str = oidc_get_current_url_port(r, scheme_str, x_forwarded_headers);",
                "// Line 830:     port_str = port_str ? apr_psprintf(r->pool, \":%s\", port_str) : \"\";",
                "// Line 831: ",
                "// Line 832:     char *url = apr_pstrcat(r->pool, scheme_str, \"://\", host_str, port_str, NULL);",
                "// Line 833: ",
                "// Line 834:     return url;",
                "// vulnerable line: 835: }",
                "// Line 836: ",
                "// Line 837: /*",
                "// Line 838:  * get the URL that is currently being accessed",
                "// Line 839:  */",
                "// Line 840: char *oidc_get_current_url(request_rec *r, const apr_byte_t x_forwarded_headers) {",
                "// Line 841:     char *url = NULL;",
                "// Line 842:     char *path = NULL;",
                "// Line 843:     apr_uri_t uri;",
                "// Line 844: ",
                "// Line 845:     path = r->uri;",
                "// Line 846: ",
                "// Line 847:     /* check if we're dealing with a forward proxying secenario i.e. a non-relative URL */",
                "// Line 848:     if ((path) && (path[0] != '/')) {",
                "// Line 849:         _oidc_memset(&uri, 0, sizeof(apr_uri_t));",
                "// Line 850:         if (apr_uri_parse(r->pool, r->uri, &uri) == APR_SUCCESS)",
                "// Line 851:             path = apr_pstrcat(r->pool, uri.path, (r->args != NULL && *r->args != '\u0000' ? \"?\" : \"\"), r->args,",
                "// Line 852:                        NULL);",
                "// Line 853:         else",
                "// Line 854:             oidc_warn(r, \"apr_uri_parse failed on non-relative URL: %s\", r->uri);",
                "// vulnerable line: 855: } else {",
                "// Line 856:         /* make sure we retain URL-encoded characters original URL that we send the user back to */",
                "// Line 857:         path = r->unparsed_uri;",
                "// vulnerable line: 858: }",
                "// Line 859: ",
                "// Line 860:     url = apr_pstrcat(r->pool, oidc_get_current_url_base(r, x_forwarded_headers), path, NULL);",
                "// Line 861: ",
                "// Line 862:     oidc_debug(r, \"current URL '%s'\", url);",
                "// Line 863: ",
                "// Line 864:     return url;",
                "// vulnerable line: 865: }",
                "// Line 866: ",
                "// Line 867: /*",
                "// Line 868:  * infer a full absolute URL from the (optional) relative one",
                "// Line 869:  */",
                "// Line 870: const char *oidc_get_absolute_url(request_rec *r, oidc_cfg *cfg, const char *url) {",
                "// Line 871:     if ((url != NULL) && (url[0] == OIDC_CHAR_FORWARD_SLASH)) {",
                "// Line 872:         url = apr_pstrcat(r->pool, oidc_get_current_url_base(r, cfg->x_forwarded_headers), url, NULL);",
                "// Line 873:         oidc_debug(r, \"determined absolute url: %s\", url);",
                "// vulnerable line: 874: }",
                "// Line 875:     return url;",
                "// vulnerable line: 876: }",
                "// Line 877: ",
                "// Line 878: /*",
                "// Line 879:  * determine absolute Redirect URI",
                "// Line 880:  */",
                "// Line 881: const char *oidc_get_redirect_uri(request_rec *r, oidc_cfg *cfg) {",
                "// Line 882:     return oidc_get_absolute_url(r, cfg, cfg->redirect_uri);",
                "// vulnerable line: 883: }",
                "// Line 884: ",
                "// Line 885: /*",
                "// Line 886:  * determine absolute redirect uri that is issuer specific",
                "// Line 887:  */",
                "// Line 888: const char *oidc_get_redirect_uri_iss(request_rec *r, oidc_cfg *cfg, oidc_provider_t *provider) {",
                "// Line 889:     const char *redirect_uri = oidc_get_redirect_uri(r, cfg);",
                "// Line 890:     if (redirect_uri == NULL) {",
                "// Line 891:         oidc_error(r, \"redirect URI is NULL\");",
                "// Line 892:         return NULL;",
                "// vulnerable line: 893: }",
                "// Line 894:     if (provider->issuer_specific_redirect_uri != 0) {",
                "// Line 895:         redirect_uri =",
                "// Line 896:             apr_psprintf(r->pool, \"%s%s%s=%s\", redirect_uri,",
                "// Line 897:                  strchr(redirect_uri, OIDC_CHAR_QUERY) != NULL ? OIDC_STR_AMP : OIDC_STR_QUERY,",
                "// Line 898:                  OIDC_PROTO_ISS, oidc_util_escape_string(r, provider->issuer));",
                "// Line 899:         oidc_debug(r, \"determined issuer specific redirect uri: %s\", redirect_uri);",
                "// vulnerable line: 900: }",
                "// Line 901:     return redirect_uri;",
                "// vulnerable line: 902: }",
                "// Line 903: ",
                "// Line 904: /* buffer to hold HTTP call responses */",
                "// Line 905: typedef struct oidc_curl_buffer {",
                "// Line 906:     request_rec *r;",
                "// Line 907:     char *memory;",
                "// Line 908:     size_t size;",
                "// Line 909: } oidc_curl_buffer;",
                "// Line 910: ",
                "// Line 911: /* maximum acceptable size of HTTP responses: 10 Mb */",
                "// Line 912: #define OIDC_CURL_MAX_RESPONSE_SIZE 1024 * 1024 * 10",
                "// Line 918:     size_t realsize = size * nmemb;",
                "// Line 919:     oidc_curl_buffer *mem = (oidc_curl_buffer *)userp;",
                "// Line 920: ",
                "// Line 921:     /* check if we don't run over the maximum buffer/memory size for HTTP responses */",
                "// Line 922:     if (mem->size + realsize > OIDC_CURL_MAX_RESPONSE_SIZE) {",
                "// Line 923:         oidc_error(",
                "// Line 924:             mem->r,",
                "// Line 925:             \"HTTP response larger than maximum allowed size: current size=%ld, additional size=%ld, max=%d\",",
                "// Line 926:             (long)mem->size, (long)realsize, OIDC_CURL_MAX_RESPONSE_SIZE);",
                "// Line 927:         return 0;",
                "// vulnerable line: 928: }",
                "// Line 929: ",
                "// Line 930:     /* allocate the new buffer for the current + new response bytes */",
                "// Line 931:     char *newptr = apr_palloc(mem->r->pool, mem->size + realsize + 1);",
                "// Line 932:     if (newptr == NULL) {",
                "// Line 933:         oidc_error(mem->r, \"memory allocation for new buffer of %ld bytes failed\",",
                "// Line 934:                (long)(mem->size + realsize + 1));",
                "// Line 935:         return 0;",
                "// vulnerable line: 936: }",
                "// Line 937: ",
                "// Line 938:     /* copy over the data from current memory plus the cURL buffer */",
                "// Line 939:     _oidc_memcpy(newptr, mem->memory, mem->size);",
                "// Line 940:     _oidc_memcpy(&(newptr[mem->size]), contents, realsize);",
                "// Line 941:     mem->size += realsize;",
                "// Line 942:     mem->memory = newptr;",
                "// Line 943:     mem->memory[mem->size] = 0;",
                "// Line 944: ",
                "// Line 945:     return realsize;",
                "// vulnerable line: 946: }",
                "// Line 947: ",
                "// Line 948: /* context structure for encoding parameters */",
                "// Line 949: typedef struct oidc_http_encode_t {",
                "// Line 950:     request_rec *r;",
                "// Line 951:     char *encoded_params;",
                "// Line 952: } oidc_http_encode_t;",
                "// Line 953: ",
                "// Line 954: /*",
                "// Line 955:  * add a url-form-encoded name/value pair",
                "// Line 956:  */",
                "// Line 958:     oidc_http_encode_t *ctx = (oidc_http_encode_t *)rec;",
                "// Line 959:     oidc_debug(ctx->r, \"processing: %s=%s\", key,",
                "// Line 960:            (_oidc_strncmp(key, OIDC_PROTO_CLIENT_SECRET, _oidc_strlen(OIDC_PROTO_CLIENT_SECRET)) == 0)",
                "// Line 961:                ? \"***\"",
                "// Line 962:                : (value ? value : \"\"));",
                "// Line 963:     const char *sep = ctx->encoded_params ? OIDC_STR_AMP : \"\";",
                "// Line 964:     ctx->encoded_params =",
                "// Line 965:         apr_psprintf(ctx->r->pool, \"%s%s%s=%s\", ctx->encoded_params ? ctx->encoded_params : \"\", sep,",
                "// Line 966:              oidc_util_escape_string(ctx->r, key), oidc_util_escape_string(ctx->r, value));",
                "// Line 967:     return 1;",
                "// vulnerable line: 968: }",
                "// Line 969: ",
                "// Line 970: /*",
                "// Line 971:  * construct a URL with query parameters",
                "// Line 972:  */",
                "// Line 973: char *oidc_util_http_query_encoded_url(request_rec *r, const char *url, const apr_table_t *params) {",
                "// Line 974:     char *result = NULL;",
                "// Line 975:     if (url == NULL) {",
                "// Line 976:         oidc_error(r, \"URL is NULL\");",
                "// Line 977:         return NULL;",
                "// vulnerable line: 978: }",
                "// Line 979:     if ((params != NULL) && (apr_table_elts(params)->nelts > 0)) {",
                "// Line 980:         oidc_http_encode_t data = {r, NULL};",
                "// Line 981:         apr_table_do(oidc_util_http_add_form_url_encoded_param, &data, params, NULL);",
                "// Line 982:         const char *sep = NULL;",
                "// Line 983:         if (data.encoded_params)",
                "// Line 984:             sep = strchr(url, OIDC_CHAR_QUERY) != NULL ? OIDC_STR_AMP : OIDC_STR_QUERY;",
                "// Line 985:         result = apr_psprintf(r->pool, \"%s%s%s\", url, sep ? sep : \"\",",
                "// Line 986:                       data.encoded_params ? data.encoded_params : \"\");",
                "// vulnerable line: 987: } else {",
                "// Line 988:         result = apr_pstrdup(r->pool, url);",
                "// vulnerable line: 989: }",
                "// Line 990:     oidc_debug(r, \"url=%s\", result);",
                "// Line 991:     return result;",
                "// vulnerable line: 992: }",
                "// Line 993: ",
                "// Line 994: /*",
                "// Line 995:  * construct form-encoded POST data",
                "// Line 996:  */",
                "// Line 997: char *oidc_util_http_form_encoded_data(request_rec *r, const apr_table_t *params) {",
                "// Line 998:     char *data = NULL;",
                "// Line 999:     if ((params != NULL) && (apr_table_elts(params)->nelts > 0)) {",
                "// Line 1000:         oidc_http_encode_t encode_data = {r, NULL};",
                "// Line 1001:         apr_table_do(oidc_util_http_add_form_url_encoded_param, &encode_data, params, NULL);",
                "// Line 1002:         data = encode_data.encoded_params;",
                "// vulnerable line: 1003: }",
                "// Line 1004:     oidc_debug(r, \"data=%s\", data);",
                "// Line 1005:     return data;",
                "// vulnerable line: 1006: }",
                "// Line 1007: ",
                "// Line 1008: /*",
                "// Line 1009:  * set libcurl SSL options",
                "// Line 1010:  */",
                "// Line 1011: ",
                "// Line 1012: #define OIDC_CURLOPT_SSL_OPTIONS \"CURLOPT_SSL_OPTIONS\"",
                "// Line 1013: ",
                "// Line 1014: #define OIDC_UTIL_SET_CURL_OPTION(r, curl, env_var_value, option, key, val)                                                if (strstr(env_var_value, option) != NULL) {                                                                           oidc_debug(r, \"curl_easy_setopt (%d) %s (%d)\", key, option, val);                                              curl_easy_setopt(curl, key, val);                                                                          }",
                "// Line 1015: ",
                "// Line 1016: static void oidc_util_set_curl_ssl_options(request_rec *r, CURL *curl) {",
                "// Line 1055: #if LIBCURL_VERSION_NUM >= 0x073600",
                "// Line 1056:     OIDC_UTIL_SET_CURL_OPTION(r, curl, env_var_value, \"CURL_SSLVERSION_MAX_TLSv1_0\", CURLOPT_SSLVERSION,",
                "// Line 1057:                   CURL_SSLVERSION_MAX_TLSv1_0)",
                "// Line 1058:     OIDC_UTIL_SET_CURL_OPTION(r, curl, env_var_value, \"CURL_SSLVERSION_MAX_TLSv1_1\", CURLOPT_SSLVERSION,",
                "// Line 1059:                   CURL_SSLVERSION_MAX_TLSv1_1)",
                "// Line 1060:     OIDC_UTIL_SET_CURL_OPTION(r, curl, env_var_value, \"CURL_SSLVERSION_MAX_TLSv1_2\", CURLOPT_SSLVERSION,",
                "// Line 1061:                   CURL_SSLVERSION_MAX_TLSv1_2)",
                "// Line 1062:     OIDC_UTIL_SET_CURL_OPTION(r, curl, env_var_value, \"CURL_SSLVERSION_MAX_TLSv1_3\", CURLOPT_SSLVERSION,",
                "// Line 1063:                   CURL_SSLVERSION_MAX_TLSv1_3)",
                "// Line 1064: #endif",
                "// vulnerable line: 1065: }",
                "// Line 1066: ",
                "// Line 1067: char *oidc_util_openssl_version(apr_pool_t *pool) {",
                "// Line 1068:     char *s_version = NULL;",
                "// Line 1069: #ifdef OPENSSL_VERSION_STR",
                "// Line 1070:     s_version = apr_psprintf(pool, \"openssl-%s\", OPENSSL_VERSION_STR);",
                "// Line 1071: #else",
                "// Line 1072:     s_version = OPENSSL_VERSION_TEXT;",
                "// Line 1073: #endif",
                "// Line 1074:     return s_version;",
                "// vulnerable line: 1075: }",
                "// Line 1076: ",
                "// Line 1077: #define OIDC_USER_AGENT_ENV_VAR \"OIDC_USER_AGENT\"",
                "// Line 1078: ",
                "// Line 1079: static const char *oidc_util_user_agent(request_rec *r) {",
                "// Line 1080:     const char *s_useragent = apr_table_get(r->subprocess_env, OIDC_USER_AGENT_ENV_VAR);",
                "// Line 1081:     if (s_useragent == NULL) {",
                "// Line 1082:         s_useragent = apr_psprintf(r->pool, \"[%s:%u:%lu] %s\", r->server->server_hostname,",
                "// Line 1083:                        r->connection->local_addr->port, (unsigned long)getpid(), NAMEVERSION);",
                "// Line 1084:         s_useragent = apr_psprintf(r->pool, \"%s libcurl-%s %s\", s_useragent, LIBCURL_VERSION,",
                "// Line 1085:                        oidc_util_openssl_version(r->pool));",
                "// vulnerable line: 1086: }",
                "// Line 1087:     return s_useragent;",
                "// vulnerable line: 1088: }",
                "// Line 1089: ",
                "// Line 1090: /*",
                "// Line 1091:  * execute a HTTP (GET or POST) request",
                "// Line 1092:  */",
                "// Line 1093: static apr_byte_t oidc_util_http_call(request_rec *r, const char *url, const char *data, const char *content_type,",
                "// Line 1094:                       const char *basic_auth, const char *bearer_token, int ssl_validate_server,",
                "// Line 1095:                       char **response, oidc_http_timeout_t *http_timeout,",
                "// Line 1096:                       const oidc_outgoing_proxy_t *outgoing_proxy, apr_array_header_t *pass_cookies,",
                "// Line 1097:                       const char *ssl_cert, const char *ssl_key, const char *ssl_key_pwd) {",
                "// Line 1098: ",
                "// Line 1099:     char curlError[CURL_ERROR_SIZE];",
                "// Line 1100:     oidc_curl_buffer curlBuffer;",
                "// Line 1101:     CURL *curl = NULL;",
                "// Line 1102:     struct curl_slist *h_list = NULL;",
                "// vulnerable line: 1103: int i = 0;",
                "// Line 1104:     CURLcode res = CURLE_OK;",
                "// Line 1105:     long response_code = 0;",
                "// Line 1106:     apr_byte_t rv = FALSE;",
                "// Line 1107:     oidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);",
                "// Line 1108: ",
                "// Line 1109:     /* do some logging about the inputs */",
                "// Line 1110:     oidc_debug(r,",
                "// Line 1111:            \"url=%s, data=%s, content_type=%s, basic_auth=%s, bearer_token=%s, ssl_validate_server=%d, \"",
                "// Line 1112:            \"request_timeout=%d, connect_timeout=%d, retries=%d, retry_interval=%d, outgoing_proxy=%s:%s:%d, \"",
                "// Line 1113:            \"pass_cookies=%pp, ssl_cert=%s, ssl_key=%s, ssl_key_pwd=%s\",",
                "// Line 1114:            url, data, content_type, basic_auth ? \"****\" : \"null\", bearer_token, ssl_validate_server,",
                "// Line 1115:            http_timeout->request_timeout, http_timeout->connect_timeout, http_timeout->retries,",
                "// Line 1116:            (int)http_timeout->retry_interval, outgoing_proxy->host_port,",
                "// Line 1117:            outgoing_proxy->username_password ? \"****\" : \"(null)\", (int)outgoing_proxy->auth_type, pass_cookies,",
                "// Line 1118:            ssl_cert, ssl_key, ssl_key_pwd ? \"****\" : \"(null)\");",
                "// Line 1119: ",
                "// Line 1120:     curl = curl_easy_init();",
                "// Line 1121:     if (curl == NULL) {",
                "// Line 1122:         oidc_error(r, \"curl_easy_init() error\");",
                "// Line 1123:         goto end;",
                "// vulnerable line: 1124: }",
                "// Line 1125: ",
                "// Line 1126:     /* set the error buffer as empty before performing a request */",
                "// Line 1127:     curlError[0] = 0;",
                "// Line 1128: ",
                "// Line 1129:     /* some of these are not really required */",
                "// Line 1130:     curl_easy_setopt(curl, CURLOPT_HEADER, 0L);",
                "// Line 1131:     curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);",
                "// Line 1132:     curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);",
                "// Line 1133:     curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curlError);",
                "// Line 1134:     curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);",
                "// Line 1169:         DWORD buflen;",
                "// Line 1170:         char *ptr = NULL;",
                "// Line 1171:         char *retval = (char *)malloc(sizeof(TCHAR) * (MAX_PATH + 1));",
                "// Line 1172:         retval[0] = '\u0000';",
                "// Line 1173:         buflen = SearchPath(NULL, \"curl-ca-bundle.crt\", NULL, MAX_PATH + 1, retval, &ptr);",
                "// Line 1174:         if (buflen > 0)",
                "// Line 1175:             curl_easy_setopt(curl, CURLOPT_CAINFO, retval);",
                "// Line 1176:         else",
                "// Line 1177:             oidc_warn(r, \"no curl-ca-bundle.crt file found in path\");",
                "// Line 1178:         free(retval);",
                "// vulnerable line: 1179: }",
                "// Line 1180: #endif",
                "// Line 1181: ",
                "// Line 1182:     /* identify this HTTP client */",
                "// Line 1183:     const char *useragent = oidc_util_user_agent(r);",
                "// Line 1184:     if ((useragent != NULL) && (_oidc_strcmp(useragent, \"\") != 0)) {",
                "// Line 1185:         oidc_debug(r, \"set HTTP request header User-Agent to: %s\", useragent);",
                "// Line 1186:         curl_easy_setopt(curl, CURLOPT_USERAGENT, useragent);",
                "// vulnerable line: 1187: }",
                "// Line 1188: ",
                "// Line 1189:     /* set optional outgoing proxy for the local network */",
                "// Line 1190:     if (outgoing_proxy->host_port) {",
                "// Line 1191:         curl_easy_setopt(curl, CURLOPT_PROXY, outgoing_proxy->host_port);",
                "// Line 1192:         if (outgoing_proxy->username_password)",
                "// Line 1193:             curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, outgoing_proxy->username_password);",
                "// Line 1194:         if (outgoing_proxy->auth_type != OIDC_CONFIG_POS_INT_UNSET)",
                "// Line 1195:             curl_easy_setopt(curl, CURLOPT_PROXYAUTH, outgoing_proxy->auth_type);",
                "// vulnerable line: 1196: }",
                "// Line 1197: ",
                "// Line 1198:     /* see if we need to add token in the Bearer Authorization header */",
                "// Line 1199:     if (bearer_token != NULL) {",
                "// Line 1200:         h_list = curl_slist_append(h_list, apr_psprintf(r->pool, \"Authorization: Bearer %s\", bearer_token));",
                "// vulnerable line: 1201: }",
                "// Line 1202: ",
                "// Line 1203:     /* see if we need to perform HTTP basic authentication to the remote site */",
                "// Line 1204:     if (basic_auth != NULL) {",
                "// Line 1205:         curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);",
                "// Line 1206:         curl_easy_setopt(curl, CURLOPT_USERPWD, basic_auth);",
                "// vulnerable line: 1207: }",
                "// Line 1208: ",
                "// Line 1209:     if (ssl_cert != NULL)",
                "// Line 1210:         curl_easy_setopt(curl, CURLOPT_SSLCERT, ssl_cert);",
                "// Line 1211:     if (ssl_key != NULL)",
                "// Line 1212:         curl_easy_setopt(curl, CURLOPT_SSLKEY, ssl_key);",
                "// Line 1213:     if (ssl_key_pwd != NULL)",
                "// Line 1214:         curl_easy_setopt(curl, CURLOPT_KEYPASSWD, ssl_key_pwd);",
                "// Line 1215: ",
                "// Line 1216:     if (data != NULL) {",
                "// Line 1217:         /* set POST data */",
                "// Line 1218:         curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);",
                "// Line 1219:         /* set HTTP method to POST */",
                "// Line 1220:         curl_easy_setopt(curl, CURLOPT_POST, 1);",
                "// vulnerable line: 1221: }",
                "// Line 1222: ",
                "// Line 1223:     if (content_type != NULL) {",
                "// Line 1224:         /* set content type */",
                "// Line 1225:         h_list = curl_slist_append(h_list,",
                "// Line 1226:                        apr_psprintf(r->pool, \"%s: %s\", OIDC_HTTP_HDR_CONTENT_TYPE, content_type));",
                "// vulnerable line: 1227: }",
                "// Line 1228: ",
                "// Line 1229:     const char *traceparent = oidc_util_hdr_in_traceparent_get(r);",
                "// Line 1230:     if (traceparent && c->trace_parent != OIDC_TRACE_PARENT_OFF) {",
                "// Line 1231:         oidc_debug(r, \"propagating traceparent header: %s\", traceparent);",
                "// Line 1232:         h_list =",
                "// Line 1233:             curl_slist_append(h_list, apr_psprintf(r->pool, \"%s: %s\", OIDC_HTTP_HDR_TRACE_PARENT, traceparent));",
                "// vulnerable line: 1234: }",
                "// Line 1235: ",
                "// Line 1236:     /* see if we need to add any custom headers */",
                "// Line 1237:     if (h_list != NULL)",
                "// Line 1238:         curl_easy_setopt(curl, CURLOPT_HTTPHEADER, h_list);",
                "// Line 1239: ",
                "// Line 1240:     if (pass_cookies != NULL) {",
                "// Line 1241:         /* gather cookies that we need to pass on from the incoming request */",
                "// Line 1242:         char *cookie_string = NULL;",
                "// Line 1243:         for (i = 0; i < pass_cookies->nelts; i++) {",
                "// Line 1244:             const char *cookie_name = APR_ARRAY_IDX(pass_cookies, i, const char *);",
                "// Line 1245:             char *cookie_value = oidc_util_get_cookie(r, cookie_name);",
                "// Line 1246:             if (cookie_value != NULL) {",
                "// Line 1247:                 cookie_string =",
                "// Line 1248:                     (cookie_string == NULL)",
                "// Line 1249:                     ? apr_psprintf(r->pool, \"%s=%s\", cookie_name, cookie_value)",
                "// Line 1250:                     : apr_psprintf(r->pool, \"%s; %s=%s\", cookie_string, cookie_name, cookie_value);",
                "// vulnerable line: 1251: }",
                "// vulnerable line: 1252: }",
                "// Line 1253: ",
                "// Line 1254:         /* see if we need to pass any cookies */",
                "// Line 1255:         if (cookie_string != NULL) {",
                "// Line 1256:             oidc_debug(r, \"passing browser cookies on backend call: %s\", cookie_string);",
                "// Line 1257:             curl_easy_setopt(curl, CURLOPT_COOKIE, cookie_string);",
                "// vulnerable line: 1258: }",
                "// vulnerable line: 1259: }",
                "// Line 1260: ",
                "// Line 1261:     /* set the target URL */",
                "// Line 1262:     curl_easy_setopt(curl, CURLOPT_URL, url);",
                "// Line 1263: ",
                "// Line 1264:     /* call it and record the result */",
                "// Line 1265:     for (i = 0; i <= http_timeout->retries; i++) {",
                "// Line 1266:         res = curl_easy_perform(curl);",
                "// Line 1267:         if (res == CURLE_OK) {",
                "// Line 1268:             rv = TRUE;",
                "// Line 1269:             break;",
                "// vulnerable line: 1270: }",
                "// Line 1271:         if (res == CURLE_OPERATION_TIMEDOUT) {",
                "// Line 1272:             /* in case of a request/transfer timeout (which includes the connect timeout) we'll not retry */",
                "// Line 1273:             oidc_error(r, \"curl_easy_perform failed with a timeout for %s: [%s]; won't retry\", url,",
                "// Line 1274:                    curlError[0] ? curlError : \"<n/a>\");",
                "// Line 1275:             OIDC_METRICS_COUNTER_INC_SPEC(r, c, OM_PROVIDER_CONNECT_ERROR,",
                "// Line 1276:                               curlError[0] ? curlError : \"timeout\")",
                "// Line 1277:             break;",
                "// vulnerable line: 1278: }",
                "// Line 1279:         oidc_error(r, \"curl_easy_perform(%d/%d) failed for %s with: [%s]\", i + 1, http_timeout->retries + 1,",
                "// Line 1280:                url, curlError[0] ? curlError : \"<n/a>\");",
                "// Line 1281:         OIDC_METRICS_COUNTER_INC_SPEC(r, c, OM_PROVIDER_CONNECT_ERROR, curlError[0] ? curlError : \"undefined\")",
                "// Line 1282:         /* in case of a connectivity/network glitch we'll back off before retrying */",
                "// Line 1283:         if (i < http_timeout->retries)",
                "// Line 1284:             apr_sleep(http_timeout->retry_interval);",
                "// vulnerable line: 1285: }",
                "// Line 1286:     if (rv == FALSE)",
                "// Line 1287:         goto end;",
                "// Line 1288: ",
                "// Line 1289:     curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);",
                "// Line 1290:     oidc_debug(r, \"HTTP response code=%ld\", response_code);",
                "// Line 1291: ",
                "// Line 1292:     OIDC_METRICS_COUNTER_INC_SPEC(r, c, OM_PROVIDER_HTTP_RESPONSE_CODE,",
                "// Line 1293:                       apr_psprintf(r->pool, \"%ld\", response_code));",
                "// Line 1294: ",
                "// Line 1295:     *response = apr_pstrmemdup(r->pool, curlBuffer.memory, curlBuffer.size);",
                "// Line 1299: ",
                "// Line 1300: end:",
                "// Line 1301: ",
                "// Line 1302:     /* cleanup and return the result */",
                "// Line 1303:     if (h_list != NULL)",
                "// Line 1304:         curl_slist_free_all(h_list);",
                "// Line 1305:     if (curl != NULL)",
                "// Line 1306:         curl_easy_cleanup(curl);",
                "// Line 1307: ",
                "// Line 1308:     return rv;",
                "// vulnerable line: 1309: }",
                "// Line 1310: ",
                "// Line 1311: /*",
                "// Line 1312:  * execute HTTP GET request",
                "// Line 1313:  */",
                "// Line 1314: apr_byte_t oidc_util_http_get(request_rec *r, const char *url, const apr_table_t *params, const char *basic_auth,",
                "// Line 1315:                   const char *bearer_token, int ssl_validate_server, char **response,",
                "// Line 1316:                   oidc_http_timeout_t *http_timeout, const oidc_outgoing_proxy_t *outgoing_proxy,",
                "// Line 1317:                   apr_array_header_t *pass_cookies, const char *ssl_cert, const char *ssl_key,",
                "// Line 1318:                   const char *ssl_key_pwd) {",
                "// Line 1319:     char *query_url = oidc_util_http_query_encoded_url(r, url, params);",
                "// Line 1320:     return oidc_util_http_call(r, query_url, NULL, NULL, basic_auth, bearer_token, ssl_validate_server, response,",
                "// Line 1321:                    http_timeout, outgoing_proxy, pass_cookies, ssl_cert, ssl_key, ssl_key_pwd);",
                "// vulnerable line: 1322: }",
                "// Line 1323: ",
                "// Line 1324: /*",
                "// Line 1325:  * execute HTTP POST request with form-encoded data",
                "// Line 1326:  */",
                "// Line 1327: apr_byte_t oidc_util_http_post_form(request_rec *r, const char *url, const apr_table_t *params, const char *basic_auth,",
                "// Line 1328:                     const char *bearer_token, int ssl_validate_server, char **response,",
                "// Line 1329:                     oidc_http_timeout_t *http_timeout, const oidc_outgoing_proxy_t *outgoing_proxy,",
                "// Line 1330:                     apr_array_header_t *pass_cookies, const char *ssl_cert, const char *ssl_key,",
                "// Line 1331:                     const char *ssl_key_pwd) {",
                "// Line 1332:     char *data = oidc_util_http_form_encoded_data(r, params);",
                "// Line 1333:     return oidc_util_http_call(r, url, data, OIDC_CONTENT_TYPE_FORM_ENCODED, basic_auth, bearer_token,",
                "// Line 1334:                    ssl_validate_server, response, http_timeout, outgoing_proxy, pass_cookies, ssl_cert,",
                "// Line 1335:                    ssl_key, ssl_key_pwd);",
                "// vulnerable line: 1336: }",
                "// Line 1337: ",
                "// Line 1338: /*",
                "// Line 1339:  * execute HTTP POST request with JSON-encoded data",
                "// Line 1340:  */",
                "// Line 1341: apr_byte_t oidc_util_http_post_json(request_rec *r, const char *url, json_t *json, const char *basic_auth,",
                "// Line 1342:                     const char *bearer_token, int ssl_validate_server, char **response,",
                "// Line 1343:                     oidc_http_timeout_t *http_timeout, const oidc_outgoing_proxy_t *outgoing_proxy,",
                "// Line 1344:                     apr_array_header_t *pass_cookies, const char *ssl_cert, const char *ssl_key,",
                "// Line 1345:                     const char *ssl_key_pwd) {",
                "// Line 1346:     char *data = json != NULL ? oidc_util_encode_json_object(r, json, JSON_COMPACT) : NULL;",
                "// Line 1347:     return oidc_util_http_call(r, url, data, OIDC_CONTENT_TYPE_JSON, basic_auth, bearer_token, ssl_validate_server,",
                "// Line 1348:                    response, http_timeout, outgoing_proxy, pass_cookies, ssl_cert, ssl_key,",
                "// Line 1349:                    ssl_key_pwd);",
                "// vulnerable line: 1350: }",
                "// Line 1351: ",
                "// Line 1352: /*",
                "// Line 1353:  * get the current path from the request in a normalized way",
                "// Line 1354:  */",
                "// Line 1355: static char *oidc_util_get_path(request_rec *r) {",
                "// Line 1356:     size_t i;",
                "// Line 1357:     char *p;",
                "// Line 1358:     p = r->parsed_uri.path;",
                "// Line 1359:     if ((p == NULL) || (p[0] == '\u0000'))",
                "// Line 1360:         return apr_pstrdup(r->pool, OIDC_STR_FORWARD_SLASH);",
                "// Line 1361:     for (i = _oidc_strlen(p) - 1; i > 0; i--)",
                "// Line 1362:         if (p[i] == OIDC_CHAR_FORWARD_SLASH)",
                "// Line 1363:             break;",
                "// Line 1364:     return apr_pstrndup(r->pool, p, i + 1);",
                "// vulnerable line: 1365: }",
                "// Line 1366: ",
                "// Line 1367: /*",
                "// Line 1368:  * get the cookie path setting and check that it matches the request path; cook it up if it is not set",
                "// Line 1369:  */",
                "// Line 1370: static char *oidc_util_get_cookie_path(request_rec *r) {",
                "// Line 1371:     char *rv = NULL;",
                "// Line 1372:     char *requestPath = oidc_util_get_path(r);",
                "// Line 1373:     char *cookie_path = oidc_cfg_dir_cookie_path(r);",
                "// Line 1374:     if (cookie_path != NULL) {",
                "// Line 1375:         if (_oidc_strncmp(cookie_path, requestPath, _oidc_strlen(cookie_path)) == 0)",
                "// Line 1376:             rv = cookie_path;",
                "// Line 1377:         else {",
                "// Line 1378:             oidc_warn(r,",
                "// Line 1379:                   \"\" OIDCCookiePath",
                "// Line 1380:                   \" (%s) is not a substring of request path, using request path (%s) for cookie\",",
                "// Line 1381:                   cookie_path, requestPath);",
                "// Line 1382:             rv = requestPath;",
                "// vulnerable line: 1383: }",
                "// vulnerable line: 1384: } else {",
                "// Line 1385:         rv = requestPath;",
                "// vulnerable line: 1386: }",
                "// Line 1387:     return rv;",
                "// vulnerable line: 1388: }",
                "// Line 1389: ",
                "// Line 1390: #define OIDC_COOKIE_FLAG_DOMAIN \"Domain\"",
                "// Line 1391: #define OIDC_COOKIE_FLAG_PATH \"Path\"",
                "// Line 1392: #define OIDC_COOKIE_FLAG_EXPIRES \"Expires\"",
                "// Line 1393: #define OIDC_COOKIE_FLAG_SECURE \"Secure\"",
                "// Line 1394: #define OIDC_COOKIE_FLAG_HTTP_ONLY \"HttpOnly\"",
                "// Line 1395: ",
                "// Line 1396: #define OIDC_COOKIE_MAX_SIZE 4093",
                "// Line 1397: ",
                "// Line 1398: #define OIDC_SET_COOKIE_APPEND_ENV_VAR \"OIDC_SET_COOKIE_APPEND\"",
                "// Line 1399: ",
                "// Line 1400: const char *oidc_util_set_cookie_append_value(request_rec *r) {",
                "// Line 1401:     const char *env_var_value = NULL;",
                "// Line 1402: ",
                "// Line 1403:     if (r->subprocess_env != NULL)",
                "// Line 1404:         env_var_value = apr_table_get(r->subprocess_env, OIDC_SET_COOKIE_APPEND_ENV_VAR);",
                "// Line 1405: ",
                "// Line 1406:     if (env_var_value == NULL) {",
                "// Line 1407:         oidc_debug(r, \"no cookie append environment variable %s found\", OIDC_SET_COOKIE_APPEND_ENV_VAR);",
                "// Line 1408:         return NULL;",
                "// vulnerable line: 1409: }",
                "// Line 1410: ",
                "// Line 1411:     oidc_debug(r, \"cookie append environment variable %s=%s found\", OIDC_SET_COOKIE_APPEND_ENV_VAR, env_var_value);",
                "// Line 1412: ",
                "// Line 1413:     return env_var_value;",
                "// vulnerable line: 1414: }",
                "// Line 1415: ",
                "// Line 1416: apr_byte_t oidc_util_request_is_secure(request_rec *r, const oidc_cfg *c) {",
                "// Line 1417:     return (_oidc_strnatcasecmp(\"https\", oidc_get_current_url_scheme(r, c->x_forwarded_headers)) == 0);",
                "// vulnerable line: 1418: }",
                "// Line 1419: ",
                "// Line 1420: /*",
                "// Line 1421:  * set a cookie in the HTTP response headers",
                "// Line 1422:  */",
                "// Line 1423: void oidc_util_set_cookie(request_rec *r, const char *cookieName, const char *cookieValue, apr_time_t expires,",
                "// Line 1424:               const char *ext) {",
                "// Line 1425: ",
                "// Line 1426:     oidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);",
                "// Line 1427:     char *headerString = NULL;",
                "// Line 1428:     char *expiresString = NULL;",
                "// Line 1430: ",
                "// Line 1431:     /* see if we need to clear the cookie */",
                "// Line 1432:     if (_oidc_strcmp(cookieValue, \"\") == 0)",
                "// Line 1433:         expires = 0;",
                "// Line 1434: ",
                "// Line 1435:     /* construct the expire value */",
                "// Line 1436:     if (expires != -1) {",
                "// Line 1437:         expiresString = (char *)apr_pcalloc(r->pool, APR_RFC822_DATE_LEN);",
                "// Line 1438:         if (apr_rfc822_date(expiresString, expires) != APR_SUCCESS) {",
                "// Line 1439:             oidc_error(r, \"could not set cookie expiry date\");",
                "// vulnerable line: 1440: }",
                "// vulnerable line: 1441: }",
                "// Line 1442: ",
                "// Line 1443:     /* construct the cookie value */",
                "// Line 1444:     headerString = apr_psprintf(r->pool, \"%s=%s\", cookieName, cookieValue);",
                "// Line 1445: ",
                "// Line 1446:     headerString =",
                "// Line 1447:         apr_psprintf(r->pool, \"%s; %s=%s\", headerString, OIDC_COOKIE_FLAG_PATH, oidc_util_get_cookie_path(r));",
                "// Line 1448: ",
                "// Line 1449:     if (expiresString != NULL)",
                "// Line 1450:         headerString =",
                "// Line 1451:             apr_psprintf(r->pool, \"%s; %s=%s\", headerString, OIDC_COOKIE_FLAG_EXPIRES, expiresString);",
                "// Line 1465:         headerString = apr_psprintf(r->pool, \"%s; %s\", headerString, appendString);",
                "// Line 1466:     else if (ext != NULL)",
                "// Line 1467:         headerString = apr_psprintf(r->pool, \"%s; %s\", headerString, ext);",
                "// Line 1468: ",
                "// Line 1469:     /* sanity check on overall cookie value size */",
                "// Line 1470:     if (_oidc_strlen(headerString) > OIDC_COOKIE_MAX_SIZE) {",
                "// Line 1471:         oidc_warn(r,",
                "// Line 1472:               \"the length of the cookie value (%d) is greater than %d(!) bytes, this may not work with all \"",
                "// Line 1473:               \"browsers/server combinations: consider switching to a server side caching!\",",
                "// Line 1474:               (int)_oidc_strlen(headerString), OIDC_COOKIE_MAX_SIZE);",
                "// vulnerable line: 1475: }",
                "// Line 1476: ",
                "// Line 1477:     /* use r->err_headers_out so we always print our headers (even on 302 redirect) - headers_out only prints on 2xx",
                "// Line 1478:      * responses */",
                "// Line 1479:     oidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_SET_COOKIE, headerString);",
                "// vulnerable line: 1480: }",
                "// Line 1481: ",
                "// Line 1482: /*",
                "// Line 1483:  * get a cookie from the HTTP request",
                "// Line 1484:  */",
                "// Line 1485: char *oidc_util_get_cookie(request_rec *r, const char *cookieName) {",
                "// Line 1486:     char *cookie = NULL;",
                "// Line 1487:     char *tokenizerCtx = NULL;",
                "// Line 1488:     char *rv = NULL;",
                "// Line 1489: ",
                "// Line 1490:     /* get the Cookie value */",
                "// Line 1502: ",
                "// Line 1503:             /* see if we've found the cookie that we're looking for */",
                "// Line 1504:             if ((_oidc_strncmp(cookie, cookieName, _oidc_strlen(cookieName)) == 0) &&",
                "// Line 1505:                 (cookie[_oidc_strlen(cookieName)] == OIDC_CHAR_EQUAL)) {",
                "// Line 1506: ",
                "// Line 1507:                 /* skip to the meat of the parameter (the value after the '=') */",
                "// Line 1508:                 cookie += (_oidc_strlen(cookieName) + 1);",
                "// Line 1509:                 rv = apr_pstrdup(r->pool, cookie);",
                "// Line 1510: ",
                "// Line 1511:                 break;",
                "// vulnerable line: 1512: }",
                "// Line 1513: ",
                "// Line 1514:             /* go to the next cookie */",
                "// Line 1515:             cookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &tokenizerCtx);",
                "// vulnerable line: 1516: }",
                "// vulnerable line: 1517: }",
                "// Line 1518: ",
                "// Line 1519:     /* log what we've found */",
                "// Line 1520:     oidc_debug(r, \"returning \"%s\" = %s\", cookieName, rv ? apr_psprintf(r->pool, \"\"%s\"\", rv) : \"<null>\");",
                "// Line 1521: ",
                "// Line 1522:     return rv;",
                "// vulnerable line: 1523: }",
                "// Line 1524: ",
                "// Line 1525: #define OIDC_COOKIE_CHUNKS_SEPARATOR \"_\"",
                "// Line 1526: #define OIDC_COOKIE_CHUNKS_POSTFIX \"chunks\"",
                "// Line 1527: ",
                "// Line 1528: /*",
                "// Line 1529:  * get the name of the cookie that contains the number of chunks",
                "// Line 1530:  */",
                "// Line 1531: static char *oidc_util_get_chunk_count_name(request_rec *r, const char *cookieName) {",
                "// Line 1532:     return apr_psprintf(r->pool, \"%s%s%s\", cookieName, OIDC_COOKIE_CHUNKS_SEPARATOR, OIDC_COOKIE_CHUNKS_POSTFIX);",
                "// vulnerable line: 1533: }",
                "// Line 1534: ",
                "// Line 1535: /*",
                "// Line 1536:  * get the number of cookie chunks set by the browser",
                "// Line 1537:  */",
                "// Line 1538: static int oidc_util_get_chunked_count(request_rec *r, const char *cookieName) {",
                "// Line 1539:     int chunkCount = 0;",
                "// Line 1540:     char *chunkCountValue = oidc_util_get_cookie(r, oidc_util_get_chunk_count_name(r, cookieName));",
                "// Line 1541:     if (chunkCountValue != NULL) {",
                "// Line 1542:         chunkCount = _oidc_str_to_int(chunkCountValue);",
                "// Line 1543:         if (*chunkCountValue == '\u0000')",
                "// Line 1544:             chunkCount = 0;",
                "// vulnerable line: 1545: }",
                "// Line 1546:     return chunkCount;",
                "// vulnerable line: 1547: }",
                "// Line 1548: ",
                "// Line 1549: /*",
                "// Line 1550:  * get the name of a chunk",
                "// Line 1551:  */",
                "// Line 1552: static char *oidc_util_get_chunk_cookie_name(request_rec *r, const char *cookieName, int i) {",
                "// Line 1553:     return apr_psprintf(r->pool, \"%s%s%d\", cookieName, OIDC_COOKIE_CHUNKS_SEPARATOR, i);",
                "// vulnerable line: 1554: }",
                "// Line 1555: ",
                "// Line 1556: /*",
                "// Line 1557:  * get a cookie value that is split over a number of chunked cookies",
                "// Line 1558:  */",
                "// Line 1559: char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {",
                "// vulnerable line: 1560: char *cookieValue = NULL;",
                "// vulnerable line: 1561: char *chunkValue = NULL;",
                "// vulnerable line: 1562: int i = 0;",
                "// vulnerable line: 1563: if (chunkSize == 0) {",
                "// vulnerable line: 1564: cookieValue = oidc_util_get_cookie(r, cookieName);",
                "// vulnerable line: 1565: } else {",
                "// vulnerable line: 1566: int chunkCount = oidc_util_get_chunked_count(r, cookieName);",
                "// vulnerable line: 1567: if (chunkCount > 0) {",
                "// vulnerable line: 1568: cookieValue = \"\";",
                "// vulnerable line: 1569: for (i = 0; i < chunkCount; i++) {",
                "// vulnerable line: 1570: chunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));",
                "// vulnerable line: 1571: if (chunkValue != NULL)",
                "// vulnerable line: 1572: cookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);",
                "// vulnerable line: 1573: }",
                "// vulnerable line: 1574: } else {",
                "// vulnerable line: 1575: cookieValue = oidc_util_get_cookie(r, cookieName);",
                "// vulnerable line: 1576: }",
                "// vulnerable line: 1577: }",
                "// Line 1578:     return cookieValue;",
                "// vulnerable line: 1579: }",
                "// Line 1580: ",
                "// Line 1581: /*",
                "// Line 1582:  * unset all chunked cookies, including the counter cookie, if they exist",
                "// Line 1583:  */",
                "// Line 1584: static void oidc_util_clear_chunked_cookie(request_rec *r, const char *cookieName, apr_time_t expires,",
                "// Line 1585:                        const char *ext) {",
                "// vulnerable line: 1586: int i = 0;",
                "// vulnerable line: 1587: int chunkCount = oidc_util_get_chunked_count(r, cookieName);",
                "// vulnerable line: 1588: if (chunkCount > 0) {",
                "// Line 1589:         for (i = 0; i < chunkCount; i++)",
                "// Line 1590:             oidc_util_set_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i), \"\", expires, ext);",
                "// Line 1591:         oidc_util_set_cookie(r, oidc_util_get_chunk_count_name(r, cookieName), \"\", expires, ext);",
                "// vulnerable line: 1592: }",
                "// vulnerable line: 1593: }",
                "// Line 1594: ",
                "// Line 1595: /*",
                "// Line 1596:  * set a cookie value that is split over a number of chunked cookies",
                "// Line 1597:  */",
                "// Line 1598: void oidc_util_set_chunked_cookie(request_rec *r, const char *cookieName, const char *cookieValue, apr_time_t expires,",
                "// Line 1599:                   int chunkSize, const char *ext) {",
                "// vulnerable line: 1600: int i = 0;",
                "// Line 1601:     int cookieLength = _oidc_strlen(cookieValue);",
                "// vulnerable line: 1602: char *chunkValue = NULL;",
                "// Line 1603: ",
                "// Line 1604:     /* see if we need to chunk at all */",
                "// Line 1605:     if ((chunkSize == 0) || ((cookieLength > 0) && (cookieLength < chunkSize))) {",
                "// Line 1606:         oidc_util_set_cookie(r, cookieName, cookieValue, expires, ext);",
                "// Line 1607:         oidc_util_clear_chunked_cookie(r, cookieName, expires, ext);",
                "// Line 1608:         return;",
                "// vulnerable line: 1609: }",
                "// Line 1610: ",
                "// Line 1611:     /* see if we need to clear a possibly chunked cookie */",
                "// Line 1612:     if (cookieLength == 0) {",
                "// Line 1613:         oidc_util_set_cookie(r, cookieName, \"\", expires, ext);",
                "// Line 1614:         oidc_util_clear_chunked_cookie(r, cookieName, expires, ext);",
                "// Line 1615:         return;",
                "// vulnerable line: 1616: }",
                "// Line 1617: ",
                "// Line 1618:     /* set a chunked cookie */",
                "// Line 1619:     int chunkCountValue = cookieLength / chunkSize + 1;",
                "// Line 1620:     const char *ptr = cookieValue;",
                "// Line 1621:     for (i = 0; i < chunkCountValue; i++) {",
                "// Line 1622:         chunkValue = apr_pstrndup(r->pool, ptr, chunkSize);",
                "// Line 1623:         ptr += chunkSize;",
                "// Line 1624:         oidc_util_set_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i), chunkValue, expires, ext);",
                "// vulnerable line: 1625: }",
                "// Line 1626:     oidc_util_set_cookie(r, oidc_util_get_chunk_count_name(r, cookieName),",
                "// Line 1627:                  apr_psprintf(r->pool, \"%d\", chunkCountValue), expires, ext);",
                "// Line 1628:     oidc_util_set_cookie(r, cookieName, \"\", expires, ext);",
                "// vulnerable line: 1629: }",
                "// Line 1630: ",
                "// Line 1631: /*",
                "// Line 1632:  * normalize a string for use as an HTTP Header Name.  Any invalid",
                "// Line 1633:  * characters (per http://tools.ietf.org/html/rfc2616#section-4.2 and",
                "// Line 1634:  * http://tools.ietf.org/html/rfc2616#section-2.2) are replaced with",
                "// Line 1635:  * a dash ('-') character.",
                "// Line 1636:  */",
                "// Line 1637: char *oidc_normalize_header_name(const request_rec *r, const char *str) {",
                "// Line 1638:     /* token = 1*<any CHAR except CTLs or separators>",
                "// Line 1639:      * CTL = <any US-ASCII control character",
                "// Line 1644:      *              | \"{\" | \"}\" | SP | HT */",
                "// Line 1645:     const char *separators = \"()<>@,;:\\\"/[]?={}     \";",
                "// Line 1646: ",
                "// Line 1647:     char *ns = apr_pstrdup(r->pool, str);",
                "// Line 1648:     size_t i;",
                "// Line 1649:     for (i = 0; i < _oidc_strlen(ns); i++) {",
                "// Line 1650:         if (ns[i] < 32 || ns[i] == 127)",
                "// Line 1651:             ns[i] = '-';",
                "// Line 1652:         else if (strchr(separators, ns[i]) != NULL)",
                "// Line 1653:             ns[i] = '-';",
                "// vulnerable line: 1654: }",
                "// Line 1655:     return ns;",
                "// vulnerable line: 1656: }",
                "// Line 1657: ",
                "// Line 1658: /*",
                "// Line 1659:  * see if the currently accessed path matches a path from a defined URL",
                "// Line 1660:  */",
                "// Line 1661: apr_byte_t oidc_util_request_matches_url(request_rec *r, const char *url) {",
                "// Line 1662:     apr_uri_t uri;",
                "// Line 1663:     _oidc_memset(&uri, 0, sizeof(apr_uri_t));",
                "// Line 1664:     if ((url == NULL) || (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS))",
                "// Line 1665:         return FALSE;",
                "// Line 1666:     oidc_debug(r, \"comparing \"%s\"==\"%s\"\", r->parsed_uri.path, uri.path);",
                "// Line 1667:     if ((r->parsed_uri.path == NULL) || (uri.path == NULL))",
                "// Line 1668:         return (r->parsed_uri.path == uri.path);",
                "// Line 1669:     return (_oidc_strcmp(r->parsed_uri.path, uri.path) == 0);",
                "// vulnerable line: 1670: }",
                "// Line 1671: ",
                "// Line 1672: /*",
                "// Line 1673:  * see if the currently accessed path has a certain query parameter",
                "// Line 1674:  */",
                "// Line 1675: apr_byte_t oidc_util_request_has_parameter(request_rec *r, const char *param) {",
                "// Line 1676:     if (r->args == NULL)",
                "// Line 1677:         return FALSE;",
                "// Line 1678:     const char *option1 = apr_psprintf(r->pool, \"%s=\", param);",
                "// Line 1679:     const char *option2 = apr_psprintf(r->pool, \"&%s=\", param);",
                "// Line 1680:     return ((strstr(r->args, option1) == r->args) || (strstr(r->args, option2) != NULL)) ? TRUE : FALSE;",
                "// vulnerable line: 1681: }",
                "// Line 1682: ",
                "// Line 1683: /*",
                "// Line 1684:  * get a query parameter",
                "// Line 1685:  */",
                "// Line 1686: apr_byte_t oidc_util_get_request_parameter(request_rec *r, char *name, char **value) {",
                "// Line 1687:     char *tokenizer_ctx = NULL;",
                "// Line 1688:     char *p = NULL;",
                "// Line 1689:     char *args = NULL;",
                "// Line 1690:     const char *k_param = apr_psprintf(r->pool, \"%s=\", name);",
                "// Line 1691:     const size_t k_param_sz = _oidc_strlen(k_param);",
                "// Line 1696:         return FALSE;",
                "// Line 1697: ",
                "// Line 1698:     /* not sure why we do this, but better be safe than sorry */",
                "// Line 1699:     args = apr_pstrmemdup(r->pool, r->args, _oidc_strlen(r->args));",
                "// Line 1700: ",
                "// Line 1701:     p = apr_strtok(args, OIDC_STR_AMP, &tokenizer_ctx);",
                "// Line 1702:     do {",
                "// Line 1703:         if (p && _oidc_strncmp(p, k_param, k_param_sz) == 0) {",
                "// Line 1704:             *value = apr_pstrdup(r->pool, p + k_param_sz);",
                "// Line 1705:             *value = oidc_util_unescape_string(r, *value);",
                "// vulnerable line: 1706: }",
                "// Line 1707:         p = apr_strtok(NULL, OIDC_STR_AMP, &tokenizer_ctx);",
                "// Line 1708:     } while (p);",
                "// Line 1709: ",
                "// Line 1710:     return (*value != NULL ? TRUE : FALSE);",
                "// vulnerable line: 1711: }",
                "// Line 1712: ",
                "// Line 1713: /*",
                "// Line 1714:  * printout a JSON string value",
                "// Line 1715:  */",
                "// Line 1716: static apr_byte_t oidc_util_json_string_print(request_rec *r, json_t *result, const char *key, const char *log) {",
                "// Line 1717:     json_t *value = json_object_get(result, key);",
                "// Line 1718:     if (value != NULL && !json_is_null(value)) {",
                "// Line 1719:         oidc_error(r, \"%s: response contained an \"%s\" entry with value: \"%s\"\", log, key,",
                "// Line 1720:                oidc_util_encode_json_object(r, value, JSON_ENCODE_ANY));",
                "// Line 1721:         return TRUE;",
                "// vulnerable line: 1722: }",
                "// Line 1723:     return FALSE;",
                "// vulnerable line: 1724: }",
                "// Line 1725: ",
                "// Line 1726: /*",
                "// Line 1727:  * check a JSON object for \"error\" results and printout",
                "// Line 1728:  */",
                "// Line 1729: static apr_byte_t oidc_util_check_json_error(request_rec *r, json_t *json) {",
                "// Line 1730:     if (oidc_util_json_string_print(r, json, OIDC_PROTO_ERROR, \"oidc_util_check_json_error\") == TRUE) {",
                "// Line 1731:         oidc_util_json_string_print(r, json, OIDC_PROTO_ERROR_DESCRIPTION, \"oidc_util_check_json_error\");",
                "// Line 1732:         return TRUE;",
                "// vulnerable line: 1733: }",
                "// Line 1734:     return FALSE;",
                "// vulnerable line: 1735: }",
                "// Line 1736: ",
                "// Line 1737: #define OIDC_JSON_MAX_ERROR_STR 4096",
                "// Line 1738: ",
                "// Line 1739: /*",
                "// Line 1740:  * parse a JSON object",
                "// Line 1741:  */",
                "// Line 1742: apr_byte_t oidc_util_decode_json_object(request_rec *r, const char *str, json_t **json) {",
                "// Line 1743: ",
                "// Line 1744:     if (str == NULL)",
                "// Line 1745:         return FALSE;",
                "// Line 1746: ",
                "// Line 1747:     json_error_t json_error;",
                "// Line 1748:     *json = json_loads(str, 0, &json_error);",
                "// Line 1749: ",
                "// Line 1750:     /* decode the JSON contents of the buffer */",
                "// Line 1751:     if (*json == NULL) {",
                "// Line 1752:         /* something went wrong */",
                "// Line 1753: #if JANSSON_VERSION_HEX >= 0x020B00",
                "// Line 1754:         if (json_error_code(&json_error) == json_error_null_character) {",
                "// Line 1755:             oidc_error(r, \"JSON parsing returned an error: %s\", json_error.text);",
                "// vulnerable line: 1756: } else {",
                "// Line 1757: #endif",
                "// Line 1758:             oidc_error(r, \"JSON parsing returned an error: %s (%s)\", json_error.text,",
                "// Line 1759:                    apr_pstrndup(r->pool, str, OIDC_JSON_MAX_ERROR_STR));",
                "// Line 1760: #if JANSSON_VERSION_HEX >= 0x020B00",
                "// vulnerable line: 1761: }",
                "// Line 1762: #endif",
                "// Line 1763:         return FALSE;",
                "// vulnerable line: 1764: }",
                "// Line 1765: ",
                "// Line 1766:     if (!json_is_object(*json)) {",
                "// Line 1767:         /* oops, no JSON */",
                "// Line 1768:         oidc_error(r, \"parsed JSON did not contain a JSON object\");",
                "// Line 1769:         json_decref(*json);",
                "// Line 1770:         *json = NULL;",
                "// Line 1771:         return FALSE;",
                "// vulnerable line: 1772: }",
                "// Line 1773: ",
                "// Line 1774:     return TRUE;",
                "// vulnerable line: 1775: }",
                "// Line 1776: ",
                "// Line 1777: /*",
                "// Line 1778:  * encode a JSON object",
                "// Line 1779:  */",
                "// Line 1780: char *oidc_util_encode_json_object(request_rec *r, json_t *json, size_t flags) {",
                "// Line 1781:     char *s = json_dumps(json, flags);",
                "// Line 1782:     char *s_value = apr_pstrdup(r->pool, s);",
                "// Line 1783:     free(s);",
                "// Line 1784:     return s_value;",
                "// vulnerable line: 1785: }",
                "// Line 1786: ",
                "// Line 1787: /*",
                "// Line 1788:  * decode a JSON string, check for \"error\" results and printout",
                "// Line 1789:  */",
                "// Line 1790: apr_byte_t oidc_util_decode_json_and_check_error(request_rec *r, const char *str, json_t **json) {",
                "// Line 1791: ",
                "// Line 1792:     if (oidc_util_decode_json_object(r, str, json) == FALSE)",
                "// Line 1793:         return FALSE;",
                "// Line 1794: ",
                "// Line 1795:     // see if it is not an error response somehow",
                "// Line 1796:     if (oidc_util_check_json_error(r, *json) == TRUE) {",
                "// Line 1797:         json_decref(*json);",
                "// Line 1798:         *json = NULL;",
                "// Line 1799:         return FALSE;",
                "// vulnerable line: 1800: }",
                "// Line 1801: ",
                "// Line 1802:     return TRUE;",
                "// vulnerable line: 1803: }",
                "// Line 1804: ",
                "// Line 1805: /*",
                "// Line 1806:  * sends content to the user agent",
                "// Line 1807:  */",
                "// Line 1808: int oidc_util_http_send(request_rec *r, const char *data, size_t data_len, const char *content_type,",
                "// Line 1809:             int success_rvalue) {",
                "// Line 1810:     ap_set_content_type(r, content_type);",
                "// Line 1811:     apr_bucket_brigade *bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);",
                "// Line 1812:     apr_bucket *b = apr_bucket_transient_create(data, data_len, r->connection->bucket_alloc);",
                "// Line 1813:     APR_BRIGADE_INSERT_TAIL(bb, b);",
                "// Line 1814:     b = apr_bucket_eos_create(r->connection->bucket_alloc);",
                "// Line 1815:     APR_BRIGADE_INSERT_TAIL(bb, b);",
                "// Line 1816:     int rc = ap_pass_brigade(r->output_filters, bb);",
                "// Line 1817:     if (rc != APR_SUCCESS) {",
                "// Line 1818:         oidc_error(r,",
                "// Line 1819:                \"ap_pass_brigade returned an error: %d; if you're using this module combined with \"",
                "// Line 1820:                \"mod_deflate try make an exception for the \" OIDCRedirectURI",
                "// Line 1821:                \" e.g. using SetEnvIf Request_URI <url> no-gzip\",",
                "// Line 1822:                rc);",
                "// Line 1823:         return HTTP_INTERNAL_SERVER_ERROR;",
                "// vulnerable line: 1824: }",
                "// Line 1825:     /*",
                "// Line 1826:      *r->status = success_rvalue;",
                "// Line 1827:      */",
                "// Line 1828: ",
                "// Line 1829:     if ((success_rvalue == OK) && (r->user == NULL)) {",
                "// Line 1830:         /*",
                "// Line 1831:          * satisfy Apache 2.4 mod_authz_core:",
                "// Line 1832:          * prevent it to return HTTP 500 after sending content",
                "// Line 1833:          */",
                "// Line 1834:         r->user = \"\";",
                "// vulnerable line: 1835: }",
                "// Line 1836: ",
                "// Line 1837:     return success_rvalue;",
                "// vulnerable line: 1838: }",
                "// Line 1839: ",
                "// Line 1840: /*",
                "// Line 1841:  * send HTML content to the user agent",
                "// Line 1842:  */",
                "// Line 1843: int oidc_util_html_send(request_rec *r, const char *title, const char *html_head, const char *on_load,",
                "// Line 1844:             const char *html_body, int status_code) {",
                "// Line 1845: ",
                "// Line 1846:     char *html = \"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">",
                "// Line 1847: \"",
                "// Line 1848:              \"<html>",
                "// Line 1864:              \"  </body>",
                "// Line 1865: \"",
                "// Line 1866:              \"</html>",
                "// Line 1867: \";",
                "// Line 1868: ",
                "// Line 1869:     html = apr_psprintf(",
                "// Line 1870:         r->pool, html, title ? oidc_util_html_escape(r->pool, title) : \"\", html_head ? html_head : \"\",",
                "// Line 1871:         on_load ? apr_psprintf(r->pool, \" onload=\"%s()\"\", on_load) : \"\", html_body ? html_body : \"<p></p>\");",
                "// Line 1872: ",
                "// Line 1873:     return oidc_util_http_send(r, html, _oidc_strlen(html), OIDC_CONTENT_TYPE_TEXT_HTML, status_code);",
                "// vulnerable line: 1874: }",
                "// Line 1875: ",
                "// Line 1876: static char *html_error_template_contents = NULL;",
                "// Line 1877: ",
                "// Line 1878: /*",
                "// Line 1879:  * get the full path to a file based on an (already) absolute filename or a filename",
                "// Line 1880:  * that is relative to the Apache root directory",
                "// Line 1881:  */",
                "// Line 1882: char *oidc_util_get_full_path(apr_pool_t *pool, const char *abs_or_rel_filename) {",
                "// Line 1883:     return abs_or_rel_filename ? ap_server_root_relative(pool, abs_or_rel_filename) : NULL;",
                "// vulnerable line: 1884: }",
                "// Line 1885: ",
                "// Line 1886: /*",
                "// Line 1887:  * escape characters in an HTML/Javascript template",
                "// Line 1888:  */",
                "// Line 1889: static char *oidc_util_template_escape(request_rec *r, const char *arg, int escape) {",
                "// Line 1890:     char *rv = NULL;",
                "// Line 1891:     if (escape == OIDC_POST_PRESERVE_ESCAPE_HTML) {",
                "// Line 1892:         rv = oidc_util_html_escape(r->pool, arg ? arg : \"\");",
                "// Line 1893:     } else if (escape == OIDC_POST_PRESERVE_ESCAPE_JAVASCRIPT) {",
                "// Line 1894:         rv = oidc_util_javascript_escape(r->pool, arg ? arg : \"\");",
                "// vulnerable line: 1895: } else {",
                "// Line 1896:         rv = apr_pstrdup(r->pool, arg);",
                "// vulnerable line: 1897: }",
                "// Line 1898:     return rv;",
                "// vulnerable line: 1899: }",
                "// Line 1900: ",
                "// Line 1901: /*",
                "// Line 1902:  * fill and send a HTML template",
                "// Line 1903:  */",
                "// Line 1904: apr_byte_t oidc_util_html_send_in_template(request_rec *r, const char *filename, char **static_template_content,",
                "// Line 1905:                        const char *arg1, int arg1_esc, const char *arg2, int arg2_esc,",
                "// Line 1906:                        int status_code) {",
                "// Line 1907:     char *fullname = NULL;",
                "// Line 1908:     char *html = NULL;",
                "// Line 1909:     int rc = status_code;",
                "// Line 1910:     if (*static_template_content == NULL) {",
                "// Line 1911:         fullname = oidc_util_get_full_path(r->pool, filename);",
                "// Line 1912:         // NB: templates go into the server process pool",
                "// Line 1913:         if (oidc_util_file_read(r, fullname, r->server->process->pool, static_template_content) == FALSE) {",
                "// Line 1914:             oidc_error(r, \"could not read template: %s\", fullname);",
                "// Line 1915:             *static_template_content = NULL;",
                "// vulnerable line: 1916: }",
                "// vulnerable line: 1917: }",
                "// Line 1918:     if (static_template_content) {",
                "// Line 1919:         html = apr_psprintf(r->pool, *static_template_content, oidc_util_template_escape(r, arg1, arg1_esc),",
                "// Line 1920:                     oidc_util_template_escape(r, arg2, arg2_esc));",
                "// Line 1921:         rc = oidc_util_http_send(r, html, _oidc_strlen(html), OIDC_CONTENT_TYPE_TEXT_HTML, status_code);",
                "// vulnerable line: 1922: }",
                "// Line 1923:     return rc;",
                "// vulnerable line: 1924: }",
                "// Line 1925: ",
                "// Line 1926: /*",
                "// Line 1927:  * send a user-facing error to the browser",
                "// Line 1928:  */",
                "// Line 1929: int oidc_util_html_send_error(request_rec *r, const char *html_template, const char *error, const char *description,",
                "// Line 1930:                   int status_code) {",
                "// Line 1931: ",
                "// Line 1932:     char *html = \"\";",
                "// Line 1933:     int rc = status_code;",
                "// Line 1934: ",
                "// Line 1935:     if (html_template != NULL) {",
                "// Line 1936: ",
                "// Line 1937:         if (_oidc_strcmp(html_template, \"deprecated\") != 0) {",
                "// Line 1938: ",
                "// Line 1939:             rc = oidc_util_html_send_in_template(r, html_template, &html_error_template_contents, error,",
                "// Line 1940:                                  OIDC_POST_PRESERVE_ESCAPE_HTML, description,",
                "// Line 1941:                                  OIDC_POST_PRESERVE_ESCAPE_HTML, status_code);",
                "// Line 1942: ",
                "// vulnerable line: 1943: } else {",
                "// Line 1944: ",
                "// Line 1945:             if (error != NULL) {",
                "// Line 1946:                 html = apr_psprintf(r->pool, \"%s<p>Error: <pre>%s</pre></p>\", html,",
                "// Line 1947:                             oidc_util_html_escape(r->pool, error));",
                "// vulnerable line: 1948: }",
                "// Line 1949:             if (description != NULL) {",
                "// Line 1950:                 html = apr_psprintf(r->pool, \"%s<p>Description: <pre>%s</pre></p>\", html,",
                "// Line 1951:                             oidc_util_html_escape(r->pool, description));",
                "// vulnerable line: 1952: }",
                "// Line 1953: ",
                "// Line 1954:             rc = oidc_util_html_send(r, \"Error\", NULL, NULL, html, status_code);",
                "// vulnerable line: 1955: }",
                "// vulnerable line: 1956: }",
                "// Line 1957: ",
                "// Line 1958:     oidc_debug(r, \"setting \" OIDC_ERROR_ENVVAR \" environment variable to: %s\", error);",
                "// Line 1959:     apr_table_set(r->subprocess_env, OIDC_ERROR_ENVVAR, error ? error : \"\");",
                "// Line 1960: ",
                "// Line 1961:     oidc_debug(r, \"setting \" OIDC_ERROR_DESC_ENVVAR \" environment variable to: %s\", description);",
                "// Line 1962:     apr_table_set(r->subprocess_env, OIDC_ERROR_DESC_ENVVAR, description ? description : \"\");",
                "// Line 1963: ",
                "// Line 1964:     return rc;",
                "// vulnerable line: 1965: }",
                "// Line 1966: ",
                "// Line 1967: /*",
                "// Line 1968:  * read all bytes from the HTTP request",
                "// Line 1969:  */",
                "// Line 1970: static apr_byte_t oidc_util_read(request_rec *r, char **rbuf) {",
                "// Line 1971:     apr_size_t bytes_read;",
                "// Line 1972:     apr_size_t bytes_left;",
                "// Line 1973:     apr_size_t len;",
                "// Line 1974:     long read_length;",
                "// Line 1975: ",
                "// Line 1976:     if (ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK) != OK)",
                "// Line 1977:         return FALSE;",
                "// Line 1978: ",
                "// Line 1979:     len = ap_should_client_block(r) ? r->remaining : 0;",
                "// Line 1980: ",
                "// Line 1981:     if (len > OIDC_MAX_POST_DATA_LEN) {",
                "// Line 1982:         oidc_error(r, \"POST parameter value is too large: %lu bytes (max=%d)\", (unsigned long)len,",
                "// Line 1983:                OIDC_MAX_POST_DATA_LEN);",
                "// Line 1984:         return FALSE;",
                "// vulnerable line: 1985: }",
                "// Line 1986: ",
                "// Line 1987:     *rbuf = (char *)apr_palloc(r->pool, len + 1);",
                "// Line 1988:     if (*rbuf == NULL) {",
                "// Line 1989:         oidc_error(r, \"could not allocate memory for %lu bytes of POST data.\", (unsigned long)len);",
                "// Line 1990:         return FALSE;",
                "// vulnerable line: 1991: }",
                "// Line 1992:     (*rbuf)[len] = '\u0000';",
                "// Line 1993: ",
                "// Line 1994:     bytes_read = 0;",
                "// Line 1995:     bytes_left = len;",
                "// Line 1996:     while (bytes_left > 0) {",
                "// Line 1997:         read_length = ap_get_client_block(r, &(*rbuf)[bytes_read], bytes_left);",
                "// Line 1998:         if (read_length == 0) {",
                "// Line 1999:             (*rbuf)[bytes_read] = '\u0000';",
                "// Line 2000:             break;",
                "// Line 2001:         } else if (read_length < 0) {",
                "// Line 2002:             oidc_error(r, \"failed to read POST data from client\");",
                "// Line 2003:             return FALSE;",
                "// vulnerable line: 2004: }",
                "// Line 2005:         bytes_read += read_length;",
                "// Line 2006:         bytes_left -= read_length;",
                "// vulnerable line: 2007: }",
                "// Line 2008: ",
                "// Line 2009:     return TRUE;",
                "// vulnerable line: 2010: }",
                "// Line 2011: ",
                "// Line 2012: /*",
                "// Line 2013:  * read form-encoded parameters from a string in to a table",
                "// Line 2014:  */",
                "// Line 2015: apr_byte_t oidc_util_read_form_encoded_params(request_rec *r, apr_table_t *table, char *data) {",
                "// Line 2016:     const char *key = NULL;",
                "// Line 2017:     const char *val = NULL;",
                "// Line 2018:     const char *p = data;",
                "// Line 2019: ",
                "// Line 2020:     while (p && *p && (val = ap_getword(r->pool, &p, OIDC_CHAR_AMP))) {",
                "// Line 2021:         key = ap_getword(r->pool, &val, OIDC_CHAR_EQUAL);",
                "// Line 2022:         key = oidc_util_unescape_string(r, key);",
                "// Line 2023:         val = oidc_util_unescape_string(r, val);",
                "// Line 2024:         oidc_debug(r, \"read: %s=%s\", key, val);",
                "// Line 2025:         apr_table_set(table, key, val);",
                "// vulnerable line: 2026: }",
                "// Line 2027: ",
                "// Line 2028:     oidc_debug(r, \"parsed: %d bytes into %d elements\", data ? (int)_oidc_strlen(data) : 0,",
                "// Line 2029:            apr_table_elts(table)->nelts);",
                "// Line 2030: ",
                "// Line 2031:     return TRUE;",
                "// vulnerable line: 2032: }",
                "// Line 2033: ",
                "// Line 2034: static void oidc_userdata_set_post_param(request_rec *r, const char *post_param_name, const char *post_param_value) {",
                "// Line 2035:     apr_table_t *userdata_post_params = NULL;",
                "// Line 2036:     apr_pool_userdata_get((void **)&userdata_post_params, OIDC_USERDATA_POST_PARAMS_KEY, r->pool);",
                "// Line 2037:     if (userdata_post_params == NULL)",
                "// Line 2038:         userdata_post_params = apr_table_make(r->pool, 1);",
                "// Line 2039:     apr_table_set(userdata_post_params, post_param_name, post_param_value);",
                "// Line 2040:     apr_pool_userdata_set(userdata_post_params, OIDC_USERDATA_POST_PARAMS_KEY, NULL, r->pool);",
                "// vulnerable line: 2041: }",
                "// Line 2042: ",
                "// Line 2043: /*",
                "// Line 2044:  * read the POST parameters in to a table",
                "// Line 2045:  */",
                "// Line 2046: apr_byte_t oidc_util_read_post_params(request_rec *r, apr_table_t *table, apr_byte_t propagate,",
                "// Line 2047:                       const char *strip_param_name) {",
                "// Line 2048:     apr_byte_t rc = FALSE;",
                "// Line 2049:     char *data = NULL;",
                "// Line 2050:     const apr_array_header_t *arr = NULL;",
                "// Line 2051:     const apr_table_entry_t *elts = NULL;",
                "// vulnerable line: 2052: int i = 0;",
                "// Line 2053:     const char *content_type = NULL;",
                "// Line 2054: ",
                "// Line 2055:     content_type = oidc_util_hdr_in_content_type_get(r);",
                "// Line 2056:     if ((r->method_number != M_POST) || (content_type == NULL) ||",
                "// Line 2057:         (strstr(content_type, OIDC_CONTENT_TYPE_FORM_ENCODED) != content_type)) {",
                "// Line 2058:         oidc_debug(r, \"required content-type %s not found\", OIDC_CONTENT_TYPE_FORM_ENCODED);",
                "// Line 2059:         goto end;",
                "// vulnerable line: 2060: }",
                "// Line 2061: ",
                "// Line 2062:     if (oidc_util_read(r, &data) != TRUE)",
                "// Line 2063:         goto end;",
                "// Line 2064: ",
                "// Line 2065:     rc = oidc_util_read_form_encoded_params(r, table, data);",
                "// Line 2066:     if (rc != TRUE)",
                "// Line 2067:         goto end;",
                "// Line 2068: ",
                "// Line 2069:     if (propagate == FALSE)",
                "// Line 2070:         goto end;",
                "// Line 2071: ",
                "// Line 2072:     arr = apr_table_elts(table);",
                "// Line 2073:     elts = (const apr_table_entry_t *)arr->elts;",
                "// Line 2074:     for (i = 0; i < arr->nelts; i++)",
                "// Line 2075:         if (_oidc_strcmp(elts[i].key, strip_param_name) != 0)",
                "// Line 2076:             oidc_userdata_set_post_param(r, elts[i].key, elts[i].val);",
                "// Line 2077: ",
                "// Line 2078: end:",
                "// Line 2079: ",
                "// Line 2080:     return rc;",
                "// vulnerable line: 2081: }",
                "// Line 2082: ",
                "// Line 2083: /*",
                "// Line 2084:  * read a file from a path on disk",
                "// Line 2085:  */",
                "// Line 2086: apr_byte_t oidc_util_file_read(request_rec *r, const char *path, apr_pool_t *pool, char **result) {",
                "// Line 2087:     apr_file_t *fd = NULL;",
                "// Line 2088:     apr_status_t rc = APR_SUCCESS;",
                "// Line 2089:     char s_err[128];",
                "// Line 2090:     apr_finfo_t finfo;",
                "// Line 2091: ",
                "// Line 2092:     /* open the file if it exists */",
                "// Line 2093:     if ((rc = apr_file_open(&fd, path, APR_FOPEN_READ | APR_FOPEN_BUFFERED, APR_OS_DEFAULT, r->pool)) !=",
                "// Line 2094:         APR_SUCCESS) {",
                "// Line 2095:         oidc_warn(r, \"no file found at: \"%s\" (%s)\", path, apr_strerror(rc, s_err, sizeof(s_err)));",
                "// Line 2096:         return FALSE;",
                "// vulnerable line: 2097: }",
                "// Line 2098: ",
                "// Line 2099:     /* the file exists, now lock it */",
                "// Line 2100:     apr_file_lock(fd, APR_FLOCK_EXCLUSIVE);",
                "// Line 2101: ",
                "// Line 2102:     /* move the read pointer to the very start of the cache file */",
                "// Line 2103:     apr_off_t begin = 0;",
                "// Line 2104:     apr_file_seek(fd, APR_SET, &begin);",
                "// Line 2105: ",
                "// Line 2106:     /* get the file info so we know its size */",
                "// Line 2107:     if ((rc = apr_file_info_get(&finfo, APR_FINFO_SIZE, fd)) != APR_SUCCESS) {",
                "// Line 2108:         oidc_error(r, \"error calling apr_file_info_get on file: \"%s\" (%s)\", path,",
                "// Line 2109:                apr_strerror(rc, s_err, sizeof(s_err)));",
                "// Line 2110:         goto error_close;",
                "// vulnerable line: 2111: }",
                "// Line 2112: ",
                "// Line 2113:     /* now that we have the size of the file, allocate a buffer that can contain its contents */",
                "// Line 2114:     *result = apr_palloc(pool, finfo.size + 1);",
                "// Line 2115: ",
                "// Line 2116:     /* read the file in to the buffer */",
                "// Line 2117:     apr_size_t bytes_read = 0;",
                "// Line 2118:     if ((rc = apr_file_read_full(fd, *result, finfo.size, &bytes_read)) != APR_SUCCESS) {",
                "// Line 2119:         oidc_error(r, \"apr_file_read_full on (%s) returned an error: %s\", path,",
                "// Line 2120:                apr_strerror(rc, s_err, sizeof(s_err)));",
                "// Line 2121:         goto error_close;",
                "// vulnerable line: 2122: }",
                "// Line 2123: ",
                "// Line 2124:     /* just to be sure, we set a \u0000 (we allocated space for it anyway) */",
                "// Line 2125:     (*result)[bytes_read] = '\u0000';",
                "// Line 2126: ",
                "// Line 2127:     /* check that we've got all of it */",
                "// Line 2128:     if (bytes_read != finfo.size) {",
                "// Line 2129:         oidc_error(r,",
                "// Line 2130:                \"apr_file_read_full on (%s) returned less bytes (%\" APR_SIZE_T_FMT",
                "// Line 2131:                \") than expected: (%\" APR_OFF_T_FMT \")\",",
                "// Line 2132:                path, bytes_read, finfo.size);",
                "// Line 2133:         goto error_close;",
                "// vulnerable line: 2134: }",
                "// Line 2135: ",
                "// Line 2136:     /* we're done, unlock and close the file */",
                "// Line 2137:     apr_file_unlock(fd);",
                "// Line 2138:     apr_file_close(fd);",
                "// Line 2139: ",
                "// Line 2140:     /* log successful content retrieval */",
                "// Line 2141:     oidc_debug(r, \"file read successfully \"%s\"\", path);",
                "// Line 2142: ",
                "// Line 2143:     return TRUE;",
                "// Line 2144: ",
                "// Line 2145: error_close:",
                "// Line 2146: ",
                "// Line 2147:     apr_file_unlock(fd);",
                "// Line 2148:     apr_file_close(fd);",
                "// Line 2149: ",
                "// Line 2150:     oidc_error(r, \"return error\");",
                "// Line 2151: ",
                "// Line 2152:     return FALSE;",
                "// vulnerable line: 2153: }",
                "// Line 2154: ",
                "// Line 2155: /*",
                "// Line 2156:  * write data to a file",
                "// Line 2157:  */",
                "// Line 2158: apr_byte_t oidc_util_file_write(request_rec *r, const char *path, const char *data) {",
                "// Line 2159: ",
                "// Line 2160:     apr_file_t *fd = NULL;",
                "// Line 2161:     apr_status_t rc = APR_SUCCESS;",
                "// Line 2162:     apr_size_t bytes_written = 0;",
                "// Line 2163:     char s_err[128];",
                "// Line 2164: ",
                "// Line 2165:     /* try to open the metadata file for writing, creating it if it does not exist */",
                "// Line 2166:     if ((rc = apr_file_open(&fd, path, (APR_FOPEN_WRITE | APR_FOPEN_CREATE | APR_FOPEN_TRUNCATE), APR_OS_DEFAULT,",
                "// Line 2167:                 r->pool)) != APR_SUCCESS) {",
                "// Line 2168:         oidc_error(r, \"file \"%s\" could not be opened (%s)\", path, apr_strerror(rc, s_err, sizeof(s_err)));",
                "// Line 2169:         return FALSE;",
                "// vulnerable line: 2170: }",
                "// Line 2171: ",
                "// Line 2172:     /* lock the file and move the write pointer to the start of it */",
                "// Line 2173:     apr_file_lock(fd, APR_FLOCK_EXCLUSIVE);",
                "// Line 2174:     apr_off_t begin = 0;",
                "// Line 2175:     apr_file_seek(fd, APR_SET, &begin);",
                "// Line 2176: ",
                "// Line 2177:     /* calculate the length of the data, which is a string length */",
                "// Line 2178:     apr_size_t len = _oidc_strlen(data);",
                "// Line 2179: ",
                "// Line 2180:     /* (blocking) write the number of bytes in the buffer */",
                "// Line 2181:     rc = apr_file_write_full(fd, data, len, &bytes_written);",
                "// Line 2182: ",
                "// Line 2183:     /* check for a system error */",
                "// Line 2184:     if (rc != APR_SUCCESS) {",
                "// Line 2185:         oidc_error(r, \"could not write to: \"%s\" (%s)\", path, apr_strerror(rc, s_err, sizeof(s_err)));",
                "// Line 2186:         return FALSE;",
                "// vulnerable line: 2187: }",
                "// Line 2188: ",
                "// Line 2189:     /* check that all bytes from the header were written */",
                "// Line 2190:     if (bytes_written != len) {",
                "// Line 2191:         oidc_error(r,",
                "// Line 2192:                \"could not write enough bytes to: \"%s\", bytes_written (%\" APR_SIZE_T_FMT",
                "// Line 2193:                \") != len (%\" APR_SIZE_T_FMT \")\",",
                "// Line 2194:                path, bytes_written, len);",
                "// Line 2195:         return FALSE;",
                "// vulnerable line: 2196: }",
                "// Line 2197: ",
                "// Line 2198:     /* unlock and close the written file */",
                "// Line 2199:     apr_file_unlock(fd);",
                "// Line 2200:     apr_file_close(fd);",
                "// Line 2201: ",
                "// Line 2202:     oidc_debug(r, \"file \"%s\" written; number of bytes (%\" APR_SIZE_T_FMT \")\", path, len);",
                "// Line 2203: ",
                "// Line 2204:     return TRUE;",
                "// vulnerable line: 2205: }",
                "// Line 2206: ",
                "// Line 2207: /*",
                "// Line 2208:  * see if two provided issuer identifiers match (cq. ignore trailing slash)",
                "// Line 2209:  */",
                "// Line 2210: apr_byte_t oidc_util_issuer_match(const char *a, const char *b) {",
                "// Line 2211: ",
                "// Line 2212:     /* check the \"issuer\" value against the one configure for the provider we got this id_token from */",
                "// Line 2213:     if (_oidc_strcmp(a, b) != 0) {",
                "// Line 2214: ",
                "// Line 2215:         /* no strict match, but we are going to accept if the difference is only a trailing slash */",
                "// Line 2216:         int n1 = _oidc_strlen(a);",
                "// Line 2217:         int n2 = _oidc_strlen(b);",
                "// Line 2218:         int n = ((n1 == n2 + 1) && (a[n1 - 1] == OIDC_CHAR_FORWARD_SLASH))",
                "// Line 2219:                 ? n2",
                "// Line 2220:                 : (((n2 == n1 + 1) && (b[n2 - 1] == OIDC_CHAR_FORWARD_SLASH)) ? n1 : 0);",
                "// Line 2221:         if ((n == 0) || (_oidc_strncmp(a, b, n) != 0))",
                "// Line 2222:             return FALSE;",
                "// vulnerable line: 2223: }",
                "// Line 2224: ",
                "// Line 2225:     return TRUE;",
                "// vulnerable line: 2226: }",
                "// Line 2227: ",
                "// Line 2228: /*",
                "// Line 2229:  * see if a certain string value is part of a JSON array with string elements",
                "// Line 2230:  */",
                "// Line 2231: apr_byte_t oidc_util_json_array_has_value(request_rec *r, json_t *haystack, const char *needle) {",
                "// Line 2232: ",
                "// Line 2233:     if ((haystack == NULL) || (!json_is_array(haystack)))",
                "// Line 2234:         return FALSE;",
                "// Line 2235: ",
                "// Line 2236:     int i;",
                "// Line 2237:     for (i = 0; i < json_array_size(haystack); i++) {",
                "// Line 2238:         json_t *elem = json_array_get(haystack, i);",
                "// Line 2239:         if (!json_is_string(elem)) {",
                "// Line 2240:             oidc_error(r, \"unhandled in-array JSON non-string object type [%d]\", elem->type);",
                "// Line 2241:             continue;",
                "// vulnerable line: 2242: }",
                "// Line 2243:         if (_oidc_strcmp(json_string_value(elem), needle) == 0) {",
                "// Line 2244:             break;",
                "// vulnerable line: 2245: }",
                "// vulnerable line: 2246: }",
                "// Line 2247: ",
                "// Line 2248:     /*    oidc_debug(r,",
                "// Line 2249:      *            \"returning (%d=%d)\", i,",
                "// Line 2250:      *            haystack->value.array->nelts);",
                "// Line 2251:      */",
                "// Line 2252: ",
                "// Line 2253:     return (i == json_array_size(haystack)) ? FALSE : TRUE;",
                "// vulnerable line: 2254: }",
                "// Line 2255: ",
                "// Line 2256: static char *oidc_util_utf8_to_latin1(request_rec *r, const char *src) {",
                "// Line 2257:     char *dst = \"\";",
                "// Line 2258:     unsigned int cp = 0;",
                "// Line 2259:     unsigned char ch;",
                "// vulnerable line: 2260: int i = 0;",
                "// Line 2261:     if (src == NULL)",
                "// Line 2262:         return NULL;",
                "// Line 2263:     dst = apr_pcalloc(r->pool, strlen(src) + 1);",
                "// Line 2264:     while (*src != '\u0000') {",
                "// Line 2265:         ch = (unsigned char)(*src);",
                "// Line 2266:         if (ch <= 0x7f)",
                "// Line 2267:             cp = ch;",
                "// Line 2268:         else if (ch <= 0xbf)",
                "// Line 2269:             cp = (cp << 6) | (ch & 0x3f);",
                "// Line 2270:         else if (ch <= 0xdf)",
                "// Line 2271:             cp = ch & 0x1f;",
                "// Line 2272:         else if (ch <= 0xef)",
                "// Line 2273:             cp = ch & 0x0f;",
                "// Line 2274:         else",
                "// Line 2275:             cp = ch & 0x07;",
                "// Line 2276:         ++src;",
                "// Line 2277:         if (((*src & 0xc0) != 0x80) && (cp <= 0x10ffff)) {",
                "// Line 2278:             if (cp <= 255) {",
                "// Line 2279:                 dst[i] = (unsigned char)cp;",
                "// vulnerable line: 2280: } else {",
                "// Line 2281:                 // no encoding possible",
                "// Line 2282:                 dst[i] = '?';",
                "// vulnerable line: 2283: }",
                "// Line 2284:             i++;",
                "// vulnerable line: 2285: }",
                "// vulnerable line: 2286: }",
                "// Line 2287:     dst[i] = '\u0000';",
                "// Line 2288:     return dst;",
                "// vulnerable line: 2289: }",
                "// Line 2290: ",
                "// Line 2291: /*",
                "// Line 2292:  * set a HTTP header and/or environment variable to pass information to the application",
                "// Line 2293:  */",
                "// Line 2294: void oidc_util_set_app_info(request_rec *r, const char *s_key, const char *s_value, const char *claim_prefix,",
                "// Line 2295:                 apr_byte_t as_header, apr_byte_t as_env_var, int pass_as) {",
                "// Line 2296: ",
                "// Line 2297:     /* construct the header name, cq. put the prefix in front of a normalized key name */",
                "// Line 2298:     const char *s_name = apr_psprintf(r->pool, \"%s%s\", claim_prefix, oidc_normalize_header_name(r, s_key));",
                "// Line 2299:     char *d_value = NULL;",
                "// Line 2300: ",
                "// Line 2301:     if (s_value != NULL) {",
                "// Line 2302:         if (pass_as == OIDC_PASS_APP_INFO_AS_BASE64URL) {",
                "// Line 2303:             oidc_base64url_encode(r, &d_value, s_value, _oidc_strlen(s_value), TRUE);",
                "// Line 2304:         } else if (pass_as == OIDC_PASS_APP_INFO_AS_LATIN1) {",
                "// Line 2305:             d_value = oidc_util_utf8_to_latin1(r, s_value);",
                "// vulnerable line: 2306: }",
                "// vulnerable line: 2307: }",
                "// Line 2308: ",
                "// Line 2309:     if (as_header) {",
                "// Line 2310:         oidc_util_hdr_in_set(r, s_name, (d_value != NULL) ? d_value : s_value);",
                "// vulnerable line: 2311: }",
                "// Line 2312: ",
                "// Line 2313:     if (as_env_var) {",
                "// Line 2314: ",
                "// Line 2315:         /* do some logging about this event */",
                "// Line 2316:         oidc_debug(r, \"setting environment variable \"%s: %s\"\", s_name, (d_value != NULL) ? d_value : s_value);",
                "// Line 2317: ",
                "// Line 2318:         apr_table_set(r->subprocess_env, s_name, (d_value != NULL) ? d_value : s_value);",
                "// vulnerable line: 2319: }",
                "// vulnerable line: 2320: }",
                "// Line 2321: ",
                "// Line 2322: /*",
                "// Line 2323:  * set the user/claims information from the session in HTTP headers passed on to the application",
                "// Line 2324:  */",
                "// Line 2325: void oidc_util_set_app_infos(request_rec *r, json_t *j_attrs, const char *claim_prefix, const char *claim_delimiter,",
                "// Line 2326:                  apr_byte_t as_header, apr_byte_t as_env_var, int pass_as) {",
                "// Line 2327: ",
                "// Line 2328:     char s_int[255];",
                "// Line 2329:     json_t *j_value = NULL;",
                "// Line 2330:     const char *s_key = NULL;",
                "// Line 2331: ",
                "// Line 2332:     /* if not attributes are set, nothing needs to be done */",
                "// Line 2333:     if (j_attrs == NULL) {",
                "// Line 2334:         oidc_debug(r, \"no attributes to set\");",
                "// Line 2335:         return;",
                "// vulnerable line: 2336: }",
                "// Line 2337: ",
                "// Line 2338:     /* loop over the claims in the JSON structure */",
                "// Line 2339:     void *iter = json_object_iter((json_t *)j_attrs);",
                "// Line 2340:     while (iter) {",
                "// Line 2341: ",
                "// Line 2342:         /* get the next key/value entry */",
                "// Line 2343:         s_key = json_object_iter_key(iter);",
                "// Line 2344:         j_value = json_object_iter_value(iter);",
                "// Line 2345: ",
                "// Line 2346:         //        char *s_value= json_dumps(j_value, JSON_ENCODE_ANY);",
                "// Line 2360:             /* set boolean value in the application header whose name is based on the key and the prefix */",
                "// Line 2361:             oidc_util_set_app_info(r, s_key, (json_is_true(j_value) ? \"1\" : \"0\"), claim_prefix, as_header,",
                "// Line 2362:                            as_env_var, pass_as);",
                "// Line 2363: ",
                "// Line 2364:         } else if (json_is_integer(j_value)) {",
                "// Line 2365: ",
                "// Line 2366:             if (snprintf(s_int, 255, \"%ld\", (long)json_integer_value(j_value)) > 0) {",
                "// Line 2367:                 /* set long value in the application header whose name is based on the key and the",
                "// Line 2368:                  * prefix */",
                "// Line 2369:                 oidc_util_set_app_info(r, s_key, s_int, claim_prefix, as_header, as_env_var, pass_as);",
                "// vulnerable line: 2370: } else {",
                "// Line 2371:                 oidc_warn(r, \"could not convert JSON number to string (> 255 characters?), skipping\");",
                "// vulnerable line: 2372: }",
                "// Line 2373: ",
                "// Line 2374:         } else if (json_is_real(j_value)) {",
                "// Line 2375: ",
                "// Line 2376:             /* set float value in the application header whose name is based on the key and the prefix */",
                "// Line 2377:             oidc_util_set_app_info(r, s_key, apr_psprintf(r->pool, \"%lf\", json_real_value(j_value)),",
                "// Line 2378:                            claim_prefix, as_header, as_env_var, pass_as);",
                "// Line 2379: ",
                "// Line 2380:         } else if (json_is_object(j_value)) {",
                "// Line 2381: ",
                "// Line 2382:             /* set json value in the application header whose name is based on the key and the prefix */",
                "// Line 2403:                 /* check if it is a string */",
                "// Line 2404:                 if (json_is_string(elem)) {",
                "// Line 2405: ",
                "// Line 2406:                     /* concatenate the string to the s_concat value using the configured separator",
                "// Line 2407:                      * char */",
                "// Line 2408:                     // TODO: escape the delimiter in the values (maybe reuse/extract url-formatted",
                "// Line 2409:                     // code from oidc_session_identity_encode)",
                "// Line 2410:                     if (_oidc_strcmp(s_concat, \"\") != 0) {",
                "// Line 2411:                         s_concat = apr_psprintf(r->pool, \"%s%s%s\", s_concat, claim_delimiter,",
                "// Line 2412:                                     json_string_value(elem));",
                "// vulnerable line: 2413: } else {",
                "// Line 2414:                         s_concat = apr_psprintf(r->pool, \"%s\", json_string_value(elem));",
                "// vulnerable line: 2415: }",
                "// Line 2416: ",
                "// Line 2417:                 } else if (json_is_boolean(elem)) {",
                "// Line 2418: ",
                "// Line 2419:                     if (_oidc_strcmp(s_concat, \"\") != 0) {",
                "// Line 2420:                         s_concat = apr_psprintf(r->pool, \"%s%s%s\", s_concat, claim_delimiter,",
                "// Line 2421:                                     json_is_true(elem) ? \"1\" : \"0\");",
                "// vulnerable line: 2422: } else {",
                "// Line 2423:                         s_concat = apr_psprintf(r->pool, \"%s\", json_is_true(elem) ? \"1\" : \"0\");",
                "// vulnerable line: 2424: }",
                "// Line 2425: ",
                "// vulnerable line: 2426: } else {",
                "// Line 2427: ",
                "// Line 2428:                     /* don't know how to handle a non-string array element */",
                "// Line 2429:                     oidc_warn(r,",
                "// Line 2430:                           \"unhandled in-array JSON object type [%d] for key \"%s\" when \"",
                "// Line 2431:                           \"parsing claims array elements\",",
                "// Line 2432:                           elem->type, s_key);",
                "// vulnerable line: 2433: }",
                "// vulnerable line: 2434: }",
                "// Line 2435: ",
                "// Line 2436:             /* set the concatenated string */",
                "// Line 2437:             oidc_util_set_app_info(r, s_key, s_concat, claim_prefix, as_header, as_env_var, pass_as);",
                "// Line 2438: ",
                "// vulnerable line: 2439: } else {",
                "// Line 2440: ",
                "// Line 2441:             /* no string and no array, so unclear how to handle this */",
                "// Line 2442:             oidc_warn(r, \"unhandled JSON object type [%d] for key \"%s\" when parsing claims\",",
                "// Line 2443:                   j_value->type, s_key);",
                "// vulnerable line: 2444: }",
                "// Line 2445: ",
                "// Line 2446:         iter = json_object_iter_next(j_attrs, iter);",
                "// vulnerable line: 2447: }",
                "// vulnerable line: 2448: }",
                "// Line 2449: ",
                "// Line 2450: /*",
                "// Line 2451:  * parse a space separated string in to a hash table",
                "// Line 2452:  */",
                "// Line 2453: apr_hash_t *oidc_util_spaced_string_to_hashtable(apr_pool_t *pool, const char *str) {",
                "// Line 2454:     char *val;",
                "// Line 2455:     const char *data = apr_pstrdup(pool, str);",
                "// Line 2456:     apr_hash_t *result = apr_hash_make(pool);",
                "// Line 2457:     while (*data && (val = ap_getword_white(pool, &data))) {",
                "// Line 2458:         apr_hash_set(result, val, APR_HASH_KEY_STRING, val);",
                "// vulnerable line: 2459: }",
                "// Line 2460:     return result;",
                "// vulnerable line: 2461: }",
                "// Line 2462: ",
                "// Line 2463: /*",
                "// Line 2464:  * compare two space separated value types",
                "// Line 2465:  */",
                "// Line 2466: apr_byte_t oidc_util_spaced_string_equals(apr_pool_t *pool, const char *a, const char *b) {",
                "// Line 2467: ",
                "// Line 2468:     /* parse both entries as hash tables */",
                "// Line 2469:     apr_hash_t *ht_a = oidc_util_spaced_string_to_hashtable(pool, a);",
                "// Line 2470:     apr_hash_t *ht_b = oidc_util_spaced_string_to_hashtable(pool, b);",
                "// Line 2471: ",
                "// Line 2474:         return FALSE;",
                "// Line 2475: ",
                "// Line 2476:     /* then loop over all entries */",
                "// Line 2477:     apr_hash_index_t *hi;",
                "// Line 2478:     for (hi = apr_hash_first(NULL, ht_a); hi; hi = apr_hash_next(hi)) {",
                "// Line 2479:         const char *k;",
                "// Line 2480:         const char *v;",
                "// Line 2481:         apr_hash_this(hi, (const void **)&k, NULL, (void **)&v);",
                "// Line 2482:         if (apr_hash_get(ht_b, k, APR_HASH_KEY_STRING) == NULL)",
                "// Line 2483:             return FALSE;",
                "// vulnerable line: 2484: }",
                "// Line 2485: ",
                "// Line 2486:     /* if we've made it this far, a an b are equal in length and every element in a is in b */",
                "// Line 2487:     return TRUE;",
                "// vulnerable line: 2488: }",
                "// Line 2489: ",
                "// Line 2490: /*",
                "// Line 2491:  * see if a particular value is part of a space separated value",
                "// Line 2492:  */",
                "// Line 2493: apr_byte_t oidc_util_spaced_string_contains(apr_pool_t *pool, const char *str, const char *match) {",
                "// Line 2494:     apr_hash_t *ht = oidc_util_spaced_string_to_hashtable(pool, str);",
                "// Line 2495:     return (apr_hash_get(ht, match, APR_HASH_KEY_STRING) != NULL);",
                "// vulnerable line: 2496: }",
                "// Line 2497: ",
                "// Line 2498: /*",
                "// Line 2499:  * get (optional) string from a JSON object",
                "// Line 2500:  */",
                "// Line 2501: apr_byte_t oidc_json_object_get_string(apr_pool_t *pool, json_t *json, const char *name, char **value,",
                "// Line 2502:                        const char *default_value) {",
                "// Line 2503:     *value = default_value ? apr_pstrdup(pool, default_value) : NULL;",
                "// Line 2504:     if (json != NULL) {",
                "// Line 2505:         json_t *v = json_object_get(json, name);",
                "// Line 2506:         if ((v != NULL) && (json_is_string(v))) {",
                "// Line 2507:             *value = apr_pstrdup(pool, json_string_value(v));",
                "// vulnerable line: 2508: }",
                "// vulnerable line: 2509: }",
                "// Line 2510:     return TRUE;",
                "// vulnerable line: 2511: }",
                "// Line 2512: ",
                "// Line 2513: /*",
                "// Line 2514:  * get (optional) int from a JSON object",
                "// Line 2515:  */",
                "// Line 2516: apr_byte_t oidc_json_object_get_int(const json_t *json, const char *name, int *value, const int default_value) {",
                "// Line 2517:     const json_t *v = NULL;",
                "// Line 2518:     *value = default_value;",
                "// Line 2519:     if (json != NULL) {",
                "// Line 2520:         v = json_object_get(json, name);",
                "// Line 2521:         if ((v != NULL) && (json_is_integer(v))) {",
                "// Line 2522:             *value = json_integer_value(v);",
                "// vulnerable line: 2523: }",
                "// vulnerable line: 2524: }",
                "// Line 2525:     return TRUE;",
                "// vulnerable line: 2526: }",
                "// Line 2527: ",
                "// Line 2528: /*",
                "// Line 2529:  * get (optional) boolean from a JSON object",
                "// Line 2530:  */",
                "// Line 2531: apr_byte_t oidc_json_object_get_bool(const json_t *json, const char *name, int *value, const int default_value) {",
                "// Line 2532:     const json_t *v = NULL;",
                "// Line 2533:     *value = default_value;",
                "// Line 2534:     if (json != NULL) {",
                "// Line 2535:         v = json_object_get(json, name);",
                "// Line 2536:         if ((v != NULL) && (json_is_boolean(v))) {",
                "// Line 2537:             *value = json_is_true(v);",
                "// Line 2538:             return TRUE;",
                "// vulnerable line: 2539: }",
                "// vulnerable line: 2540: }",
                "// Line 2541:     return FALSE;",
                "// vulnerable line: 2542: }",
                "// Line 2543: ",
                "// Line 2544: /*",
                "// Line 2545:  * merge two JSON objects",
                "// Line 2546:  */",
                "// Line 2547: apr_byte_t oidc_util_json_merge(request_rec *r, json_t *src, json_t *dst) {",
                "// Line 2548: ",
                "// Line 2549:     const char *key;",
                "// Line 2550:     json_t *value = NULL;",
                "// Line 2551:     void *iter = NULL;",
                "// Line 2552: ",
                "// Line 2555: ",
                "// Line 2556:     oidc_debug(r, \"src=%s, dst=%s\", oidc_util_encode_json_object(r, src, JSON_COMPACT),",
                "// Line 2557:            oidc_util_encode_json_object(r, dst, JSON_COMPACT));",
                "// Line 2558: ",
                "// Line 2559:     iter = json_object_iter(src);",
                "// Line 2560:     while (iter) {",
                "// Line 2561:         key = json_object_iter_key(iter);",
                "// Line 2562:         value = json_object_iter_value(iter);",
                "// Line 2563:         json_object_set(dst, key, value);",
                "// Line 2564:         iter = json_object_iter_next(src, iter);",
                "// vulnerable line: 2565: }",
                "// Line 2566: ",
                "// Line 2567:     oidc_debug(r, \"result dst=%s\", oidc_util_encode_json_object(r, dst, JSON_COMPACT));",
                "// Line 2568: ",
                "// Line 2569:     return TRUE;",
                "// vulnerable line: 2570: }",
                "// Line 2571: ",
                "// Line 2572: /*",
                "// Line 2573:  * add query encoded parameters to a table",
                "// Line 2574:  */",
                "// Line 2575: void oidc_util_table_add_query_encoded_params(apr_pool_t *pool, apr_table_t *table, const char *params) {",
                "// Line 2576:     if (params != NULL) {",
                "// Line 2577:         char *key = NULL;",
                "// Line 2578:         const char *val = NULL;",
                "// Line 2579:         const char *p = params;",
                "// Line 2580:         while (*p && (val = ap_getword(pool, &p, OIDC_CHAR_AMP))) {",
                "// Line 2581:             key = ap_getword(pool, &val, OIDC_CHAR_EQUAL);",
                "// Line 2582:             ap_unescape_url((char *)key);",
                "// Line 2583:             ap_unescape_url((char *)val);",
                "// Line 2584:             apr_table_add(table, key, val);",
                "// vulnerable line: 2585: }",
                "// vulnerable line: 2586: }",
                "// vulnerable line: 2587: }",
                "// Line 2588: ",
                "// Line 2589: /*",
                "// Line 2590:  * create a symmetric key from a client_secret",
                "// Line 2591:  */",
                "// Line 2592: apr_byte_t oidc_util_create_symmetric_key(request_rec *r, const char *client_secret, unsigned int r_key_len,",
                "// Line 2593:                       const char *hash_algo, apr_byte_t set_kid, oidc_jwk_t **jwk) {",
                "// Line 2594:     oidc_jose_error_t err;",
                "// Line 2595:     unsigned char *key = NULL;",
                "// Line 2596:     unsigned int key_len;",
                "// Line 2597: ",
                "// Line 2598:     if ((client_secret != NULL) && (_oidc_strlen(client_secret) > 0)) {",
                "// Line 2599: ",
                "// Line 2600:         if (hash_algo == NULL) {",
                "// Line 2601:             key = (unsigned char *)client_secret;",
                "// Line 2602:             key_len = _oidc_strlen(client_secret);",
                "// vulnerable line: 2603: } else {",
                "// Line 2604:             /* hash the client_secret first, this is OpenID Connect specific */",
                "// Line 2605:             oidc_jose_hash_bytes(r->pool, hash_algo, (const unsigned char *)client_secret,",
                "// Line 2606:                          _oidc_strlen(client_secret), &key, &key_len, &err);",
                "// vulnerable line: 2607: }",
                "// Line 2608: ",
                "// Line 2609:         if ((key != NULL) && (key_len > 0)) {",
                "// Line 2610:             if ((r_key_len != 0) && (key_len >= r_key_len))",
                "// Line 2611:                 key_len = r_key_len;",
                "// Line 2612:             oidc_debug(r, \"key_len=%d\", key_len);",
                "// Line 2613:             *jwk = oidc_jwk_create_symmetric_key(r->pool, NULL, key, key_len, set_kid, &err);",
                "// vulnerable line: 2614: }",
                "// Line 2615: ",
                "// Line 2616:         if (*jwk == NULL) {",
                "// Line 2617:             oidc_error(r, \"could not create JWK from the provided secret: %s\", oidc_jose_e2s(r->pool, err));",
                "// Line 2618:             return FALSE;",
                "// vulnerable line: 2619: }",
                "// vulnerable line: 2620: }",
                "// Line 2621: ",
                "// Line 2622:     return TRUE;",
                "// vulnerable line: 2623: }",
                "// Line 2624: ",
                "// Line 2625: /*",
                "// Line 2626:  * merge provided keys and client secret in to a single hashtable",
                "// Line 2627:  */",
                "// Line 2628: apr_hash_t *oidc_util_merge_symmetric_key(apr_pool_t *pool, const apr_array_header_t *keys, oidc_jwk_t *jwk) {",
                "// Line 2629:     apr_hash_t *result = apr_hash_make(pool);",
                "// Line 2630:     const oidc_jwk_t *elem = NULL;",
                "// vulnerable line: 2631: int i = 0;",
                "// Line 2632:     if (keys != NULL) {",
                "// Line 2633:         for (i = 0; i < keys->nelts; i++) {",
                "// Line 2634:             elem = APR_ARRAY_IDX(keys, i, oidc_jwk_t *);",
                "// Line 2635:             apr_hash_set(result, elem->kid, APR_HASH_KEY_STRING, elem);",
                "// vulnerable line: 2636: }",
                "// vulnerable line: 2637: }",
                "// Line 2638:     if (jwk != NULL) {",
                "// Line 2639:         apr_hash_set(result, jwk->kid, APR_HASH_KEY_STRING, jwk);",
                "// vulnerable line: 2640: }",
                "// Line 2641:     return result;",
                "// vulnerable line: 2642: }",
                "// Line 2643: ",
                "// Line 2644: /*",
                "// Line 2645:  * openssl hash and base64 encode",
                "// Line 2646:  */",
                "// Line 2647: apr_byte_t oidc_util_hash_string_and_base64url_encode(request_rec *r, const char *openssl_hash_algo, const char *input,",
                "// Line 2648:                               char **output) {",
                "// Line 2649:     oidc_jose_error_t err;",
                "// Line 2650:     unsigned char *hashed = NULL;",
                "// Line 2651:     unsigned int hashed_len = 0;",
                "// Line 2652:     if (oidc_jose_hash_bytes(r->pool, openssl_hash_algo, (const unsigned char *)input, _oidc_strlen(input), &hashed,",
                "// Line 2653:                  &hashed_len, &err) == FALSE) {",
                "// Line 2654:         oidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);",
                "// Line 2655:         return FALSE;",
                "// vulnerable line: 2656: }",
                "// Line 2657: ",
                "// Line 2658:     if (oidc_base64url_encode(r, output, (const char *)hashed, hashed_len, TRUE) <= 0) {",
                "// Line 2659:         oidc_error(r, \"oidc_base64url_encode returned an error: %s\", err.text);",
                "// Line 2660:         return FALSE;",
                "// vulnerable line: 2661: }",
                "// Line 2662:     return TRUE;",
                "// vulnerable line: 2663: }",
                "// Line 2664: ",
                "// Line 2665: /*",
                "// Line 2666:  * merge two key sets",
                "// Line 2667:  */",
                "// Line 2668: apr_hash_t *oidc_util_merge_key_sets(apr_pool_t *pool, apr_hash_t *k1, const apr_array_header_t *k2) {",
                "// Line 2669:     apr_hash_t *rv = k1 ? apr_hash_copy(pool, k1) : apr_hash_make(pool);",
                "// Line 2670:     const oidc_jwk_t *jwk = NULL;",
                "// vulnerable line: 2671: int i = 0;",
                "// Line 2672:     if (k2 != NULL) {",
                "// Line 2673:         for (i = 0; i < k2->nelts; i++) {",
                "// Line 2674:             jwk = APR_ARRAY_IDX(k2, i, oidc_jwk_t *);",
                "// Line 2675:             apr_hash_set(rv, jwk->kid, APR_HASH_KEY_STRING, jwk);",
                "// vulnerable line: 2676: }",
                "// vulnerable line: 2677: }",
                "// Line 2678:     return rv;",
                "// vulnerable line: 2679: }",
                "// Line 2680: ",
                "// Line 2681: apr_hash_t *oidc_util_merge_key_sets_hash(apr_pool_t *pool, apr_hash_t *k1, apr_hash_t *k2) {",
                "// Line 2682:     if (k1 == NULL) {",
                "// Line 2683:         if (k2 == NULL)",
                "// Line 2684:             return apr_hash_make(pool);",
                "// Line 2685:         return k2;",
                "// vulnerable line: 2686: }",
                "// Line 2687:     if (k2 == NULL)",
                "// Line 2688:         return k1;",
                "// Line 2689:     return apr_hash_overlay(pool, k1, k2);",
                "// vulnerable line: 2690: }",
                "// Line 2691: ",
                "// Line 2692: /*",
                "// Line 2693:  * regexp substitute",
                "// Line 2694:  *   Example:",
                "// Line 2695:  *     regex: \"^.*([0-9]+).*$\"",
                "// Line 2696:  *     replace: \"$1\"",
                "// Line 2697:  *     text_original: \"match 292 numbers\"",
                "// Line 2698:  *     text_replaced: \"292\"",
                "// Line 2699:  */",
                "// Line 2700: apr_byte_t oidc_util_regexp_substitute(apr_pool_t *pool, const char *input, const char *regexp, const char *replace,",
                "// Line 2701:                        char **output, char **error_str) {",
                "// Line 2702: ",
                "// Line 2703:     char *substituted = NULL;",
                "// Line 2704:     apr_byte_t rc = FALSE;",
                "// Line 2705: ",
                "// Line 2706:     struct oidc_pcre *preg = oidc_pcre_compile(pool, regexp, error_str);",
                "// Line 2707:     if (preg == NULL) {",
                "// Line 2708:         *error_str =",
                "// Line 2709:             apr_psprintf(pool, \"pattern [%s] is not a valid regular expression: %s\", regexp, *error_str);",
                "// Line 2710:         goto out;",
                "// vulnerable line: 2711: }",
                "// Line 2712: ",
                "// Line 2713:     if (_oidc_strlen(input) >= OIDC_PCRE_MAXCAPTURE - 1) {",
                "// Line 2714:         *error_str =",
                "// Line 2715:             apr_psprintf(pool, \"string length (%d) is larger than the maximum allowed for pcre_subst (%d)\",",
                "// Line 2716:                  (int)_oidc_strlen(input), OIDC_PCRE_MAXCAPTURE - 1);",
                "// Line 2717:         goto out;",
                "// vulnerable line: 2718: }",
                "// Line 2719: ",
                "// Line 2720:     substituted = oidc_pcre_subst(pool, preg, input, (int)_oidc_strlen(input), replace);",
                "// Line 2721:     if (substituted == NULL) {",
                "// Line 2722:         *error_str = apr_psprintf(",
                "// Line 2723:             pool, \"unknown error could not match string [%s] using pattern [%s] and replace matches in [%s]\",",
                "// Line 2724:             input, regexp, replace);",
                "// Line 2725:         goto out;",
                "// vulnerable line: 2726: }",
                "// Line 2727: ",
                "// Line 2728:     *output = apr_pstrdup(pool, substituted);",
                "// Line 2729:     rc = TRUE;",
                "// Line 2730: ",
                "// Line 2731: out:",
                "// Line 2732: ",
                "// Line 2733:     if (preg)",
                "// Line 2734:         oidc_pcre_free(preg);",
                "// Line 2735: ",
                "// Line 2736:     return rc;",
                "// vulnerable line: 2737: }",
                "// Line 2738: ",
                "// Line 2739: /*",
                "// Line 2740:  * regexp match",
                "// Line 2741:  */",
                "// Line 2742: ",
                "// Line 2743: apr_byte_t oidc_util_regexp_first_match(apr_pool_t *pool, const char *input, const char *regexp, char **output,",
                "// Line 2744:                     char **error_str) {",
                "// Line 2745:     apr_byte_t rv = FALSE;",
                "// Line 2746:     int rc = 0;",
                "// Line 2747: ",
                "// Line 2748:     struct oidc_pcre *preg = oidc_pcre_compile(pool, regexp, error_str);",
                "// Line 2749:     if (preg == NULL) {",
                "// Line 2750:         *error_str =",
                "// Line 2751:             apr_psprintf(pool, \"pattern [%s] is not a valid regular expression: %s\", regexp, *error_str);",
                "// Line 2752:         goto out;",
                "// vulnerable line: 2753: }",
                "// Line 2754: ",
                "// Line 2755:     if ((rc = oidc_pcre_exec(pool, preg, input, (int)_oidc_strlen(input), error_str)) < 0)",
                "// Line 2756:         goto out;",
                "// Line 2757: ",
                "// Line 2758:     if (output && (oidc_pcre_get_substring(pool, preg, input, rc, output, error_str) <= 0)) {",
                "// Line 2759:         *error_str = apr_psprintf(pool, \"pcre_get_substring failed: %s\", *error_str);",
                "// Line 2760:         goto out;",
                "// vulnerable line: 2761: }",
                "// Line 2762: ",
                "// Line 2763:     rv = TRUE;",
                "// Line 2764: ",
                "// Line 2765: out:",
                "// Line 2766: ",
                "// Line 2767:     if (preg)",
                "// Line 2768:         oidc_pcre_free(preg);",
                "// Line 2769: ",
                "// Line 2770:     return rv;",
                "// vulnerable line: 2771: }",
                "// Line 2772: ",
                "// Line 2773: int oidc_util_cookie_domain_valid(const char *hostname, char *cookie_domain) {",
                "// Line 2774:     char *p = NULL;",
                "// Line 2775:     char *check_cookie = cookie_domain;",
                "// Line 2776:     // Skip past the first char of a cookie_domain that starts",
                "// Line 2777:     // with a \".\", ASCII 46",
                "// Line 2778:     if (check_cookie[0] == 46)",
                "// Line 2779:         check_cookie++;",
                "// Line 2780:     p = strstr(hostname, check_cookie);",
                "// Line 2781: ",
                "// Line 2782:     if ((p == NULL) || (_oidc_strcmp(check_cookie, p) != 0)) {",
                "// Line 2783:         return FALSE;",
                "// vulnerable line: 2784: }",
                "// Line 2785:     return TRUE;",
                "// vulnerable line: 2786: }",
                "// Line 2787: ",
                "// Line 2788: static const char *oidc_util_hdr_in_get(const request_rec *r, const char *name) {",
                "// Line 2789:     const char *value = apr_table_get(r->headers_in, name);",
                "// Line 2790:     if (value)",
                "// Line 2791:         oidc_debug(r, \"%s=%s\", name, value);",
                "// Line 2792:     return value;",
                "// vulnerable line: 2793: }",
                "// Line 2794: ",
                "// Line 2795: static const char *oidc_util_hdr_in_get_left_most_only(const request_rec *r, const char *name, const char *separator) {",
                "// Line 2796:     char *last = NULL;",
                "// Line 2797:     const char *value = oidc_util_hdr_in_get(r, name);",
                "// Line 2798:     if (value)",
                "// Line 2799:         return apr_strtok(apr_pstrdup(r->pool, value), separator, &last);",
                "// Line 2800:     return NULL;",
                "// vulnerable line: 2801: }",
                "// Line 2802: ",
                "// Line 2803: static apr_byte_t oidc_util_hdr_in_contains(const request_rec *r, const char *name, const char *separator,",
                "// Line 2804:                         const char postfix_separator, const char *needle) {",
                "// Line 2805:     char *ctx = NULL, *elem = NULL;",
                "// Line 2806:     const char *value = oidc_util_hdr_in_get(r, name);",
                "// Line 2807:     apr_byte_t rc = FALSE;",
                "// Line 2808:     if (value) {",
                "// Line 2809:         elem = apr_strtok(apr_pstrdup(r->pool, value), separator, &ctx);",
                "// Line 2810:         while (elem != NULL) {",
                "// Line 2811:             while (*elem == OIDC_CHAR_SPACE)",
                "// Line 2812:                 elem++;",
                "// Line 2813:             if ((_oidc_strncmp(elem, needle, _oidc_strlen(needle)) == 0) &&",
                "// Line 2814:                 ((elem[_oidc_strlen(needle)] == '\u0000') ||",
                "// Line 2815:                  (elem[_oidc_strlen(needle)] == postfix_separator))) {",
                "// Line 2816:                 rc = TRUE;",
                "// Line 2817:                 break;",
                "// vulnerable line: 2818: }",
                "// Line 2819:             elem = apr_strtok(NULL, separator, &ctx);",
                "// vulnerable line: 2820: }",
                "// vulnerable line: 2821: }",
                "// Line 2822:     return rc;",
                "// vulnerable line: 2823: }",
                "// Line 2824: ",
                "// Line 2825: static void oidc_util_hdr_table_set(const request_rec *r, apr_table_t *table, const char *name, const char *value) {",
                "// Line 2826: ",
                "// Line 2827:     if (value != NULL) {",
                "// Line 2828: ",
                "// Line 2829:         char *s_value = apr_pstrdup(r->pool, value);",
                "// Line 2830: ",
                "// Line 2831:         /*",
                "// Line 2832:          * sanitize the header value by replacing line feeds with spaces",
                "// Line 2833:          * just like the Apache header input algorithms do for incoming headers",
                "// Line 2838:          * overwriting/setting outgoing headers when used in proxy mode",
                "// Line 2839:          */",
                "// Line 2840:         char *p = NULL;",
                "// Line 2841:         while ((p = strchr(s_value, '",
                "// Line 2842: ')))",
                "// Line 2843:             *p = OIDC_CHAR_SPACE;",
                "// Line 2844: ",
                "// Line 2845:         oidc_debug(r, \"%s: %s\", name, s_value);",
                "// Line 2846:         apr_table_set(table, name, s_value);",
                "// Line 2847: ",
                "// vulnerable line: 2848: } else {",
                "// Line 2849: ",
                "// Line 2850:         oidc_debug(r, \"unset %s\", name);",
                "// Line 2851:         apr_table_unset(table, name);",
                "// vulnerable line: 2852: }",
                "// vulnerable line: 2853: }",
                "// Line 2854: ",
                "// Line 2855: static void oidc_util_hdr_out_set(const request_rec *r, const char *name, const char *value) {",
                "// Line 2856:     oidc_util_hdr_table_set(r, r->headers_out, name, value);",
                "// vulnerable line: 2857: }",
                "// Line 2858: ",
                "// Line 2859: static const char *oidc_util_hdr_out_get(const request_rec *r, const char *name) {",
                "// Line 2860:     return apr_table_get(r->headers_out, name);",
                "// vulnerable line: 2861: }",
                "// Line 2862: ",
                "// Line 2863: void oidc_util_hdr_err_out_add(const request_rec *r, const char *name, const char *value) {",
                "// Line 2864:     oidc_debug(r, \"%s: %s\", name, value);",
                "// Line 2865:     apr_table_add(r->err_headers_out, name, value);",
                "// vulnerable line: 2866: }",
                "// Line 2867: ",
                "// Line 2868: void oidc_util_hdr_in_set(const request_rec *r, const char *name, const char *value) {",
                "// Line 2869:     oidc_util_hdr_table_set(r, r->headers_in, name, value);",
                "// vulnerable line: 2870: }",
                "// Line 2871: ",
                "// Line 2872: const char *oidc_util_hdr_in_cookie_get(const request_rec *r) {",
                "// Line 2873:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_COOKIE);",
                "// vulnerable line: 2874: }",
                "// Line 2875: ",
                "// Line 2876: void oidc_util_hdr_in_cookie_set(const request_rec *r, const char *value) {",
                "// Line 2877:     oidc_util_hdr_in_set(r, OIDC_HTTP_HDR_COOKIE, value);",
                "// vulnerable line: 2878: }",
                "// Line 2879: ",
                "// Line 2880: const char *oidc_util_hdr_in_user_agent_get(const request_rec *r) {",
                "// Line 2881:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_USER_AGENT);",
                "// vulnerable line: 2882: }",
                "// Line 2883: ",
                "// Line 2884: const char *oidc_util_hdr_in_x_forwarded_for_get(const request_rec *r) {",
                "// Line 2885:     return oidc_util_hdr_in_get_left_most_only(r, OIDC_HTTP_HDR_X_FORWARDED_FOR, OIDC_STR_COMMA OIDC_STR_SPACE);",
                "// vulnerable line: 2886: }",
                "// Line 2887: ",
                "// Line 2888: const char *oidc_util_hdr_in_content_type_get(const request_rec *r) {",
                "// Line 2889:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_CONTENT_TYPE);",
                "// vulnerable line: 2890: }",
                "// Line 2891: ",
                "// Line 2892: const char *oidc_util_hdr_in_content_length_get(const request_rec *r) {",
                "// Line 2893:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_CONTENT_LENGTH);",
                "// vulnerable line: 2894: }",
                "// Line 2895: ",
                "// Line 2896: const char *oidc_util_hdr_in_x_requested_with_get(const request_rec *r) {",
                "// Line 2897:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_X_REQUESTED_WITH);",
                "// vulnerable line: 2898: }",
                "// Line 2899: ",
                "// Line 2900: const char *oidc_util_hdr_in_sec_fetch_mode_get(const request_rec *r) {",
                "// Line 2901:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_SEC_FETCH_MODE);",
                "// vulnerable line: 2902: }",
                "// Line 2903: ",
                "// Line 2904: const char *oidc_util_hdr_in_sec_fetch_dest_get(const request_rec *r) {",
                "// Line 2905:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_SEC_FETCH_DEST);",
                "// vulnerable line: 2906: }",
                "// Line 2907: ",
                "// Line 2908: const char *oidc_util_hdr_in_accept_get(const request_rec *r) {",
                "// Line 2909:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_ACCEPT);",
                "// vulnerable line: 2910: }",
                "// Line 2911: ",
                "// Line 2912: apr_byte_t oidc_util_hdr_in_accept_contains(const request_rec *r, const char *needle) {",
                "// Line 2913:     return oidc_util_hdr_in_contains(r, OIDC_HTTP_HDR_ACCEPT, OIDC_STR_COMMA, OIDC_CHAR_SEMI_COLON, needle);",
                "// vulnerable line: 2914: }",
                "// Line 2915: ",
                "// Line 2916: const char *oidc_util_hdr_in_authorization_get(const request_rec *r) {",
                "// Line 2917:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_AUTHORIZATION);",
                "// vulnerable line: 2918: }",
                "// Line 2919: ",
                "// Line 2920: const char *oidc_util_hdr_in_x_forwarded_proto_get(const request_rec *r) {",
                "// Line 2921:     return oidc_util_hdr_in_get_left_most_only(r, OIDC_HTTP_HDR_X_FORWARDED_PROTO, OIDC_STR_COMMA OIDC_STR_SPACE);",
                "// vulnerable line: 2922: }",
                "// Line 2923: ",
                "// Line 2924: const char *oidc_util_hdr_in_x_forwarded_port_get(const request_rec *r) {",
                "// Line 2925:     return oidc_util_hdr_in_get_left_most_only(r, OIDC_HTTP_HDR_X_FORWARDED_PORT, OIDC_STR_COMMA OIDC_STR_SPACE);",
                "// vulnerable line: 2926: }",
                "// Line 2927: ",
                "// Line 2928: const char *oidc_util_hdr_in_x_forwarded_host_get(const request_rec *r) {",
                "// Line 2929:     return oidc_util_hdr_in_get_left_most_only(r, OIDC_HTTP_HDR_X_FORWARDED_HOST, OIDC_STR_COMMA OIDC_STR_SPACE);",
                "// vulnerable line: 2930: }",
                "// Line 2931: ",
                "// Line 2932: const char *oidc_util_hdr_in_forwarded_get(const request_rec *r) {",
                "// Line 2933:     return oidc_util_hdr_in_get_left_most_only(r, OIDC_HTTP_HDR_FORWARDED, OIDC_STR_COMMA);",
                "// vulnerable line: 2934: }",
                "// Line 2935: ",
                "// Line 2936: const char *oidc_util_hdr_in_host_get(const request_rec *r) {",
                "// Line 2937:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_HOST);",
                "// vulnerable line: 2938: }",
                "// Line 2939: ",
                "// Line 2940: const char *oidc_util_hdr_in_traceparent_get(const request_rec *r) {",
                "// Line 2941:     return oidc_util_hdr_in_get(r, OIDC_HTTP_HDR_TRACE_PARENT);",
                "// vulnerable line: 2942: }",
                "// Line 2943: ",
                "// Line 2944: void oidc_util_hdr_out_location_set(const request_rec *r, const char *value) {",
                "// Line 2945:     oidc_util_hdr_out_set(r, OIDC_HTTP_HDR_LOCATION, value);",
                "// vulnerable line: 2946: }",
                "// Line 2947: ",
                "// Line 2948: const char *oidc_util_hdr_out_location_get(const request_rec *r) {",
                "// Line 2949:     return oidc_util_hdr_out_get(r, OIDC_HTTP_HDR_LOCATION);",
                "// vulnerable line: 2950: }",
                "// Line 2951: ",
                "// Line 2952: oidc_jwk_t *oidc_util_key_list_first(const apr_array_header_t *key_list, int kty, const char *use) {",
                "// Line 2953:     oidc_jwk_t *rv = NULL;",
                "// vulnerable line: 2954: int i = 0;",
                "// Line 2955:     oidc_jwk_t *jwk = NULL;",
                "// Line 2956:     for (i = 0; (key_list) && (i < key_list->nelts); i++) {",
                "// Line 2957:         jwk = APR_ARRAY_IDX(key_list, i, oidc_jwk_t *);",
                "// Line 2958:         if ((kty != -1) && (jwk->kty != kty))",
                "// Line 2959:             continue;",
                "// Line 2960:         if (((use == NULL) || (jwk->use == NULL) || (_oidc_strncmp(jwk->use, use, _oidc_strlen(use)) == 0))) {",
                "// Line 2961:             rv = jwk;",
                "// Line 2962:             break;",
                "// vulnerable line: 2963: }",
                "// vulnerable line: 2964: }",
                "// Line 2965:     return rv;",
                "// vulnerable line: 2966: }",
                "// Line 2967: ",
                "// Line 2968: #ifdef USE_LIBJQ",
                "// Line 2969: ",
                "// Line 2970: static const char *oidc_util_jq_exec(request_rec *r, jq_state *jq, struct jv_parser *parser) {",
                "// Line 2971:     const char *rv = NULL;",
                "// Line 2972:     jv value, elem, str, msg;",
                "// Line 2973: ",
                "// Line 2974:     while (jv_is_valid((value = jv_parser_next(parser)))) {",
                "// Line 2975:         jq_start(jq, value, 0);",
                "// Line 2976:         while (jv_is_valid(elem = jq_next(jq))) {",
                "// Line 2977:             str = jv_dump_string(elem, 0);",
                "// Line 2978:             rv = apr_pstrdup(r->pool, jv_string_value(str));",
                "// Line 2979:             oidc_debug(r, \"jv_dump_string: %s\", rv);",
                "// Line 2980:             jv_free(str);",
                "// vulnerable line: 2981: }",
                "// Line 2982:         jv_free(elem);",
                "// vulnerable line: 2983: }",
                "// Line 2984: ",
                "// Line 2985:     if (jv_invalid_has_msg(jv_copy(value))) {",
                "// Line 2986:         msg = jv_invalid_get_msg(value);",
                "// Line 2987:         oidc_error(r, \"invalid: %s\", jv_string_value(msg));",
                "// Line 2988:         jv_free(msg);",
                "// vulnerable line: 2989: } else {",
                "// Line 2990:         jv_free(value);",
                "// vulnerable line: 2991: }",
                "// Line 2992: ",
                "// Line 2993:     return rv;",
                "// vulnerable line: 2994: }",
                "// Line 2995: ",
                "// Line 2996: #endif",
                "// Line 2997: ",
                "// Line 2998: const char *oidc_util_jq_filter(request_rec *r, const char *input, const char *filter) {",
                "// Line 2999:     const char *result = input;",
                "// Line 3000: #ifdef USE_LIBJQ",
                "// Line 3001:     jq_state *jq = NULL;",
                "// Line 3002:     struct jv_parser *parser = NULL;",
                "// Line 3003:     int ttl = 0;",
                "// Line 3004:     char *key = NULL;",
                "// Line 3005:     char *value = NULL;",
                "// Line 3006: ",
                "// Line 3007:     if (filter == NULL) {",
                "// Line 3008:         oidc_debug(r, \"filter is NULL, abort\");",
                "// Line 3009:         goto end;",
                "// vulnerable line: 3010: }",
                "// Line 3011: ",
                "// Line 3012:     if (input == NULL) {",
                "// Line 3013:         oidc_debug(r, \"input is NULL, set to empty object\");",
                "// Line 3014:         input = \"{}\";",
                "// vulnerable line: 3015: }",
                "// Line 3016: ",
                "// Line 3017:     oidc_debug(r, \"processing input: %s\", input);",
                "// Line 3018:     oidc_debug(r, \"processing filter: %s\", filter);",
                "// Line 3019: ",
                "// Line 3020:     ttl = oidc_jq_filter_cache_ttl(r);",
                "// Line 3021:     if (ttl != 0) {",
                "// Line 3022:         if (oidc_util_hash_string_and_base64url_encode(",
                "// Line 3023:             r, OIDC_JOSE_ALG_SHA256, apr_pstrcat(r->pool, input, filter, NULL), &key) == FALSE) {",
                "// Line 3024:             oidc_error(r, \"oidc_util_hash_string_and_base64url_encode returned an error\");",
                "// Line 3025:             goto end;",
                "// vulnerable line: 3026: }",
                "// Line 3027:         oidc_cache_get_jq_filter(r, key, &value);",
                "// Line 3028:         if (value != NULL) {",
                "// Line 3029:             oidc_debug(r, \"return cached result: %s\", value);",
                "// Line 3030:             result = value;",
                "// Line 3031:             goto end;",
                "// vulnerable line: 3032: }",
                "// vulnerable line: 3033: }",
                "// Line 3034: ",
                "// Line 3035:     jq = jq_init();",
                "// Line 3036:     if (jq == NULL) {",
                "// Line 3037:         oidc_error(r, \"jq_init returned NULL\");",
                "// Line 3038:         goto end;",
                "// vulnerable line: 3039: }",
                "// Line 3040: ",
                "// Line 3041:     if (jq_compile(jq, filter) == 0) {",
                "// Line 3042:         oidc_error(r, \"jq_compile returned an error\");",
                "// Line 3043:         goto end;",
                "// vulnerable line: 3044: }",
                "// Line 3045: ",
                "// Line 3046:     parser = jv_parser_new(0);",
                "// Line 3047:     if (parser == NULL) {",
                "// Line 3048:         oidc_error(r, \"jv_parser_new returned NULL\");",
                "// Line 3049:         goto end;",
                "// vulnerable line: 3050: }",
                "// Line 3051: ",
                "// Line 3052:     jv_parser_set_buf(parser, input, _oidc_strlen(input), 0);",
                "// Line 3053: ",
                "// Line 3054:     result = oidc_util_jq_exec(r, jq, parser);",
                "// Line 3055: ",
                "// Line 3056:     if ((result != NULL) && (ttl != 0)) {",
                "// Line 3057:         oidc_debug(r, \"caching result: %s\", result);",
                "// Line 3058:         oidc_cache_set_jq_filter(r, key, result, apr_time_now() + apr_time_from_sec(ttl));",
                "// vulnerable line: 3059: }",
                "// Line 3060: ",
                "// Line 3061: end:",
                "// Line 3062: ",
                "// Line 3063:     if (parser)",
                "// Line 3064:         jv_parser_free(parser);",
                "// Line 3065:     if (jq)",
                "// Line 3066:         jq_teardown(&jq);",
                "// Line 3067: #endif",
                "// Line 3068: ",
                "// Line 3069:     return result;",
                "// vulnerable line: 3070: }",
                "// Line 3071: ",
                "// Line 3072: char *oidc_util_apr_expr_parse(cmd_parms *cmd, const char *str, oidc_apr_expr_t **expr, apr_byte_t result_is_str) {",
                "// Line 3073:     char *rv = NULL;",
                "// Line 3074:     if ((str == NULL) || (expr == NULL))",
                "// Line 3075:         return NULL;",
                "// Line 3076:     *expr = apr_pcalloc(cmd->pool, sizeof(oidc_apr_expr_t));",
                "// Line 3077:     (*expr)->str = apr_pstrdup(cmd->pool, str);",
                "// Line 3078: #if HAVE_APACHE_24",
                "// Line 3079:     const char *expr_err = NULL;",
                "// Line 3080:     unsigned int flags = AP_EXPR_FLAG_DONT_VARY & AP_EXPR_FLAG_RESTRICTED;",
                "// Line 3081:     if (result_is_str)",
                "// Line 3082:         flags += AP_EXPR_FLAG_STRING_RESULT;",
                "// Line 3083:     (*expr)->expr = ap_expr_parse_cmd(cmd, str, flags, &expr_err, NULL);",
                "// Line 3084:     if (expr_err != NULL) {",
                "// Line 3085:         rv = apr_pstrcat(cmd->temp_pool, \"cannot parse expression: \", expr_err, NULL);",
                "// Line 3086:         *expr = NULL;",
                "// vulnerable line: 3087: }",
                "// Line 3088: #endif",
                "// Line 3089:     return rv;",
                "// vulnerable line: 3090: }",
                "// Line 3091: ",
                "// Line 3092: const char *oidc_util_apr_expr_exec(request_rec *r, const oidc_apr_expr_t *expr, apr_byte_t result_is_str) {",
                "// Line 3093:     const char *expr_result = NULL;",
                "// Line 3094:     if (expr == NULL)",
                "// Line 3095:         return NULL;",
                "// Line 3096: #if HAVE_APACHE_24",
                "// Line 3097:     const char *expr_err = NULL;",
                "// Line 3098:     if (result_is_str) {",
                "// Line 3099:         expr_result = ap_expr_str_exec(r, expr->expr, &expr_err);",
                "// vulnerable line: 3100: } else {",
                "// Line 3101:         expr_result = ap_expr_exec(r, expr->expr, &expr_err) ? \"\" : NULL;",
                "// vulnerable line: 3102: }",
                "// Line 3103:     if (expr_err) {",
                "// Line 3104:         oidc_error(r, \"executing expression \"%s\" failed: %s\", expr->str, expr_err);",
                "// Line 3105:         expr_result = NULL;",
                "// vulnerable line: 3106: }",
                "// Line 3107: #else",
                "// Line 3108:     expr_result = expr->str;",
                "// Line 3109: #endif",
                "// Line 3110:     return expr_result;",
                "// vulnerable line: 3111: }",
                "// Line 3112: ",
                "// Line 3113: #define OIDC_TP_TRACE_ID_LEN 16",
                "// Line 3114: #define OIDC_TP_PARENT_ID_LEN 8",
                "// Line 3115: ",
                "// Line 3116: /*",
                "// Line 3117: The following version-format definition is used for version 00.",
                "// Line 3118: version-format   = trace-id \"-\" parent-id \"-\" trace-flags",
                "// Line 3119: trace-id         = 32HEXDIGLC  ; 16 bytes array identifier. All zeroes forbidden",
                "// Line 3120: parent-id        = 16HEXDIGLC  ; 8 bytes array identifier. All zeroes forbidden",
                "// Line 3121: trace-flags      = 2HEXDIGLC   ; 8 bit flags. Currently, only one bit is used.",
                "// Line 3122:  */",
                "// Line 3123: void oidc_util_set_trace_parent(request_rec *r, oidc_cfg *c, const char *span) {",
                "// Line 3124:     // apr_table_get(r->subprocess_env, \"UNIQUE_ID\");",
                "// Line 3125:     unsigned char trace_id[OIDC_TP_TRACE_ID_LEN];",
                "// Line 3126:     unsigned char parent_id[OIDC_TP_PARENT_ID_LEN];",
                "// Line 3127:     unsigned char trace_flags = 0;",
                "// Line 3128:     char *s_parent_id = \"\", *s_trace_id = \"\";",
                "// Line 3129:     const char *v = NULL;",
                "// vulnerable line: 3130: int i = 0;",
                "// Line 3131:     char *hostname = \"localhost\";",
                "// Line 3132:     const uint64_t P1 = 7;",
                "// Line 3133:     const uint64_t P2 = 31;",
                "// Line 3134:     uint64_t hash = P1;",
                "// Line 3135: ",
                "// Line 3136:     if (c->trace_parent != OIDC_TRACE_PARENT_GENERATE)",
                "// Line 3137:         return;",
                "// Line 3138: ",
                "// Line 3139:     if (r->server->server_hostname)",
                "// Line 3140:         hostname = r->server->server_hostname;",
                "// Line 3141: ",
                "// Line 3142:     v = oidc_request_state_get(r, OIDC_REQUEST_STATE_TRACE_ID);",
                "// Line 3143: ",
                "// Line 3144:     if (span == NULL) {",
                "// Line 3145:         _oidc_memset(parent_id, 0, OIDC_TP_PARENT_ID_LEN);",
                "// Line 3146:         _oidc_memcpy(parent_id, hostname,",
                "// Line 3147:                  _oidc_strlen(hostname) < OIDC_TP_PARENT_ID_LEN ? _oidc_strlen(hostname)",
                "// Line 3148:                                         : OIDC_TP_PARENT_ID_LEN);",
                "// vulnerable line: 3149: } else {",
                "// Line 3150:         if (v == NULL)",
                "// Line 3151:             oidc_warn(r, \"parameter \"span\" is set, but no \"trace-id\" [%s] found in the request state\",",
                "// Line 3152:                   OIDC_REQUEST_STATE_TRACE_ID);",
                "// Line 3153:         else",
                "// Line 3154:             oidc_debug(r, \"changing \"parent-id\" of current traceparent\");",
                "// Line 3155:         for (const char *p = span; *p != 0; p++)",
                "// Line 3156:             hash = hash * P2 + *p;",
                "// Line 3157:         _oidc_memcpy(parent_id, &hash, OIDC_TP_PARENT_ID_LEN);",
                "// vulnerable line: 3158: }",
                "// Line 3159:     for (i = 0; i < OIDC_TP_PARENT_ID_LEN; i++)",
                "// Line 3160:         s_parent_id = apr_psprintf(r->pool, \"%s%02x\", s_parent_id, parent_id[i]);",
                "// Line 3161: ",
                "// Line 3162:     if (v == NULL) {",
                "// Line 3163:         apr_generate_random_bytes(trace_id, OIDC_TP_TRACE_ID_LEN);",
                "// Line 3164:         for (i = 0; i < OIDC_TP_TRACE_ID_LEN; i++)",
                "// Line 3165:             s_trace_id = apr_psprintf(r->pool, \"%s%02x\", s_trace_id, trace_id[i]);",
                "// Line 3166:         oidc_request_state_set(r, OIDC_REQUEST_STATE_TRACE_ID, s_trace_id);",
                "// vulnerable line: 3167: } else {",
                "// Line 3168:         s_trace_id = apr_pstrdup(r->pool, v);",
                "// vulnerable line: 3169: }",
                "// Line 3170: ",
                "// Line 3171:     if (c->metrics_hook_data != NULL)",
                "// Line 3172:         trace_flags = trace_flags | 0x01;",
                "// Line 3173: ",
                "// Line 3174:     oidc_util_hdr_in_set(r, OIDC_HTTP_HDR_TRACE_PARENT,",
                "// Line 3175:                  apr_psprintf(r->pool, \"00-%s-%s-%02x\", s_trace_id, s_parent_id, trace_flags));",
                "// vulnerable line: 3176: }"
            ]
        }
    ]
}