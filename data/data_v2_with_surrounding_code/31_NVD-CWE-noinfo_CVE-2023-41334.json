{
    "cve_id": "CVE-2023-41334",
    "cve_description": "Astropy is a project for astronomy in Python that fosters interoperability between Python astronomy packages. Version 5.3.2 of the Astropy core package is vulnerable to remote code execution due to improper input validation in the `TranformGraph().to_dot_graph` function. A malicious user can provide a command or a script file as a value to the `savelayout` argument, which will be placed as the first value in a list of arguments passed to `subprocess.Popen`.  Although an error will be raised, the command or script will be executed successfully. Version 5.3.3 fixes this issue.",
    "cve_publish_date": "2024-03-18T19:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "MNT: Explicit option for savelayout in to_dot_graph",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "transformations.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "16",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 238:                 agraph = self._graph[a]",
                "// Line 239:                 for b in agraph:",
                "// Line 240:                     if agraph[b] is transform:",
                "// Line 241:                         del agraph[b]",
                "// Line 242:                         fromsys = a",
                "// Line 243:                         break",
                "// Line 244: ",
                "// Line 245:                 # If the transform was found, need to break out of the outer for loop too",
                "// Line 246:                 if fromsys:",
                "// Line 247:                     break",
                "// vulnerable line: 248: else:",
                "// Line 249:                 raise ValueError(f\"Could not find transform {transform} in the graph\")",
                "// Line 250: ",
                "// vulnerable line: 251: else:",
                "// Line 252:             if transform is None:",
                "// Line 253:                 self._graph[fromsys].pop(tosys, None)",
                "// vulnerable line: 254: else:",
                "// Line 255:                 curr = self._graph[fromsys].get(tosys, None)",
                "// Line 256:                 if curr is transform:",
                "// Line 257:                     self._graph[fromsys].pop(tosys)",
                "// vulnerable line: 258: else:",
                "// Line 259:                     raise ValueError(",
                "// Line 260:                         f\"Current transform from {fromsys} to {tosys} is not\"",
                "// Line 261:                         f\" {transform}\"",
                "// Line 262:                     )",
                "// Line 263: ",
                "// Line 264:         # Remove the subgraph if it is now empty",
                "// Line 265:         if self._graph[fromsys] == {}:",
                "// Line 266:             self._graph.pop(fromsys)",
                "// Line 267: ",
                "// Line 268:         self.invalidate_cache()",
                "// Line 303:             t = self._graph[fromsys][tosys]",
                "// Line 304:             return [fromsys, tosys], float(t.priority if hasattr(t, \"priority\") else 1)",
                "// Line 305: ",
                "// Line 306:         # otherwise, need to construct the path:",
                "// Line 307: ",
                "// Line 308:         if fromsys in self._shortestpaths:",
                "// Line 309:             # already have a cached result",
                "// Line 310:             fpaths = self._shortestpaths[fromsys]",
                "// Line 311:             if tosys in fpaths:",
                "// Line 312:                 return fpaths[tosys]",
                "// vulnerable line: 313: else:",
                "// Line 314:                 return None, inf",
                "// Line 315: ",
                "// Line 316:         # use Dijkstra's algorithm to find shortest path in all other cases",
                "// Line 317: ",
                "// Line 318:         nodes = []",
                "// Line 319:         # first make the list of nodes",
                "// Line 320:         for a in self._graph:",
                "// Line 321:             if a not in nodes:",
                "// Line 322:                 nodes.append(a)",
                "// Line 323:             for b in self._graph[a]:",
                "// Line 352:         while len(q) > 0:",
                "// Line 353:             d, orderi, n, path = heapq.heappop(q)",
                "// Line 354: ",
                "// Line 355:             if d == inf:",
                "// Line 356:                 # everything left is unreachable from fromsys, just copy them to",
                "// Line 357:                 # the results and jump out of the loop",
                "// Line 358:                 result[n] = (None, d)",
                "// Line 359:                 for d, orderi, n, path in q:",
                "// Line 360:                     result[n] = (None, d)",
                "// Line 361:                 break",
                "// vulnerable line: 362: else:",
                "// Line 363:                 result[n] = (path, d)",
                "// Line 364:                 path.append(n)",
                "// Line 365:                 if n not in edgeweights:",
                "// Line 366:                     # this is a system that can be transformed to, but not from.",
                "// Line 367:                     continue",
                "// Line 368:                 for n2 in edgeweights[n]:",
                "// Line 369:                     if n2 not in result:  # already visited",
                "// Line 370:                         # find where n2 is in the heap",
                "// Line 371:                         for i in range(len(q)):",
                "// Line 372:                             if q[i][2] == n2:",
                "// Line 373:                                 break",
                "// vulnerable line: 374: else:",
                "// Line 375:                             raise ValueError(",
                "// Line 376:                                 \"n2 not in heap - this should be impossible!\"",
                "// Line 377:                             )",
                "// Line 378: ",
                "// Line 379:                         newd = d + edgeweights[n][n2]",
                "// Line 380:                         if newd < q[i][0]:",
                "// Line 381:                             q[i][0] = newd",
                "// Line 382:                             q[i][3] = list(path)",
                "// Line 383:                             heapq.heapify(q)",
                "// Line 384: ",
                "// Line 486:         ----------",
                "// Line 487:         priorities : bool",
                "// Line 488:             If `True`, show the priority values for each transform.  Otherwise,",
                "// Line 489:             the will not be included in the graph.",
                "// Line 490:         addnodes : sequence of str",
                "// Line 491:             Additional coordinate systems to add (this can include systems",
                "// Line 492:             already in the transform graph, but they will only appear once).",
                "// Line 493:         savefn : None or str",
                "// Line 494:             The file name to save this graph to or `None` to not save",
                "// Line 495:             to a file.",
                "// vulnerable line: 496: savelayout : str",
                "// Line 497:             The graphviz program to use to layout the graph (see",
                "// Line 498:             graphviz_ for details) or 'plain' to just save the DOT graph",
                "// Line 499:             content. Ignored if ``savefn`` is `None`.",
                "// Line 500:         saveformat : str",
                "// Line 501:             The graphviz output format. (e.g. the ``-Txxx`` option for",
                "// Line 502:             the command line program - see graphviz docs for details).",
                "// Line 503:             Ignored if ``savefn`` is `None`.",
                "// Line 504:         color_edges : bool",
                "// Line 505:             Color the edges between two nodes (frames) based on the type of",
                "// Line 506:             transform. ``FunctionTransform``: red, ``StaticMatrixTransform``:",
                "// Line 528:             for f in self.frame_set",
                "// Line 529:         }",
                "// Line 530:         for n in nodes:",
                "// Line 531:             if n in invclsaliases:",
                "// Line 532:                 aliases = \"`",
                "// Line 533: `\".join(invclsaliases[n])",
                "// Line 534:                 nodenames.append(",
                "// Line 535:                     '{0} [shape=oval label=\"{0}",
                "// Line 536: `{1}`\"]'.format(n.__name__, aliases)",
                "// Line 537:                 )",
                "// vulnerable line: 538: else:",
                "// Line 539:                 nodenames.append(n.__name__ + \"[ shape=oval ]\")",
                "// Line 540: ",
                "// Line 541:         edgenames = []",
                "// Line 542:         # Now the edges",
                "// Line 543:         for a in self._graph:",
                "// Line 544:             agraph = self._graph[a]",
                "// Line 545:             for b in agraph:",
                "// Line 546:                 transform = agraph[b]",
                "// Line 547:                 pri = transform.priority if hasattr(transform, \"priority\") else 1",
                "// Line 548:                 color = trans_to_color[transform.__class__] if color_edges else \"black\"",
                "// Line 550: ",
                "// Line 551:         # generate simple dot format graph",
                "// Line 552:         lines = [\"digraph AstropyCoordinateTransformGraph {\"]",
                "// Line 553:         lines.append(\"graph [rankdir=LR]\")",
                "// Line 554:         lines.append(\"; \".join(nodenames) + \";\")",
                "// Line 555:         for enm1, enm2, weights, color in edgenames:",
                "// Line 556:             labelstr_fmt = \"[ {0} {1} ]\"",
                "// Line 557: ",
                "// Line 558:             if priorities:",
                "// Line 559:                 priority_part = f'label = \"{weights}\"'",
                "// vulnerable line: 560: else:",
                "// Line 561:                 priority_part = \"\"",
                "// Line 562: ",
                "// Line 563:             color_part = f'color = \"{color}\"'",
                "// Line 564: ",
                "// Line 565:             labelstr = labelstr_fmt.format(priority_part, color_part)",
                "// Line 566:             lines.append(f\"{enm1} -> {enm2}{labelstr};\")",
                "// Line 567: ",
                "// Line 568:         lines.append(\"\")",
                "// Line 569:         lines.append(\"overlap=false\")",
                "// Line 570:         lines.append(\"}\")",
                "// Line 571:         dotgraph = \"",
                "// Line 572: \".join(lines)",
                "// Line 573: ",
                "// Line 574:         if savefn is not None:",
                "// Line 575:             if savelayout == \"plain\":",
                "// Line 576:                 with open(savefn, \"w\") as f:",
                "// Line 577:                     f.write(dotgraph)",
                "// vulnerable line: 578: else:",
                "// Line 579:                 args = [savelayout]",
                "// Line 580:                 if saveformat is not None:",
                "// Line 581:                     args.append(\"-T\" + saveformat)",
                "// Line 582:                 proc = subprocess.Popen(",
                "// Line 583:                     args,",
                "// Line 584:                     stdin=subprocess.PIPE,",
                "// Line 585:                     stdout=subprocess.PIPE,",
                "// Line 586:                     stderr=subprocess.PIPE,",
                "// Line 587:                 )",
                "// Line 588:                 stdout, stderr = proc.communicate(dotgraph)",
                "// Line 826:         if not inspect.isclass(tosys):",
                "// Line 827:             raise TypeError(\"tosys must be a class\")",
                "// Line 828: ",
                "// Line 829:         self.fromsys = fromsys",
                "// Line 830:         self.tosys = tosys",
                "// Line 831:         self.priority = float(priority)",
                "// Line 832: ",
                "// Line 833:         if register_graph:",
                "// Line 834:             # this will do the type-checking when it adds to the graph",
                "// Line 835:             self.register(register_graph)",
                "// vulnerable line: 836: else:",
                "// Line 837:             if not inspect.isclass(fromsys) or not inspect.isclass(tosys):",
                "// Line 838:                 raise TypeError(\"fromsys and tosys must be classes\")",
                "// Line 839: ",
                "// Line 840:         self.overlapping_frame_attr_names = overlap = []",
                "// Line 841:         if hasattr(fromsys, \"frame_attributes\") and hasattr(tosys, \"frame_attributes\"):",
                "// Line 842:             # the if statement is there so that non-frame things might be usable",
                "// Line 843:             # if it makes sense",
                "// Line 844:             for from_nm in fromsys.frame_attributes:",
                "// Line 845:                 if from_nm in tosys.frame_attributes:",
                "// Line 846:                     overlap.append(from_nm)",
                "// Line 1028:         self.symmetric_finite_difference = symmetric_finite_difference",
                "// Line 1029: ",
                "// Line 1030:     @property",
                "// Line 1031:     def finite_difference_frameattr_name(self):",
                "// Line 1032:         return self._finite_difference_frameattr_name",
                "// Line 1033: ",
                "// Line 1034:     @finite_difference_frameattr_name.setter",
                "// Line 1035:     def finite_difference_frameattr_name(self, value):",
                "// Line 1036:         if value is None:",
                "// Line 1037:             self._diff_attr_in_fromsys = self._diff_attr_in_tosys = False",
                "// vulnerable line: 1038: else:",
                "// Line 1039:             diff_attr_in_fromsys = value in self.fromsys.frame_attributes",
                "// Line 1040:             diff_attr_in_tosys = value in self.tosys.frame_attributes",
                "// Line 1041:             if diff_attr_in_fromsys or diff_attr_in_tosys:",
                "// Line 1042:                 self._diff_attr_in_fromsys = diff_attr_in_fromsys",
                "// Line 1043:                 self._diff_attr_in_tosys = diff_attr_in_tosys",
                "// vulnerable line: 1044: else:",
                "// Line 1045:                 raise ValueError(",
                "// Line 1046:                     f\"Frame attribute name {value} is not a frame attribute of\"",
                "// Line 1047:                     f\" {self.fromsys} or {self.tosys}\"",
                "// Line 1048:                 )",
                "// Line 1049:         self._finite_difference_frameattr_name = value",
                "// Line 1050: ",
                "// Line 1051:     def __call__(self, fromcoord, toframe):",
                "// Line 1052:         from .representation import CartesianDifferential, CartesianRepresentation",
                "// Line 1053: ",
                "// Line 1054:         supcall = self.func",
                "// Line 1055:         if fromcoord.data.differentials:",
                "// Line 1056:             # this is the finite difference case",
                "// Line 1057: ",
                "// Line 1058:             if callable(self.finite_difference_dt):",
                "// Line 1059:                 dt = self.finite_difference_dt(fromcoord, toframe)",
                "// vulnerable line: 1060: else:",
                "// Line 1061:                 dt = self.finite_difference_dt",
                "// Line 1062:             halfdt = dt / 2",
                "// Line 1063: ",
                "// Line 1064:             from_diffless = fromcoord.realize_frame(",
                "// Line 1065:                 fromcoord.data.without_differentials()",
                "// Line 1066:             )",
                "// Line 1067:             reprwithoutdiff = supcall(from_diffless, toframe)",
                "// Line 1068: ",
                "// Line 1069:             # first we use the existing differential to compute an offset due to",
                "// Line 1070:             # the already-existing velocity, but in the new frame",
                "// Line 1077:                 fwd = supcall(",
                "// Line 1078:                     fromcoord.realize_frame(CartesianRepresentation(fwdxyz)), toframe",
                "// Line 1079:                 )",
                "// Line 1080:                 backxyz = (",
                "// Line 1081:                     fromcoord_cart.xyz",
                "// Line 1082:                     - fromcoord_cart.differentials[\"s\"].d_xyz * halfdt",
                "// Line 1083:                 )",
                "// Line 1084:                 back = supcall(",
                "// Line 1085:                     fromcoord.realize_frame(CartesianRepresentation(backxyz)), toframe",
                "// Line 1086:                 )",
                "// vulnerable line: 1087: else:",
                "// Line 1088:                 fwdxyz = (",
                "// Line 1089:                     fromcoord_cart.xyz + fromcoord_cart.differentials[\"s\"].d_xyz * dt",
                "// Line 1090:                 )",
                "// Line 1091:                 fwd = supcall(",
                "// Line 1092:                     fromcoord.realize_frame(CartesianRepresentation(fwdxyz)), toframe",
                "// Line 1093:                 )",
                "// Line 1094:                 back = reprwithoutdiff",
                "// Line 1095:             diffxyz = (fwd.cartesian - back.cartesian).xyz / dt",
                "// Line 1096: ",
                "// Line 1097:             # now we compute the \"induced\" velocities due to any movement in",
                "// Line 1098:             # the frame itself over time",
                "// Line 1099:             attrname = self.finite_difference_frameattr_name",
                "// Line 1100:             if attrname is not None:",
                "// Line 1101:                 if self.symmetric_finite_difference:",
                "// Line 1102:                     if self._diff_attr_in_fromsys:",
                "// Line 1103:                         kws = {attrname: getattr(from_diffless, attrname) + halfdt}",
                "// Line 1104:                         from_diffless_fwd = from_diffless.replicate(**kws)",
                "// vulnerable line: 1105: else:",
                "// Line 1106:                         from_diffless_fwd = from_diffless",
                "// Line 1107:                     if self._diff_attr_in_tosys:",
                "// Line 1108:                         kws = {attrname: getattr(toframe, attrname) + halfdt}",
                "// Line 1109:                         fwd_frame = toframe.replicate_without_data(**kws)",
                "// vulnerable line: 1110: else:",
                "// Line 1111:                         fwd_frame = toframe",
                "// Line 1112:                     fwd = supcall(from_diffless_fwd, fwd_frame)",
                "// Line 1113: ",
                "// Line 1114:                     if self._diff_attr_in_fromsys:",
                "// Line 1115:                         kws = {attrname: getattr(from_diffless, attrname) - halfdt}",
                "// Line 1116:                         from_diffless_back = from_diffless.replicate(**kws)",
                "// vulnerable line: 1117: else:",
                "// Line 1118:                         from_diffless_back = from_diffless",
                "// Line 1119:                     if self._diff_attr_in_tosys:",
                "// Line 1120:                         kws = {attrname: getattr(toframe, attrname) - halfdt}",
                "// Line 1121:                         back_frame = toframe.replicate_without_data(**kws)",
                "// vulnerable line: 1122: else:",
                "// Line 1123:                         back_frame = toframe",
                "// Line 1124:                     back = supcall(from_diffless_back, back_frame)",
                "// vulnerable line: 1125: else:",
                "// Line 1126:                     if self._diff_attr_in_fromsys:",
                "// Line 1127:                         kws = {attrname: getattr(from_diffless, attrname) + dt}",
                "// Line 1128:                         from_diffless_fwd = from_diffless.replicate(**kws)",
                "// vulnerable line: 1129: else:",
                "// Line 1130:                         from_diffless_fwd = from_diffless",
                "// Line 1131:                     if self._diff_attr_in_tosys:",
                "// Line 1132:                         kws = {attrname: getattr(toframe, attrname) + dt}",
                "// Line 1133:                         fwd_frame = toframe.replicate_without_data(**kws)",
                "// vulnerable line: 1134: else:",
                "// Line 1135:                         fwd_frame = toframe",
                "// Line 1136:                     fwd = supcall(from_diffless_fwd, fwd_frame)",
                "// Line 1137:                     back = reprwithoutdiff",
                "// Line 1138: ",
                "// Line 1139:                 diffxyz += (fwd.cartesian - back.cartesian).xyz / dt",
                "// Line 1140: ",
                "// Line 1141:             newdiff = CartesianDifferential(diffxyz)",
                "// Line 1142:             reprwithdiff = reprwithoutdiff.data.to_cartesian().with_differentials(",
                "// Line 1143:                 newdiff",
                "// Line 1144:             )",
                "// Line 1145:             return reprwithoutdiff.realize_frame(reprwithdiff)",
                "// vulnerable line: 1146: else:",
                "// Line 1147:             return supcall(fromcoord, toframe)",
                "// Line 1148: ",
                "// Line 1149: ",
                "// Line 1150: class BaseAffineTransform(CoordinateTransform):",
                "// Line 1151:     \"\"\"Base class for common functionality between the ``AffineTransform``-type",
                "// Line 1152:     subclasses.",
                "// Line 1153: ",
                "// Line 1154:     This base class is needed because `~astropy.coordinates.AffineTransform`",
                "// Line 1155:     and the matrix transform classes share the ``__call__()`` method, but",
                "// Line 1156:     differ in how they generate the affine parameters.",
                "// Line 1259:         # Only do transform if matrix is specified. This is for speed in",
                "// Line 1260:         # transformations that only specify an offset (e.g., LSR)",
                "// Line 1261:         if matrix is not None:",
                "// Line 1262:             # Note: this applies to both representation and differentials",
                "// Line 1263:             rep = rep.transform(matrix)",
                "// Line 1264: ",
                "// Line 1265:         # TODO: if we decide to allow arithmetic between representations that",
                "// Line 1266:         # contain differentials, this can be tidied up",
                "// Line 1267:         if offset is not None:",
                "// Line 1268:             newrep = rep.without_differentials() + offset.without_differentials()",
                "// vulnerable line: 1269: else:",
                "// Line 1270:             newrep = rep.without_differentials()",
                "// Line 1271: ",
                "// Line 1272:         # We need a velocity (time derivative) and, for now, are strict: the",
                "// Line 1273:         # representation can only contain a velocity differential and no others.",
                "// Line 1274:         if has_velocity and not rad_vel_diff:",
                "// Line 1275:             veldiff = rep.differentials[\"s\"]  # already in Cartesian form",
                "// Line 1276: ",
                "// Line 1277:             if offset is not None and \"s\" in offset.differentials:",
                "// Line 1278:                 veldiff = veldiff + offset.differentials[\"s\"]",
                "// Line 1279: ",
                "// Line 1299:                         copy=False, **kwargs",
                "// Line 1300:                     )",
                "// Line 1301:                 }",
                "// Line 1302: ",
                "// Line 1303:             elif has_velocity and unit_vel_diff:",
                "// Line 1304:                 newdiff = newrep.differentials[\"s\"].represent_as(",
                "// Line 1305:                     fromcoord.data.differentials[\"s\"].__class__, newrep",
                "// Line 1306:                 )",
                "// Line 1307:                 diffs = {\"s\": newdiff}",
                "// Line 1308: ",
                "// vulnerable line: 1309: else:",
                "// Line 1310:                 diffs = newrep.differentials",
                "// Line 1311: ",
                "// Line 1312:             newrep = newrep.represent_as(fromcoord.data.__class__)  # drops diffs",
                "// Line 1313:             newrep = newrep.with_differentials(diffs)",
                "// Line 1314: ",
                "// Line 1315:         elif has_velocity and unit_vel_diff:",
                "// Line 1316:             # Here, we're in the case where the representation is not",
                "// Line 1317:             # UnitSpherical, but the differential *is* one of the UnitSpherical",
                "// Line 1318:             # types. We have to convert back to that differential class or the",
                "// Line 1319:             # resulting frame will think it has a valid radial_velocity. This",
                "// Line 1549:             lasttrans = newtrans[-1] if len(newtrans) > 0 else None",
                "// Line 1550: ",
                "// Line 1551:             if isinstance(lasttrans, StaticMatrixTransform) and isinstance(",
                "// Line 1552:                 currtrans, StaticMatrixTransform",
                "// Line 1553:             ):",
                "// Line 1554:                 newtrans[-1] = StaticMatrixTransform(",
                "// Line 1555:                     currtrans.matrix @ lasttrans.matrix,",
                "// Line 1556:                     lasttrans.fromsys,",
                "// Line 1557:                     currtrans.tosys,",
                "// Line 1558:                 )",
                "// vulnerable line: 1559: else:",
                "// Line 1560:                 newtrans.append(currtrans)",
                "// Line 1561:         return newtrans",
                "// Line 1562: ",
                "// Line 1563:     def __call__(self, fromcoord, toframe):",
                "// Line 1564:         curr_coord = fromcoord",
                "// Line 1565:         for t in self.transforms:",
                "// Line 1566:             # build an intermediate frame with attributes taken from either",
                "// Line 1567:             # `toframe`, or if not there, `fromcoord`, or if not there, use",
                "// Line 1568:             # the defaults",
                "// Line 1569:             # TODO: caching this information when creating the transform may",
                "// Line 1631:                 affine_params = (None, None)",
                "// Line 1632:                 # Step through each transform step (frame A -> frame B)",
                "// Line 1633:                 for i, t in enumerate(transforms):",
                "// Line 1634:                     # Extract the relevant attributes for frame A",
                "// Line 1635:                     if i == 0:",
                "// Line 1636:                         # If frame A is actually the initial frame, preserve its attributes",
                "// Line 1637:                         a_attr = {",
                "// Line 1638:                             name: getattr(from_coo, name)",
                "// Line 1639:                             for name in from_coo.frame_attributes",
                "// Line 1640:                         }",
                "// vulnerable line: 1641: else:",
                "// Line 1642:                         a_attr = {",
                "// Line 1643:                             k: v",
                "// Line 1644:                             for k, v in merged_attr.items()",
                "// Line 1645:                             if k in t.fromsys.frame_attributes",
                "// Line 1646:                         }",
                "// Line 1647: ",
                "// Line 1648:                     # Extract the relevant attributes for frame B",
                "// Line 1649:                     b_attr = {",
                "// Line 1650:                         k: v",
                "// Line 1651:                         for k, v in merged_attr.items()",
                "// Line 1664:                     # Combine the affine parameters with the running set",
                "// Line 1665:                     affine_params = _combine_affine_params(",
                "// Line 1666:                         affine_params, next_affine_params",
                "// Line 1667:                     )",
                "// Line 1668: ",
                "// Line 1669:                 # If there is no origin shift, return only the matrix",
                "// Line 1670:                 return affine_params[0] if fixed_origin else affine_params",
                "// Line 1671: ",
                "// Line 1672:             # The return type depends on whether there is any origin shift",
                "// Line 1673:             transform_type = DynamicMatrixTransform if fixed_origin else AffineTransform",
                "// vulnerable line: 1674: else:",
                "// Line 1675:             # Dynamically define the transformation function",
                "// Line 1676:             def single_transform(from_coo, to_frame):",
                "// Line 1677:                 if from_coo.is_equivalent_frame(to_frame):  # loopback to the same frame",
                "// Line 1678:                     return to_frame.realize_frame(from_coo.data)",
                "// Line 1679:                 return self(from_coo, to_frame)",
                "// Line 1680: ",
                "// Line 1681:             transform_type = FunctionTransformWithFiniteDifference",
                "// Line 1682: ",
                "// Line 1683:         return transform_type(",
                "// Line 1684:             single_transform, self.fromsys, self.tosys, priority=self.priority",
                "// Line 1692:     The parameters for an affine transformation are a 3 x 3 Cartesian",
                "// Line 1693:     transformation matrix and a displacement vector, which can include an",
                "// Line 1694:     attached velocity.  Either type of parameter can be ``None``.",
                "// Line 1695:     \"\"\"",
                "// Line 1696:     M, vec = params",
                "// Line 1697:     next_M, next_vec = next_params",
                "// Line 1698: ",
                "// Line 1699:     # Multiply the transformation matrices if they both exist",
                "// Line 1700:     if M is not None and next_M is not None:",
                "// Line 1701:         new_M = next_M @ M",
                "// vulnerable line: 1702: else:",
                "// Line 1703:         new_M = M if M is not None else next_M",
                "// Line 1704: ",
                "// Line 1705:     if vec is not None:",
                "// Line 1706:         # Transform the first displacement vector by the second transformation matrix",
                "// Line 1707:         if next_M is not None:",
                "// Line 1708:             vec = vec.transform(next_M)",
                "// Line 1709: ",
                "// Line 1710:         # Calculate the new displacement vector",
                "// Line 1711:         if next_vec is not None:",
                "// Line 1712:             if \"s\" in vec.differentials and \"s\" in next_vec.differentials:",
                "// Line 1713:                 # Adding vectors with velocities takes more steps",
                "// Line 1714:                 # TODO: Add support in representation.py",
                "// Line 1715:                 new_vec_velocity = vec.differentials[\"s\"] + next_vec.differentials[\"s\"]",
                "// Line 1716:                 new_vec = vec.without_differentials() + next_vec.without_differentials()",
                "// Line 1717:                 new_vec = new_vec.with_differentials({\"s\": new_vec_velocity})",
                "// vulnerable line: 1718: else:",
                "// Line 1719:                 new_vec = vec + next_vec",
                "// vulnerable line: 1720: else:",
                "// Line 1721:             new_vec = vec",
                "// vulnerable line: 1722: else:",
                "// Line 1723:         new_vec = next_vec",
                "// Line 1724: ",
                "// Line 1725:     return new_M, new_vec",
                "// Line 1726: ",
                "// Line 1727: ",
                "// Line 1728: # map class names to colorblind-safe colors",
                "// Line 1729: trans_to_color = {}",
                "// Line 1730: trans_to_color[AffineTransform] = \"#555555\"  # gray",
                "// Line 1731: trans_to_color[FunctionTransform] = \"#783001\"  # dark red-ish/brown",
                "// Line 1732: trans_to_color[FunctionTransformWithFiniteDifference] = \"#d95f02\"  # red-ish"
            ]
        }
    ]
}