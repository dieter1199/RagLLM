{
    "cve_id": "CVE-2022-4967",
    "cve_description": "strongSwan versions 5.9.2 through 5.9.5 are affected by authorization bypass through improper validation of certificate with host mismatch (CWE-297). When certificates are used to authenticate clients in TLS-based EAP methods, the IKE or EAP identity supplied by a client is not enforced to be contained in the client's certificate. So clients can authenticate with any trusted certificate and claim an arbitrary IKE/EAP identity as their own. This is problematic if the identity is used to make policy decisions. A fix was released in strongSwan version 5.9.6 in August 2022 (e4b4aabc4996fc61c37deab7858d07bc4d220136).",
    "cve_publish_date": "2024-05-14T11:57Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "libtls: Enforce client/server identity when looking for public key\n\nThe client already enforces that the server identity is contained in the\nreceived certificate.  But on the server, the referenced commit changed\nthe lookup from the configured (or adopted if %any was configured) client\nidentity to the subject DN of the received client certificate.  So any\nclient with a trusted certificate was accepted.\n\nFixes: d2fc9b0961c6 (\"tls-server: Mutual authentication support for TLS 1.3\")\nCloses strongswan/strongswan#873",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "tls_peer.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 158:     chunk_t hashsig;",
                "// Line 159: ",
                "// Line 160:     /**",
                "// Line 161:      * List of server-supported client certificate types",
                "// Line 162:      */",
                "// Line 163:     chunk_t cert_types;",
                "// Line 164: };",
                "// Line 165: ",
                "// Line 166: /* Implemented in tls_server.c */",
                "// Line 167: bool tls_write_key_share(bio_writer_t **key_share, diffie_hellman_t *dh);",
                "// vulnerable line: 168: public_key_t *tls_find_public_key(auth_cfg_t *peer_auth);",
                "// Line 169: ",
                "// Line 170: /**",
                "// Line 171:  * Verify the DH group/key type requested by the server is valid.",
                "// Line 172:  */",
                "// Line 173: static bool verify_requested_key_type(private_tls_peer_t *this,",
                "// Line 174:                                       uint16_t key_type)",
                "// Line 175: {",
                "// Line 176:     enumerator_t *enumerator;",
                "// Line 177:     diffie_hellman_group_t group, found = MODP_NONE;",
                "// Line 178:     tls_named_group_t curve;",
                "// Line 634: ",
                "// Line 635: /**",
                "// Line 636:  *  Process CertificateVerify message",
                "// Line 637:  */",
                "// Line 638: static status_t process_cert_verify(private_tls_peer_t *this,",
                "// Line 639:                                     bio_reader_t *reader)",
                "// Line 640: {",
                "// Line 641:     public_key_t *public;",
                "// Line 642:     chunk_t msg;",
                "// Line 643: ",
                "// vulnerable line: 644: public = tls_find_public_key(this->server_auth);",
                "// Line 645:     if (!public)",
                "// Line 646:     {",
                "// Line 647:         DBG1(DBG_TLS, \"no trusted certificate found for '%Y' to verify TLS server\",",
                "// Line 648:              this->server);",
                "// Line 649:         this->alert->add(this->alert, TLS_FATAL, TLS_CERTIFICATE_UNKNOWN);",
                "// Line 650:         return NEED_MORE;",
                "// Line 651:     }",
                "// Line 652: ",
                "// Line 653:     msg = reader->peek(reader);",
                "// Line 654:     if (!this->crypto->verify_handshake(this->crypto, public, reader))",
                "// Line 683:         this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);",
                "// Line 684:         return NEED_MORE;",
                "// Line 685:     }",
                "// Line 686:     /* reject (export) DH groups using primes smaller than 1024 bit */",
                "// Line 687:     if (prime.len < 1024 / 8)",
                "// Line 688:     {",
                "// Line 689:         DBG1(DBG_TLS, \"short DH prime received (%zu bytes)\", prime.len);",
                "// Line 690:         this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);",
                "// Line 691:         return NEED_MORE;",
                "// Line 692:     }",
                "// vulnerable line: 693: public = tls_find_public_key(this->server_auth);",
                "// Line 694:     if (!public)",
                "// Line 695:     {",
                "// Line 696:         DBG1(DBG_TLS, \"no TLS public key found for server '%Y'\", this->server);",
                "// Line 697:         this->alert->add(this->alert, TLS_FATAL, TLS_CERTIFICATE_UNKNOWN);",
                "// Line 698:         return NEED_MORE;",
                "// Line 699:     }",
                "// Line 700: ",
                "// Line 701:     chunk.len = 2 + prime.len + 2 + generator.len + 2 + pub.len;",
                "// Line 702:     chunk = chunk_cat(\"ccc\", chunk_from_thing(this->client_random),",
                "// Line 703:                       chunk_from_thing(this->server_random), chunk);",
                "// Line 790: ",
                "// Line 791:     group = curve_to_ec_group(this, curve);",
                "// Line 792:     if (!group)",
                "// Line 793:     {",
                "// Line 794:         DBG1(DBG_TLS, \"ECDH curve %N not supported\",",
                "// Line 795:              tls_named_group_names, curve);",
                "// Line 796:         this->alert->add(this->alert, TLS_FATAL, TLS_HANDSHAKE_FAILURE);",
                "// Line 797:         return NEED_MORE;",
                "// Line 798:     }",
                "// Line 799: ",
                "// vulnerable line: 800: public = tls_find_public_key(this->server_auth);",
                "// Line 801:     if (!public)",
                "// Line 802:     {",
                "// Line 803:         DBG1(DBG_TLS, \"no TLS public key found for server '%Y'\", this->server);",
                "// Line 804:         this->alert->add(this->alert, TLS_FATAL, TLS_CERTIFICATE_UNKNOWN);",
                "// Line 805:         return NEED_MORE;",
                "// Line 806:     }",
                "// Line 807: ",
                "// Line 808:     chunk.len = 4 + pub.len;",
                "// Line 809:     chunk = chunk_cat(\"ccc\", chunk_from_thing(this->client_random),",
                "// Line 810:                       chunk_from_thing(this->server_random), chunk);",
                "// Line 1614: ",
                "// Line 1615:     if (!this->crypto->derive_secrets(this->crypto, chunk_from_thing(premaster),",
                "// Line 1616:                                       this->session, this->server,",
                "// Line 1617:                                       chunk_from_thing(this->client_random),",
                "// Line 1618:                                       chunk_from_thing(this->server_random)))",
                "// Line 1619:     {",
                "// Line 1620:         this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);",
                "// Line 1621:         return NEED_MORE;",
                "// Line 1622:     }",
                "// Line 1623: ",
                "// vulnerable line: 1624: public = tls_find_public_key(this->server_auth);",
                "// Line 1625:     if (!public)",
                "// Line 1626:     {",
                "// Line 1627:         DBG1(DBG_TLS, \"no TLS public key found for server '%Y'\", this->server);",
                "// Line 1628:         this->alert->add(this->alert, TLS_FATAL, TLS_CERTIFICATE_UNKNOWN);",
                "// Line 1629:         return NEED_MORE;",
                "// Line 1630:     }",
                "// Line 1631:     if (!public->encrypt(public, ENCRYPT_RSA_PKCS1, NULL,",
                "// Line 1632:                          chunk_from_thing(premaster), &encrypted))",
                "// Line 1633:     {",
                "// Line 1634:         public->destroy(public);"
            ]
        },
        {
            "filename_of_changes": "tls_server.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 166: ",
                "// Line 167:     /**",
                "// Line 168:      * Whether to include CAs in CertificateRequest messages",
                "// Line 169:      */",
                "// Line 170:     bool send_certreq_authorities;",
                "// Line 171: };",
                "// Line 172: ",
                "// Line 173: /**",
                "// Line 174:  * Find a trusted public key to encrypt/verify key exchange data",
                "// Line 175:  */",
                "// vulnerable line: 176: public_key_t *tls_find_public_key(auth_cfg_t *peer_auth)",
                "// Line 177: {",
                "// Line 178:     public_key_t *public = NULL, *current;",
                "// Line 179:     certificate_t *cert, *found;",
                "// Line 180:     enumerator_t *enumerator;",
                "// Line 181:     auth_cfg_t *auth;",
                "// Line 182: ",
                "// Line 183:     cert = peer_auth->get(peer_auth, AUTH_HELPER_SUBJECT_CERT);",
                "// Line 184:     if (cert)",
                "// Line 185:     {",
                "// Line 186:         enumerator = lib->credmgr->create_public_enumerator(lib->credmgr,",
                "// vulnerable line: 187: KEY_ANY, cert->get_subject(cert),",
                "// vulnerable line: 188: peer_auth, TRUE);",
                "// Line 189:         while (enumerator->enumerate(enumerator, &current, &auth))",
                "// Line 190:         {",
                "// Line 191:             found = auth->get(auth, AUTH_RULE_SUBJECT_CERT);",
                "// Line 192:             if (found && cert->equals(cert, found))",
                "// Line 193:             {",
                "// Line 194:                 public = current->get_ref(current);",
                "// Line 195:                 peer_auth->merge(peer_auth, auth, FALSE);",
                "// Line 196:                 break;",
                "// Line 197:             }",
                "// Line 198:         }",
                "// Line 916: ",
                "// Line 917: /**",
                "// Line 918:  * Process Certificate verify",
                "// Line 919:  */",
                "// Line 920: static status_t process_cert_verify(private_tls_server_t *this,",
                "// Line 921:                                     bio_reader_t *reader)",
                "// Line 922: {",
                "// Line 923:     public_key_t *public;",
                "// Line 924:     chunk_t msg;",
                "// Line 925: ",
                "// vulnerable line: 926: public = tls_find_public_key(this->peer_auth);",
                "// Line 927:     if (!public)",
                "// Line 928:     {",
                "// Line 929:         DBG1(DBG_TLS, \"no trusted certificate found for '%Y' to verify TLS peer\",",
                "// Line 930:              this->peer);",
                "// Line 931:         this->alert->add(this->alert, TLS_FATAL, TLS_CERTIFICATE_UNKNOWN);",
                "// Line 932:         return NEED_MORE;",
                "// Line 933:     }",
                "// Line 934: ",
                "// Line 935:     msg = reader->peek(reader);",
                "// Line 936:     if (!this->crypto->verify_handshake(this->crypto, public, reader))"
            ]
        }
    ]
}