{
    "cve_id": "CVE-2024-23327",
    "cve_description": "Envoy is a high-performance edge/middle/service proxy. When PPv2 is enabled both on a listener and subsequent cluster, the Envoy instance will segfault when attempting to craft the upstream PPv2 header. This occurs when the downstream request has a command type of LOCAL and does not have the protocol block. This issue has been addressed in releases 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-02-09T23:15Z",
    "cwe_id": "CWE-476",
    "cwe_name": "NULL Pointer Dereference",
    "cwe_description": "The product dereferences a pointer that it expects to be valid but is NULL.",
    "commit_message": "Fix crash from AWS NLB healthchecks when proxy protocol is enabled\n\nFix: [CVE-2024-23327](https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j)\n\nSigned-off-by: Jacob Neil Taylor <me@jacobtaylor.id.au>\nSigned-off-by: Greg Greenway <ggreenway@apple.com>\nSigned-off-by: Ryan Northey <ryan@synca.io>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "proxy_protocol.cc",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "23",
            "number_of_lines_deleted_vulnerable_to_cve": "10",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 137:   if (proxy_protocol_header_.has_value()) {",
                "// Line 138:     const ReadOrParseState read_ext_state = readExtensions(buffer);",
                "// Line 139:     if (read_ext_state != ReadOrParseState::Done) {",
                "// Line 140:       return read_ext_state;",
                "// Line 141:     }",
                "// Line 142:   }",
                "// Line 143: ",
                "// Line 144:   if (proxy_protocol_header_.has_value() &&",
                "// Line 145:       !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(",
                "// Line 146:           Network::ProxyProtocolFilterState::key())) {",
                "// vulnerable line: 147: if (!proxy_protocol_header_.value().local_command_) {",
                "// vulnerable line: 148: auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);",
                "// Line 149:       ENVOY_LOG(",
                "// Line 150:           trace,",
                "// vulnerable line: 151: \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",",
                "// Line 152:           proxy_protocol_header_.value().wholeHeaderLength(),",
                "// Line 153:           Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),",
                "// Line 154:           proxy_protocol_header_.value().extensions_length_,",
                "// Line 155:           Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),",
                "// Line 156:                              proxy_protocol_header_.value().extensions_length_));",
                "// Line 157:     }",
                "// Line 158: ",
                "// vulnerable line: 159: cb_->filterState().setData(",
                "// vulnerable line: 160: Network::ProxyProtocolFilterState::key(),",
                "// vulnerable line: 161: std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{",
                "// vulnerable line: 162: proxy_protocol_header_.value().remote_address_,",
                "// vulnerable line: 163: proxy_protocol_header_.value().local_address_, parsed_tlvs_}),",
                "// vulnerable line: 164: StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);",
                "// Line 165:   }",
                "// Line 166: ",
                "// Line 167:   if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {",
                "// Line 168:     // If this is a local_command, we are not to override address",
                "// Line 169:     // Error check the source and destination fields. Most errors are caught by the address",
                "// Line 170:     // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as",
                "// Line 171:     // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the",
                "// Line 172:     // source address.",
                "// Line 173:     const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();",
                "// Line 174:     const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();"
            ]
        },
        {
            "filename_of_changes": "proxy_protocol_header.cc",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "9",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "proxy_protocol_test.cc",
            "code_language": "C++",
            "number_of_lines_added_for_mitigation": "28",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}