{
    "cve_id": "CVE-2023-7258",
    "cve_description": "A denial of service exists in Gvisor Sandbox where a bug in reference counting code in mount point tracking could lead to a panic, making it possible for an attacker running as root and with permission to mount volumes to kill the sandbox. We recommend upgrading past commitÂ 6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
    "cve_publish_date": "2024-05-15T17:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Check for mounts marked as unmounted before propagating.\n\nIf the namespace were set to nil during umount (such as in Linux), checks\nfor mnt.neverConnected() would cover this case. We keep mnt.ns as non-nil,\nso we need to also check umounted in some cases.\n\nPiperOrigin-RevId: 586747189",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "propagation.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 259: func (vfs *VirtualFilesystem) peers(m1, m2 *Mount) bool {",
                "// Line 260:     return m1.groupID == m2.groupID && m1.groupID != 0",
                "// Line 261: }",
                "// Line 262: ",
                "// Line 263: // propagateMount propagates state.srcMount to dstMount at dstPoint.",
                "// Line 264: // This method is analogous to fs/pnode.c:propagate_one() in Linux.",
                "// Line 265: //",
                "// Line 266: // +checklocks:vfs.mountMu",
                "// Line 267: func (vfs *VirtualFilesystem) propagateMount(ctx context.Context, dstMnt *Mount, dstPoint *Dentry, state *propState) error {",
                "// Line 268:     // Skip newly added mounts.",
                "// vulnerable line: 269: if dstMnt.neverConnected() {",
                "// Line 270:         return nil",
                "// Line 271:     }",
                "// Line 272:     mp := VirtualDentry{mount: dstMnt, dentry: dstPoint}",
                "// Line 273:     if !mp.mount.fs.Impl().IsDescendant(VirtualDentry{dstMnt, dstMnt.root}, mp) {",
                "// Line 274:         return nil",
                "// Line 275:     }",
                "// Line 276:     cloneType := 0",
                "// Line 277:     if vfs.peers(dstMnt, state.prevDst) {",
                "// Line 278:         cloneType = makeSharedClone",
                "// Line 279:     } else {"
            ]
        }
    ]
}