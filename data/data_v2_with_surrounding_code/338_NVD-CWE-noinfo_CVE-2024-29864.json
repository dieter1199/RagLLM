{
    "cve_id": "CVE-2024-29864",
    "cve_description": "Distrobox before 1.7.0.1 allows attackers to execute arbitrary code via command injection into exported executables.",
    "cve_publish_date": "2024-03-21T04:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "enter: do not use a shell when executing a custom command, Fix #1275\n\nSigned-off-by: Luca Di Maio <luca.dimaio1@gmail.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "distrobox-enter",
            "code_language": "Shell",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 53: \" \"$(basename \"${0}\")\"",
                "// Line 54:     printf >&2 \"  %s --root %s",
                "// Line 55: \" \"$(basename \"${0}\")\" \"$*\"",
                "// Line 56:     exit 1",
                "// Line 57: fi",
                "// Line 58: ",
                "// Line 59: # Defaults",
                "// Line 60: container_command=\"\"",
                "// Line 61: # by default we use getent to get the login shell of the user and use that",
                "// Line 62: container_command_login=\"/bin/sh -c \"\\$(getent passwd ${USER} | cut -f 7 -d :) -l\"\"",
                "// vulnerable line: 63: # and we execute container_command using sh -c",
                "// vulnerable line: 64: container_command_prefix=\"/bin/sh -c\"",
                "// Line 65: container_image_default=\"registry.fedoraproject.org/fedora-toolbox:39\"",
                "// Line 66: container_manager=\"autodetect\"",
                "// Line 67: container_manager_additional_flags=\"\"",
                "// Line 68: container_name=\"\"",
                "// Line 69: container_name_default=\"my-distrobox\"",
                "// Line 70: non_interactive=0",
                "// Line 71: ",
                "// Line 72: # Use cd + dirname + pwd so that we do not have relative paths in mount points",
                "// Line 73: # We're not using \"realpath\" here so that symlinks are not resolved this way",
                "// Line 74: # \"realpath\" would break situations like Nix or similar symlink based package",
                "// Line 210:                 shift",
                "// Line 211:                 shift",
                "// Line 212:             fi",
                "// Line 213:             ;;",
                "// Line 214:         -Y | --yes)",
                "// Line 215:             non_interactive=1",
                "// Line 216:             shift",
                "// Line 217:             ;;",
                "// Line 218:         -e | --exec | --)",
                "// Line 219:             shift",
                "// vulnerable line: 220: container_command=\"$1\"",
                "// Line 221:             shift",
                "// Line 222:             for arg in \"$@\"; do",
                "// Line 223:                 arg=\"$(echo \"${arg}x\" | sed 's|'''|''\\'''|g')\"",
                "// Line 224:                 arg=\"${arg%x}\"",
                "// Line 225:                 container_command=\"${container_command} '${arg}'\"",
                "// Line 226:             done",
                "// Line 227:             break",
                "// Line 228:             ;;",
                "// Line 229:         -*) # Invalid options.",
                "// Line 230:             printf >&2 \"ERROR: Invalid flag '%s'",
                "// Line 322:     container_manager=\"${distrobox_sudo_program-} ${container_manager}\"",
                "// Line 323: fi",
                "// Line 324: ",
                "// Line 325: # Generate Podman, Docker or Lilipod command to execute.",
                "// Line 326: # Arguments:",
                "// Line 327: #   None",
                "// Line 328: # Outputs:",
                "// Line 329: #   prints the podman, docker or lilipod command to enter the distrobox container",
                "// Line 330: generate_command() {",
                "// Line 331:     result_command=\"${container_manager} exec\"",
                "// vulnerable line: 332: result_command=\"${result_command}",
                "// Line 333:         --interactive\"",
                "// vulnerable line: 334: result_command=\"${result_command}",
                "// Line 335:         --detach-keys=\"\"\"",
                "// Line 336: ",
                "// Line 337:     if [ \"${unshare_groups:-0}\" -eq 1 ]; then",
                "// Line 338:         # In case of initful systems or unshared groups, we don't enter directly",
                "// Line 339:         # as our user, but we instead enter as root, and then su $USER, in order",
                "// Line 340:         # to trigger a proper login",
                "// vulnerable line: 341: result_command=\"${result_command}",
                "// Line 342:             --user='root'\"",
                "// Line 343: ",
                "// Line 344:         # We use `su` to become the designed user, this triggers a proper login",
                "// Line 345:         # and we instantiate a proper pty with it",
                "// Line 346:         container_command_login=\"su ${USER}\"",
                "// Line 347:         if [ \"${headless}\" -eq 0 ]; then",
                "// Line 348:             container_command_login=\"${container_command_login} --pty\"",
                "// Line 349:         fi",
                "// Line 350:         container_command_login=\"${container_command_login} -c \"\\$(getent passwd ${USER} | cut -f 7 -d :) -l\"\"",
                "// vulnerable line: 351: container_command_prefix=\"${container_command_login} -c\"",
                "// Line 352:     else",
                "// vulnerable line: 353: result_command=\"${result_command}",
                "// Line 354:             --user=\"${USER}\"\"",
                "// Line 355:     fi",
                "// Line 356: ",
                "// Line 357:     # For some usage, like use in service, or launched by non-terminal",
                "// Line 358:     # eg. from desktop files, TTY can fail to instantiate, and fail to enter",
                "// Line 359:     # the container.",
                "// Line 360:     # To work around this, --headless let's you skip the --tty flag and make it",
                "// Line 361:     # work in tty-less situations.",
                "// Line 362:     # Disable tty also if we're NOT in a tty (test -t 0, test -t 1).",
                "// Line 363:     if [ \"${headless}\" -eq 0 ]; then",
                "// vulnerable line: 364: result_command=\"${result_command}",
                "// Line 365:             --tty\"",
                "// Line 366:     fi",
                "// Line 367: ",
                "// Line 368:     # Entering container using our user and workdir.",
                "// Line 369:     # Start container from working directory. Else default to home. Else do /.",
                "// Line 370:     # Since we are entering from host, drop at workdir through '/run/host'",
                "// Line 371:     # which represents host's root inside container. Any directory on host",
                "// Line 372:     # even if not explicitly mounted is bound to exist under /run/host.",
                "// Line 373:     # Since user $HOME is very likely present in container, enter there directly",
                "// Line 374:     # to avoid confusing the user about shifted paths.",
                "// Line 375:     # pass distrobox-enter path, it will be used in the distrobox-export tool.",
                "// Line 376:     if [ \"${skip_workdir}\" -eq 0 ]; then",
                "// Line 377:         workdir=\"$(echo \"${PWD:-${container_home:-\"/\"}}\" | sed -e 's/\"/\\\"/g')\"",
                "// Line 378:         if [ -n \"${workdir##*\"${container_home}\"*}\" ]; then",
                "// Line 379:             workdir=\"/run/host${workdir}\"",
                "// Line 380:         fi",
                "// Line 381:     else",
                "// Line 382:         # Skipping workdir we just enter $HOME of the container.",
                "// Line 383:         workdir=\"${container_home}\"",
                "// Line 384:     fi",
                "// vulnerable line: 385: result_command=\"${result_command}",
                "// Line 386:         --workdir=\"${workdir}\"\"",
                "// vulnerable line: 387: result_command=\"${result_command}",
                "// Line 388:         --env \"CONTAINER_ID=${container_name}\"\"",
                "// vulnerable line: 389: result_command=\"${result_command}",
                "// Line 390:         --env \"DISTROBOX_ENTER_PATH=${distrobox_enter_path}\"\"",
                "// Line 391:     # Loop through all the environment vars",
                "// Line 392:     # and export them to the container.",
                "// Line 393:     set +o xtrace",
                "// Line 394:     # disable logging for this snippet, or it will be too talkative.",
                "// Line 395:     for i in $(printenv | grep '=' | grep -Ev ' |\"|`|\\$' |",
                "// Line 396:         grep -Ev '^(CONTAINER_ID|HOST|HOSTNAME|HOME|PATH|PROFILEREAD|SHELL|XDG_SEAT|XDG_VTNR|XDG_.*_DIRS|^_)'); do",
                "// Line 397:         # We filter the environment so that we do not have strange variables,",
                "// Line 398:         # multiline or containing spaces.",
                "// Line 399:         # We also NEED to ignore the HOME variable, as this is set at create time",
                "// Line 400:         # and needs to stay that way to use custom home dirs.",
                "// vulnerable line: 401: result_command=\"${result_command}",
                "// Line 402:             --env \"${i}\"\"",
                "// Line 403:     done",
                "// Line 404: ",
                "// Line 405:     # Start with the $PATH set in the container's config",
                "// Line 406:     container_paths=\"${container_path:-\"\"}\"",
                "// Line 407:     # Ensure the standard FHS program paths are in PATH environment",
                "// Line 408:     standard_paths=\"/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin\"",
                "// Line 409:     # collect standard paths not existing from host PATH",
                "// Line 410:     for standard_path in ${standard_paths}; do",
                "// Line 411:         pattern=\"(:|^)${standard_path}(:|$)\"",
                "// Line 416:                 container_paths=\"${container_paths}:${standard_path}\"",
                "// Line 417:             fi",
                "// Line 418:         fi",
                "// Line 419:     done",
                "// Line 420:     # append additional standard paths to host PATH to get final container_paths",
                "// Line 421:     if [ -n \"${container_paths}\" ]; then",
                "// Line 422:         container_paths=\"${PATH}:${container_paths}\"",
                "// Line 423:     else",
                "// Line 424:         container_paths=\"${PATH}\"",
                "// Line 425:     fi",
                "// vulnerable line: 426: result_command=\"${result_command}",
                "// Line 427:         --env \"PATH=${container_paths}\"\"",
                "// Line 428: ",
                "// Line 429:     # Ensure the standard FHS program paths are in XDG_DATA_DIRS environment",
                "// Line 430:     standard_paths=\"/usr/local/share /usr/share\"",
                "// Line 431:     container_paths=\"${XDG_DATA_DIRS:=}\"",
                "// Line 432:     # add to the XDG_DATA_DIRS only after the host's paths, and only if not already present.",
                "// Line 433:     for standard_path in ${standard_paths}; do",
                "// Line 434:         pattern=\"(:|^)${standard_path}(:|$)\"",
                "// Line 435:         if [ -z \"${container_paths}\" ]; then",
                "// Line 436:             container_paths=\"${standard_path}\"",
                "// Line 437:         elif ! echo \"${container_paths}\" | grep -Eq \"${pattern}\"; then",
                "// Line 438:             container_paths=\"${container_paths}:${standard_path}\"",
                "// Line 439:         fi",
                "// Line 440:     done",
                "// vulnerable line: 441: result_command=\"${result_command}",
                "// Line 442:         --env \"XDG_DATA_DIRS=${container_paths}\"\"",
                "// Line 443: ",
                "// Line 444:     # This correctly sets the XDG_* dirs to the container_home",
                "// Line 445:     # it will be $HOME if using regular home dirs",
                "// Line 446:     # if will be $container_home if using a custom home during create",
                "// vulnerable line: 447: result_command=\"${result_command}",
                "// Line 448:         --env \"XDG_CACHE_HOME=${container_home}/.cache\"",
                "// Line 449:         --env \"XDG_CONFIG_HOME=${container_home}/.config\"",
                "// Line 450:         --env \"XDG_DATA_HOME=${container_home}/.local/share\"",
                "// Line 451:         --env \"XDG_STATE_HOME=${container_home}/.local/state\"\"",
                "// Line 452: ",
                "// Line 453:     # Ensure the standard FHS program paths are in XDG_CONFIG_DIRS environment",
                "// Line 454:     standard_paths=\"/etc/xdg\"",
                "// Line 455:     container_paths=\"${XDG_CONFIG_DIRS:=}\"",
                "// Line 456:     # add to the XDG_CONFIG_DIRS only after the host's paths, and only if not already present.",
                "// Line 457:     for standard_path in ${standard_paths}; do",
                "// Line 458:         pattern=\"(:|^)${standard_path}(:|$)\"",
                "// Line 459:         if [ -z \"${container_paths}\" ]; then",
                "// Line 460:             container_paths=\"${standard_path}\"",
                "// Line 461:         elif ! echo \"${container_paths}\" | grep -Eq \"${pattern}\"; then",
                "// Line 462:             container_paths=\"${container_paths}:${standard_path}\"",
                "// Line 463:         fi",
                "// Line 464:     done",
                "// vulnerable line: 465: result_command=\"${result_command}",
                "// Line 466:         --env \"XDG_CONFIG_DIRS=${container_paths}\"\"",
                "// Line 467: ",
                "// Line 468:     # re-enable logging if it was enabled previously.",
                "// Line 469:     if [ \"${verbose}\" -ne 0 ]; then",
                "// Line 470:         set -o xtrace",
                "// Line 471:     fi",
                "// Line 472: ",
                "// Line 473:     # Add additional flags",
                "// Line 474:     if [ -n \"${container_manager_additional_flags}\" ]; then",
                "// vulnerable line: 475: result_command=\"${result_command}",
                "// Line 476:             ${container_manager_additional_flags}\"",
                "// Line 477:     fi",
                "// Line 478: ",
                "// Line 479:     # Run selected container with specified command.",
                "// vulnerable line: 480: result_command=\"${result_command}",
                "// Line 481:         ${container_name}\"",
                "// Line 482: ",
                "// Line 483:     if [ -n \"${container_command}\" ]; then",
                "// vulnerable line: 484: result_command=\"${result_command}",
                "// Line 485:             ${container_command_prefix} \"${container_command}\"\"",
                "// Line 486:     else",
                "// Line 487:         # if no command was specified, let's execute a command that will find",
                "// Line 488:         # and run the default shell for the user",
                "// vulnerable line: 489: result_command=\"${result_command}",
                "// Line 490:             ${container_command_login}\"",
                "// Line 491:     fi",
                "// Line 492: ",
                "// Line 493:     # Return generated command.",
                "// Line 494:     printf \"%s\" \"${result_command}\"",
                "// Line 495: }",
                "// Line 496: ",
                "// Line 497: container_home=\"${HOME}\"",
                "// Line 498: container_path=\"${PATH}\"",
                "// Line 499: unshare_groups=0"
            ]
        }
    ]
}