{
    "cve_id": "CVE-2022-4963",
    "cve_description": "A vulnerability was found in Folio Spring Module Core up to 1.1.5. It has been rated as critical. Affected by this issue is the function dropSchema of the file tenant/src/main/java/org/folio/spring/tenant/hibernate/HibernateSchemaService.java of the component Schema Name Handler. The manipulation leads to sql injection. Upgrading to version 2.0.0 is able to address this issue. The name of the patch is d374a5f77e6b58e36f0e0e4419be18b95edcd7ff. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-257516.",
    "cve_publish_date": "2024-03-21T02:44Z",
    "cwe_id": "CWE-89",
    "cwe_name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
    "cwe_description": "The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component. Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data.",
    "commit_message": "FOLIO-3645: schema name SQL injection\n\nSELECT EXISTS now uses a prepared statement.\n\nPostgreSQL doesn't support a prepared statement for CREATE SCHEMA and DROP SCHEMA.\nInstead we validate the schema name before use to mitigate any SQL injection attack.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "HibernateSchemaService.java",
            "code_language": "Java",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 34: import org.springframework.beans.factory.annotation.Autowired;",
                "// Line 35: import org.springframework.beans.factory.config.BeanDefinition;",
                "// Line 36: import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;",
                "// Line 37: import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;",
                "// Line 38: import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;",
                "// Line 39: import org.springframework.core.io.Resource;",
                "// Line 40: import org.springframework.core.io.ResourceLoader;",
                "// Line 41: import org.springframework.core.type.filter.AnnotationTypeFilter;",
                "// Line 42: import org.springframework.stereotype.Service;",
                "// Line 43: ",
                "// vulnerable line: 44: import static org.hibernate.cfg.AvailableSettings.*;",
                "// Line 45: ",
                "// Line 46: @Service(\"hibernateSchemaService\")",
                "// Line 47: public class HibernateSchemaService implements InitializingBean {",
                "// Line 48: ",
                "// Line 49:   private final static String CONNECTION_DRIVER_CLASS = \"connection.driver_class\";",
                "// Line 50:   private final static String DIALECT = \"dialect\";",
                "// Line 51:   private final static String HIBERNATE_CONNECTION_URL = \"hibernate.connection.url\";",
                "// Line 52:   private final static String HIBERNATE_CONNECTION_DRIVER_CLASS = \"hibernate.connection.driver_class\";",
                "// Line 53:   private final static String HIBERNATE_DEFAULT_SCHEMA = \"hibernate.default_schema\";",
                "// Line 54:   private final static String HIBERNATE_JDBC_LOB_NON_CONTEXTUAL_CREATION = \"hibernate.jdbc.lob.non_contextual_creation\";",
                "// Line 128:     createSchema(connection, schema);",
                "// Line 129:     createTables(settings);",
                "// Line 130:     createAdditionalSchema(connection, schema);",
                "// Line 131:     initializeData(connection, schema);",
                "// Line 132:     for (HibernateTenantInit hibernateTenantInitialization : hibernateTenantInitializations) {",
                "// Line 133:       hibernateTenantInitialization.initialize(connection, schema);",
                "// Line 134:     }",
                "// Line 135:   }",
                "// Line 136: ",
                "// Line 137:   private void createSchema(Connection connection, String schema) throws SQLException {",
                "// vulnerable line: 138: try (Statement statement = connection.createStatement()) {",
                "// Line 139:       statement.executeUpdate(String.format(\"CREATE SCHEMA IF NOT EXISTS %s;\", schema));",
                "// Line 140:     }",
                "// Line 141:   }",
                "// Line 142: ",
                "// Line 143:   private void createTables(Map<String, String> settings) {",
                "// Line 144:     MetadataImplementor metadata = buildMetadata(settings);",
                "// Line 145:     SchemaExport schemaExport = new SchemaExport();",
                "// Line 146:     schemaExport.create(EnumSet.of(TargetType.DATABASE), metadata);",
                "// Line 147:   }",
                "// Line 148: ",
                "// Line 149:   private void initializeData(Connection connection, String schema) throws SQLException {",
                "// vulnerable line: 150: try (Statement statement = connection.createStatement()) {",
                "// Line 151:       statement.execute(sqlTemplateService.templateImportSql(schema));",
                "// Line 152:     }",
                "// Line 153:   }",
                "// Line 154: ",
                "// Line 155:   private void createAdditionalSchema(Connection connection, String schema) throws SQLException, IOException {",
                "// vulnerable line: 156: try (Statement statement = connection.createStatement()) {",
                "// Line 157:       statement.execute(sqlTemplateService.templateSelectSchemaSql(schema));",
                "// Line 158:       for (String path : tenantProperties.getSchemaScripts()) {",
                "// Line 159:         Resource resource = resourceLoader.getResource(path);",
                "// Line 160:         File script;",
                "// Line 161:         if (resource.getURI().getScheme().equals(\"jar\")) {",
                "// Line 162:           script = File.createTempFile(\"schema\", \".sql\");",
                "// Line 163:           script.deleteOnExit();",
                "// Line 164:           IOUtils.copy(resource.getInputStream(), new FileOutputStream(script));",
                "// Line 165:         } else {",
                "// Line 166:           script = resource.getFile();",
                "// Line 167:         }",
                "// Line 168:         statement.execute(FileUtils.readFileToString(script, StandardCharsets.UTF_8));",
                "// Line 169:       }",
                "// Line 170:     }",
                "// Line 171:   }",
                "// Line 172: ",
                "// Line 173:   private void dropSchema(Connection connection, String schema) throws SQLException {",
                "// vulnerable line: 174: try (Statement statement = connection.createStatement()) {",
                "// Line 175:       statement.executeUpdate(String.format(\"DROP SCHEMA IF EXISTS %s CASCADE;\", schema));",
                "// Line 176:     }",
                "// Line 177:   }",
                "// Line 178: ",
                "// Line 179:   private boolean schemaExists(Connection connection, String schema) throws SQLException {",
                "// vulnerable line: 180: try (Statement statement = connection.createStatement()) {",
                "// vulnerable line: 181: String queryTemplate = \"SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = '%s');\";",
                "// vulnerable line: 182: ResultSet resultSet = statement.executeQuery(String.format(queryTemplate, schema));",
                "// Line 183:       if (resultSet.next()) {",
                "// Line 184:         return resultSet.getBoolean(1);",
                "// Line 185:       }",
                "// Line 186:       return false;",
                "// Line 187:     }",
                "// Line 188:   }",
                "// Line 189: ",
                "// Line 190:   private Map<String, String> getSettings(String tenant) {",
                "// Line 191:     Map<String, String> settings = new HashMap<String, String>();",
                "// Line 192:     settings.put(CONNECTION_DRIVER_CLASS, dataSourceProperties.getDriverClassName());"
            ]
        },
        {
            "filename_of_changes": "SchemaService.java",
            "code_language": "Java",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 4: import org.springframework.beans.factory.annotation.Autowired;",
                "// Line 5: import org.springframework.stereotype.Service;",
                "// Line 6: ",
                "// Line 7: @Service",
                "// Line 8: public class SchemaService {",
                "// Line 9: ",
                "// Line 10:   @Autowired",
                "// Line 11:   private BuildInfoProperties buildInfoProperties;",
                "// Line 12: ",
                "// Line 13:   public String getSchema(String tenant) {",
                "// vulnerable line: 14: return String.format(\"%s_%s\", tenant, buildInfoProperties.getArtifact()).replace(\"-\", \"_\");",
                "// Line 15:   }",
                "// Line 16: ",
                "// Line 17: }"
            ]
        }
    ]
}