{
    "cve_id": "CVE-2024-34078",
    "cve_description": "html-sanitizer is an allowlist-based HTML cleaner. If using `keep_typographic_whitespace=False` (which is the default), the sanitizer normalizes unicode to the NFKC form at the end. Some unicode characters normalize to chevrons; this allows specially crafted HTML to escape sanitization. The problem has been fixed in 2.4.2.\n",
    "cve_publish_date": "2024-05-06T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Normalize unicode earlier",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "sanitizer.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 193:         # Allow iterables of any kind, not just sets.",
                "// Line 194:         self.tags = coerce_to_set(self.tags)",
                "// Line 195:         self.empty = coerce_to_set(self.empty)",
                "// Line 196:         self.separate = coerce_to_set(self.separate)",
                "// Line 197:         self.whitespace = coerce_to_set(self.whitespace)",
                "// Line 198:         self.attributes = {",
                "// Line 199:             tag: coerce_to_set(attributes)",
                "// Line 200:             for tag, attributes in self.attributes.items()",
                "// Line 201:         }",
                "// Line 202: ",
                "// vulnerable line: 203: if self.keep_typographic_whitespace:",
                "// Line 204:             re_whitespace = r\"[^\\S%s]\" % typographic_whitespace",
                "// vulnerable line: 205: else:",
                "// Line 206:             re_whitespace = r\"\\s\"",
                "// Line 207: ",
                "// Line 208:         self.only_whitespace_re = re.compile(rf\"^{re_whitespace}*$\")",
                "// Line 209:         self.whitespace_re = re.compile(rf\"{re_whitespace}+\")",
                "// Line 210: ",
                "// Line 211:         # Validate the settings.",
                "// Line 212:         if not self.tags:",
                "// Line 213:             raise TypeError(",
                "// Line 214:                 \"Empty list of allowed tags is not supported by the underlying\"",
                "// Line 215:                 \" lxml cleaner. If you really do not want to pass any tags\"",
                "// Line 360:                     and self.is_mergeable(element, nx)",
                "// Line 361:                 ):",
                "// Line 362:                     # Yes, we should. Tail is empty, that is, no text between",
                "// Line 363:                     # tags of a mergeable type.",
                "// Line 364:                     if nx.text:",
                "// Line 365:                         if len(element):",
                "// Line 366:                             list(element)[-1].tail = \"{}{}\".format(",
                "// Line 367:                                 list(element)[-1].tail or \"\",",
                "// Line 368:                                 nx.text,",
                "// Line 369:                             )",
                "// vulnerable line: 370: else:",
                "// Line 371:                             element.text = \"{}{}\".format(element.text or \"\", nx.text)",
                "// Line 372: ",
                "// Line 373:                     for child in nx:",
                "// Line 374:                         element.append(child)",
                "// Line 375: ",
                "// Line 376:                     # tail is merged with previous element.",
                "// Line 377:                     nx.drop_tree()",
                "// Line 378: ",
                "// Line 379:                     # Process element again",
                "// Line 380:                     backlog.append(element)",
                "// Line 415:         )(doc)",
                "// Line 416: ",
                "// Line 417:         html = lxml.html.tostring(doc, encoding=\"unicode\")",
                "// Line 418: ",
                "// Line 419:         # add a space before the closing slash in empty tags",
                "// Line 420:         html = re.sub(r\"<([^/>]+)/>\", r\"<\u0001 />\", html)",
                "// Line 421: ",
                "// Line 422:         # remove wrapping tag needed by XML parser",
                "// Line 423:         html = re.sub(r\"^<div>|</div>$\", \"\", html)",
                "// Line 424: ",
                "// vulnerable line: 425: # normalize unicode",
                "// vulnerable line: 426: if self.keep_typographic_whitespace:",
                "// vulnerable line: 427: html = unicodedata.normalize(\"NFC\", html)",
                "// vulnerable line: 428: else:",
                "// vulnerable line: 429: html = unicodedata.normalize(\"NFKC\", html)",
                "// Line 430: ",
                "// Line 431:         return html"
            ]
        },
        {
            "filename_of_changes": "tests.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "10",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}