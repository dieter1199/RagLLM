{
    "cve_id": "CVE-2024-27102",
    "cve_description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-13T21:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "server(filesystem): rebuild everything imaginable\n\nThis wonderfully large commit replaces basically everything under the\n`server/filesystem` package, re-implementing essentially everything.\n\nThis is related to\nhttps://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9\n\nIf any vulnerabilities related to symlinks persist after this commit, I\nwill be very upset.\n\nSigned-off-by: Matthew Penner <me@matthewp.io>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "archive.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 28: ",
                "// Line 29: // Archive represents an archive used to transfer the contents of a server.",
                "// Line 30: type Archive struct {",
                "// Line 31:     archive *filesystem.Archive",
                "// Line 32: }",
                "// Line 33: ",
                "// Line 34: // NewArchive returns a new archive associated with the given transfer.",
                "// Line 35: func NewArchive(t *Transfer, size uint64) *Archive {",
                "// Line 36:     return &Archive{",
                "// Line 37:         archive: &filesystem.Archive{",
                "// vulnerable line: 38: BasePath: t.Server.Filesystem().Path(),",
                "// vulnerable line: 39: Progress: progress.NewProgress(size),",
                "// Line 40:         },",
                "// Line 41:     }",
                "// Line 42: }",
                "// Line 43: ",
                "// Line 44: // Stream returns a reader that can be used to stream the contents of the archive.",
                "// Line 45: func (a *Archive) Stream(ctx context.Context, w io.Writer) error {",
                "// Line 46:     return a.archive.Stream(ctx, w)",
                "// Line 47: }",
                "// Line 48: ",
                "// Line 49: // Progress returns the current progress of the archive."
            ]
        },
        {
            "filename_of_changes": "archive_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "22",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 13:     \"github.com/mholt/archiver/v4\"",
                "// Line 14: )",
                "// Line 15: ",
                "// Line 16: func TestArchive_Stream(t *testing.T) {",
                "// Line 17:     g := Goblin(t)",
                "// Line 18:     fs, rfs := NewFs()",
                "// Line 19: ",
                "// Line 20:     g.Describe(\"Archive\", func() {",
                "// Line 21:         g.AfterEach(func() {",
                "// Line 22:             // Reset the filesystem after each run.",
                "// vulnerable line: 23: rfs.reset()",
                "// vulnerable line: 24: })",
                "// Line 25: ",
                "// vulnerable line: 26: g.It(\"throws an error when passed invalid file paths\", func() {",
                "// vulnerable line: 27: a := &Archive{",
                "// vulnerable line: 28: BasePath: fs.Path(),",
                "// vulnerable line: 29: Files: []string{",
                "// vulnerable line: 30: // To use the archiver properly, this needs to be filepath.Join(BasePath, \"yeet\")",
                "// vulnerable line: 31: // However, this test tests that we actually validate that behavior.",
                "// vulnerable line: 32: \"yeet\",",
                "// vulnerable line: 33: },",
                "// vulnerable line: 34: }",
                "// Line 35: ",
                "// vulnerable line: 36: g.Assert(a.Create(context.Background(), \"\")).IsNotNil()",
                "// vulnerable line: 37: })",
                "// Line 38: ",
                "// Line 39:         g.It(\"creates archive with intended files\", func() {",
                "// Line 40:             g.Assert(fs.CreateDirectory(\"test\", \"/\")).IsNil()",
                "// Line 41:             g.Assert(fs.CreateDirectory(\"test2\", \"/\")).IsNil()",
                "// Line 42: ",
                "// Line 43:             err := fs.Writefile(\"test/file.txt\", strings.NewReader(\"hello, world!",
                "// Line 44: \"))",
                "// Line 45:             g.Assert(err).IsNil()",
                "// Line 46: ",
                "// Line 47:             err = fs.Writefile(\"test2/file.txt\", strings.NewReader(\"hello, world!",
                "// Line 49:             g.Assert(err).IsNil()",
                "// Line 50: ",
                "// Line 51:             err = fs.Writefile(\"test_file.txt\", strings.NewReader(\"hello, world!",
                "// Line 52: \"))",
                "// Line 53:             g.Assert(err).IsNil()",
                "// Line 54: ",
                "// Line 55:             err = fs.Writefile(\"test_file.txt.old\", strings.NewReader(\"hello, world!",
                "// Line 56: \"))",
                "// Line 57:             g.Assert(err).IsNil()",
                "// Line 58: ",
                "// vulnerable line: 59: a := &Archive{",
                "// vulnerable line: 60: BasePath: fs.Path(),",
                "// vulnerable line: 61: Files: []string{",
                "// vulnerable line: 62: filepath.Join(fs.Path(), \"test\"),",
                "// vulnerable line: 63: filepath.Join(fs.Path(), \"test_file.txt\"),",
                "// vulnerable line: 64: },",
                "// vulnerable line: 65: }",
                "// Line 66: ",
                "// Line 67:             // Create the archive.",
                "// Line 68:             archivePath := filepath.Join(rfs.root, \"archive.tar.gz\")",
                "// Line 69:             g.Assert(a.Create(context.Background(), archivePath)).IsNil()",
                "// Line 70: ",
                "// Line 71:             // Ensure the archive exists.",
                "// Line 72:             _, err = os.Stat(archivePath)",
                "// Line 73:             g.Assert(err).IsNil()",
                "// Line 74: ",
                "// Line 75:             // Open the archive.",
                "// Line 81:             g.Assert(ok).IsTrue()",
                "// Line 82: ",
                "// Line 83:             // Get the names of the files recursively from the archive.",
                "// Line 84:             files, err := getFiles(afs, \".\")",
                "// Line 85:             g.Assert(err).IsNil()",
                "// Line 86: ",
                "// Line 87:             // Ensure the files in the archive match what we are expecting.",
                "// Line 88:             expected := []string{",
                "// Line 89:                 \"test_file.txt\",",
                "// Line 90:                 \"test/file.txt\",",
                "// vulnerable line: 91: }",
                "// Line 92: ",
                "// Line 93:             // Sort the slices to ensure the comparison never fails if the",
                "// Line 94:             // contents are sorted differently.",
                "// Line 95:             sort.Strings(expected)",
                "// Line 96:             sort.Strings(files)",
                "// Line 97: ",
                "// Line 98:             g.Assert(files).Equal(expected)",
                "// vulnerable line: 99: })",
                "// vulnerable line: 100: })",
                "// vulnerable line: 101: }",
                "// Line 102: ",
                "// Line 103: func getFiles(f iofs.ReadDirFS, name string) ([]string, error) {",
                "// Line 104:     var v []string",
                "// Line 105: ",
                "// Line 106:     entries, err := f.ReadDir(name)",
                "// Line 107:     if err != nil {",
                "// Line 108:         return nil, err",
                "// vulnerable line: 109: }",
                "// Line 110: ",
                "// Line 111:     for _, e := range entries {",
                "// Line 112:         entryName := e.Name()",
                "// Line 113:         if name != \".\" {",
                "// Line 114:             entryName = filepath.Join(name, entryName)",
                "// vulnerable line: 115: }",
                "// Line 116: ",
                "// Line 117:         if e.IsDir() {",
                "// Line 118:             files, err := getFiles(f, entryName)",
                "// Line 119:             if err != nil {",
                "// Line 120:                 return nil, err",
                "// vulnerable line: 121: }",
                "// Line 122: ",
                "// Line 123:             if files == nil {",
                "// Line 124:                 return nil, nil",
                "// vulnerable line: 125: }",
                "// Line 126: ",
                "// Line 127:             v = append(v, files...)",
                "// Line 128:             continue",
                "// vulnerable line: 129: }",
                "// Line 130: ",
                "// Line 131:         v = append(v, entryName)",
                "// vulnerable line: 132: }",
                "// Line 133: ",
                "// Line 134:     return v, nil",
                "// vulnerable line: 135: }"
            ]
        },
        {
            "filename_of_changes": "backup.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "9",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 17: ",
                "// Line 18: // Notifies the panel of a backup's state and returns an error if one is encountered",
                "// Line 19: // while performing this action.",
                "// Line 20: func (s *Server) notifyPanelOfBackup(uuid string, ad *backup.ArchiveDetails, successful bool) error {",
                "// Line 21:     if err := s.client.SetBackupStatus(s.Context(), uuid, ad.ToRequest(successful)); err != nil {",
                "// Line 22:         if !remote.IsRequestError(err) {",
                "// Line 23:             s.Log().WithFields(log.Fields{",
                "// Line 24:                 \"backup\": uuid,",
                "// Line 25:                 \"error\":  err,",
                "// Line 26:             }).Error(\"failed to notify panel of backup status due to wings error\")",
                "// vulnerable line: 27: return err",
                "// vulnerable line: 28: }",
                "// Line 29: ",
                "// Line 30:         return errors.New(err.Error())",
                "// vulnerable line: 31: }",
                "// Line 32: ",
                "// Line 33:     return nil",
                "// vulnerable line: 34: }",
                "// Line 35: ",
                "// Line 36: // Get all of the ignored files for a server based on its .pteroignore file in the root.",
                "// Line 37: func (s *Server) getServerwideIgnoredFiles() (string, error) {",
                "// Line 38:     f, st, err := s.Filesystem().File(\".pteroignore\")",
                "// Line 39:     if err != nil {",
                "// Line 40:         if errors.Is(err, os.ErrNotExist) {",
                "// Line 41:             return \"\", nil",
                "// vulnerable line: 42: }",
                "// Line 43:         return \"\", err",
                "// vulnerable line: 44: }",
                "// Line 45:     defer f.Close()",
                "// Line 46:     if st.Mode()&os.ModeSymlink != 0 || st.Size() > 32*1024 {",
                "// Line 47:         // Don't read a symlinked ignore file, or a file larger than 32KiB in size.",
                "// Line 48:         return \"\", nil",
                "// vulnerable line: 49: }",
                "// Line 50:     b, err := io.ReadAll(f)",
                "// Line 51:     if err != nil {",
                "// Line 52:         return \"\", err",
                "// vulnerable line: 53: }",
                "// Line 54:     return string(b), nil",
                "// vulnerable line: 55: }",
                "// Line 56: ",
                "// Line 57: // Backup performs a server backup and then emits the event over the server",
                "// Line 58: // websocket. We let the actual backup system handle notifying the panel of the",
                "// Line 59: // status, but that won't emit a websocket event.",
                "// Line 60: func (s *Server) Backup(b backup.BackupInterface) error {",
                "// Line 61:     ignored := b.Ignored()",
                "// Line 62:     if b.Ignored() == \"\" {",
                "// Line 63:         if i, err := s.getServerwideIgnoredFiles(); err != nil {",
                "// Line 64:             log.WithField(\"server\", s.ID()).WithField(\"error\", err).Warn(\"failed to get server-wide ignored files\")",
                "// Line 65:         } else {",
                "// Line 66:             ignored = i",
                "// vulnerable line: 67: }",
                "// vulnerable line: 68: }",
                "// Line 69: ",
                "// vulnerable line: 70: ad, err := b.Generate(s.Context(), s.Filesystem().Path(), ignored)",
                "// Line 71:     if err != nil {",
                "// Line 72:         if err := s.notifyPanelOfBackup(b.Identifier(), &backup.ArchiveDetails{}, false); err != nil {",
                "// Line 73:             s.Log().WithFields(log.Fields{",
                "// Line 74:                 \"backup\": b.Identifier(),",
                "// Line 75:                 \"error\":  err,",
                "// Line 76:             }).Warn(\"failed to notify panel of failed backup state\")",
                "// Line 77:         } else {",
                "// Line 78:             s.Log().WithField(\"backup\", b.Identifier()).Info(\"notified panel of failed backup state\")",
                "// vulnerable line: 79: }",
                "// Line 80: ",
                "// Line 81:         s.Events().Publish(BackupCompletedEvent+\":\"+b.Identifier(), map[string]interface{}{",
                "// Line 82:             \"uuid\":          b.Identifier(),",
                "// Line 83:             \"is_successful\": false,",
                "// Line 84:             \"checksum\":      \"\",",
                "// Line 85:             \"checksum_type\": \"sha1\",",
                "// Line 86:             \"file_size\":     0,",
                "// Line 87:         })",
                "// Line 88: ",
                "// Line 89:         return errors.WrapIf(err, \"backup: error while generating server backup\")",
                "// vulnerable line: 90: }",
                "// Line 91: ",
                "// Line 92:     // Try to notify the panel about the status of this backup. If for some reason this request",
                "// Line 93:     // fails, delete the archive from the daemon and return that error up the chain to the caller.",
                "// Line 94:     if notifyError := s.notifyPanelOfBackup(b.Identifier(), ad, true); notifyError != nil {",
                "// Line 95:         _ = b.Remove()",
                "// Line 96: ",
                "// Line 97:         s.Log().WithField(\"error\", notifyError).Info(\"failed to notify panel of successful backup state\")",
                "// vulnerable line: 98: return err",
                "// Line 99:     } else {",
                "// Line 100:         s.Log().WithField(\"backup\", b.Identifier()).Info(\"notified panel of successful backup state\")",
                "// vulnerable line: 101: }",
                "// Line 102: ",
                "// Line 103:     // Emit an event over the socket so we can update the backup in realtime on",
                "// Line 104:     // the frontend for the server.",
                "// Line 105:     s.Events().Publish(BackupCompletedEvent+\":\"+b.Identifier(), map[string]interface{}{",
                "// Line 106:         \"uuid\":          b.Identifier(),",
                "// Line 107:         \"is_successful\": true,",
                "// Line 108:         \"checksum\":      ad.Checksum,",
                "// Line 109:         \"checksum_type\": \"sha1\",",
                "// Line 110:         \"file_size\":     ad.Size,",
                "// Line 111:     })",
                "// Line 112: ",
                "// Line 113:     return nil",
                "// vulnerable line: 114: }",
                "// Line 115: ",
                "// Line 116: // RestoreBackup calls the Restore function on the provided backup. Once this",
                "// Line 117: // restoration is completed an event is emitted to the websocket to notify the",
                "// Line 118: // Panel that is has been completed.",
                "// Line 119: //",
                "// Line 120: // In addition to the websocket event an API call is triggered to notify the",
                "// Line 121: // Panel of the new state.",
                "// Line 122: func (s *Server) RestoreBackup(b backup.BackupInterface, reader io.ReadCloser) (err error) {",
                "// Line 123:     s.Config().SetSuspended(true)",
                "// Line 124:     // Local backups will not pass a reader through to this function, so check first",
                "// Line 125:     // to make sure it is a valid reader before trying to close it.",
                "// Line 126:     defer func() {",
                "// Line 127:         s.Config().SetSuspended(false)",
                "// Line 128:         if reader != nil {",
                "// Line 129:             _ = reader.Close()",
                "// vulnerable line: 130: }",
                "// Line 131:     }()",
                "// Line 132:     // Send an API call to the Panel as soon as this function is done running so that",
                "// Line 133:     // the Panel is informed of the restoration status of this backup.",
                "// Line 134:     defer func() {",
                "// Line 135:         if rerr := s.client.SendRestorationStatus(s.Context(), b.Identifier(), err == nil); rerr != nil {",
                "// Line 136:             s.Log().WithField(\"error\", rerr).WithField(\"backup\", b.Identifier()).Error(\"failed to notify Panel of backup restoration status\")",
                "// vulnerable line: 137: }",
                "// Line 138:     }()",
                "// Line 139: ",
                "// Line 140:     // Don't try to restore the server until we have completely stopped the running",
                "// Line 141:     // instance, otherwise you'll likely hit all types of write errors due to the",
                "// Line 142:     // server being suspended.",
                "// Line 143:     if s.Environment.State() != environment.ProcessOfflineState {",
                "// Line 144:         if err = s.Environment.WaitForStop(s.Context(), 2*time.Minute, false); err != nil {",
                "// Line 145:             if !client.IsErrNotFound(err) {",
                "// Line 146:                 return errors.WrapIf(err, \"server/backup: restore: failed to wait for container stop\")",
                "// vulnerable line: 147: }",
                "// vulnerable line: 148: }",
                "// vulnerable line: 149: }",
                "// Line 150: ",
                "// Line 151:     // Attempt to restore the backup to the server by running through each entry",
                "// Line 152:     // in the file one at a time and writing them to the disk.",
                "// Line 153:     s.Log().Debug(\"starting file writing process for backup restoration\")",
                "// Line 154:     err = b.Restore(s.Context(), reader, func(file string, info fs.FileInfo, r io.ReadCloser) error {",
                "// Line 155:         defer r.Close()",
                "// Line 156:         s.Events().Publish(DaemonMessageEvent, \"(restoring): \"+file)",
                "// Line 157: ",
                "// vulnerable line: 158: if err := s.Filesystem().Writefile(file, r); err != nil {",
                "// vulnerable line: 159: return err",
                "// vulnerable line: 160: }",
                "// vulnerable line: 161: if err := s.Filesystem().Chmod(file, info.Mode()); err != nil {",
                "// vulnerable line: 162: return err",
                "// vulnerable line: 163: }",
                "// Line 164: ",
                "// Line 165:         atime := info.ModTime()",
                "// vulnerable line: 166: mtime := atime",
                "// vulnerable line: 167: return s.Filesystem().Chtimes(file, atime, mtime)",
                "// Line 168:     })",
                "// Line 169: ",
                "// Line 170:     return errors.WithStackIf(err)",
                "// vulnerable line: 171: }"
            ]
        },
        {
            "filename_of_changes": "backup.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 39:     // SetClient sets the API request client on the backup interface.",
                "// Line 40:     SetClient(remote.Client)",
                "// Line 41:     // Identifier returns the UUID of this backup as tracked by the panel",
                "// Line 42:     // instance.",
                "// Line 43:     Identifier() string",
                "// Line 44:     // WithLogContext attaches additional context to the log output for this",
                "// Line 45:     // backup.",
                "// Line 46:     WithLogContext(map[string]interface{})",
                "// Line 47:     // Generate creates a backup in whatever the configured source for the",
                "// Line 48:     // specific implementation is.",
                "// vulnerable line: 49: Generate(context.Context, string, string) (*ArchiveDetails, error)",
                "// Line 50:     // Ignored returns the ignored files for this backup instance.",
                "// Line 51:     Ignored() string",
                "// Line 52:     // Checksum returns a SHA1 checksum for the generated backup.",
                "// Line 53:     Checksum() ([]byte, error)",
                "// Line 54:     // Size returns the size of the generated backup.",
                "// Line 55:     Size() (int64, error)",
                "// Line 56:     // Path returns the path to the backup on the machine. This is not always",
                "// Line 57:     // the final storage location of the backup, simply the location we're using",
                "// Line 58:     // to store it until it is moved to the final spot.",
                "// Line 59:     Path() string"
            ]
        },
        {
            "filename_of_changes": "backup_local.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 52:     return os.Remove(b.Path())",
                "// Line 53: }",
                "// Line 54: ",
                "// Line 55: // WithLogContext attaches additional context to the log output for this backup.",
                "// Line 56: func (b *LocalBackup) WithLogContext(c map[string]interface{}) {",
                "// Line 57:     b.logContext = c",
                "// Line 58: }",
                "// Line 59: ",
                "// Line 60: // Generate generates a backup of the selected files and pushes it to the",
                "// Line 61: // defined location for this instance.",
                "// vulnerable line: 62: func (b *LocalBackup) Generate(ctx context.Context, basePath, ignore string) (*ArchiveDetails, error) {",
                "// Line 63:     a := &filesystem.Archive{",
                "// vulnerable line: 64: BasePath: basePath,",
                "// vulnerable line: 65: Ignore:   ignore,",
                "// Line 66:     }",
                "// Line 67: ",
                "// Line 68:     b.log().WithField(\"path\", b.Path()).Info(\"creating backup for server\")",
                "// Line 69:     if err := a.Create(ctx, b.Path()); err != nil {",
                "// Line 70:         return nil, err",
                "// Line 71:     }",
                "// Line 72:     b.log().Info(\"created backup successfully\")",
                "// Line 73: ",
                "// Line 74:     ad, err := b.Details(ctx, nil)",
                "// Line 75:     if err != nil {"
            ]
        },
        {
            "filename_of_changes": "backup_s3.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 41:     return os.Remove(s.Path())",
                "// Line 42: }",
                "// Line 43: ",
                "// Line 44: // WithLogContext attaches additional context to the log output for this backup.",
                "// Line 45: func (s *S3Backup) WithLogContext(c map[string]interface{}) {",
                "// Line 46:     s.logContext = c",
                "// Line 47: }",
                "// Line 48: ",
                "// Line 49: // Generate creates a new backup on the disk, moves it into the S3 bucket via",
                "// Line 50: // the provided presigned URL, and then deletes the backup from the disk.",
                "// vulnerable line: 51: func (s *S3Backup) Generate(ctx context.Context, basePath, ignore string) (*ArchiveDetails, error) {",
                "// Line 52:     defer s.Remove()",
                "// Line 53: ",
                "// Line 54:     a := &filesystem.Archive{",
                "// vulnerable line: 55: BasePath: basePath,",
                "// vulnerable line: 56: Ignore:   ignore,",
                "// Line 57:     }",
                "// Line 58: ",
                "// Line 59:     s.log().WithField(\"path\", s.Path()).Info(\"creating backup for server\")",
                "// Line 60:     if err := a.Create(ctx, s.Path()); err != nil {",
                "// Line 61:         return nil, err",
                "// Line 62:     }",
                "// Line 63:     s.log().Info(\"created backup successfully\")",
                "// Line 64: ",
                "// Line 65:     rc, err := os.Open(s.Path())",
                "// Line 66:     if err != nil {"
            ]
        },
        {
            "filename_of_changes": "compress_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package filesystem",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"context\"",
                "// Line 5:     \"os\"",
                "// vulnerable line: 6: \"sync/atomic\"",
                "// Line 7:     \"testing\"",
                "// Line 8: ",
                "// Line 9:     . \"github.com/franela/goblin\"",
                "// Line 10: )",
                "// Line 11: ",
                "// Line 12: // Given an archive named test.{ext}, with the following file structure:",
                "// Line 13: //    test/",
                "// Line 14: //    |──inside/",
                "// Line 15: //    |────finside.txt",
                "// Line 16: //    |──outside.txt",
                "// Line 40:                 g.Assert(err).IsNil()",
                "// Line 41:                 g.Assert(st.IsDir()).IsTrue()",
                "// Line 42: ",
                "// Line 43:                 _, err = rfs.StatServerFile(\"test/inside/finside.txt\")",
                "// Line 44:                 g.Assert(err).IsNil()",
                "// Line 45:                 g.Assert(st.IsDir()).IsTrue()",
                "// Line 46:             })",
                "// Line 47:         }",
                "// Line 48: ",
                "// Line 49:         g.AfterEach(func() {",
                "// vulnerable line: 50: rfs.reset()",
                "// vulnerable line: 51: atomic.StoreInt64(&fs.diskUsed, 0)",
                "// vulnerable line: 52: atomic.StoreInt64(&fs.diskLimit, 0)",
                "// Line 53:         })",
                "// Line 54:     })",
                "// Line 55: }"
            ]
        },
        {
            "filename_of_changes": "config_parser.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "6",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package server",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"runtime\"",
                "// Line 5: ",
                "// Line 6:     \"github.com/gammazero/workerpool\"",
                "// Line 7: )",
                "// Line 8: ",
                "// vulnerable line: 9: // UpdateConfigurationFiles updates all of the defined configuration files for",
                "// Line 10: // a server automatically to ensure that they always use the specified values.",
                "// Line 11: func (s *Server) UpdateConfigurationFiles() {",
                "// Line 12:     pool := workerpool.New(runtime.NumCPU())",
                "// Line 13: ",
                "// Line 14:     s.Log().Debug(\"acquiring process configuration files...\")",
                "// Line 15:     files := s.ProcessConfiguration().ConfigurationFiles",
                "// Line 16:     s.Log().Debug(\"acquired process configuration files\")",
                "// Line 17:     for _, cf := range files {",
                "// Line 18:         f := cf",
                "// Line 19: ",
                "// Line 20:         pool.Submit(func() {",
                "// vulnerable line: 21: p, err := s.Filesystem().SafePath(f.FileName)",
                "// Line 22:             if err != nil {",
                "// vulnerable line: 23: s.Log().WithField(\"error\", err).Error(\"failed to generate safe path for configuration file\")",
                "// Line 24: ",
                "// Line 25:                 return",
                "// Line 26:             }",
                "// Line 27: ",
                "// vulnerable line: 28: if err := f.Parse(p, false); err != nil {",
                "// Line 29:                 s.Log().WithField(\"error\", err).Error(\"failed to parse and update server configuration file\")",
                "// Line 30:             }",
                "// Line 31: ",
                "// vulnerable line: 32: s.Log().WithField(\"path\", f.FileName).Debug(\"finished processing server configuration file\")",
                "// Line 33:         })",
                "// Line 34:     }",
                "// Line 35: ",
                "// Line 36:     pool.StopWait()",
                "// Line 37: }"
            ]
        },
        {
            "filename_of_changes": "doc.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "12",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "downloader.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "8",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 27:     // instance's local network.",
                "// Line 28:     //",
                "// Line 29:     // This specific error response just causes the client to not follow the redirect and",
                "// Line 30:     // returns the actual redirect response to the caller. Not perfect, but simple and most",
                "// Line 31:     // people won't be using URLs that redirect anyways hopefully?",
                "// Line 32:     //",
                "// Line 33:     // We'll re-evaluate this down the road if needed.",
                "// Line 34:     CheckRedirect: func(req *http.Request, via []*http.Request) error {",
                "// Line 35:         return http.ErrUseLastResponse",
                "// Line 36:     },",
                "// vulnerable line: 37: }",
                "// Line 38: ",
                "// Line 39: var instance = &Downloader{",
                "// Line 40:     // Tracks all the active downloads.",
                "// Line 41:     downloadCache: make(map[string]*Download),",
                "// Line 42:     // Tracks all the downloads active for a given server instance. This is",
                "// Line 43:     // primarily used to make things quicker and keep the code a little more",
                "// Line 44:     // legible throughout here.",
                "// Line 45:     serverCache: make(map[string][]string),",
                "// vulnerable line: 46: }",
                "// Line 47: ",
                "// Line 48: // Internal IP ranges that should be blocked if the resource requested resolves within.",
                "// Line 49: var internalRanges = []*net.IPNet{",
                "// Line 50:     mustParseCIDR(\"127.0.0.1/8\"),",
                "// Line 51:     mustParseCIDR(\"10.0.0.0/8\"),",
                "// Line 52:     mustParseCIDR(\"172.16.0.0/12\"),",
                "// Line 53:     mustParseCIDR(\"192.168.0.0/16\"),",
                "// Line 54:     mustParseCIDR(\"169.254.0.0/16\"),",
                "// Line 55:     mustParseCIDR(\"::1/128\"),",
                "// Line 56:     mustParseCIDR(\"fe80::/10\"),",
                "// Line 57:     mustParseCIDR(\"fc00::/7\"),",
                "// vulnerable line: 58: }",
                "// Line 59: ",
                "// Line 60: const (",
                "// Line 61:     ErrInternalResolution = errors.Sentinel(\"downloader: destination resolves to internal network location\")",
                "// Line 62:     ErrInvalidIPAddress   = errors.Sentinel(\"downloader: invalid IP address\")",
                "// Line 63:     ErrDownloadFailed     = errors.Sentinel(\"downloader: download request failed\")",
                "// Line 64: )",
                "// Line 65: ",
                "// Line 66: type Counter struct {",
                "// Line 67:     total   int",
                "// Line 68:     onWrite func(total int)",
                "// vulnerable line: 69: }",
                "// Line 70: ",
                "// Line 71: func (c *Counter) Write(p []byte) (int, error) {",
                "// Line 72:     n := len(p)",
                "// Line 73:     c.total += n",
                "// Line 74:     c.onWrite(c.total)",
                "// Line 75:     return n, nil",
                "// vulnerable line: 76: }",
                "// Line 77: ",
                "// Line 78: type DownloadRequest struct {",
                "// Line 79:     Directory string",
                "// Line 80:     URL       *url.URL",
                "// Line 81:     FileName  string",
                "// Line 82:     UseHeader bool",
                "// vulnerable line: 83: }",
                "// Line 84: ",
                "// Line 85: type Download struct {",
                "// Line 86:     Identifier string",
                "// Line 87:     path       string",
                "// Line 88:     mu         sync.RWMutex",
                "// Line 89:     req        DownloadRequest",
                "// Line 90:     server     *server.Server",
                "// Line 91:     progress   float64",
                "// Line 92:     cancelFunc *context.CancelFunc",
                "// vulnerable line: 93: }",
                "// Line 94: ",
                "// Line 95: // New starts a new tracked download which allows for cancellation later on by calling",
                "// Line 96: // the Downloader.Cancel function.",
                "// Line 97: func New(s *server.Server, r DownloadRequest) *Download {",
                "// Line 98:     dl := Download{",
                "// Line 99:         Identifier: uuid.Must(uuid.NewRandom()).String(),",
                "// Line 100:         req:        r,",
                "// Line 101:         server:     s,",
                "// vulnerable line: 102: }",
                "// Line 103:     instance.track(&dl)",
                "// Line 104:     return &dl",
                "// vulnerable line: 105: }",
                "// Line 106: ",
                "// Line 107: // ByServer returns all the tracked downloads for a given server instance.",
                "// Line 108: func ByServer(sid string) []*Download {",
                "// Line 109:     instance.mu.Lock()",
                "// Line 110:     defer instance.mu.Unlock()",
                "// Line 111:     var downloads []*Download",
                "// Line 112:     if v, ok := instance.serverCache[sid]; ok {",
                "// Line 113:         for _, id := range v {",
                "// Line 114:             if dl, ok := instance.downloadCache[id]; ok {",
                "// Line 115:                 downloads = append(downloads, dl)",
                "// vulnerable line: 116: }",
                "// vulnerable line: 117: }",
                "// vulnerable line: 118: }",
                "// Line 119:     return downloads",
                "// vulnerable line: 120: }",
                "// Line 121: ",
                "// Line 122: // ByID returns a single Download matching a given identifier. If no download is found",
                "// Line 123: // the second argument in the response will be false.",
                "// Line 124: func ByID(dlid string) *Download {",
                "// Line 125:     return instance.find(dlid)",
                "// vulnerable line: 126: }",
                "// Line 127: ",
                "// Line 128: //goland:noinspection GoVetCopyLock",
                "// Line 129: func (dl Download) MarshalJSON() ([]byte, error) {",
                "// Line 130:     return json.Marshal(struct {",
                "// Line 131:         Identifier string",
                "// Line 132:         Progress   float64",
                "// Line 133:     }{",
                "// Line 134:         Identifier: dl.Identifier,",
                "// Line 135:         Progress:   dl.Progress(),",
                "// Line 136:     })",
                "// vulnerable line: 137: }",
                "// Line 138: ",
                "// Line 139: // Execute executes a given download for the server and begins writing the file to the disk. Once",
                "// Line 140: // completed the download will be removed from the cache.",
                "// Line 141: func (dl *Download) Execute() error {",
                "// Line 142:     ctx, cancel := context.WithTimeout(context.Background(), time.Hour*12)",
                "// Line 143:     dl.cancelFunc = &cancel",
                "// Line 144:     defer dl.Cancel()",
                "// Line 145: ",
                "// Line 146:     // Always ensure that we're checking the destination for the download to avoid a malicious",
                "// Line 147:     // user from accessing internal network resources.",
                "// Line 148:     if err := dl.isExternalNetwork(ctx); err != nil {",
                "// Line 149:         return err",
                "// vulnerable line: 150: }",
                "// Line 151: ",
                "// Line 152:     // At this point we have verified the destination is not within the local network, so we can",
                "// Line 153:     // now make a request to that URL and pull down the file, saving it to the server's data",
                "// Line 154:     // directory.",
                "// Line 155:     req, err := http.NewRequestWithContext(ctx, http.MethodGet, dl.req.URL.String(), nil)",
                "// Line 156:     if err != nil {",
                "// Line 157:         return errors.WrapIf(err, \"downloader: failed to create request\")",
                "// vulnerable line: 158: }",
                "// Line 159: ",
                "// Line 160:     req.Header.Set(\"User-Agent\", \"Pterodactyl Panel (https://pterodactyl.io)\")",
                "// Line 161:     res, err := client.Do(req)",
                "// Line 162:     if err != nil {",
                "// Line 163:         return ErrDownloadFailed",
                "// vulnerable line: 164: }",
                "// Line 165:     defer res.Body.Close()",
                "// Line 166:     if res.StatusCode != http.StatusOK {",
                "// Line 167:         return errors.New(\"downloader: got bad response status from endpoint: \" + res.Status)",
                "// vulnerable line: 168: }",
                "// Line 169: ",
                "// vulnerable line: 170: // If there is a Content-Length header on this request go ahead and check that we can",
                "// vulnerable line: 171: // even write the whole file before beginning this process. If there is no header present",
                "// vulnerable line: 172: // we'll just have to give it a spin and see how it goes.",
                "// vulnerable line: 173: if res.ContentLength > 0 {",
                "// vulnerable line: 174: if err := dl.server.Filesystem().HasSpaceFor(res.ContentLength); err != nil {",
                "// vulnerable line: 175: return errors.WrapIf(err, \"downloader: failed to write file: not enough space\")",
                "// vulnerable line: 176: }",
                "// vulnerable line: 177: }",
                "// Line 178: ",
                "// Line 179:     if dl.req.UseHeader {",
                "// Line 180:         if contentDisposition := res.Header.Get(\"Content-Disposition\"); contentDisposition != \"\" {",
                "// Line 181:             _, params, err := mime.ParseMediaType(contentDisposition)",
                "// Line 182:             if err != nil {",
                "// Line 183:                 return errors.WrapIf(err, \"downloader: invalid \"Content-Disposition\" header\")",
                "// vulnerable line: 184: }",
                "// Line 185: ",
                "// Line 186:             if v, ok := params[\"filename\"]; ok {",
                "// Line 187:                 dl.path = v",
                "// vulnerable line: 188: }",
                "// vulnerable line: 189: }",
                "// vulnerable line: 190: }",
                "// Line 191:     if dl.path == \"\" {",
                "// Line 192:         if dl.req.FileName != \"\" {",
                "// Line 193:             dl.path = dl.req.FileName",
                "// Line 194:         } else {",
                "// Line 195:             parts := strings.Split(dl.req.URL.Path, \"/\")",
                "// Line 196:             dl.path = parts[len(parts)-1]",
                "// vulnerable line: 197: }",
                "// vulnerable line: 198: }",
                "// Line 199: ",
                "// Line 200:     p := dl.Path()",
                "// Line 201:     dl.server.Log().WithField(\"path\", p).Debug(\"writing remote file to disk\")",
                "// Line 202: ",
                "// Line 203:     r := io.TeeReader(res.Body, dl.counter(res.ContentLength))",
                "// vulnerable line: 204: if err := dl.server.Filesystem().Writefile(p, r); err != nil {",
                "// Line 205:         return errors.WrapIf(err, \"downloader: failed to write file to server directory\")",
                "// vulnerable line: 206: }",
                "// Line 207:     return nil",
                "// vulnerable line: 208: }",
                "// Line 209: ",
                "// Line 210: // Cancel cancels a running download and frees up the associated resources. If a file is being",
                "// Line 211: // written a partial file will remain present on the disk.",
                "// Line 212: func (dl *Download) Cancel() {",
                "// Line 213:     if dl.cancelFunc != nil {",
                "// Line 214:         (*dl.cancelFunc)()",
                "// vulnerable line: 215: }",
                "// Line 216:     instance.remove(dl.Identifier)",
                "// vulnerable line: 217: }",
                "// Line 218: ",
                "// Line 219: // BelongsTo checks if the given download belongs to the provided server.",
                "// Line 220: func (dl *Download) BelongsTo(s *server.Server) bool {",
                "// Line 221:     return dl.server.ID() == s.ID()",
                "// vulnerable line: 222: }",
                "// Line 223: ",
                "// Line 224: // Progress returns the current progress of the download as a float value between 0 and 1 where",
                "// Line 225: // 1 indicates that the download is completed.",
                "// Line 226: func (dl *Download) Progress() float64 {",
                "// Line 227:     dl.mu.RLock()",
                "// Line 228:     defer dl.mu.RUnlock()",
                "// Line 229:     return dl.progress",
                "// vulnerable line: 230: }",
                "// Line 231: ",
                "// Line 232: func (dl *Download) Path() string {",
                "// Line 233:     return filepath.Join(dl.req.Directory, dl.path)",
                "// vulnerable line: 234: }",
                "// Line 235: ",
                "// Line 236: // Handles a write event by updating the progress completed percentage and firing off",
                "// Line 237: // events to the server websocket as needed.",
                "// Line 238: func (dl *Download) counter(contentLength int64) *Counter {",
                "// Line 239:     onWrite := func(t int) {",
                "// Line 240:         dl.mu.Lock()",
                "// Line 241:         defer dl.mu.Unlock()",
                "// Line 242:         dl.progress = float64(t) / float64(contentLength)",
                "// vulnerable line: 243: }",
                "// Line 244:     return &Counter{",
                "// Line 245:         onWrite: onWrite,",
                "// vulnerable line: 246: }",
                "// vulnerable line: 247: }",
                "// Line 248: ",
                "// Line 249: // Verifies that a given download resolves to a location not within the current local",
                "// Line 250: // network for the machine. If the final destination of a resource is within the local",
                "// Line 251: // network an ErrInternalResolution error is returned.",
                "// Line 252: func (dl *Download) isExternalNetwork(ctx context.Context) error {",
                "// Line 253:     dialer := &net.Dialer{",
                "// Line 254:         LocalAddr: nil,",
                "// vulnerable line: 255: }",
                "// Line 256: ",
                "// Line 257:     host := dl.req.URL.Host",
                "// Line 258: ",
                "// Line 259:     // This cluster-fuck of math and integer shit converts an integer IP into a proper IPv4.",
                "// Line 260:     // For example: 16843009 would become 1.1.1.1",
                "// Line 261:     //if i, err := strconv.ParseInt(host, 10, 64); err == nil {",
                "// Line 262:     //    host = strconv.FormatInt((i>>24)&0xFF, 10) + \".\" + strconv.FormatInt((i>>16)&0xFF, 10) + \".\" + strconv.FormatInt((i>>8)&0xFF, 10) + \".\" + strconv.FormatInt(i&0xFF, 10)",
                "// Line 263:     //}",
                "// Line 264: ",
                "// Line 265:     if _, _, err := net.SplitHostPort(host); err != nil {",
                "// Line 266:         if !strings.Contains(err.Error(), \"missing port in address\") {",
                "// Line 267:             return errors.WithStack(err)",
                "// vulnerable line: 268: }",
                "// Line 269:         switch dl.req.URL.Scheme {",
                "// Line 270:         case \"http\":",
                "// Line 271:             host += \":80\"",
                "// Line 272:         case \"https\":",
                "// Line 273:             host += \":443\"",
                "// vulnerable line: 274: }",
                "// vulnerable line: 275: }",
                "// Line 276: ",
                "// Line 277:     c, err := dialer.DialContext(ctx, \"tcp\", host)",
                "// Line 278:     if err != nil {",
                "// Line 279:         return errors.WithStack(err)",
                "// vulnerable line: 280: }",
                "// Line 281:     _ = c.Close()",
                "// Line 282: ",
                "// Line 283:     ipStr, _, err := net.SplitHostPort(c.RemoteAddr().String())",
                "// Line 284:     if err != nil {",
                "// Line 285:         return errors.WithStack(err)",
                "// vulnerable line: 286: }",
                "// Line 287:     ip := net.ParseIP(ipStr)",
                "// Line 288:     if ip == nil {",
                "// Line 289:         return errors.WithStack(ErrInvalidIPAddress)",
                "// vulnerable line: 290: }",
                "// Line 291:     if ip.IsLoopback() || ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() || ip.IsInterfaceLocalMulticast() {",
                "// Line 292:         return errors.WithStack(ErrInternalResolution)",
                "// vulnerable line: 293: }",
                "// Line 294:     for _, block := range internalRanges {",
                "// Line 295:         if block.Contains(ip) {",
                "// Line 296:             return errors.WithStack(ErrInternalResolution)",
                "// vulnerable line: 297: }",
                "// vulnerable line: 298: }",
                "// Line 299:     return nil",
                "// vulnerable line: 300: }",
                "// Line 301: ",
                "// Line 302: // Downloader represents a global downloader that keeps track of all currently processing downloads",
                "// Line 303: // for the machine.",
                "// Line 304: type Downloader struct {",
                "// Line 305:     mu            sync.RWMutex",
                "// Line 306:     downloadCache map[string]*Download",
                "// Line 307:     serverCache   map[string][]string",
                "// vulnerable line: 308: }",
                "// Line 309: ",
                "// Line 310: // track tracks a download in the internal cache for this instance.",
                "// Line 311: func (d *Downloader) track(dl *Download) {",
                "// Line 312:     d.mu.Lock()",
                "// Line 313:     defer d.mu.Unlock()",
                "// Line 314:     sid := dl.server.ID()",
                "// Line 315:     if _, ok := d.downloadCache[dl.Identifier]; !ok {",
                "// Line 316:         d.downloadCache[dl.Identifier] = dl",
                "// Line 317:         if _, ok := d.serverCache[sid]; !ok {",
                "// Line 318:             d.serverCache[sid] = []string{}",
                "// vulnerable line: 319: }",
                "// Line 320:         d.serverCache[sid] = append(d.serverCache[sid], dl.Identifier)",
                "// vulnerable line: 321: }",
                "// vulnerable line: 322: }",
                "// Line 323: ",
                "// Line 324: // find finds a given download entry using the provided ID and returns it.",
                "// Line 325: func (d *Downloader) find(dlid string) *Download {",
                "// Line 326:     d.mu.RLock()",
                "// Line 327:     defer d.mu.RUnlock()",
                "// Line 328:     if entry, ok := d.downloadCache[dlid]; ok {",
                "// Line 329:         return entry",
                "// vulnerable line: 330: }",
                "// Line 331:     return nil",
                "// vulnerable line: 332: }",
                "// Line 333: ",
                "// Line 334: // remove removes the given download reference from the cache storing them. This also updates",
                "// Line 335: // the slice of active downloads for a given server to not include this download.",
                "// Line 336: func (d *Downloader) remove(dlID string) {",
                "// Line 337:     d.mu.Lock()",
                "// Line 338:     defer d.mu.Unlock()",
                "// Line 339:     if _, ok := d.downloadCache[dlID]; !ok {",
                "// Line 340:         return",
                "// vulnerable line: 341: }",
                "// Line 342:     sID := d.downloadCache[dlID].server.ID()",
                "// Line 343:     delete(d.downloadCache, dlID)",
                "// Line 344:     if tracked, ok := d.serverCache[sID]; ok {",
                "// Line 345:         var out []string",
                "// Line 346:         for _, k := range tracked {",
                "// Line 347:             if k != dlID {",
                "// Line 348:                 out = append(out, k)",
                "// vulnerable line: 349: }",
                "// vulnerable line: 350: }",
                "// Line 351:         d.serverCache[sID] = out",
                "// vulnerable line: 352: }",
                "// vulnerable line: 353: }",
                "// Line 354: ",
                "// Line 355: func mustParseCIDR(ip string) *net.IPNet {",
                "// Line 356:     _, block, err := net.ParseCIDR(ip)",
                "// Line 357:     if err != nil {",
                "// Line 358:         panic(fmt.Errorf(\"downloader: failed to parse CIDR: %s\", err))",
                "// vulnerable line: 359: }",
                "// Line 360:     return block",
                "// vulnerable line: 361: }"
            ]
        },
        {
            "filename_of_changes": "errors.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package filesystem",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"fmt\"",
                "// vulnerable line: 5: \"os\"",
                "// Line 6:     \"path/filepath\"",
                "// Line 7: ",
                "// Line 8:     \"emperror.dev/errors\"",
                "// Line 9:     \"github.com/apex/log\"",
                "// Line 10: )",
                "// Line 11: ",
                "// Line 12: type ErrorCode string",
                "// Line 13: ",
                "// Line 14: const (",
                "// Line 15:     ErrCodeIsDirectory    ErrorCode = \"E_ISDIR\"",
                "// Line 79: }",
                "// Line 80: ",
                "// Line 81: // Unwrap returns the underlying cause of this filesystem error. In some causes",
                "// Line 82: // there may not be a cause present, in which case nil will be returned.",
                "// Line 83: func (e *Error) Unwrap() error {",
                "// Line 84:     return e.err",
                "// Line 85: }",
                "// Line 86: ",
                "// Line 87: // Generates an error logger instance with some basic information.",
                "// Line 88: func (fs *Filesystem) error(err error) *log.Entry {",
                "// vulnerable line: 89: return log.WithField(\"subsystem\", \"filesystem\").WithField(\"root\", fs.root).WithField(\"error\", err)",
                "// Line 90: }",
                "// Line 91: ",
                "// Line 92: // Handle errors encountered when walking through directories.",
                "// Line 93: //",
                "// Line 94: // If there is a path resolution error just skip the item entirely. Only return this for a",
                "// Line 95: // directory, otherwise return nil. Returning this error for a file will stop the walking",
                "// vulnerable line: 96: // for the remainder of the directory. This is assuming an os.FileInfo struct was even returned.",
                "// vulnerable line: 97: func (fs *Filesystem) handleWalkerError(err error, f os.FileInfo) error {",
                "// Line 98:     if !IsErrorCode(err, ErrCodePathResolution) {",
                "// Line 99:         return err",
                "// Line 100:     }",
                "// Line 101:     if f != nil && f.IsDir() {",
                "// Line 102:         return filepath.SkipDir",
                "// Line 103:     }",
                "// Line 104:     return nil",
                "// Line 105: }",
                "// Line 106: ",
                "// Line 107: // IsFilesystemError checks if the given error is one of the Filesystem errors."
            ]
        },
        {
            "filename_of_changes": "go.mod",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 23:     github.com/gbrlsnchs/jwt/v3 v3.0.1",
                "// Line 24:     github.com/gin-gonic/gin v1.9.1",
                "// Line 25:     github.com/glebarez/sqlite v1.10.0",
                "// Line 26:     github.com/go-co-op/gocron v1.37.0",
                "// Line 27:     github.com/goccy/go-json v0.10.2",
                "// Line 28:     github.com/google/uuid v1.6.0",
                "// Line 29:     github.com/gorilla/websocket v1.5.1",
                "// Line 30:     github.com/iancoleman/strcase v0.3.0",
                "// Line 31:     github.com/icza/dyno v0.0.0-20230330125955-09f820a8d9c0",
                "// Line 32:     github.com/juju/ratelimit v1.0.2",
                "// vulnerable line: 33: github.com/karrick/godirwalk v1.17.0",
                "// Line 34:     github.com/klauspost/pgzip v1.2.6",
                "// Line 35:     github.com/magiconair/properties v1.8.7",
                "// Line 36:     github.com/mattn/go-colorable v0.1.13",
                "// Line 37:     github.com/mholt/archiver/v4 v4.0.0-alpha.8",
                "// Line 38:     github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db",
                "// Line 39:     github.com/patrickmn/go-cache v2.1.0+incompatible",
                "// Line 40:     github.com/pkg/sftp v1.13.6",
                "// Line 41:     github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06",
                "// Line 42:     github.com/spf13/cobra v1.8.0",
                "// Line 43:     github.com/stretchr/testify v1.9.0",
                "// Line 76:     github.com/go-playground/validator/v10 v10.19.0 // indirect",
                "// Line 77:     github.com/gogo/protobuf v1.3.2 // indirect",
                "// Line 78:     github.com/golang/snappy v0.0.4 // indirect",
                "// Line 79:     github.com/hashicorp/errwrap v1.1.0 // indirect",
                "// Line 80:     github.com/hashicorp/go-multierror v1.1.1 // indirect",
                "// Line 81:     github.com/inconshreveable/mousetrap v1.1.0 // indirect",
                "// Line 82:     github.com/jinzhu/inflection v1.0.0 // indirect",
                "// Line 83:     github.com/jinzhu/now v1.1.5 // indirect",
                "// Line 84:     github.com/json-iterator/go v1.1.12 // indirect",
                "// Line 85:     github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect",
                "// vulnerable line: 86: github.com/klauspost/compress v1.17.7 // indirect",
                "// Line 87:     github.com/klauspost/cpuid/v2 v2.2.7 // indirect",
                "// Line 88:     github.com/kr/fs v0.1.0 // indirect",
                "// Line 89:     github.com/leodido/go-urn v1.4.0 // indirect",
                "// Line 90:     github.com/magefile/mage v1.15.0 // indirect",
                "// Line 91:     github.com/mattn/go-isatty v0.0.20 // indirect",
                "// Line 92:     github.com/mgutz/ansi v0.0.0-20200706080929-d51e80ef957d // indirect",
                "// Line 93:     github.com/moby/term v0.0.0-20220808134915-39b0c02b01ae // indirect",
                "// Line 94:     github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect",
                "// Line 95:     github.com/modern-go/reflect2 v1.0.2 // indirect",
                "// Line 96:     github.com/morikuni/aec v1.0.0 // indirect",
                "// Line 115:     go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.24.0 // indirect",
                "// Line 116:     go.opentelemetry.io/otel/metric v1.24.0 // indirect",
                "// Line 117:     go.opentelemetry.io/otel/sdk v1.24.0 // indirect",
                "// Line 118:     go.opentelemetry.io/otel/trace v1.24.0 // indirect",
                "// Line 119:     go.uber.org/atomic v1.11.0 // indirect",
                "// Line 120:     go.uber.org/multierr v1.11.0 // indirect",
                "// Line 121:     go4.org v0.0.0-20230225012048-214862532bf5 // indirect",
                "// Line 122:     golang.org/x/arch v0.7.0 // indirect",
                "// Line 123:     golang.org/x/mod v0.16.0 // indirect",
                "// Line 124:     golang.org/x/net v0.22.0 // indirect",
                "// vulnerable line: 125: golang.org/x/sys v0.18.0 // indirect",
                "// Line 126:     golang.org/x/term v0.18.0 // indirect",
                "// Line 127:     golang.org/x/text v0.14.0 // indirect",
                "// Line 128:     golang.org/x/time v0.0.0-20220922220347-f3bd1da661af // indirect",
                "// Line 129:     golang.org/x/tools v0.19.0 // indirect",
                "// Line 130:     golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028 // indirect",
                "// Line 131:     google.golang.org/protobuf v1.33.0 // indirect",
                "// Line 132:     gotest.tools/v3 v3.0.2 // indirect",
                "// Line 133:     modernc.org/libc v1.44.0 // indirect",
                "// Line 134:     modernc.org/mathutil v1.6.0 // indirect",
                "// Line 135:     modernc.org/memory v1.7.2 // indirect"
            ]
        },
        {
            "filename_of_changes": "go.sum",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "0",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 212: github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=",
                "// Line 213: github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=",
                "// Line 214: github.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af/go.mod h1:Nht3zPeWKUH0NzdCt2Blrr5ys8VGpn0CEB0cQHVjt7k=",
                "// Line 215: github.com/jpillora/backoff v0.0.0-20180909062703-3050d21c67d7/go.mod h1:2iMrUgbbvHEiQClaW2NsSzMyGHqN+rDFqY705q49KG0=",
                "// Line 216: github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=",
                "// Line 217: github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=",
                "// Line 218: github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=",
                "// Line 219: github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=",
                "// Line 220: github.com/juju/ratelimit v1.0.2 h1:sRxmtRiajbvrcLQT7S+JbqU0ntsb9W2yhSdNN8tWfaI=",
                "// Line 221: github.com/juju/ratelimit v1.0.2/go.mod h1:qapgC/Gy+xNh9UxzV13HGGl/6UXNN+ct+vwSgWNm/qk=",
                "// vulnerable line: 222: github.com/karrick/godirwalk v1.17.0 h1:b4kY7nqDdioR/6qnbHQyDvmA17u5G1cZ6J+CZXwSWoI=",
                "// vulnerable line: 223: github.com/karrick/godirwalk v1.17.0/go.mod h1:j4mkqPuvaLI8mp1DroR3P6ad7cyYd4c1qeJ3RV7ULlk=",
                "// Line 224: github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=",
                "// Line 225: github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=",
                "// Line 226: github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=",
                "// Line 227: github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=",
                "// Line 228: github.com/klauspost/compress v1.4.1/go.mod h1:RyIbtBH6LamlWaDj8nUwkbUhJ87Yi3uG0guNDohfE1A=",
                "// Line 229: github.com/klauspost/compress v1.17.7 h1:ehO88t2UGzQK66LMdE8tibEd1ErmzZjNEqWkjLAKQQg=",
                "// Line 230: github.com/klauspost/compress v1.17.7/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=",
                "// Line 231: github.com/klauspost/cpuid v1.2.0/go.mod h1:Pj4uuM528wm8OyEC2QMXAi2YiTZ96dNQPGgoMS4s3ek=",
                "// Line 232: github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=",
                "// Line 233: github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM="
            ]
        },
        {
            "filename_of_changes": "handler.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "18",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package sftp",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"io\"",
                "// vulnerable line: 5: \"io/ioutil\"",
                "// Line 6:     \"os\"",
                "// Line 7:     \"path/filepath\"",
                "// Line 8:     \"strings\"",
                "// Line 9:     \"sync\"",
                "// Line 10: ",
                "// Line 11:     \"emperror.dev/errors\"",
                "// Line 12:     \"github.com/apex/log\"",
                "// Line 13:     \"github.com/pkg/sftp\"",
                "// Line 14:     \"golang.org/x/crypto/ssh\"",
                "// Line 15: ",
                "// Line 27: )",
                "// Line 28: ",
                "// Line 29: type Handler struct {",
                "// Line 30:     mu          sync.Mutex",
                "// Line 31:     server      *server.Server",
                "// Line 32:     fs          *filesystem.Filesystem",
                "// Line 33:     events      *eventHandler",
                "// Line 34:     permissions []string",
                "// Line 35:     logger      *log.Entry",
                "// Line 36:     ro          bool",
                "// vulnerable line: 37: }",
                "// Line 38: ",
                "// Line 39: // NewHandler returns a new connection handler for the SFTP server. This allows a given user",
                "// Line 40: // to access the underlying filesystem.",
                "// Line 41: func NewHandler(sc *ssh.ServerConn, srv *server.Server) (*Handler, error) {",
                "// Line 42:     uuid, ok := sc.Permissions.Extensions[\"user\"]",
                "// Line 43:     if !ok {",
                "// Line 44:         return nil, errors.New(\"sftp: mismatched Wings and Panel versions — Panel 1.10 is required for this version of Wings.\")",
                "// vulnerable line: 45: }",
                "// Line 46: ",
                "// Line 47:     events := eventHandler{",
                "// Line 48:         ip:     sc.RemoteAddr().String(),",
                "// Line 49:         user:   uuid,",
                "// Line 50:         server: srv.ID(),",
                "// vulnerable line: 51: }",
                "// Line 52: ",
                "// Line 53:     return &Handler{",
                "// Line 54:         permissions: strings.Split(sc.Permissions.Extensions[\"permissions\"], \",\"),",
                "// Line 55:         server:      srv,",
                "// Line 56:         fs:          srv.Filesystem(),",
                "// Line 57:         events:      &events,",
                "// Line 58:         ro:          config.Get().System.Sftp.ReadOnly,",
                "// Line 59:         logger:      log.WithFields(log.Fields{\"subsystem\": \"sftp\", \"user\": uuid, \"ip\": sc.RemoteAddr()}),",
                "// Line 60:     }, nil",
                "// vulnerable line: 61: }",
                "// Line 62: ",
                "// Line 63: // Handlers returns the sftp.Handlers for this struct.",
                "// Line 64: func (h *Handler) Handlers() sftp.Handlers {",
                "// Line 65:     return sftp.Handlers{",
                "// Line 66:         FileGet:  h,",
                "// Line 67:         FilePut:  h,",
                "// Line 68:         FileCmd:  h,",
                "// Line 69:         FileList: h,",
                "// vulnerable line: 70: }",
                "// vulnerable line: 71: }",
                "// Line 72: ",
                "// Line 73: // Fileread creates a reader for a file on the system and returns the reader back.",
                "// Line 74: func (h *Handler) Fileread(request *sftp.Request) (io.ReaderAt, error) {",
                "// Line 75:     // Check first if the user can actually open and view a file. This permission is named",
                "// Line 76:     // really poorly, but it is checking if they can read. There is an addition permission,",
                "// Line 77:     // \"save-files\" which determines if they can write that file.",
                "// Line 78:     if !h.can(PermissionFileReadContent) {",
                "// Line 79:         return nil, sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 80: }",
                "// Line 81:     h.mu.Lock()",
                "// Line 82:     defer h.mu.Unlock()",
                "// Line 83:     f, _, err := h.fs.File(request.Filepath)",
                "// vulnerable line: 84: if err != nil {",
                "// Line 85:         if !errors.Is(err, os.ErrNotExist) {",
                "// Line 86:             h.logger.WithField(\"error\", err).Error(\"error processing readfile request\")",
                "// Line 87:             return nil, sftp.ErrSSHFxFailure",
                "// vulnerable line: 88: }",
                "// vulnerable line: 89: return nil, sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 90: }",
                "// Line 91:     return f, nil",
                "// vulnerable line: 92: }",
                "// Line 93: ",
                "// Line 94: // Filewrite handles the write actions for a file on the system.",
                "// Line 95: func (h *Handler) Filewrite(request *sftp.Request) (io.WriterAt, error) {",
                "// Line 96:     if h.ro {",
                "// Line 97:         return nil, sftp.ErrSSHFxOpUnsupported",
                "// vulnerable line: 98: }",
                "// Line 99:     l := h.logger.WithField(\"source\", request.Filepath)",
                "// Line 100:     // If the user doesn't have enough space left on the server it should respond with an",
                "// Line 101:     // error since we won't be letting them write this file to the disk.",
                "// Line 102:     if !h.fs.HasSpaceAvailable(true) {",
                "// Line 103:         return nil, ErrSSHQuotaExceeded",
                "// vulnerable line: 104: }",
                "// Line 105: ",
                "// Line 106:     h.mu.Lock()",
                "// Line 107:     defer h.mu.Unlock()",
                "// Line 108:     // The specific permission required to perform this action. If the file exists on the",
                "// Line 109:     // system already it only needs to be an update, otherwise we'll check for a create.",
                "// Line 110:     permission := PermissionFileUpdate",
                "// Line 111:     _, sterr := h.fs.Stat(request.Filepath)",
                "// Line 112:     if sterr != nil {",
                "// Line 113:         if !errors.Is(sterr, os.ErrNotExist) {",
                "// Line 114:             l.WithField(\"error\", sterr).Error(\"error while getting file reader\")",
                "// Line 115:             return nil, sftp.ErrSSHFxFailure",
                "// vulnerable line: 116: }",
                "// Line 117:         permission = PermissionFileCreate",
                "// vulnerable line: 118: }",
                "// Line 119:     // Confirm the user has permission to perform this action BEFORE calling Touch, otherwise",
                "// Line 120:     // you'll potentially create a file on the system and then fail out because of user",
                "// Line 121:     // permission checking after the fact.",
                "// Line 122:     if !h.can(permission) {",
                "// Line 123:         return nil, sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 124: }",
                "// vulnerable line: 125: f, err := h.fs.Touch(request.Filepath, os.O_RDWR|os.O_CREATE|os.O_TRUNC)",
                "// vulnerable line: 126: if err != nil {",
                "// Line 127:         l.WithField(\"flags\", request.Flags).WithField(\"error\", err).Error(\"failed to open existing file on system\")",
                "// Line 128:         return nil, sftp.ErrSSHFxFailure",
                "// vulnerable line: 129: }",
                "// Line 130:     // Chown may or may not have been called in the touch function, so always do",
                "// Line 131:     // it at this point to avoid the file being improperly owned.",
                "// Line 132:     _ = h.fs.Chown(request.Filepath)",
                "// Line 133:     event := server.ActivitySftpWrite",
                "// Line 134:     if permission == PermissionFileCreate {",
                "// Line 135:         event = server.ActivitySftpCreate",
                "// vulnerable line: 136: }",
                "// Line 137:     h.events.MustLog(event, FileAction{Entity: request.Filepath})",
                "// Line 138:     return f, nil",
                "// vulnerable line: 139: }",
                "// Line 140: ",
                "// Line 141: // Filecmd hander for basic SFTP system calls related to files, but not anything to do with reading",
                "// Line 142: // or writing to those files.",
                "// Line 143: func (h *Handler) Filecmd(request *sftp.Request) error {",
                "// Line 144:     if h.ro {",
                "// Line 145:         return sftp.ErrSSHFxOpUnsupported",
                "// vulnerable line: 146: }",
                "// Line 147:     l := h.logger.WithField(\"source\", request.Filepath)",
                "// Line 148:     if request.Target != \"\" {",
                "// Line 149:         l = l.WithField(\"target\", request.Target)",
                "// vulnerable line: 150: }",
                "// Line 151: ",
                "// Line 152:     switch request.Method {",
                "// Line 153:     // Allows a user to make changes to the permissions of a given file or directory",
                "// Line 154:     // on their server using their SFTP client.",
                "// Line 155:     case \"Setstat\":",
                "// Line 156:         if !h.can(PermissionFileUpdate) {",
                "// Line 157:             return sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 158: }",
                "// Line 159:         mode := request.Attributes().FileMode().Perm()",
                "// Line 160:         // If the client passes an invalid FileMode just use the default 0644.",
                "// Line 161:         if mode == 0o000 {",
                "// Line 162:             mode = os.FileMode(0o644)",
                "// vulnerable line: 163: }",
                "// Line 164:         // Force directories to be 0755.",
                "// Line 165:         if request.Attributes().FileMode().IsDir() {",
                "// Line 166:             mode = 0o755",
                "// vulnerable line: 167: }",
                "// Line 168:         if err := h.fs.Chmod(request.Filepath, mode); err != nil {",
                "// Line 169:             if errors.Is(err, os.ErrNotExist) {",
                "// vulnerable line: 170: return sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 171: }",
                "// Line 172:             l.WithField(\"error\", err).Error(\"failed to perform setstat on item\")",
                "// Line 173:             return sftp.ErrSSHFxFailure",
                "// vulnerable line: 174: }",
                "// Line 175:         break",
                "// Line 176:     // Support renaming a file (aka Move).",
                "// Line 177:     case \"Rename\":",
                "// Line 178:         if !h.can(PermissionFileUpdate) {",
                "// Line 179:             return sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 180: }",
                "// Line 181:         if err := h.fs.Rename(request.Filepath, request.Target); err != nil {",
                "// Line 182:             if errors.Is(err, os.ErrNotExist) {",
                "// vulnerable line: 183: return sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 184: }",
                "// Line 185:             l.WithField(\"error\", err).Error(\"failed to rename file\")",
                "// Line 186:             return sftp.ErrSSHFxFailure",
                "// vulnerable line: 187: }",
                "// Line 188:         h.events.MustLog(server.ActivitySftpRename, FileAction{Entity: request.Filepath, Target: request.Target})",
                "// Line 189:         break",
                "// Line 190:     // Handle deletion of a directory. This will properly delete all of the files and",
                "// Line 191:     // folders within that directory if it is not already empty (unlike a lot of SFTP",
                "// Line 192:     // clients that must delete each file individually).",
                "// Line 193:     case \"Rmdir\":",
                "// Line 194:         if !h.can(PermissionFileDelete) {",
                "// Line 195:             return sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 196: }",
                "// Line 197:         p := filepath.Clean(request.Filepath)",
                "// Line 198:         if err := h.fs.Delete(p); err != nil {",
                "// Line 199:             l.WithField(\"error\", err).Error(\"failed to remove directory\")",
                "// Line 200:             return sftp.ErrSSHFxFailure",
                "// vulnerable line: 201: }",
                "// Line 202:         h.events.MustLog(server.ActivitySftpDelete, FileAction{Entity: request.Filepath})",
                "// Line 203:         return sftp.ErrSSHFxOk",
                "// Line 204:     // Handle requests to create a new Directory.",
                "// Line 205:     case \"Mkdir\":",
                "// Line 206:         if !h.can(PermissionFileCreate) {",
                "// Line 207:             return sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 208: }",
                "// Line 209:         name := strings.Split(filepath.Clean(request.Filepath), \"/\")",
                "// Line 210:         p := strings.Join(name[0:len(name)-1], \"/\")",
                "// Line 211:         if err := h.fs.CreateDirectory(name[len(name)-1], p); err != nil {",
                "// Line 212:             l.WithField(\"error\", err).Error(\"failed to create directory\")",
                "// Line 213:             return sftp.ErrSSHFxFailure",
                "// vulnerable line: 214: }",
                "// Line 215:         h.events.MustLog(server.ActivitySftpCreateDirectory, FileAction{Entity: request.Filepath})",
                "// Line 216:         break",
                "// Line 217:     // Support creating symlinks between files. The source and target must resolve within",
                "// Line 218:     // the server home directory.",
                "// Line 219:     case \"Symlink\":",
                "// Line 220:         if !h.can(PermissionFileCreate) {",
                "// Line 221:             return sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 222: }",
                "// vulnerable line: 223: source, err := h.fs.SafePath(request.Filepath)",
                "// vulnerable line: 224: if err != nil {",
                "// vulnerable line: 225: return sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 226: }",
                "// vulnerable line: 227: target, err := h.fs.SafePath(request.Target)",
                "// vulnerable line: 228: if err != nil {",
                "// vulnerable line: 229: return sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 230: }",
                "// vulnerable line: 231: if err := os.Symlink(source, target); err != nil {",
                "// vulnerable line: 232: l.WithField(\"target\", target).WithField(\"error\", err).Error(\"failed to create symlink\")",
                "// Line 233:             return sftp.ErrSSHFxFailure",
                "// vulnerable line: 234: }",
                "// Line 235:         break",
                "// Line 236:     // Called when deleting a file.",
                "// Line 237:     case \"Remove\":",
                "// Line 238:         if !h.can(PermissionFileDelete) {",
                "// Line 239:             return sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 240: }",
                "// Line 241:         if err := h.fs.Delete(request.Filepath); err != nil {",
                "// Line 242:             if errors.Is(err, os.ErrNotExist) {",
                "// vulnerable line: 243: return sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 244: }",
                "// Line 245:             l.WithField(\"error\", err).Error(\"failed to remove a file\")",
                "// Line 246:             return sftp.ErrSSHFxFailure",
                "// vulnerable line: 247: }",
                "// Line 248:         h.events.MustLog(server.ActivitySftpDelete, FileAction{Entity: request.Filepath})",
                "// Line 249:         return sftp.ErrSSHFxOk",
                "// Line 250:     default:",
                "// Line 251:         return sftp.ErrSSHFxOpUnsupported",
                "// vulnerable line: 252: }",
                "// Line 253: ",
                "// Line 254:     target := request.Filepath",
                "// Line 255:     if request.Target != \"\" {",
                "// Line 256:         target = request.Target",
                "// vulnerable line: 257: }",
                "// Line 258:     // Not failing here is intentional. We still made the file, it is just owned incorrectly",
                "// Line 259:     // and will likely cause some issues. There is no logical check for if the file was removed",
                "// Line 260:     // because both of those cases (Rmdir, Remove) have an explicit return rather than break.",
                "// Line 261:     if err := h.fs.Chown(target); err != nil {",
                "// Line 262:         l.WithField(\"error\", err).Warn(\"error chowning file\")",
                "// vulnerable line: 263: }",
                "// Line 264: ",
                "// Line 265:     return sftp.ErrSSHFxOk",
                "// vulnerable line: 266: }",
                "// Line 267: ",
                "// Line 268: // Filelist is the handler for SFTP filesystem list calls. This will handle calls to list the contents of",
                "// Line 269: // a directory as well as perform file/folder stat calls.",
                "// Line 270: func (h *Handler) Filelist(request *sftp.Request) (sftp.ListerAt, error) {",
                "// Line 271:     if !h.can(PermissionFileRead) {",
                "// Line 272:         return nil, sftp.ErrSSHFxPermissionDenied",
                "// vulnerable line: 273: }",
                "// Line 274: ",
                "// Line 275:     switch request.Method {",
                "// Line 276:     case \"List\":",
                "// vulnerable line: 277: p, err := h.fs.SafePath(request.Filepath)",
                "// vulnerable line: 278: if err != nil {",
                "// vulnerable line: 279: return nil, sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 280: }",
                "// vulnerable line: 281: files, err := ioutil.ReadDir(p)",
                "// vulnerable line: 282: if err != nil {",
                "// Line 283:             h.logger.WithField(\"source\", request.Filepath).WithField(\"error\", err).Error(\"error while listing directory\")",
                "// Line 284:             return nil, sftp.ErrSSHFxFailure",
                "// vulnerable line: 285: }",
                "// vulnerable line: 286: return ListerAt(files), nil",
                "// Line 287:     case \"Stat\":",
                "// Line 288:         st, err := h.fs.Stat(request.Filepath)",
                "// vulnerable line: 289: if err != nil {",
                "// Line 290:             if errors.Is(err, os.ErrNotExist) {",
                "// vulnerable line: 291: return nil, sftp.ErrSSHFxNoSuchFile",
                "// vulnerable line: 292: }",
                "// Line 293:             h.logger.WithField(\"source\", request.Filepath).WithField(\"error\", err).Error(\"error performing stat on file\")",
                "// Line 294:             return nil, sftp.ErrSSHFxFailure",
                "// vulnerable line: 295: }",
                "// Line 296:         return ListerAt([]os.FileInfo{st.FileInfo}), nil",
                "// Line 297:     default:",
                "// Line 298:         return nil, sftp.ErrSSHFxOpUnsupported",
                "// vulnerable line: 299: }",
                "// vulnerable line: 300: }",
                "// Line 301: ",
                "// Line 302: // Determines if a user has permission to perform a specific action on the SFTP server. These",
                "// Line 303: // permissions are defined and returned by the Panel API.",
                "// Line 304: func (h *Handler) can(permission string) bool {",
                "// Line 305:     if h.server.IsSuspended() {",
                "// Line 306:         return false",
                "// vulnerable line: 307: }",
                "// Line 308:     for _, p := range h.permissions {",
                "// Line 309:         // If we match the permission specifically, or the user has been granted the \"*\"",
                "// Line 310:         // permission because they're an admin, let them through.",
                "// Line 311:         if p == permission || p == \"*\" {",
                "// Line 312:             return true",
                "// vulnerable line: 313: }",
                "// vulnerable line: 314: }",
                "// Line 315:     return false",
                "// vulnerable line: 316: }"
            ]
        },
        {
            "filename_of_changes": "helpers.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "15",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package parser",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"bytes\"",
                "// vulnerable line: 5: \"io\"",
                "// vulnerable line: 6: \"os\"",
                "// Line 7:     \"regexp\"",
                "// Line 8:     \"strconv\"",
                "// Line 9:     \"strings\"",
                "// Line 10: ",
                "// Line 11:     \"emperror.dev/errors\"",
                "// Line 12:     \"github.com/Jeffail/gabs/v2\"",
                "// Line 13:     \"github.com/apex/log\"",
                "// Line 14:     \"github.com/buger/jsonparser\"",
                "// Line 15:     \"github.com/iancoleman/strcase\"",
                "// Line 16: )",
                "// Line 22: // This allows configurations to reference values that are node dependent, such as the",
                "// Line 23: // internal IP address used by the daemon, useful in Bungeecord setups for example, where",
                "// Line 24: // it is common to see variables such as \"{{config.docker.interface}}\"",
                "// Line 25: var configMatchRegex = regexp.MustCompile(`{{\\s?config\\.([\\w.-]+)\\s?}}`)",
                "// Line 26: ",
                "// Line 27: // Regex to support modifying XML inline variable data using the config tools. This means",
                "// Line 28: // you can pass a replacement of Root.Property='[value=\"testing\"]' to get an XML node",
                "// Line 29: // matching:",
                "// Line 30: //",
                "// Line 31: // <Root>",
                "// vulnerable line: 32: //   <Property value=\"testing\"/>",
                "// Line 33: // </Root>",
                "// Line 34: //",
                "// Line 35: // noinspection RegExpRedundantEscape",
                "// Line 36: var xmlValueMatchRegex = regexp.MustCompile(`^\\[([\\w]+)='(.*)'\\]$`)",
                "// Line 37: ",
                "// vulnerable line: 38: // Gets the []byte representation of a configuration file to be passed through to other",
                "// vulnerable line: 39: // handler functions. If the file does not currently exist, it will be created.",
                "// vulnerable line: 40: func readFileBytes(path string) ([]byte, error) {",
                "// vulnerable line: 41: file, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)",
                "// vulnerable line: 42: if err != nil {",
                "// vulnerable line: 43: return nil, err",
                "// vulnerable line: 44: }",
                "// vulnerable line: 45: defer file.Close()",
                "// Line 46: ",
                "// vulnerable line: 47: return io.ReadAll(file)",
                "// vulnerable line: 48: }",
                "// Line 49: ",
                "// Line 50: // Gets the value of a key based on the value type defined.",
                "// Line 51: func (cfr *ConfigurationFileReplacement) getKeyValue(value string) interface{} {",
                "// Line 52:     if cfr.ReplaceWith.Type() == jsonparser.Boolean {",
                "// Line 53:         v, _ := strconv.ParseBool(value)",
                "// Line 54:         return v",
                "// vulnerable line: 55: }",
                "// Line 56: ",
                "// Line 57:     // Try to parse into an int, if this fails just ignore the error and continue",
                "// Line 58:     // through, returning the string.",
                "// Line 59:     if v, err := strconv.Atoi(value); err == nil {",
                "// Line 60:         return v",
                "// vulnerable line: 61: }",
                "// Line 62: ",
                "// Line 63:     return value",
                "// vulnerable line: 64: }",
                "// Line 65: ",
                "// Line 66: // Iterate over an unstructured JSON/YAML/etc. interface and set all of the required",
                "// Line 67: // key/value pairs for the configuration file.",
                "// Line 68: //",
                "// Line 69: // We need to support wildcard characters in key searches, this allows you to make",
                "// Line 70: // modifications to multiple keys at once, especially useful for games with multiple",
                "// Line 71: // configurations per-world (such as Spigot and Bungeecord) where we'll need to make",
                "// Line 72: // adjustments to the bind address for the user.",
                "// Line 73: //",
                "// Line 74: // This does not currently support nested wildcard matches. For example, foo.*.bar",
                "// Line 75: // will work, however foo.*.bar.*.baz will not, since we'll only be splitting at the",
                "// Line 76: // first wildcard, and not subsequent ones.",
                "// Line 77: func (f *ConfigurationFile) IterateOverJson(data []byte) (*gabs.Container, error) {",
                "// Line 78:     parsed, err := gabs.ParseJSON(data)",
                "// vulnerable line: 79: if err != nil {",
                "// vulnerable line: 80: return nil, err",
                "// vulnerable line: 81: }",
                "// Line 82: ",
                "// Line 83:     for _, v := range f.Replace {",
                "// Line 84:         value, err := f.LookupConfigurationValue(v)",
                "// vulnerable line: 85: if err != nil {",
                "// vulnerable line: 86: return nil, err",
                "// vulnerable line: 87: }",
                "// Line 88: ",
                "// Line 89:         // Check for a wildcard character, and if found split the key on that value to",
                "// Line 90:         // begin doing a search and replace in the data.",
                "// Line 91:         if strings.Contains(v.Match, \".*\") {",
                "// Line 92:             parts := strings.SplitN(v.Match, \".*\", 2)",
                "// Line 93: ",
                "// Line 94:             // Iterate over each matched child and set the remaining path to the value",
                "// Line 95:             // that is passed through in the loop.",
                "// Line 96:             //",
                "// Line 97:             // If the child is a null value, nothing will happen. Seems reasonable as of the",
                "// Line 98:             // time this code is being written.",
                "// Line 99:             for _, child := range parsed.Path(strings.Trim(parts[0], \".\")).Children() {",
                "// Line 100:                 if err := v.SetAtPathway(child, strings.Trim(parts[1], \".\"), value); err != nil {",
                "// Line 101:                     if errors.Is(err, gabs.ErrNotFound) {",
                "// Line 102:                         continue",
                "// vulnerable line: 103: }",
                "// Line 104:                     return nil, errors.WithMessage(err, \"failed to set config value of array child\")",
                "// vulnerable line: 105: }",
                "// vulnerable line: 106: }",
                "// Line 107:             continue",
                "// vulnerable line: 108: }",
                "// Line 109: ",
                "// Line 110:         if err := v.SetAtPathway(parsed, v.Match, value); err != nil {",
                "// Line 111:             if errors.Is(err, gabs.ErrNotFound) {",
                "// Line 112:                 continue",
                "// vulnerable line: 113: }",
                "// Line 114:             return nil, errors.WithMessage(err, \"unable to set config value at pathway: \"+v.Match)",
                "// vulnerable line: 115: }",
                "// vulnerable line: 116: }",
                "// Line 117: ",
                "// Line 118:     return parsed, nil",
                "// vulnerable line: 119: }",
                "// Line 120: ",
                "// Line 121: // Regex used to check if there is an array element present in the given pathway by looking for something",
                "// Line 122: // along the lines of \"something[1]\" or \"something[1].nestedvalue\" as the path.",
                "// Line 123: var checkForArrayElement = regexp.MustCompile(`^([^\\[\\]]+)\\[([\\d]+)](\\..+)?$`)",
                "// Line 124: ",
                "// Line 125: // Attempt to set the value of the path depending on if it is an array or not. Gabs cannot handle array",
                "// Line 126: // values as \"something[1]\" but can parse them just fine. This is basically just overly complex code",
                "// Line 127: // to handle that edge case and ensure the value gets set correctly.",
                "// Line 128: //",
                "// Line 129: // Bless thee who has to touch these most unholy waters.",
                "// Line 130: func setValueAtPath(c *gabs.Container, path string, value interface{}) error {",
                "// Line 131:     var err error",
                "// Line 132: ",
                "// Line 133:     matches := checkForArrayElement.FindStringSubmatch(path)",
                "// Line 134: ",
                "// Line 135:     // Check if we are **NOT** updating an array element.",
                "// Line 136:     if len(matches) < 3 {",
                "// Line 137:         _, err = c.SetP(value, path)",
                "// Line 138:         return err",
                "// vulnerable line: 139: }",
                "// Line 140: ",
                "// Line 141:     i, _ := strconv.Atoi(matches[2])",
                "// Line 142:     // Find the array element \"i\" or try to create it if \"i\" is equal to 0 and is not found",
                "// Line 143:     // at the given path.",
                "// Line 144:     ct, err := c.ArrayElementP(i, matches[1])",
                "// vulnerable line: 145: if err != nil {",
                "// Line 146:         if i != 0 || (!errors.Is(err, gabs.ErrNotArray) && !errors.Is(err, gabs.ErrNotFound)) {",
                "// Line 147:             return errors.WithMessage(err, \"error while parsing array element at path\")",
                "// vulnerable line: 148: }",
                "// Line 149: ",
                "// Line 150:         t := make([]interface{}, 1)",
                "// Line 151:         // If the length of matches is 4 it means we're trying to access an object down in this array",
                "// Line 152:         // key, so make sure we generate the array as an array of objects, and not just a generic nil",
                "// Line 153:         // array.",
                "// Line 154:         if len(matches) == 4 {",
                "// Line 155:             t = []interface{}{map[string]interface{}{}}",
                "// vulnerable line: 156: }",
                "// Line 157: ",
                "// Line 158:         // If the error is because this isn't an array or isn't found go ahead and create the array with",
                "// Line 159:         // an empty object if we have additional things to set on the array, or just an empty array type",
                "// Line 160:         // if there is not an object structure detected (no matches[3] available).",
                "// Line 161:         if _, err = c.SetP(t, matches[1]); err != nil {",
                "// Line 162:             return errors.WithMessage(err, \"failed to create empty array for missing element\")",
                "// vulnerable line: 163: }",
                "// Line 164: ",
                "// Line 165:         // Set our cursor to be the array element we expect, which in this case is just the first element",
                "// Line 166:         // since we won't run this code unless the array element is 0. There is too much complexity in trying",
                "// Line 167:         // to match additional elements. In those cases the server will just have to be rebooted or something.",
                "// Line 168:         ct, err = c.ArrayElementP(0, matches[1])",
                "// vulnerable line: 169: if err != nil {",
                "// Line 170:             return errors.WithMessage(err, \"failed to find array element at path\")",
                "// vulnerable line: 171: }",
                "// vulnerable line: 172: }",
                "// Line 173: ",
                "// Line 174:     // Try to set the value. If the path does not exist an error will be raised to the caller which will",
                "// Line 175:     // then check if the error is because the path is missing. In those cases we just ignore the error since",
                "// Line 176:     // we don't want to do anything specifically when that happens.",
                "// Line 177:     //",
                "// Line 178:     // If there are four matches in the regex it means that we managed to also match a trailing pathway",
                "// Line 179:     // for the key, which should be found in the given array key item and modified further.",
                "// Line 180:     if len(matches) == 4 {",
                "// Line 181:         _, err = ct.SetP(value, strings.TrimPrefix(matches[3], \".\"))",
                "// Line 182:     } else {",
                "// Line 183:         _, err = ct.Set(value)",
                "// vulnerable line: 184: }",
                "// Line 185: ",
                "// vulnerable line: 186: if err != nil {",
                "// Line 187:         return errors.WithMessage(err, \"failed to set value at config path: \"+path)",
                "// vulnerable line: 188: }",
                "// Line 189: ",
                "// Line 190:     return nil",
                "// vulnerable line: 191: }",
                "// Line 192: ",
                "// Line 193: // Sets the value at a specific pathway, but checks if we were looking for a specific",
                "// Line 194: // value or not before doing it.",
                "// Line 195: func (cfr *ConfigurationFileReplacement) SetAtPathway(c *gabs.Container, path string, value string) error {",
                "// Line 196:     if cfr.IfValue == \"\" {",
                "// Line 197:         return setValueAtPath(c, path, cfr.getKeyValue(value))",
                "// vulnerable line: 198: }",
                "// Line 199: ",
                "// Line 200:     // Check if we are replacing instead of overwriting.",
                "// Line 201:     if strings.HasPrefix(cfr.IfValue, \"regex:\") {",
                "// Line 202:         // Doing a regex replacement requires an existing value.",
                "// Line 203:         // TODO: Do we try passing an empty string to the regex?",
                "// Line 204:         if c.ExistsP(path) {",
                "// Line 205:             return gabs.ErrNotFound",
                "// vulnerable line: 206: }",
                "// Line 207: ",
                "// Line 208:         r, err := regexp.Compile(strings.TrimPrefix(cfr.IfValue, \"regex:\"))",
                "// vulnerable line: 209: if err != nil {",
                "// Line 210:             log.WithFields(log.Fields{\"if_value\": strings.TrimPrefix(cfr.IfValue, \"regex:\"), \"error\": err}).",
                "// Line 211:                 Warn(\"configuration if_value using invalid regexp, cannot perform replacement\")",
                "// Line 212:             return nil",
                "// vulnerable line: 213: }",
                "// Line 214: ",
                "// Line 215:         v := strings.Trim(c.Path(path).String(), \"\"\")",
                "// Line 216:         if r.Match([]byte(v)) {",
                "// Line 217:             return setValueAtPath(c, path, r.ReplaceAllString(v, value))",
                "// vulnerable line: 218: }",
                "// Line 219:         return nil",
                "// vulnerable line: 220: }",
                "// Line 221: ",
                "// Line 222:     if c.ExistsP(path) && !bytes.Equal(c.Bytes(), []byte(cfr.IfValue)) {",
                "// Line 223:         return nil",
                "// vulnerable line: 224: }",
                "// Line 225: ",
                "// Line 226:     return setValueAtPath(c, path, cfr.getKeyValue(value))",
                "// vulnerable line: 227: }",
                "// Line 228: ",
                "// Line 229: // Looks up a configuration value on the Daemon given a dot-notated syntax.",
                "// Line 230: func (f *ConfigurationFile) LookupConfigurationValue(cfr ConfigurationFileReplacement) (string, error) {",
                "// Line 231:     // If this is not something that we can do a regex lookup on then just continue",
                "// Line 232:     // on our merry way. If the value isn't a string, we're not going to be doing anything",
                "// Line 233:     // with it anyways.",
                "// Line 234:     if cfr.ReplaceWith.Type() != jsonparser.String || !configMatchRegex.Match(cfr.ReplaceWith.Value()) {",
                "// Line 235:         return cfr.ReplaceWith.String(), nil",
                "// vulnerable line: 236: }",
                "// Line 237: ",
                "// Line 238:     // If there is a match, lookup the value in the configuration for the Daemon. If no key",
                "// Line 239:     // is found, just return the string representation, otherwise use the value from the",
                "// Line 240:     // daemon configuration here.",
                "// Line 241:     huntPath := configMatchRegex.ReplaceAllString(",
                "// Line 242:         configMatchRegex.FindString(cfr.ReplaceWith.String()), \"$1\",",
                "// Line 243:     )",
                "// Line 244: ",
                "// Line 245:     var path []string",
                "// Line 246:     for _, value := range strings.Split(huntPath, \".\") {",
                "// Line 247:         path = append(path, strcase.ToSnake(value))",
                "// vulnerable line: 248: }",
                "// Line 249: ",
                "// Line 250:     // Look for the key in the configuration file, and if found return that value to the",
                "// Line 251:     // calling function.",
                "// Line 252:     match, _, _, err := jsonparser.Get(f.configuration, path...)",
                "// vulnerable line: 253: if err != nil {",
                "// Line 254:         if err != jsonparser.KeyPathNotFoundError {",
                "// Line 255:             return string(match), err",
                "// vulnerable line: 256: }",
                "// Line 257: ",
                "// Line 258:         log.WithFields(log.Fields{\"path\": path, \"filename\": f.FileName}).Debug(\"attempted to load a configuration value that does not exist\")",
                "// Line 259: ",
                "// Line 260:         // If there is no key, keep the original value intact, that way it is obvious there",
                "// Line 261:         // is a replace issue at play.",
                "// Line 262:         return string(match), nil",
                "// Line 263:     } else {",
                "// Line 264:         return configMatchRegex.ReplaceAllString(cfr.ReplaceWith.String(), string(match)), nil",
                "// vulnerable line: 265: }",
                "// vulnerable line: 266: }"
            ]
        },
        {
            "filename_of_changes": "install.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "15",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package server",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"bufio\"",
                "// vulnerable line: 5: \"bytes\"",
                "// Line 6:     \"context\"",
                "// Line 7:     \"html/template\"",
                "// Line 8:     \"io\"",
                "// Line 9:     \"os\"",
                "// Line 10:     \"path/filepath\"",
                "// Line 11:     \"strconv\"",
                "// Line 12:     \"strings\"",
                "// Line 13:     \"time\"",
                "// Line 14: ",
                "// Line 15:     \"emperror.dev/errors\"",
                "// Line 26: )",
                "// Line 27: ",
                "// Line 28: // Install executes the installation stack for a server process. Bubbles any",
                "// Line 29: // errors up to the calling function which should handle contacting the panel to",
                "// Line 30: // notify it of the server state.",
                "// Line 31: //",
                "// Line 32: // Pass true as the first argument in order to execute a server sync before the",
                "// Line 33: // process to ensure the latest information is used.",
                "// Line 34: func (s *Server) Install() error {",
                "// Line 35:     return s.install(false)",
                "// vulnerable line: 36: }",
                "// Line 37: ",
                "// Line 38: func (s *Server) install(reinstall bool) error {",
                "// Line 39:     var err error",
                "// Line 40:     if !s.Config().SkipEggScripts {",
                "// Line 41:         // Send the start event so the Panel can automatically update. We don't",
                "// Line 42:         // send this unless the process is actually going to run, otherwise all",
                "// Line 43:         // sorts of weird rapid UI behavior happens since there isn't an actual",
                "// Line 44:         // install process being executed.",
                "// Line 45:         s.Events().Publish(InstallStartedEvent, \"\")",
                "// Line 46: ",
                "// Line 47:         err = s.internalInstall()",
                "// Line 48:     } else {",
                "// Line 49:         s.Log().Info(\"server configured to skip running installation scripts for this egg, not executing process\")",
                "// vulnerable line: 50: }",
                "// Line 51: ",
                "// Line 52:     s.Log().WithField(\"was_successful\", err == nil).Debug(\"notifying panel of server install state\")",
                "// Line 53:     if serr := s.SyncInstallState(err == nil, reinstall); serr != nil {",
                "// Line 54:         l := s.Log().WithField(\"was_successful\", err == nil)",
                "// Line 55: ",
                "// Line 56:         // If the request was successful but there was an error with this request,",
                "// Line 57:         // attach the error to this log entry. Otherwise, ignore it in this log",
                "// Line 58:         // since whatever is calling this function should handle the error and",
                "// Line 59:         // will end up logging the same one.",
                "// Line 60:         if err == nil {",
                "// Line 61:             l.WithField(\"error\", err)",
                "// vulnerable line: 62: }",
                "// Line 63: ",
                "// Line 64:         l.Warn(\"failed to notify panel of server install state\")",
                "// vulnerable line: 65: }",
                "// Line 66: ",
                "// Line 67:     // Ensure that the server is marked as offline at this point, otherwise you",
                "// Line 68:     // end up with a blank value which is a bit confusing.",
                "// Line 69:     s.Environment.SetState(environment.ProcessOfflineState)",
                "// Line 70: ",
                "// Line 71:     // Push an event to the websocket, so we can auto-refresh the information in",
                "// Line 72:     // the panel once the installation is completed.",
                "// Line 73:     s.Events().Publish(InstallCompletedEvent, \"\")",
                "// Line 74: ",
                "// Line 75:     return errors.WithStackIf(err)",
                "// vulnerable line: 76: }",
                "// Line 77: ",
                "// Line 78: // Reinstall reinstalls a server's software by utilizing the installation script",
                "// Line 79: // for the server egg. This does not touch any existing files for the server,",
                "// Line 80: // other than what the script modifies.",
                "// Line 81: func (s *Server) Reinstall() error {",
                "// Line 82:     if s.Environment.State() != environment.ProcessOfflineState {",
                "// Line 83:         s.Log().Debug(\"waiting for server instance to enter a stopped state\")",
                "// Line 84:         if err := s.Environment.WaitForStop(s.Context(), time.Second*10, true); err != nil {",
                "// Line 85:             return errors.WrapIf(err, \"install: failed to stop running environment\")",
                "// vulnerable line: 86: }",
                "// vulnerable line: 87: }",
                "// Line 88: ",
                "// Line 89:     s.Log().Info(\"syncing server state with remote source before executing re-installation process\")",
                "// Line 90:     if err := s.Sync(); err != nil {",
                "// Line 91:         return errors.WrapIf(err, \"install: failed to sync server state with Panel\")",
                "// vulnerable line: 92: }",
                "// Line 93: ",
                "// Line 94:     return s.install(true)",
                "// vulnerable line: 95: }",
                "// Line 96: ",
                "// Line 97: // Internal installation function used to simplify reporting back to the Panel.",
                "// Line 98: func (s *Server) internalInstall() error {",
                "// Line 99:     script, err := s.client.GetInstallationScript(s.Context(), s.ID())",
                "// Line 100:     if err != nil {",
                "// Line 101:         return err",
                "// vulnerable line: 102: }",
                "// Line 103:     p, err := NewInstallationProcess(s, &script)",
                "// Line 104:     if err != nil {",
                "// Line 105:         return err",
                "// vulnerable line: 106: }",
                "// Line 107: ",
                "// Line 108:     s.Log().Info(\"beginning installation process for server\")",
                "// Line 109:     if err := p.Run(); err != nil {",
                "// Line 110:         return err",
                "// vulnerable line: 111: }",
                "// Line 112: ",
                "// Line 113:     s.Log().Info(\"completed installation process for server\")",
                "// Line 114:     return nil",
                "// vulnerable line: 115: }",
                "// Line 116: ",
                "// Line 117: type InstallationProcess struct {",
                "// Line 118:     Server *Server",
                "// Line 119:     Script *remote.InstallationScript",
                "// Line 120:     client *client.Client",
                "// vulnerable line: 121: }",
                "// Line 122: ",
                "// Line 123: // NewInstallationProcess returns a new installation process struct that will be",
                "// Line 124: // used to create containers and otherwise perform installation commands for a",
                "// Line 125: // server.",
                "// Line 126: func NewInstallationProcess(s *Server, script *remote.InstallationScript) (*InstallationProcess, error) {",
                "// Line 127:     proc := &InstallationProcess{",
                "// Line 128:         Script: script,",
                "// Line 129:         Server: s,",
                "// vulnerable line: 130: }",
                "// Line 131: ",
                "// Line 132:     if c, err := environment.Docker(); err != nil {",
                "// Line 133:         return nil, err",
                "// Line 134:     } else {",
                "// Line 135:         proc.client = c",
                "// vulnerable line: 136: }",
                "// Line 137: ",
                "// Line 138:     return proc, nil",
                "// vulnerable line: 139: }",
                "// Line 140: ",
                "// Line 141: // IsInstalling returns if the server is actively running the installation",
                "// Line 142: // process by checking the status of the installer lock.",
                "// Line 143: func (s *Server) IsInstalling() bool {",
                "// Line 144:     return s.installing.Load()",
                "// vulnerable line: 145: }",
                "// Line 146: ",
                "// Line 147: func (s *Server) IsTransferring() bool {",
                "// Line 148:     return s.transferring.Load()",
                "// vulnerable line: 149: }",
                "// Line 150: ",
                "// Line 151: func (s *Server) SetTransferring(state bool) {",
                "// Line 152:     s.transferring.Store(state)",
                "// vulnerable line: 153: }",
                "// Line 154: ",
                "// Line 155: func (s *Server) IsRestoring() bool {",
                "// Line 156:     return s.restoring.Load()",
                "// vulnerable line: 157: }",
                "// Line 158: ",
                "// Line 159: func (s *Server) SetRestoring(state bool) {",
                "// Line 160:     s.restoring.Store(state)",
                "// vulnerable line: 161: }",
                "// Line 162: ",
                "// Line 163: // RemoveContainer removes the installation container for the server.",
                "// Line 164: func (ip *InstallationProcess) RemoveContainer() error {",
                "// Line 165:     err := ip.client.ContainerRemove(ip.Server.Context(), ip.Server.ID()+\"_installer\", types.ContainerRemoveOptions{",
                "// Line 166:         RemoveVolumes: true,",
                "// Line 167:         Force:         true,",
                "// Line 168:     })",
                "// Line 169:     if err != nil && !client.IsErrNotFound(err) {",
                "// Line 170:         return err",
                "// vulnerable line: 171: }",
                "// Line 172:     return nil",
                "// vulnerable line: 173: }",
                "// Line 174: ",
                "// Line 175: // Run runs the installation process, this is done as in a background thread.",
                "// Line 176: // This will configure the required environment, and then spin up the",
                "// Line 177: // installation container. Once the container finishes installing the results",
                "// Line 178: // are stored in an installation log in the server's configuration directory.",
                "// Line 179: func (ip *InstallationProcess) Run() error {",
                "// Line 180:     ip.Server.Log().Debug(\"acquiring installation process lock\")",
                "// Line 181:     if !ip.Server.installing.SwapIf(true) {",
                "// Line 182:         return errors.New(\"install: cannot obtain installation lock\")",
                "// vulnerable line: 183: }",
                "// Line 184: ",
                "// Line 185:     // We now have an exclusive lock on this installation process. Ensure that whenever this",
                "// Line 186:     // process is finished that the semaphore is released so that other processes and be executed",
                "// Line 187:     // without encountering a wait timeout.",
                "// Line 188:     defer func() {",
                "// Line 189:         ip.Server.Log().Debug(\"releasing installation process lock\")",
                "// Line 190:         ip.Server.installing.Store(false)",
                "// Line 191:     }()",
                "// Line 192: ",
                "// Line 193:     if err := ip.BeforeExecute(); err != nil {",
                "// Line 194:         return err",
                "// vulnerable line: 195: }",
                "// Line 196: ",
                "// Line 197:     cID, err := ip.Execute()",
                "// Line 198:     if err != nil {",
                "// Line 199:         _ = ip.RemoveContainer()",
                "// Line 200:         return err",
                "// vulnerable line: 201: }",
                "// Line 202: ",
                "// Line 203:     // If this step fails, log a warning but don't exit out of the process. This is completely",
                "// Line 204:     // internal to the daemon's functionality, and does not affect the status of the server itself.",
                "// Line 205:     if err := ip.AfterExecute(cID); err != nil {",
                "// Line 206:         ip.Server.Log().WithField(\"error\", err).Warn(\"failed to complete after-execute step of installation process\")",
                "// vulnerable line: 207: }",
                "// Line 208: ",
                "// Line 209:     return nil",
                "// vulnerable line: 210: }",
                "// Line 211: ",
                "// Line 212: // Returns the location of the temporary data for the installation process.",
                "// Line 213: func (ip *InstallationProcess) tempDir() string {",
                "// Line 214:     return filepath.Join(config.Get().System.TmpDirectory, ip.Server.ID())",
                "// vulnerable line: 215: }",
                "// Line 216: ",
                "// Line 217: // Writes the installation script to a temporary file on the host machine so that it",
                "// Line 218: // can be properly mounted into the installation container and then executed.",
                "// Line 219: func (ip *InstallationProcess) writeScriptToDisk() error {",
                "// Line 220:     // Make sure the temp directory root exists before trying to make a directory within it. The",
                "// vulnerable line: 221: // ioutil.TempDir call expects this base to exist, it won't create it for you.",
                "// Line 222:     if err := os.MkdirAll(ip.tempDir(), 0o700); err != nil {",
                "// Line 223:         return errors.WithMessage(err, \"could not create temporary directory for install process\")",
                "// vulnerable line: 224: }",
                "// Line 225: ",
                "// Line 226:     f, err := os.OpenFile(filepath.Join(ip.tempDir(), \"install.sh\"), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o644)",
                "// Line 227:     if err != nil {",
                "// Line 228:         return errors.WithMessage(err, \"failed to write server installation script to disk before mount\")",
                "// vulnerable line: 229: }",
                "// Line 230:     defer f.Close()",
                "// Line 231: ",
                "// vulnerable line: 232: w := bufio.NewWriter(f)",
                "// Line 233: ",
                "// vulnerable line: 234: scanner := bufio.NewScanner(bytes.NewReader([]byte(ip.Script.Script)))",
                "// vulnerable line: 235: for scanner.Scan() {",
                "// Line 236:         w.WriteString(scanner.Text() + \"",
                "// Line 237: \")",
                "// vulnerable line: 238: }",
                "// Line 239: ",
                "// vulnerable line: 240: if err := scanner.Err(); err != nil {",
                "// Line 241:         return err",
                "// vulnerable line: 242: }",
                "// Line 243: ",
                "// vulnerable line: 244: w.Flush()",
                "// Line 245: ",
                "// Line 246:     return nil",
                "// vulnerable line: 247: }",
                "// Line 248: ",
                "// Line 249: // Pulls the docker image to be used for the installation container.",
                "// Line 250: func (ip *InstallationProcess) pullInstallationImage() error {",
                "// Line 251:     // Get a registry auth configuration from the config.",
                "// Line 252:     var registryAuth *config.RegistryConfiguration",
                "// Line 253:     for registry, c := range config.Get().Docker.Registries {",
                "// Line 254:         if !strings.HasPrefix(ip.Script.ContainerImage, registry) {",
                "// Line 255:             continue",
                "// vulnerable line: 256: }",
                "// Line 257: ",
                "// Line 258:         log.WithField(\"registry\", registry).Debug(\"using authentication for registry\")",
                "// Line 259:         registryAuth = &c",
                "// Line 260:         break",
                "// vulnerable line: 261: }",
                "// Line 262: ",
                "// Line 263:     // Get the ImagePullOptions.",
                "// Line 264:     imagePullOptions := types.ImagePullOptions{All: false}",
                "// Line 265:     if registryAuth != nil {",
                "// Line 266:         b64, err := registryAuth.Base64()",
                "// Line 267:         if err != nil {",
                "// Line 268:             log.WithError(err).Error(\"failed to get registry auth credentials\")",
                "// vulnerable line: 269: }",
                "// Line 270: ",
                "// Line 271:         // b64 is a string so if there is an error it will just be empty, not nil.",
                "// Line 272:         imagePullOptions.RegistryAuth = b64",
                "// vulnerable line: 273: }",
                "// Line 274: ",
                "// Line 275:     r, err := ip.client.ImagePull(ip.Server.Context(), ip.Script.ContainerImage, imagePullOptions)",
                "// Line 276:     if err != nil {",
                "// Line 277:         images, ierr := ip.client.ImageList(ip.Server.Context(), types.ImageListOptions{})",
                "// Line 278:         if ierr != nil {",
                "// Line 279:             // Well damn, something has gone really wrong here, just go ahead and abort there",
                "// Line 280:             // isn't much anything we can do to try and self-recover from this.",
                "// Line 281:             return ierr",
                "// vulnerable line: 282: }",
                "// Line 283: ",
                "// Line 284:         for _, img := range images {",
                "// Line 285:             for _, t := range img.RepoTags {",
                "// Line 286:                 if t != ip.Script.ContainerImage {",
                "// Line 287:                     continue",
                "// vulnerable line: 288: }",
                "// Line 289: ",
                "// Line 290:                 log.WithFields(log.Fields{",
                "// Line 291:                     \"image\": ip.Script.ContainerImage,",
                "// Line 292:                     \"err\":   err.Error(),",
                "// Line 293:                 }).Warn(\"unable to pull requested image from remote source, however the image exists locally\")",
                "// Line 294: ",
                "// Line 295:                 // Okay, we found a matching container image, in that case just go ahead and return",
                "// Line 296:                 // from this function, since there is nothing else we need to do here.",
                "// Line 297:                 return nil",
                "// vulnerable line: 298: }",
                "// vulnerable line: 299: }",
                "// Line 300: ",
                "// Line 301:         return err",
                "// vulnerable line: 302: }",
                "// Line 303:     defer r.Close()",
                "// Line 304: ",
                "// Line 305:     log.WithField(\"image\", ip.Script.ContainerImage).Debug(\"pulling docker image... this could take a bit of time\")",
                "// Line 306: ",
                "// Line 307:     // Block continuation until the image has been pulled successfully.",
                "// Line 308:     scanner := bufio.NewScanner(r)",
                "// vulnerable line: 309: for scanner.Scan() {",
                "// Line 310:         log.Debug(scanner.Text())",
                "// vulnerable line: 311: }",
                "// Line 312: ",
                "// vulnerable line: 313: if err := scanner.Err(); err != nil {",
                "// Line 314:         return err",
                "// vulnerable line: 315: }",
                "// Line 316: ",
                "// Line 317:     return nil",
                "// vulnerable line: 318: }",
                "// Line 319: ",
                "// Line 320: // BeforeExecute runs before the container is executed. This pulls down the",
                "// Line 321: // required docker container image as well as writes the installation script to",
                "// Line 322: // the disk. This process is executed in an async manner, if either one fails",
                "// Line 323: // the error is returned.",
                "// Line 324: func (ip *InstallationProcess) BeforeExecute() error {",
                "// Line 325:     if err := ip.writeScriptToDisk(); err != nil {",
                "// Line 326:         return errors.WithMessage(err, \"failed to write installation script to disk\")",
                "// vulnerable line: 327: }",
                "// Line 328:     if err := ip.pullInstallationImage(); err != nil {",
                "// Line 329:         return errors.WithMessage(err, \"failed to pull updated installation container image for server\")",
                "// vulnerable line: 330: }",
                "// Line 331:     if err := ip.RemoveContainer(); err != nil {",
                "// Line 332:         return errors.WithMessage(err, \"failed to remove existing install container for server\")",
                "// vulnerable line: 333: }",
                "// Line 334:     return nil",
                "// vulnerable line: 335: }",
                "// Line 336: ",
                "// Line 337: // GetLogPath returns the log path for the installation process.",
                "// Line 338: func (ip *InstallationProcess) GetLogPath() string {",
                "// Line 339:     return filepath.Join(config.Get().System.LogDirectory, \"/install\", ip.Server.ID()+\".log\")",
                "// vulnerable line: 340: }",
                "// Line 341: ",
                "// Line 342: // AfterExecute cleans up after the execution of the installation process.",
                "// Line 343: // This grabs the logs from the process to store in the server configuration",
                "// Line 344: // directory, and then destroys the associated installation container.",
                "// Line 345: func (ip *InstallationProcess) AfterExecute(containerId string) error {",
                "// Line 346:     defer ip.RemoveContainer()",
                "// Line 347: ",
                "// Line 348:     ip.Server.Log().WithField(\"container_id\", containerId).Debug(\"pulling installation logs for server\")",
                "// Line 349:     reader, err := ip.client.ContainerLogs(ip.Server.Context(), containerId, types.ContainerLogsOptions{",
                "// Line 350:         ShowStdout: true,",
                "// Line 351:         ShowStderr: true,",
                "// Line 352:         Follow:     false,",
                "// Line 353:     })",
                "// Line 354: ",
                "// Line 355:     if err != nil && !client.IsErrNotFound(err) {",
                "// Line 356:         return err",
                "// vulnerable line: 357: }",
                "// Line 358: ",
                "// Line 359:     f, err := os.OpenFile(ip.GetLogPath(), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o600)",
                "// Line 360:     if err != nil {",
                "// Line 361:         return err",
                "// vulnerable line: 362: }",
                "// Line 363:     defer f.Close()",
                "// Line 364: ",
                "// Line 365:     // We write the contents of the container output to a more \"permanent\" file so that they",
                "// Line 366:     // can be referenced after this container is deleted. We'll also include the environment",
                "// Line 367:     // variables passed into the container to make debugging things a little easier.",
                "// Line 368:     ip.Server.Log().WithField(\"path\", ip.GetLogPath()).Debug(\"writing most recent installation logs to disk\")",
                "// Line 369: ",
                "// Line 370:     tmpl, err := template.New(\"header\").Parse(`Pterodactyl Server Installation Log",
                "// Line 371: ",
                "// Line 372: |",
                "// Line 381: | ------------------------------",
                "// Line 382: {{ range $key, $value := .Server.GetEnvironmentVariables }}  {{ $value }}",
                "// Line 383: {{ end }}",
                "// Line 384: ",
                "// Line 385: |",
                "// Line 386: | Script Output",
                "// Line 387: | ------------------------------",
                "// Line 388: `)",
                "// Line 389:     if err != nil {",
                "// Line 390:         return err",
                "// vulnerable line: 391: }",
                "// Line 392: ",
                "// Line 393:     if err := tmpl.Execute(f, ip); err != nil {",
                "// Line 394:         return err",
                "// vulnerable line: 395: }",
                "// Line 396: ",
                "// Line 397:     if _, err := io.Copy(f, reader); err != nil {",
                "// Line 398:         return err",
                "// vulnerable line: 399: }",
                "// Line 400: ",
                "// Line 401:     return nil",
                "// vulnerable line: 402: }",
                "// Line 403: ",
                "// Line 404: // Execute executes the installation process inside a specially created docker",
                "// Line 405: // container.",
                "// Line 406: func (ip *InstallationProcess) Execute() (string, error) {",
                "// Line 407:     // Create a child context that is canceled once this function is done running. This",
                "// Line 408:     // will also be canceled if the parent context (from the Server struct) is canceled",
                "// Line 409:     // which occurs if the server is deleted.",
                "// Line 410:     ctx, cancel := context.WithCancel(ip.Server.Context())",
                "// Line 411:     defer cancel()",
                "// Line 412: ",
                "// Line 417:         AttachStdin:  true,",
                "// Line 418:         OpenStdin:    true,",
                "// Line 419:         Tty:          true,",
                "// Line 420:         Cmd:          []string{ip.Script.Entrypoint, \"/mnt/install/install.sh\"},",
                "// Line 421:         Image:        ip.Script.ContainerImage,",
                "// Line 422:         Env:          ip.Server.GetEnvironmentVariables(),",
                "// Line 423:         Labels: map[string]string{",
                "// Line 424:             \"Service\":       \"Pterodactyl\",",
                "// Line 425:             \"ContainerType\": \"server_installer\",",
                "// Line 426:         },",
                "// vulnerable line: 427: }",
                "// Line 428: ",
                "// Line 429:     cfg := config.Get()",
                "// Line 430:     tmpfsSize := strconv.Itoa(int(cfg.Docker.TmpfsSize))",
                "// Line 431:     hostConf := &container.HostConfig{",
                "// Line 432:         Mounts: []mount.Mount{",
                "// Line 433:             {",
                "// Line 434:                 Target:   \"/mnt/server\",",
                "// Line 435:                 Source:   ip.Server.Filesystem().Path(),",
                "// Line 436:                 Type:     mount.TypeBind,",
                "// Line 437:                 ReadOnly: false,",
                "// Line 444:             },",
                "// Line 445:         },",
                "// Line 446:         Resources: ip.resourceLimits(),",
                "// Line 447:         Tmpfs: map[string]string{",
                "// Line 448:             \"/tmp\": \"rw,exec,nosuid,size=\" + tmpfsSize + \"M\",",
                "// Line 449:         },",
                "// Line 450:         DNS:         cfg.Docker.Network.Dns,",
                "// Line 451:         LogConfig:   cfg.Docker.ContainerLogConfig(),",
                "// Line 452:         NetworkMode: container.NetworkMode(cfg.Docker.Network.Mode),",
                "// Line 453:         UsernsMode:  container.UsernsMode(cfg.Docker.UsernsMode),",
                "// vulnerable line: 454: }",
                "// Line 455: ",
                "// Line 456:     // Ensure the root directory for the server exists properly before attempting",
                "// Line 457:     // to trigger the reinstall of the server. It is possible the directory would",
                "// Line 458:     // not exist when this runs if Wings boots with a missing directory and a user",
                "// Line 459:     // triggers a reinstall before trying to start the server.",
                "// Line 460:     if err := ip.Server.EnsureDataDirectoryExists(); err != nil {",
                "// Line 461:         return \"\", err",
                "// vulnerable line: 462: }",
                "// Line 463: ",
                "// Line 464:     ip.Server.Log().WithField(\"install_script\", ip.tempDir()+\"/install.sh\").Info(\"creating install container for server process\")",
                "// Line 465:     // Remove the temporary directory when the installation process finishes for this server container.",
                "// Line 466:     defer func() {",
                "// Line 467:         if err := os.RemoveAll(ip.tempDir()); err != nil {",
                "// Line 468:             if !os.IsNotExist(err) {",
                "// Line 469:                 ip.Server.Log().WithField(\"error\", err).Warn(\"failed to remove temporary data directory after install process\")",
                "// vulnerable line: 470: }",
                "// vulnerable line: 471: }",
                "// Line 472:     }()",
                "// Line 473: ",
                "// Line 474:     r, err := ip.client.ContainerCreate(ctx, conf, hostConf, nil, nil, ip.Server.ID()+\"_installer\")",
                "// Line 475:     if err != nil {",
                "// Line 476:         return \"\", err",
                "// vulnerable line: 477: }",
                "// Line 478: ",
                "// Line 479:     ip.Server.Log().WithField(\"container_id\", r.ID).Info(\"running installation script for server in container\")",
                "// Line 480:     if err := ip.client.ContainerStart(ctx, r.ID, types.ContainerStartOptions{}); err != nil {",
                "// Line 481:         return \"\", err",
                "// vulnerable line: 482: }",
                "// Line 483: ",
                "// Line 484:     // Process the install event in the background by listening to the stream output until the",
                "// Line 485:     // container has stopped, at which point we'll disconnect from it.",
                "// Line 486:     //",
                "// Line 487:     // If there is an error during the streaming output just report it and do nothing else, the",
                "// Line 488:     // install can still run, the console just won't have any output.",
                "// Line 489:     go func(id string) {",
                "// Line 490:         ip.Server.Events().Publish(DaemonMessageEvent, \"Starting installation process, this could take a few minutes...\")",
                "// Line 491:         if err := ip.StreamOutput(ctx, id); err != nil {",
                "// Line 492:             ip.Server.Log().WithField(\"error\", err).Warn(\"error connecting to server install stream output\")",
                "// vulnerable line: 493: }",
                "// Line 494:     }(r.ID)",
                "// Line 495: ",
                "// Line 496:     sChan, eChan := ip.client.ContainerWait(ctx, r.ID, container.WaitConditionNotRunning)",
                "// Line 497:     select {",
                "// Line 498:     case err := <-eChan:",
                "// Line 499:         // Once the container has stopped running we can mark the install process as being completed.",
                "// Line 500:         if err == nil {",
                "// Line 501:             ip.Server.Events().Publish(DaemonMessageEvent, \"Installation process completed.\")",
                "// Line 502:         } else {",
                "// Line 503:             return \"\", err",
                "// vulnerable line: 504: }",
                "// Line 505:     case <-sChan:",
                "// vulnerable line: 506: }",
                "// Line 507: ",
                "// Line 508:     return r.ID, nil",
                "// vulnerable line: 509: }",
                "// Line 510: ",
                "// Line 511: // StreamOutput streams the output of the installation process to a log file in",
                "// Line 512: // the server configuration directory, as well as to a websocket listener so",
                "// Line 513: // that the process can be viewed in the panel by administrators.",
                "// Line 514: func (ip *InstallationProcess) StreamOutput(ctx context.Context, id string) error {",
                "// Line 515:     opts := types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true, Follow: true}",
                "// Line 516:     reader, err := ip.client.ContainerLogs(ctx, id, opts)",
                "// Line 517:     if err != nil {",
                "// Line 518:         return err",
                "// vulnerable line: 519: }",
                "// Line 520:     defer reader.Close()",
                "// Line 521: ",
                "// Line 522:     err = system.ScanReader(reader, ip.Server.Sink(system.InstallSink).Push)",
                "// Line 523:     if err != nil && !errors.Is(err, context.Canceled) {",
                "// Line 524:         ip.Server.Log().WithFields(log.Fields{\"container_id\": id, \"error\": err}).Warn(\"error processing install output lines\")",
                "// vulnerable line: 525: }",
                "// Line 526:     return nil",
                "// vulnerable line: 527: }",
                "// Line 528: ",
                "// Line 529: // resourceLimits returns resource limits for the installation container. This",
                "// Line 530: // looks at the globally defined install container limits and attempts to use",
                "// Line 531: // the higher of the two (defined limits & server limits). This allows for servers",
                "// Line 532: // with super low limits (e.g. Discord bots with 128Mb of memory) to perform more",
                "// Line 533: // intensive installation processes if needed.",
                "// Line 534: //",
                "// Line 535: // This also avoids a server with limits such as 4GB of memory from accidentally",
                "// Line 536: // consuming 2-5x the defined limits during the install process and causing",
                "// Line 537: // system instability.",
                "// Line 538: func (ip *InstallationProcess) resourceLimits() container.Resources {",
                "// Line 539:     limits := config.Get().Docker.InstallerLimits",
                "// Line 540: ",
                "// Line 541:     // Create a copy of the configuration, so we're not accidentally making",
                "// Line 542:     // changes to the underlying server build data.",
                "// Line 543:     c := *ip.Server.Config()",
                "// Line 544:     cfg := c.Build",
                "// Line 545:     if cfg.MemoryLimit < limits.Memory {",
                "// Line 546:         cfg.MemoryLimit = limits.Memory",
                "// vulnerable line: 547: }",
                "// Line 548:     // Only apply the CPU limit if neither one is currently set to unlimited. If the",
                "// Line 549:     // installer CPU limit is unlimited don't even waste time with the logic, just",
                "// Line 550:     // set the config to unlimited for this.",
                "// Line 551:     if limits.Cpu == 0 {",
                "// Line 552:         cfg.CpuLimit = 0",
                "// Line 553:     } else if cfg.CpuLimit != 0 && cfg.CpuLimit < limits.Cpu {",
                "// Line 554:         cfg.CpuLimit = limits.Cpu",
                "// vulnerable line: 555: }",
                "// Line 556: ",
                "// Line 557:     resources := cfg.AsContainerResources()",
                "// Line 558:     // Explicitly remove the PID limits for the installation container. These scripts are",
                "// Line 559:     // defined at an administrative level and users can't manually execute things like a",
                "// Line 560:     // fork bomb during this process.",
                "// Line 561:     resources.PidsLimit = nil",
                "// Line 562: ",
                "// Line 563:     return resources",
                "// vulnerable line: 564: }",
                "// Line 565: ",
                "// Line 566: // SyncInstallState makes an HTTP request to the Panel instance notifying it that",
                "// Line 567: // the server has completed the installation process, and what the state of the",
                "// Line 568: // server is.",
                "// Line 569: func (s *Server) SyncInstallState(successful, reinstall bool) error {",
                "// Line 570:     return s.client.SetInstallationStatus(s.Context(), s.ID(), remote.InstallStatusRequest{",
                "// Line 571:         Successful: successful,",
                "// Line 572:         Reinstall:  reinstall,",
                "// Line 573:     })",
                "// vulnerable line: 574: }"
            ]
        },
        {
            "filename_of_changes": "manager.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 189:     if err != nil {",
                "// Line 190:         return nil, err",
                "// Line 191:     }",
                "// Line 192: ",
                "// Line 193:     // Setup the base server configuration data which will be used for all of the",
                "// Line 194:     // remaining functionality in this call.",
                "// Line 195:     if err := s.SyncWithConfiguration(data); err != nil {",
                "// Line 196:         return nil, errors.WithStackIf(err)",
                "// Line 197:     }",
                "// Line 198: ",
                "// vulnerable line: 199: s.fs = filesystem.New(filepath.Join(config.Get().System.Data, s.ID()), s.DiskSpace(), s.Config().Egg.FileDenylist)",
                "// Line 200: ",
                "// Line 201:     // Right now we only support a Docker based environment, so I'm going to hard code",
                "// Line 202:     // this logic in. When we're ready to support other environment we'll need to make",
                "// Line 203:     // some modifications here, obviously.",
                "// Line 204:     settings := environment.Settings{",
                "// Line 205:         Mounts:      s.Mounts(),",
                "// Line 206:         Allocations: s.cfg.Allocations,",
                "// Line 207:         Limits:      s.cfg.Build,",
                "// Line 208:         Labels:      s.cfg.Labels,",
                "// Line 209:     }"
            ]
        },
        {
            "filename_of_changes": "router_download.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "12",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 14:     \"github.com/pterodactyl/wings/server/backup\"",
                "// Line 15: )",
                "// Line 16: ",
                "// Line 17: // Handle a download request for a server backup.",
                "// Line 18: func getDownloadBackup(c *gin.Context) {",
                "// Line 19:     client := middleware.ExtractApiClient(c)",
                "// Line 20:     manager := middleware.ExtractManager(c)",
                "// Line 21: ",
                "// Line 22:     token := tokens.BackupPayload{}",
                "// Line 23:     if err := tokens.ParseToken([]byte(c.Query(\"token\")), &token); err != nil {",
                "// vulnerable line: 24: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 25: return",
                "// vulnerable line: 26: }",
                "// Line 27: ",
                "// Line 28:     if _, ok := manager.Get(token.ServerUuid); !ok || !token.IsUniqueRequest() {",
                "// Line 29:         c.AbortWithStatusJSON(http.StatusNotFound, gin.H{",
                "// Line 30:             \"error\": \"The requested resource was not found on this server.\",",
                "// Line 31:         })",
                "// vulnerable line: 32: return",
                "// vulnerable line: 33: }",
                "// Line 34: ",
                "// Line 35:     b, st, err := backup.LocateLocal(client, token.BackupUuid)",
                "// vulnerable line: 36: if err != nil {",
                "// Line 37:         if errors.Is(err, os.ErrNotExist) {",
                "// Line 38:             c.AbortWithStatusJSON(http.StatusNotFound, gin.H{",
                "// Line 39:                 \"error\": \"The requested backup was not found on this server.\",",
                "// Line 40:             })",
                "// vulnerable line: 41: return",
                "// vulnerable line: 42: }",
                "// Line 43: ",
                "// vulnerable line: 44: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 45: return",
                "// vulnerable line: 46: }",
                "// Line 47: ",
                "// Line 48:     f, err := os.Open(b.Path())",
                "// vulnerable line: 49: if err != nil {",
                "// vulnerable line: 50: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 51: return",
                "// vulnerable line: 52: }",
                "// vulnerable line: 53: defer f.Close()",
                "// Line 54: ",
                "// Line 55:     c.Header(\"Content-Length\", strconv.Itoa(int(st.Size())))",
                "// Line 56:     c.Header(\"Content-Disposition\", \"attachment; filename=\"+strconv.Quote(st.Name()))",
                "// Line 57:     c.Header(\"Content-Type\", \"application/octet-stream\")",
                "// Line 58: ",
                "// Line 59:     _, _ = bufio.NewReader(f).WriteTo(c.Writer)",
                "// vulnerable line: 60: }",
                "// Line 61: ",
                "// Line 62: // Handles downloading a specific file for a server.",
                "// Line 63: func getDownloadFile(c *gin.Context) {",
                "// Line 64:     manager := middleware.ExtractManager(c)",
                "// Line 65:     token := tokens.FilePayload{}",
                "// Line 66:     if err := tokens.ParseToken([]byte(c.Query(\"token\")), &token); err != nil {",
                "// vulnerable line: 67: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 68: return",
                "// vulnerable line: 69: }",
                "// Line 70: ",
                "// Line 71:     s, ok := manager.Get(token.ServerUuid)",
                "// Line 72:     if !ok || !token.IsUniqueRequest() {",
                "// Line 73:         c.AbortWithStatusJSON(http.StatusNotFound, gin.H{",
                "// Line 74:             \"error\": \"The requested resource was not found on this server.\",",
                "// Line 75:         })",
                "// vulnerable line: 76: return",
                "// vulnerable line: 77: }",
                "// Line 78: ",
                "// vulnerable line: 79: p, _ := s.Filesystem().SafePath(token.FilePath)",
                "// vulnerable line: 80: st, err := os.Stat(p)",
                "// vulnerable line: 81: // If there is an error or we're somehow trying to download a directory, just",
                "// vulnerable line: 82: // respond with the appropriate error.",
                "// vulnerable line: 83: if err != nil {",
                "// vulnerable line: 84: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 85: return",
                "// vulnerable line: 86: } else if st.IsDir() {",
                "// Line 87:         c.AbortWithStatusJSON(http.StatusNotFound, gin.H{",
                "// Line 88:             \"error\": \"The requested resource was not found on this server.\",",
                "// Line 89:         })",
                "// vulnerable line: 90: return",
                "// vulnerable line: 91: }",
                "// Line 92: ",
                "// vulnerable line: 93: f, err := os.Open(p)",
                "// vulnerable line: 94: if err != nil {",
                "// vulnerable line: 95: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 96: return",
                "// vulnerable line: 97: }",
                "// vulnerable line: 98: defer f.Close()",
                "// Line 99: ",
                "// Line 100:     c.Header(\"Content-Length\", strconv.Itoa(int(st.Size())))",
                "// Line 101:     c.Header(\"Content-Disposition\", \"attachment; filename=\"+strconv.Quote(st.Name()))",
                "// Line 102:     c.Header(\"Content-Type\", \"application/octet-stream\")",
                "// Line 103: ",
                "// Line 104:     _, _ = bufio.NewReader(f).WriteTo(c.Writer)",
                "// vulnerable line: 105: }"
            ]
        },
        {
            "filename_of_changes": "router_server.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "router_server_files.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "11",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 23:     \"github.com/pterodactyl/wings/router/downloader\"",
                "// Line 24:     \"github.com/pterodactyl/wings/router/middleware\"",
                "// Line 25:     \"github.com/pterodactyl/wings/router/tokens\"",
                "// Line 26:     \"github.com/pterodactyl/wings/server\"",
                "// Line 27:     \"github.com/pterodactyl/wings/server/filesystem\"",
                "// Line 28: )",
                "// Line 29: ",
                "// Line 30: // getServerFileContents returns the contents of a file on the server.",
                "// Line 31: func getServerFileContents(c *gin.Context) {",
                "// Line 32:     s := middleware.ExtractServer(c)",
                "// vulnerable line: 33: p := \"/\" + strings.TrimLeft(c.Query(\"file\"), \"/\")",
                "// Line 34:     f, st, err := s.Filesystem().File(p)",
                "// vulnerable line: 35: if err != nil {",
                "// vulnerable line: 36: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 37: return",
                "// vulnerable line: 38: }",
                "// Line 39:     defer f.Close()",
                "// Line 40:     // Don't allow a named pipe to be opened.",
                "// Line 41:     //",
                "// Line 42:     // @see https://github.com/pterodactyl/panel/issues/4059",
                "// Line 43:     if st.Mode()&os.ModeNamedPipe != 0 {",
                "// Line 44:         c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 45:             \"error\": \"Cannot open files of this type.\",",
                "// Line 46:         })",
                "// vulnerable line: 47: return",
                "// vulnerable line: 48: }",
                "// Line 49: ",
                "// Line 50:     c.Header(\"X-Mime-Type\", st.Mimetype)",
                "// Line 51:     c.Header(\"Content-Length\", strconv.Itoa(int(st.Size())))",
                "// Line 52:     // If a download parameter is included in the URL go ahead and attach the necessary headers",
                "// Line 53:     // so that the file can be downloaded.",
                "// Line 54:     if c.Query(\"download\") != \"\" {",
                "// Line 55:         c.Header(\"Content-Disposition\", \"attachment; filename=\"+strconv.Quote(st.Name()))",
                "// Line 56:         c.Header(\"Content-Type\", \"application/octet-stream\")",
                "// vulnerable line: 57: }",
                "// Line 58:     defer c.Writer.Flush()",
                "// Line 59:     // If you don't do a limited reader here you will trigger a panic on write when",
                "// Line 60:     // a different server process writes content to the file after you've already",
                "// Line 61:     // determined the file size. This could lead to some weird content output but",
                "// Line 62:     // it would technically be accurate based on the content at the time of the request.",
                "// Line 63:     //",
                "// Line 64:     // \"http: wrote more than the declared Content-Length\"",
                "// Line 65:     //",
                "// Line 66:     // @see https://github.com/pterodactyl/panel/issues/3131",
                "// Line 67:     r := io.LimitReader(f, st.Size())",
                "// Line 68:     if _, err = bufio.NewReader(r).WriteTo(c.Writer); err != nil {",
                "// Line 69:         // Pretty sure this will unleash chaos on the response, but its a risk we can",
                "// Line 70:         // take since a panic will at least be recovered and this should be incredibly",
                "// Line 71:         // rare?",
                "// vulnerable line: 72: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 73: return",
                "// vulnerable line: 74: }",
                "// vulnerable line: 75: }",
                "// Line 76: ",
                "// Line 77: // Returns the contents of a directory for a server.",
                "// Line 78: func getServerListDirectory(c *gin.Context) {",
                "// Line 79:     s := ExtractServer(c)",
                "// Line 80:     dir := c.Query(\"directory\")",
                "// Line 81:     if stats, err := s.Filesystem().ListDirectory(dir); err != nil {",
                "// vulnerable line: 82: middleware.CaptureAndAbort(c, err)",
                "// Line 83:     } else {",
                "// Line 84:         c.JSON(http.StatusOK, stats)",
                "// vulnerable line: 85: }",
                "// vulnerable line: 86: }",
                "// Line 87: ",
                "// Line 88: type renameFile struct {",
                "// Line 89:     To   string `json:\"to\"`",
                "// Line 90:     From string `json:\"from\"`",
                "// vulnerable line: 91: }",
                "// Line 92: ",
                "// Line 93: // Renames (or moves) files for a server.",
                "// Line 94: func putServerRenameFiles(c *gin.Context) {",
                "// Line 95:     s := ExtractServer(c)",
                "// Line 96: ",
                "// Line 97:     var data struct {",
                "// Line 98:         Root  string       `json:\"root\"`",
                "// Line 99:         Files []renameFile `json:\"files\"`",
                "// vulnerable line: 100: }",
                "// Line 101:     // BindJSON sends 400 if the request fails, all we need to do is return",
                "// Line 102:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 103: return",
                "// vulnerable line: 104: }",
                "// Line 105: ",
                "// Line 106:     if len(data.Files) == 0 {",
                "// Line 107:         c.AbortWithStatusJSON(http.StatusUnprocessableEntity, gin.H{",
                "// Line 108:             \"error\": \"No files to move or rename were provided.\",",
                "// Line 109:         })",
                "// vulnerable line: 110: return",
                "// vulnerable line: 111: }",
                "// Line 112: ",
                "// Line 113:     g, ctx := errgroup.WithContext(c.Request.Context())",
                "// Line 114:     // Loop over the array of files passed in and perform the move or rename action against each.",
                "// Line 115:     for _, p := range data.Files {",
                "// Line 116:         pf := path.Join(data.Root, p.From)",
                "// Line 117:         pt := path.Join(data.Root, p.To)",
                "// Line 118: ",
                "// Line 119:         g.Go(func() error {",
                "// Line 120:             select {",
                "// Line 121:             case <-ctx.Done():",
                "// Line 122:                 return ctx.Err()",
                "// Line 123:             default:",
                "// Line 124:                 fs := s.Filesystem()",
                "// Line 125:                 // Ignore renames on a file that is on the denylist (both as the rename from or",
                "// Line 126:                 // the rename to value).",
                "// Line 127:                 if err := fs.IsIgnored(pf, pt); err != nil {",
                "// Line 128:                     return err",
                "// vulnerable line: 129: }",
                "// Line 130:                 if err := fs.Rename(pf, pt); err != nil {",
                "// Line 131:                     // Return nil if the error is an is not exists.",
                "// vulnerable line: 132: // NOTE: os.IsNotExist() does not work if the error is wrapped.",
                "// Line 133:                     if errors.Is(err, os.ErrNotExist) {",
                "// Line 134:                         s.Log().WithField(\"error\", err).",
                "// Line 135:                             WithField(\"from_path\", pf).",
                "// Line 136:                             WithField(\"to_path\", pt).",
                "// Line 137:                             Warn(\"failed to rename: source or target does not exist\")",
                "// Line 138:                         return nil",
                "// vulnerable line: 139: }",
                "// Line 140:                     return err",
                "// vulnerable line: 141: }",
                "// Line 142:                 return nil",
                "// vulnerable line: 143: }",
                "// Line 144:         })",
                "// vulnerable line: 145: }",
                "// Line 146: ",
                "// Line 147:     if err := g.Wait(); err != nil {",
                "// Line 148:         if errors.Is(err, os.ErrExist) {",
                "// Line 149:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 150:                 \"error\": \"Cannot move or rename file, destination already exists.\",",
                "// Line 151:             })",
                "// vulnerable line: 152: return",
                "// vulnerable line: 153: }",
                "// Line 154: ",
                "// vulnerable line: 155: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 156: return",
                "// vulnerable line: 157: }",
                "// Line 158: ",
                "// Line 159:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 160: }",
                "// Line 161: ",
                "// Line 162: // Copies a server file.",
                "// Line 163: func postServerCopyFile(c *gin.Context) {",
                "// Line 164:     s := ExtractServer(c)",
                "// Line 165: ",
                "// Line 166:     var data struct {",
                "// Line 167:         Location string `json:\"location\"`",
                "// vulnerable line: 168: }",
                "// Line 169:     // BindJSON sends 400 if the request fails, all we need to do is return",
                "// Line 170:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 171: return",
                "// vulnerable line: 172: }",
                "// Line 173: ",
                "// Line 174:     if err := s.Filesystem().IsIgnored(data.Location); err != nil {",
                "// vulnerable line: 175: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 176: return",
                "// vulnerable line: 177: }",
                "// Line 178:     if err := s.Filesystem().Copy(data.Location); err != nil {",
                "// vulnerable line: 179: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 180: return",
                "// vulnerable line: 181: }",
                "// Line 182: ",
                "// Line 183:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 184: }",
                "// Line 185: ",
                "// Line 186: // Deletes files from a server.",
                "// Line 187: func postServerDeleteFiles(c *gin.Context) {",
                "// Line 188:     s := ExtractServer(c)",
                "// Line 189: ",
                "// Line 190:     var data struct {",
                "// Line 191:         Root  string   `json:\"root\"`",
                "// Line 192:         Files []string `json:\"files\"`",
                "// vulnerable line: 193: }",
                "// Line 194: ",
                "// Line 195:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 196: return",
                "// vulnerable line: 197: }",
                "// Line 198: ",
                "// Line 199:     if len(data.Files) == 0 {",
                "// Line 200:         c.AbortWithStatusJSON(http.StatusUnprocessableEntity, gin.H{",
                "// Line 201:             \"error\": \"No files were specified for deletion.\",",
                "// Line 202:         })",
                "// vulnerable line: 203: return",
                "// vulnerable line: 204: }",
                "// Line 205: ",
                "// Line 206:     g, ctx := errgroup.WithContext(context.Background())",
                "// Line 207: ",
                "// Line 208:     // Loop over the array of files passed in and delete them. If any of the file deletions",
                "// Line 209:     // fail just abort the process entirely.",
                "// Line 210:     for _, p := range data.Files {",
                "// Line 211:         pi := path.Join(data.Root, p)",
                "// Line 212: ",
                "// Line 213:         g.Go(func() error {",
                "// Line 214:             select {",
                "// Line 215:             case <-ctx.Done():",
                "// Line 216:                 return ctx.Err()",
                "// Line 217:             default:",
                "// Line 218:                 return s.Filesystem().Delete(pi)",
                "// vulnerable line: 219: }",
                "// Line 220:         })",
                "// vulnerable line: 221: }",
                "// Line 222: ",
                "// Line 223:     if err := g.Wait(); err != nil {",
                "// vulnerable line: 224: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 225: return",
                "// vulnerable line: 226: }",
                "// Line 227: ",
                "// Line 228:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 229: }",
                "// Line 230: ",
                "// Line 231: // Writes the contents of the request to a file on a server.",
                "// Line 232: func postServerWriteFile(c *gin.Context) {",
                "// Line 233:     s := ExtractServer(c)",
                "// Line 234: ",
                "// Line 235:     f := c.Query(\"file\")",
                "// Line 236:     f = \"/\" + strings.TrimLeft(f, \"/\")",
                "// Line 237: ",
                "// Line 238:     if err := s.Filesystem().IsIgnored(f); err != nil {",
                "// vulnerable line: 239: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 240: return",
                "// vulnerable line: 241: }",
                "// vulnerable line: 242: if err := s.Filesystem().Writefile(f, c.Request.Body); err != nil {",
                "// Line 243:         if filesystem.IsErrorCode(err, filesystem.ErrCodeIsDirectory) {",
                "// Line 244:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 245:                 \"error\": \"Cannot write file, name conflicts with an existing directory by the same name.\",",
                "// Line 246:             })",
                "// vulnerable line: 247: return",
                "// vulnerable line: 248: }",
                "// Line 249: ",
                "// vulnerable line: 250: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 251: return",
                "// vulnerable line: 252: }",
                "// Line 253: ",
                "// Line 254:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 255: }",
                "// Line 256: ",
                "// Line 257: // Returns all of the currently in-progress file downloads and their current download",
                "// Line 258: // progress. The progress is also pushed out via a websocket event allowing you to just",
                "// Line 259: // call this once to get current downloads, and then listen to targeted websocket events",
                "// Line 260: // with the current progress for everything.",
                "// Line 261: func getServerPullingFiles(c *gin.Context) {",
                "// Line 262:     s := ExtractServer(c)",
                "// Line 263:     c.JSON(http.StatusOK, gin.H{",
                "// Line 264:         \"downloads\": downloader.ByServer(s.ID()),",
                "// Line 265:     })",
                "// vulnerable line: 266: }",
                "// Line 267: ",
                "// Line 268: // Writes the contents of the remote URL to a file on a server.",
                "// Line 269: func postServerPullRemoteFile(c *gin.Context) {",
                "// Line 270:     s := ExtractServer(c)",
                "// Line 271:     var data struct {",
                "// Line 272:         // Deprecated",
                "// Line 273:         Directory  string `binding:\"required_without=RootPath,omitempty\" json:\"directory\"`",
                "// Line 274:         RootPath   string `binding:\"required_without=Directory,omitempty\" json:\"root\"`",
                "// Line 275:         URL        string `binding:\"required\" json:\"url\"`",
                "// Line 276:         FileName   string `json:\"file_name\"`",
                "// Line 277:         UseHeader  bool   `json:\"use_header\"`",
                "// Line 278:         Foreground bool   `json:\"foreground\"`",
                "// vulnerable line: 279: }",
                "// Line 280:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 281: return",
                "// vulnerable line: 282: }",
                "// Line 283: ",
                "// Line 284:     // Handle the deprecated Directory field in the struct until it is removed.",
                "// Line 285:     if data.Directory != \"\" && data.RootPath == \"\" {",
                "// Line 286:         data.RootPath = data.Directory",
                "// vulnerable line: 287: }",
                "// Line 288: ",
                "// Line 289:     u, err := url.Parse(data.URL)",
                "// vulnerable line: 290: if err != nil {",
                "// Line 291:         if e, ok := err.(*url.Error); ok {",
                "// Line 292:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 293:                 \"error\": \"An error occurred while parsing that URL: \" + e.Err.Error(),",
                "// Line 294:             })",
                "// vulnerable line: 295: return",
                "// vulnerable line: 296: }",
                "// vulnerable line: 297: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 298: return",
                "// vulnerable line: 299: }",
                "// Line 300: ",
                "// Line 301:     if err := s.Filesystem().HasSpaceErr(true); err != nil {",
                "// vulnerable line: 302: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 303: return",
                "// vulnerable line: 304: }",
                "// Line 305:     // Do not allow more than three simultaneous remote file downloads at one time.",
                "// Line 306:     if len(downloader.ByServer(s.ID())) >= 3 {",
                "// Line 307:         c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 308:             \"error\": \"This server has reached its limit of 3 simultaneous remote file downloads at once. Please wait for one to complete before trying again.\",",
                "// Line 309:         })",
                "// vulnerable line: 310: return",
                "// vulnerable line: 311: }",
                "// Line 312: ",
                "// Line 313:     dl := downloader.New(s, downloader.DownloadRequest{",
                "// Line 314:         Directory: data.RootPath,",
                "// Line 315:         URL:       u,",
                "// Line 316:         FileName:  data.FileName,",
                "// Line 317:         UseHeader: data.UseHeader,",
                "// Line 318:     })",
                "// Line 319: ",
                "// Line 320:     download := func() error {",
                "// Line 321:         s.Log().WithField(\"download_id\", dl.Identifier).WithField(\"url\", u.String()).Info(\"starting pull of remote file to disk\")",
                "// Line 322:         if err := dl.Execute(); err != nil {",
                "// Line 323:             s.Log().WithField(\"download_id\", dl.Identifier).WithField(\"error\", err).Error(\"failed to pull remote file\")",
                "// Line 324:             return err",
                "// Line 325:         } else {",
                "// Line 326:             s.Log().WithField(\"download_id\", dl.Identifier).Info(\"completed pull of remote file\")",
                "// vulnerable line: 327: }",
                "// Line 328:         return nil",
                "// vulnerable line: 329: }",
                "// Line 330:     if !data.Foreground {",
                "// Line 331:         go func() {",
                "// Line 332:             _ = download()",
                "// Line 333:         }()",
                "// Line 334:         c.JSON(http.StatusAccepted, gin.H{",
                "// Line 335:             \"identifier\": dl.Identifier,",
                "// Line 336:         })",
                "// vulnerable line: 337: return",
                "// vulnerable line: 338: }",
                "// Line 339: ",
                "// Line 340:     if err := download(); err != nil {",
                "// vulnerable line: 341: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 342: return",
                "// vulnerable line: 343: }",
                "// Line 344: ",
                "// Line 345:     st, err := s.Filesystem().Stat(dl.Path())",
                "// vulnerable line: 346: if err != nil {",
                "// vulnerable line: 347: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 348: return",
                "// vulnerable line: 349: }",
                "// Line 350:     c.JSON(http.StatusOK, &st)",
                "// vulnerable line: 351: }",
                "// Line 352: ",
                "// Line 353: // Stops a remote file download if it exists and belongs to this server.",
                "// Line 354: func deleteServerPullRemoteFile(c *gin.Context) {",
                "// Line 355:     s := ExtractServer(c)",
                "// Line 356:     if dl := downloader.ByID(c.Param(\"download\")); dl != nil && dl.BelongsTo(s) {",
                "// Line 357:         dl.Cancel()",
                "// vulnerable line: 358: }",
                "// Line 359:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 360: }",
                "// Line 361: ",
                "// Line 362: // Create a directory on a server.",
                "// Line 363: func postServerCreateDirectory(c *gin.Context) {",
                "// Line 364:     s := ExtractServer(c)",
                "// Line 365: ",
                "// Line 366:     var data struct {",
                "// Line 367:         Name string `json:\"name\"`",
                "// Line 368:         Path string `json:\"path\"`",
                "// vulnerable line: 369: }",
                "// Line 370:     // BindJSON sends 400 if the request fails, all we need to do is return",
                "// Line 371:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 372: return",
                "// vulnerable line: 373: }",
                "// Line 374: ",
                "// Line 375:     if err := s.Filesystem().CreateDirectory(data.Name, data.Path); err != nil {",
                "// Line 376:         if err.Error() == \"not a directory\" {",
                "// Line 377:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 378:                 \"error\": \"Part of the path being created is not a directory (ENOTDIR).\",",
                "// Line 379:             })",
                "// vulnerable line: 380: return",
                "// vulnerable line: 381: }",
                "// Line 382: ",
                "// vulnerable line: 383: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 384: return",
                "// vulnerable line: 385: }",
                "// Line 386: ",
                "// Line 387:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 388: }",
                "// Line 389: ",
                "// Line 390: func postServerCompressFiles(c *gin.Context) {",
                "// Line 391:     s := ExtractServer(c)",
                "// Line 392: ",
                "// Line 393:     var data struct {",
                "// Line 394:         RootPath string   `json:\"root\"`",
                "// Line 395:         Files    []string `json:\"files\"`",
                "// vulnerable line: 396: }",
                "// Line 397: ",
                "// Line 398:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 399: return",
                "// vulnerable line: 400: }",
                "// Line 401: ",
                "// Line 402:     if len(data.Files) == 0 {",
                "// Line 403:         c.AbortWithStatusJSON(http.StatusUnprocessableEntity, gin.H{",
                "// Line 404:             \"error\": \"No files were passed through to be compressed.\",",
                "// Line 405:         })",
                "// vulnerable line: 406: return",
                "// vulnerable line: 407: }",
                "// Line 408: ",
                "// Line 409:     if !s.Filesystem().HasSpaceAvailable(true) {",
                "// Line 410:         c.AbortWithStatusJSON(http.StatusConflict, gin.H{",
                "// Line 411:             \"error\": \"This server does not have enough available disk space to generate a compressed archive.\",",
                "// Line 412:         })",
                "// vulnerable line: 413: return",
                "// vulnerable line: 414: }",
                "// Line 415: ",
                "// Line 416:     f, err := s.Filesystem().CompressFiles(data.RootPath, data.Files)",
                "// vulnerable line: 417: if err != nil {",
                "// vulnerable line: 418: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 419: return",
                "// vulnerable line: 420: }",
                "// Line 421: ",
                "// Line 422:     c.JSON(http.StatusOK, &filesystem.Stat{",
                "// Line 423:         FileInfo: f,",
                "// Line 424:         Mimetype: \"application/tar+gzip\",",
                "// Line 425:     })",
                "// vulnerable line: 426: }",
                "// Line 427: ",
                "// Line 428: // postServerDecompressFiles receives the HTTP request and starts the process",
                "// Line 429: // of unpacking an archive that exists on the server into the provided RootPath",
                "// Line 430: // for the server.",
                "// Line 431: func postServerDecompressFiles(c *gin.Context) {",
                "// Line 432:     var data struct {",
                "// Line 433:         RootPath string `json:\"root\"`",
                "// Line 434:         File     string `json:\"file\"`",
                "// vulnerable line: 435: }",
                "// Line 436:     if err := c.BindJSON(&data); err != nil {",
                "// vulnerable line: 437: return",
                "// vulnerable line: 438: }",
                "// Line 439: ",
                "// Line 440:     s := middleware.ExtractServer(c)",
                "// Line 441:     lg := middleware.ExtractLogger(c).WithFields(log.Fields{\"root_path\": data.RootPath, \"file\": data.File})",
                "// Line 442:     lg.Debug(\"checking if space is available for file decompression\")",
                "// Line 443:     err := s.Filesystem().SpaceAvailableForDecompression(context.Background(), data.RootPath, data.File)",
                "// vulnerable line: 444: if err != nil {",
                "// Line 445:         if filesystem.IsErrorCode(err, filesystem.ErrCodeUnknownArchive) {",
                "// Line 446:             lg.WithField(\"error\", err).Warn(\"failed to decompress file: unknown archive format\")",
                "// Line 447:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{\"error\": \"The archive provided is in a format Wings does not understand.\"})",
                "// vulnerable line: 448: return",
                "// vulnerable line: 449: }",
                "// vulnerable line: 450: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 451: return",
                "// vulnerable line: 452: }",
                "// Line 453: ",
                "// Line 454:     lg.Info(\"starting file decompression\")",
                "// Line 455:     if err := s.Filesystem().DecompressFile(context.Background(), data.RootPath, data.File); err != nil {",
                "// Line 456:         // If the file is busy for some reason just return a nicer error to the user since there is not",
                "// Line 457:         // much we specifically can do. They'll need to stop the running server process in order to overwrite",
                "// Line 458:         // a file like this.",
                "// Line 459:         if strings.Contains(err.Error(), \"text file busy\") {",
                "// Line 460:             lg.WithField(\"error\", errors.WithStackIf(err)).Warn(\"failed to decompress file: text file busy\")",
                "// Line 461:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 462:                 \"error\": \"One or more files this archive is attempting to overwrite are currently in use by another process. Please try again.\",",
                "// Line 463:             })",
                "// vulnerable line: 464: return",
                "// vulnerable line: 465: }",
                "// vulnerable line: 466: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 467: return",
                "// vulnerable line: 468: }",
                "// Line 469:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 470: }",
                "// Line 471: ",
                "// Line 472: type chmodFile struct {",
                "// Line 473:     File string `json:\"file\"`",
                "// Line 474:     Mode string `json:\"mode\"`",
                "// vulnerable line: 475: }",
                "// Line 476: ",
                "// Line 477: var errInvalidFileMode = errors.New(\"invalid file mode\")",
                "// Line 478: ",
                "// Line 479: func postServerChmodFile(c *gin.Context) {",
                "// Line 480:     s := ExtractServer(c)",
                "// Line 481: ",
                "// Line 482:     var data struct {",
                "// Line 483:         Root  string      `json:\"root\"`",
                "// Line 484:         Files []chmodFile `json:\"files\"`",
                "// vulnerable line: 485: }",
                "// Line 486: ",
                "// Line 487:     if err := c.BindJSON(&data); err != nil {",
                "// Line 488:         log.Debug(err.Error())",
                "// vulnerable line: 489: return",
                "// vulnerable line: 490: }",
                "// Line 491: ",
                "// Line 492:     if len(data.Files) == 0 {",
                "// Line 493:         c.AbortWithStatusJSON(http.StatusUnprocessableEntity, gin.H{",
                "// Line 494:             \"error\": \"No files to chmod were provided.\",",
                "// Line 495:         })",
                "// vulnerable line: 496: return",
                "// vulnerable line: 497: }",
                "// Line 498: ",
                "// Line 499:     g, ctx := errgroup.WithContext(context.Background())",
                "// Line 500: ",
                "// Line 501:     // Loop over the array of files passed in and perform the move or rename action against each.",
                "// Line 502:     for _, p := range data.Files {",
                "// Line 503:         g.Go(func() error {",
                "// Line 504:             select {",
                "// Line 505:             case <-ctx.Done():",
                "// Line 506:                 return ctx.Err()",
                "// Line 507:             default:",
                "// Line 508:                 mode, err := strconv.ParseUint(p.Mode, 8, 32)",
                "// vulnerable line: 509: if err != nil {",
                "// Line 510:                     return errInvalidFileMode",
                "// vulnerable line: 511: }",
                "// Line 512: ",
                "// Line 513:                 if err := s.Filesystem().Chmod(path.Join(data.Root, p.File), os.FileMode(mode)); err != nil {",
                "// Line 514:                     // Return nil if the error is an is not exists.",
                "// vulnerable line: 515: // NOTE: os.IsNotExist() does not work if the error is wrapped.",
                "// Line 516:                     if errors.Is(err, os.ErrNotExist) {",
                "// Line 517:                         return nil",
                "// vulnerable line: 518: }",
                "// Line 519: ",
                "// Line 520:                     return err",
                "// vulnerable line: 521: }",
                "// Line 522: ",
                "// Line 523:                 return nil",
                "// vulnerable line: 524: }",
                "// Line 525:         })",
                "// vulnerable line: 526: }",
                "// Line 527: ",
                "// Line 528:     if err := g.Wait(); err != nil {",
                "// Line 529:         if errors.Is(err, errInvalidFileMode) {",
                "// Line 530:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 531:                 \"error\": \"Invalid file mode.\",",
                "// Line 532:             })",
                "// vulnerable line: 533: return",
                "// vulnerable line: 534: }",
                "// Line 535: ",
                "// vulnerable line: 536: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 537: return",
                "// vulnerable line: 538: }",
                "// Line 539: ",
                "// Line 540:     c.Status(http.StatusNoContent)",
                "// vulnerable line: 541: }",
                "// Line 542: ",
                "// Line 543: func postServerUploadFiles(c *gin.Context) {",
                "// Line 544:     manager := middleware.ExtractManager(c)",
                "// Line 545: ",
                "// Line 546:     token := tokens.UploadPayload{}",
                "// Line 547:     if err := tokens.ParseToken([]byte(c.Query(\"token\")), &token); err != nil {",
                "// vulnerable line: 548: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 549: return",
                "// vulnerable line: 550: }",
                "// Line 551: ",
                "// Line 552:     s, ok := manager.Get(token.ServerUuid)",
                "// Line 553:     if !ok || !token.IsUniqueRequest() {",
                "// Line 554:         c.AbortWithStatusJSON(http.StatusNotFound, gin.H{",
                "// Line 555:             \"error\": \"The requested resource was not found on this server.\",",
                "// Line 556:         })",
                "// vulnerable line: 557: return",
                "// vulnerable line: 558: }",
                "// Line 559: ",
                "// Line 560:     form, err := c.MultipartForm()",
                "// vulnerable line: 561: if err != nil {",
                "// Line 562:         c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 563:             \"error\": \"Failed to get multipart form data from request.\",",
                "// Line 564:         })",
                "// vulnerable line: 565: return",
                "// vulnerable line: 566: }",
                "// Line 567: ",
                "// Line 568:     headers, ok := form.File[\"files\"]",
                "// Line 569:     if !ok {",
                "// Line 570:         c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 571:             \"error\": \"No files were found on the request body.\",",
                "// Line 572:         })",
                "// vulnerable line: 573: return",
                "// vulnerable line: 574: }",
                "// Line 575: ",
                "// Line 576:     directory := c.Query(\"directory\")",
                "// Line 577: ",
                "// Line 578:     maxFileSize := config.Get().Api.UploadLimit",
                "// Line 579:     maxFileSizeBytes := maxFileSize * 1024 * 1024",
                "// Line 580:     var totalSize int64",
                "// Line 581:     for _, header := range headers {",
                "// Line 582:         if header.Size > maxFileSizeBytes {",
                "// Line 583:             c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{",
                "// Line 584:                 \"error\": \"File \" + header.Filename + \" is larger than the maximum file upload size of \" + strconv.FormatInt(maxFileSize, 10) + \" MB.\",",
                "// Line 585:             })",
                "// vulnerable line: 586: return",
                "// vulnerable line: 587: }",
                "// Line 588:         totalSize += header.Size",
                "// vulnerable line: 589: }",
                "// Line 590: ",
                "// Line 591:     for _, header := range headers {",
                "// vulnerable line: 592: p, err := s.Filesystem().SafePath(filepath.Join(directory, header.Filename))",
                "// vulnerable line: 593: if err != nil {",
                "// vulnerable line: 594: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 595: return",
                "// vulnerable line: 596: }",
                "// Line 597: ",
                "// Line 598:         // We run this in a different method so I can use defer without any of",
                "// Line 599:         // the consequences caused by calling it in a loop.",
                "// vulnerable line: 600: if err := handleFileUpload(p, s, header); err != nil {",
                "// vulnerable line: 601: middleware.CaptureAndAbort(c, err)",
                "// vulnerable line: 602: return",
                "// Line 603:         } else {",
                "// Line 604:             s.SaveActivity(s.NewRequestActivity(token.UserUuid, c.ClientIP()), server.ActivityFileUploaded, models.ActivityMeta{",
                "// Line 605:                 \"file\":      header.Filename,",
                "// Line 606:                 \"directory\": filepath.Clean(directory),",
                "// Line 607:             })",
                "// vulnerable line: 608: }",
                "// vulnerable line: 609: }",
                "// vulnerable line: 610: }",
                "// Line 611: ",
                "// Line 612: func handleFileUpload(p string, s *server.Server, header *multipart.FileHeader) error {",
                "// Line 613:     file, err := header.Open()",
                "// vulnerable line: 614: if err != nil {",
                "// Line 615:         return err",
                "// vulnerable line: 616: }",
                "// Line 617:     defer file.Close()",
                "// Line 618: ",
                "// Line 619:     if err := s.Filesystem().IsIgnored(p); err != nil {",
                "// Line 620:         return err",
                "// vulnerable line: 621: }",
                "// vulnerable line: 622: if err := s.Filesystem().Writefile(p, file); err != nil {",
                "// Line 623:         return err",
                "// vulnerable line: 624: }",
                "// Line 625:     return nil",
                "// vulnerable line: 626: }"
            ]
        },
        {
            "filename_of_changes": "router_transfer.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "stat.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "28",
            "number_of_lines_deleted_vulnerable_to_cve": "21",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package filesystem",
                "// Line 2: ",
                "// Line 3: import (",
                "// vulnerable line: 4: \"os\"",
                "// Line 5:     \"strconv\"",
                "// Line 6:     \"time\"",
                "// Line 7: ",
                "// Line 8:     \"github.com/gabriel-vasile/mimetype\"",
                "// vulnerable line: 9: \"github.com/goccy/go-json\"",
                "// Line 10: )",
                "// Line 11: ",
                "// Line 12: type Stat struct {",
                "// vulnerable line: 13: os.FileInfo",
                "// Line 14:     Mimetype string",
                "// vulnerable line: 15: }",
                "// Line 16: ",
                "// Line 17: func (s *Stat) MarshalJSON() ([]byte, error) {",
                "// Line 18:     return json.Marshal(struct {",
                "// Line 19:         Name      string `json:\"name\"`",
                "// Line 20:         Created   string `json:\"created\"`",
                "// Line 21:         Modified  string `json:\"modified\"`",
                "// Line 22:         Mode      string `json:\"mode\"`",
                "// Line 23:         ModeBits  string `json:\"mode_bits\"`",
                "// Line 24:         Size      int64  `json:\"size\"`",
                "// Line 25:         Directory bool   `json:\"directory\"`",
                "// Line 26:         File      bool   `json:\"file\"`",
                "// Line 27:         Symlink   bool   `json:\"symlink\"`",
                "// Line 28:         Mime      string `json:\"mime\"`",
                "// Line 29:     }{",
                "// Line 30:         Name:     s.Name(),",
                "// Line 31:         Created:  s.CTime().Format(time.RFC3339),",
                "// Line 32:         Modified: s.ModTime().Format(time.RFC3339),",
                "// Line 33:         Mode:     s.Mode().String(),",
                "// vulnerable line: 34: // Using `&os.ModePerm` on the file's mode will cause the mode to only have the permission values, and nothing else.",
                "// vulnerable line: 35: ModeBits:  strconv.FormatUint(uint64(s.Mode()&os.ModePerm), 8),",
                "// Line 36:         Size:      s.Size(),",
                "// Line 37:         Directory: s.IsDir(),",
                "// Line 38:         File:      !s.IsDir(),",
                "// vulnerable line: 39: Symlink:   s.Mode().Perm()&os.ModeSymlink != 0,",
                "// Line 40:         Mime:      s.Mimetype,",
                "// Line 41:     })",
                "// vulnerable line: 42: }",
                "// Line 43: ",
                "// vulnerable line: 44: // Stat stats a file or folder and returns the base stat object from go along",
                "// vulnerable line: 45: // with the MIME data that can be used for editing files.",
                "// vulnerable line: 46: func (fs *Filesystem) Stat(p string) (Stat, error) {",
                "// vulnerable line: 47: cleaned, err := fs.SafePath(p)",
                "// vulnerable line: 48: if err != nil {",
                "// vulnerable line: 49: return Stat{}, err",
                "// vulnerable line: 50: }",
                "// vulnerable line: 51: return fs.unsafeStat(cleaned)",
                "// vulnerable line: 52: }",
                "// Line 53: ",
                "// vulnerable line: 54: func (fs *Filesystem) unsafeStat(p string) (Stat, error) {",
                "// vulnerable line: 55: s, err := os.Stat(p)",
                "// vulnerable line: 56: if err != nil {",
                "// vulnerable line: 57: return Stat{}, err",
                "// vulnerable line: 58: }",
                "// Line 59: ",
                "// Line 60:     var m *mimetype.MIME",
                "// Line 61:     if !s.IsDir() {",
                "// vulnerable line: 62: m, err = mimetype.DetectFile(p)",
                "// vulnerable line: 63: if err != nil {",
                "// vulnerable line: 64: return Stat{}, err",
                "// vulnerable line: 65: }",
                "// vulnerable line: 66: }",
                "// Line 67: ",
                "// Line 68:     st := Stat{",
                "// Line 69:         FileInfo: s,",
                "// Line 70:         Mimetype: \"inode/directory\",",
                "// vulnerable line: 71: }",
                "// Line 72:     if m != nil {",
                "// Line 73:         st.Mimetype = m.String()",
                "// vulnerable line: 74: }",
                "// Line 75: ",
                "// Line 76:     return st, nil",
                "// vulnerable line: 77: }"
            ]
        },
        {
            "filename_of_changes": "stat_linux.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "15",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package filesystem",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"syscall\"",
                "// Line 5:     \"time\"",
                "// Line 6: )",
                "// Line 7: ",
                "// vulnerable line: 8: // Returns the time that the file/folder was created.",
                "// Line 9: func (s *Stat) CTime() time.Time {",
                "// vulnerable line: 10: st := s.Sys().(*syscall.Stat_t)",
                "// Line 11: ",
                "// vulnerable line: 12: // Do not remove these \"redundant\" type-casts, they are required for 32-bit builds to work.",
                "// vulnerable line: 13: return time.Unix(int64(st.Ctim.Sec), int64(st.Ctim.Nsec))",
                "// Line 14: }"
            ]
        }
    ]
}