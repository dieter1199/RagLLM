{
    "cve_id": "CVE-2024-35183",
    "cve_description": "wolfictl is a command line tool for working with Wolfi. A git authentication issue in versions prior to 0.16.10 allows a local userâ€™s GitHub token to be sent to remote servers other than `github.com`. Most git-dependent functionality in wolfictl relies on its own `git` package, which contains centralized logic for implementing interactions with git repositories. Some of this functionality requires authentication in order to access private repositories. A central function `GetGitAuth` looks for a GitHub token in the environment variable `GITHUB_TOKEN` and returns it as an HTTP basic auth object to be used with the `github.com/go-git/go-git/v5` library. Most callers (direct or indirect) of `GetGitAuth` use the token to authenticate to github.com only; however, in some cases callers were passing this authentication without checking that the remote git repository was hosted on github.com. This behavior has existed in one form or another since commit 0d06e1578300327c212dda26a5ab31d09352b9d0 - committed January 25, 2023. This impacts anyone who ran the `wolfictl check update` commands with a Melange configuration that included a `git-checkout` directive step that referenced a git repository not hosted on github.com. This also impacts anyone who ran `wolfictl update <url>` with a remote URL outside of github.com. Additionally, these subcommands must have run with the `GITHUB_TOKEN` environment variable set to a valid GitHub token. Users should upgrade to version 0.16.10 to receive a patch.",
    "cve_publish_date": "2024-05-15T22:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Git based commands, only use GITHUB_TOKEN when interacting with GitHub's API\n\nThis change also removes the submodules git update as this is not used anymore, therefore does not need updating with the new GetGitAuth signature.\n\nSigned-off-by: James Rawlings <jrawlings@chainguard.dev>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "cleanup.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 39:     if err != nil {",
                "// Line 40:         return err",
                "// Line 41:     }",
                "// Line 42: ",
                "// Line 43:     cloneOpts := &git.CloneOptions{",
                "// Line 44:         URL:               repoValue,",
                "// Line 45:         ReferenceName:     plumbing.ReferenceName(fmt.Sprintf(\"refs/tags/%s\", evaluatedTag)),",
                "// Line 46:         Progress:          os.Stdout,",
                "// Line 47:         RecurseSubmodules: git.NoRecurseSubmodules,",
                "// Line 48:         Depth:             1,",
                "// vulnerable line: 49: Auth:              wgit.GetGitAuth(),",
                "// Line 50:     }",
                "// Line 51: ",
                "// Line 52:     log.Printf(\"cloning sources from %s tag %s into a temporary directory '%s', this may take a while\", repoValue, dir, evaluatedTag)",
                "// Line 53: ",
                "// Line 54:     maxRetries := 3",
                "// Line 55:     r := &git.Repository{}",
                "// Line 56:     for attempt := 0; attempt < maxRetries; attempt++ {",
                "// Line 57:         r, err = git.PlainClone(dir, false, cloneOpts)",
                "// Line 58:         if err == nil {",
                "// Line 59:             break"
            ]
        },
        {
            "filename_of_changes": "data_session.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 47:     ds := &DataSession{",
                "// Line 48:         tempDir: tempDir,",
                "// Line 49:         distro:  opts.Distro,",
                "// Line 50:     }",
                "// Line 51: ",
                "// Line 52:     ds.githubClient = opts.GitHubClient",
                "// Line 53: ",
                "// Line 54:     // clone advisories repo",
                "// Line 55:     repo, err := git.PlainCloneContext(ctx, tempDir, false, &git.CloneOptions{",
                "// Line 56:         URL:  opts.Distro.Absolute.AdvisoriesHTTPSCloneURL(),",
                "// vulnerable line: 57: Auth: wgit.GetGitAuth(),",
                "// Line 58:     })",
                "// Line 59:     if err != nil {",
                "// Line 60:         return nil, fmt.Errorf(\"cloning advisories repo: %w\", err)",
                "// Line 61:     }",
                "// Line 62:     ds.repo = repo",
                "// Line 63: ",
                "// Line 64:     // checkout a new branch",
                "// Line 65:     u := uuid.New()",
                "// Line 66:     branchName := fmt.Sprintf(\"wolfictl-data-session-%s\", u)",
                "// Line 67:     ds.workingBranch = branchName",
                "// Line 161: ",
                "// Line 162: // Modified returns true if any changes have been made to the advisory data",
                "// Line 163: // during the session.",
                "// Line 164: func (ds DataSession) Modified() bool {",
                "// Line 165:     return ds.modified",
                "// Line 166: }",
                "// Line 167: ",
                "// Line 168: // Push pushes the changes made during the session to the remote advisories",
                "// Line 169: // repository.",
                "// Line 170: func (ds DataSession) Push(ctx context.Context) error {",
                "// vulnerable line: 171: err := ds.repo.PushContext(ctx, &git.PushOptions{",
                "// Line 172:         RemoteURL: ds.distro.Absolute.AdvisoriesHTTPSCloneURL(),",
                "// vulnerable line: 173: Auth:      wgit.GetGitAuth(),",
                "// Line 174:     })",
                "// Line 175:     if err != nil {",
                "// Line 176:         return fmt.Errorf(\"pushing changes: %w\", err)",
                "// Line 177:     }",
                "// Line 178: ",
                "// Line 179:     return nil",
                "// Line 180: }",
                "// Line 181: ",
                "// Line 182: // OpenPullRequest opens a pull request for the changes made during the session.",
                "// Line 183: func (ds DataSession) OpenPullRequest(ctx context.Context) (*PullRequest, error) {"
            ]
        },
        {
            "filename_of_changes": "git.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "23",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 12:     \"github.com/go-git/go-git/v5/plumbing/object\"",
                "// Line 13:     \"github.com/go-git/go-git/v5/plumbing/storer\"",
                "// Line 14:     \"github.com/go-git/go-git/v5/plumbing/transport\"",
                "// Line 15: ",
                "// Line 16:     \"github.com/go-git/go-git/v5\"",
                "// Line 17:     \"github.com/wolfi-dev/wolfictl/pkg/stringhelpers\"",
                "// Line 18: ",
                "// Line 19:     gitHttp \"github.com/go-git/go-git/v5/plumbing/transport/http\"",
                "// Line 20: )",
                "// Line 21: ",
                "// vulnerable line: 22: func GetGitAuth() *gitHttp.BasicAuth {",
                "// Line 23:     gitToken := os.Getenv(\"GITHUB_TOKEN\")",
                "// Line 24: ",
                "// Line 25:     if gitToken == \"\" {",
                "// Line 26:         // If the token is empty, there's no way we can return a usable authentication",
                "// Line 27:         // anyway. Whereas if we return nil, and don't auth, we have a chance at",
                "// Line 28:         // succeeding with access of a public repo.",
                "// vulnerable line: 29: return nil",
                "// vulnerable line: 30: }",
                "// Line 31: ",
                "// Line 32:     return &gitHttp.BasicAuth{",
                "// Line 33:         Username: \"abc123\",",
                "// Line 34:         Password: gitToken,",
                "// vulnerable line: 35: }",
                "// vulnerable line: 36: }",
                "// Line 37: ",
                "// Line 38: type URL struct {",
                "// Line 39:     Scheme       string",
                "// Line 40:     Host         string",
                "// Line 41:     Organisation string",
                "// Line 42:     Name         string",
                "// Line 43:     RawURL       string",
                "// vulnerable line: 44: }",
                "// Line 45: ",
                "// Line 46: func GetRemoteURLFromDir(dir string) (*URL, error) {",
                "// Line 47:     r, err := git.PlainOpen(dir)",
                "// Line 48:     if err != nil {",
                "// Line 49:         return nil, err",
                "// vulnerable line: 50: }",
                "// Line 51:     return GetRemoteURL(r)",
                "// vulnerable line: 52: }",
                "// Line 53: ",
                "// Line 54: func GetRemoteURL(repo *git.Repository) (*URL, error) {",
                "// Line 55:     remote, err := repo.Remote(\"origin\")",
                "// Line 56:     if err != nil {",
                "// Line 57:         return nil, fmt.Errorf(\"failed to find git origin URL: %w\", err)",
                "// vulnerable line: 58: }",
                "// Line 59: ",
                "// Line 60:     if len(remote.Config().URLs) == 0 {",
                "// Line 61:         return nil, fmt.Errorf(\"no remote config URLs found for remote origin\")",
                "// vulnerable line: 62: }",
                "// Line 63: ",
                "// Line 64:     return ParseGitURL(remote.Config().URLs[0])",
                "// vulnerable line: 65: }",
                "// Line 66: ",
                "// Line 67: // ParseGitURL returns owner, repo name, errors",
                "// Line 68: func ParseGitURL(rawURL string) (*URL, error) {",
                "// Line 69:     if rawURL == \"\" {",
                "// Line 70:         return nil, fmt.Errorf(\"no URL provided\")",
                "// vulnerable line: 71: }",
                "// Line 72: ",
                "// Line 73:     gitURL := &URL{}",
                "// Line 74: ",
                "// Line 75:     rawURL = strings.TrimSuffix(rawURL, \".git\")",
                "// Line 76: ",
                "// Line 77:     // handle git@ kinds of URIs",
                "// Line 78:     if strings.HasPrefix(rawURL, \"git@\") {",
                "// Line 79:         t := strings.TrimPrefix(rawURL, \"git@\")",
                "// Line 80:         t = strings.TrimPrefix(t, \"/\")",
                "// Line 81:         t = strings.TrimPrefix(t, \"/\")",
                "// Line 82:         t = strings.TrimSuffix(t, \"/\")",
                "// Line 83: ",
                "// Line 84:         arr := stringhelpers.RegexpSplit(t, \":|/\")",
                "// Line 85:         if len(arr) >= 3 {",
                "// Line 86:             gitURL.Scheme = \"git\"",
                "// Line 87:             gitURL.Host = arr[0]",
                "// Line 88:             gitURL.Organisation = arr[1]",
                "// Line 89:             gitURL.Name = arr[len(arr)-1]",
                "// Line 90:             gitURL.RawURL = fmt.Sprintf(\"https://%s/%s/%s.git\", gitURL.Host, gitURL.Organisation, gitURL.Name)",
                "// Line 91:             return gitURL, nil",
                "// vulnerable line: 92: }",
                "// vulnerable line: 93: }",
                "// Line 94: ",
                "// Line 95:     parsedURL, err := url.Parse(rawURL)",
                "// Line 96:     if err != nil {",
                "// Line 97:         return gitURL, fmt.Errorf(\"failed to parse git url %s: %w\", rawURL, err)",
                "// vulnerable line: 98: }",
                "// Line 99:     gitURL.Scheme = parsedURL.Scheme",
                "// Line 100:     gitURL.Host = parsedURL.Host",
                "// Line 101:     parts := strings.Split(parsedURL.Path, \"/\")",
                "// Line 102:     gitURL.Organisation = parts[1]",
                "// Line 103:     gitURL.Name = parts[2]",
                "// Line 104:     gitURL.RawURL = rawURL",
                "// Line 105: ",
                "// Line 106:     return gitURL, nil",
                "// vulnerable line: 107: }",
                "// Line 108: ",
                "// Line 109: func GetGitAuthorSignature() *object.Signature {",
                "// Line 110:     gitAuthorName := os.Getenv(\"GIT_AUTHOR_NAME\")",
                "// Line 111:     gitAuthorEmail := os.Getenv(\"GIT_AUTHOR_EMAIL\")",
                "// Line 112:     // override default git config tagger info",
                "// Line 113:     if gitAuthorName != \"\" && gitAuthorEmail != \"\" {",
                "// Line 114:         return &object.Signature{",
                "// Line 115:             Name:  gitAuthorName,",
                "// Line 116:             Email: gitAuthorEmail,",
                "// Line 117:             When:  time.Now(),",
                "// vulnerable line: 118: }",
                "// vulnerable line: 119: }",
                "// vulnerable line: 120: return nil",
                "// vulnerable line: 121: }",
                "// Line 122: ",
                "// Line 123: func SetGitSignOptions(repoPath string) error {",
                "// Line 124:     cmd := exec.Command(\"git\", \"config\", \"--local\", \"commit.gpgsign\", \"true\")",
                "// Line 125:     cmd.Dir = repoPath",
                "// Line 126:     rs, err := cmd.Output()",
                "// Line 127:     if err != nil {",
                "// Line 128:         return fmt.Errorf(\"failed to set git config gpgsign %q: %w\", rs, err)",
                "// vulnerable line: 129: }",
                "// Line 130: ",
                "// Line 131:     cmd = exec.Command(\"git\", \"config\", \"--local\", \"gpg.x509.program\", \"gitsign\")",
                "// Line 132:     cmd.Dir = repoPath",
                "// Line 133:     rs, err = cmd.Output()",
                "// Line 134:     if err != nil {",
                "// Line 135:         return fmt.Errorf(\"failed to set git config gpg.x509.program %q: %w\", rs, err)",
                "// vulnerable line: 136: }",
                "// Line 137: ",
                "// Line 138:     cmd = exec.Command(\"git\", \"config\", \"--local\", \"gpg.format\", \"x509\")",
                "// Line 139:     cmd.Dir = repoPath",
                "// Line 140:     rs, err = cmd.Output()",
                "// Line 141:     if err != nil {",
                "// Line 142:         return fmt.Errorf(\"failed to set git config gpg.format %q: %w\", rs, err)",
                "// vulnerable line: 143: }",
                "// Line 144: ",
                "// Line 145:     gitAuthorName := os.Getenv(\"GIT_AUTHOR_NAME\")",
                "// Line 146:     gitAuthorEmail := os.Getenv(\"GIT_AUTHOR_EMAIL\")",
                "// Line 147:     if gitAuthorName == \"\" || gitAuthorEmail == \"\" {",
                "// Line 148:         return fmt.Errorf(\"missing GIT_AUTHOR_NAME and/or GIT_AUTHOR_EMAIL environment variable, please set\")",
                "// vulnerable line: 149: }",
                "// Line 150: ",
                "// Line 151:     cmd = exec.Command(\"git\", \"config\", \"--local\", \"user.name\", gitAuthorName)",
                "// Line 152:     cmd.Dir = repoPath",
                "// Line 153:     rs, err = cmd.Output()",
                "// Line 154:     if err != nil {",
                "// Line 155:         return fmt.Errorf(\"failed to set git config user.name %q: %w\", rs, err)",
                "// vulnerable line: 156: }",
                "// Line 157: ",
                "// Line 158:     cmd = exec.Command(\"git\", \"config\", \"--local\", \"user.email\", gitAuthorEmail)",
                "// Line 159:     cmd.Dir = repoPath",
                "// Line 160:     rs, err = cmd.Output()",
                "// Line 161:     if err != nil {",
                "// Line 162:         return fmt.Errorf(\"failed to set git config user.email %q: %w\", rs, err)",
                "// vulnerable line: 163: }",
                "// Line 164: ",
                "// vulnerable line: 165: return nil",
                "// vulnerable line: 166: }",
                "// Line 167: ",
                "// Line 168: // TempClone clones the repo using the provided HTTPS URL to a temp directory,",
                "// Line 169: // and returns the path to the temp directory.",
                "// Line 170: //",
                "// Line 171: // If hash is non-empty, the repo will be checked out to that commit hash.",
                "// Line 172: //",
                "// Line 173: // If user authentication is requested, a personal access token will be read in",
                "// Line 174: // from the GITHUB_TOKEN environment variable.",
                "// Line 175: //",
                "// Line 176: // The caller is responsible for cleaning up the temp directory.",
                "// Line 177: func TempClone(gitURL, hash string, useAuth bool) (repoDir string, err error) {",
                "// Line 178:     dir, err := os.MkdirTemp(\"\", \"wolfictl-git-clone-*\")",
                "// Line 179:     if err != nil {",
                "// Line 180:         return dir, fmt.Errorf(\"unable to create temp directory for git clone: %w\", err)",
                "// vulnerable line: 181: }",
                "// Line 182: ",
                "// Line 183:     var auth transport.AuthMethod",
                "// Line 184:     if useAuth {",
                "// vulnerable line: 185: auth = GetGitAuth()",
                "// vulnerable line: 186: }",
                "// Line 187: ",
                "// Line 188:     repo, err := git.PlainClone(dir, false, &git.CloneOptions{",
                "// Line 189:         Auth: auth,",
                "// Line 190:         URL:  gitURL,",
                "// Line 191:     })",
                "// Line 192:     if err != nil {",
                "// Line 193:         return dir, fmt.Errorf(\"unable to clone repo %q to temp directory: %w\", gitURL, err)",
                "// vulnerable line: 194: }",
                "// Line 195: ",
                "// Line 196:     if hash != \"\" {",
                "// Line 197:         w, err := repo.Worktree()",
                "// Line 198:         if err != nil {",
                "// Line 199:             return \"\", fmt.Errorf(\"unable to get worktree for repo %q: %w\", gitURL, err)",
                "// vulnerable line: 200: }",
                "// Line 201:         err = w.Checkout(&git.CheckoutOptions{",
                "// Line 202:             Hash: plumbing.NewHash(hash),",
                "// Line 203:         })",
                "// Line 204:         if err != nil {",
                "// Line 205:             return \"\", fmt.Errorf(\"unable to checkout hash %q for repo %q: %w\", hash, gitURL, err)",
                "// vulnerable line: 206: }",
                "// vulnerable line: 207: }",
                "// Line 208: ",
                "// Line 209:     return dir, nil",
                "// vulnerable line: 210: }",
                "// Line 211: ",
                "// Line 212: // FindForkPoint finds the fork point between the local branch and the upstream",
                "// Line 213: // branch.",
                "// Line 214: //",
                "// Line 215: // The fork point is the commit hash of the latest commit had in common between",
                "// Line 216: // the local branch and the upstream branch.",
                "// Line 217: //",
                "// Line 218: // The local branch is the branch pointed to by the provided branchRef.",
                "// Line 219: //",
                "// Line 220: // The upstream branch is the branch pointed to by the provided upstreamRef.",
                "// Line 221: //",
                "// Line 222: // The caller is responsible for closing the provided repo.",
                "// Line 223: func FindForkPoint(repo *git.Repository, branchRef, upstreamRef *plumbing.Reference) (*plumbing.Hash, error) {",
                "// Line 224:     // Get the commit object for the local branch",
                "// Line 225:     localCommit, err := repo.CommitObject(branchRef.Hash())",
                "// Line 226:     if err != nil {",
                "// Line 227:         return nil, err",
                "// vulnerable line: 228: }",
                "// Line 229: ",
                "// Line 230:     // Get the commit iterator for the upstream branch",
                "// Line 231:     upstreamIter, err := repo.Log(&git.LogOptions{From: upstreamRef.Hash()})",
                "// Line 232:     if err != nil {",
                "// Line 233:         return nil, err",
                "// vulnerable line: 234: }",
                "// Line 235:     defer upstreamIter.Close()",
                "// Line 236: ",
                "// Line 237:     // Collect all upstream commit hashes for comparison",
                "// Line 238:     upstreamCommits := make(map[plumbing.Hash]bool)",
                "// Line 239:     err = upstreamIter.ForEach(func(c *object.Commit) error {",
                "// Line 240:         upstreamCommits[c.Hash] = true",
                "// vulnerable line: 241: return nil",
                "// Line 242:     })",
                "// Line 243:     if err != nil {",
                "// Line 244:         return nil, err",
                "// vulnerable line: 245: }",
                "// Line 246: ",
                "// Line 247:     // Now walk through the local branch commits to find where it diverged",
                "// Line 248:     localIter, err := repo.Log(&git.LogOptions{From: localCommit.Hash})",
                "// Line 249:     if err != nil {",
                "// Line 250:         return nil, err",
                "// vulnerable line: 251: }",
                "// Line 252:     defer localIter.Close()",
                "// Line 253: ",
                "// Line 254:     var forkPoint *plumbing.Hash",
                "// Line 255:     err = localIter.ForEach(func(c *object.Commit) error {",
                "// Line 256:         if _, exists := upstreamCommits[c.Hash]; exists {",
                "// Line 257:             // This commit exists in both histories, so it's a common ancestor and potential fork point",
                "// Line 258:             forkPoint = &c.Hash",
                "// Line 259:             // We stop iterating as we found the most recent common commit",
                "// Line 260:             return storer.ErrStop",
                "// vulnerable line: 261: }",
                "// vulnerable line: 262: return nil",
                "// Line 263:     })",
                "// Line 264:     if err != nil {",
                "// Line 265:         return nil, err",
                "// vulnerable line: 266: }",
                "// Line 267: ",
                "// Line 268:     if forkPoint == nil {",
                "// Line 269:         return nil, fmt.Errorf(\"fork point not found\")",
                "// vulnerable line: 270: }",
                "// Line 271: ",
                "// Line 272:     return forkPoint, nil",
                "// vulnerable line: 273: }"
            ]
        },
        {
            "filename_of_changes": "package.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 50:     if o.DryRun {",
                "// Line 51:         o.Logger.Printf(\"using working directory %s\", tempDir)",
                "// Line 52:     } else {",
                "// Line 53:         defer os.Remove(tempDir)",
                "// Line 54:     }",
                "// Line 55: ",
                "// Line 56:     cloneOpts := &git.CloneOptions{",
                "// Line 57:         URL:               o.TargetRepo,",
                "// Line 58:         Progress:          os.Stdout,",
                "// Line 59:         RecurseSubmodules: git.NoRecurseSubmodules,",
                "// vulnerable line: 60: Auth:              wolfigit.GetGitAuth(),",
                "// Line 61:         Depth:             1,",
                "// Line 62:     }",
                "// Line 63: ",
                "// Line 64:     repo, err := git.PlainClone(tempDir, false, cloneOpts)",
                "// Line 65:     if err != nil {",
                "// Line 66:         return fmt.Errorf(\"failed to clone repository %s into %s: %w\", o.TargetRepo, tempDir, err)",
                "// Line 67:     }",
                "// Line 68: ",
                "// Line 69:     // first, let's get the melange package(s) from the target git repo, that we want to check for updates",
                "// Line 70:     o.PackageConfig, err = melange.ReadPackageConfigs(ctx, []string{o.PackageName}, tempDir)",
                "// Line 117:     }",
                "// Line 118:     gitURL, err := wolfigit.GetRemoteURLFromDir(currentDir)",
                "// Line 119:     if err != nil {",
                "// Line 120:         return err",
                "// Line 121:     }",
                "// Line 122:     // checkout repo into tmp dir so we know we are working on a clean HEAD",
                "// Line 123:     cloneOpts := &git.CloneOptions{",
                "// Line 124:         URL:               gitURL.RawURL,",
                "// Line 125:         RecurseSubmodules: git.NoRecurseSubmodules,",
                "// Line 126:         ShallowSubmodules: true,",
                "// vulnerable line: 127: Auth:              wolfigit.GetGitAuth(),",
                "// Line 128:         Tags:              git.AllTags,",
                "// Line 129:         Depth:             20,",
                "// Line 130:     }",
                "// Line 131: ",
                "// Line 132:     tempDir, err := os.MkdirTemp(\"\", \"wolfictl\")",
                "// Line 133:     if err != nil {",
                "// Line 134:         return fmt.Errorf(\"failed to create temporary folder to clone package configs into: %w\", err)",
                "// Line 135:     }",
                "// Line 136: ",
                "// Line 137:     _, err = git.PlainClone(tempDir, false, cloneOpts)"
            ]
        },
        {
            "filename_of_changes": "tag.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 48:     gitURL, err := ParseGitURL(remote.Config().URLs[0])",
                "// Line 49:     if err != nil {",
                "// Line 50:         return err",
                "// Line 51:     }",
                "// Line 52:     remoteURL := fmt.Sprintf(\"https://github.com/%s/%s.git\", gitURL.Organisation, gitURL.Name)",
                "// Line 53: ",
                "// Line 54:     po := &git.PushOptions{",
                "// Line 55:         RemoteName: \"origin\",",
                "// Line 56:         RemoteURL:  remoteURL,",
                "// Line 57:         RefSpecs:   []config.RefSpec{config.RefSpec(fmt.Sprintf(\"refs/tags/%s:refs/tags/%s\", tagName, tagName))},",
                "// vulnerable line: 58: Auth:       GetGitAuth(),",
                "// Line 59:     }",
                "// Line 60: ",
                "// Line 61:     err = r.Push(po)",
                "// Line 62: ",
                "// Line 63:     if err != nil {",
                "// Line 64:         if err == git.NoErrAlreadyUpToDate {",
                "// Line 65:             return nil",
                "// Line 66:         }",
                "// Line 67:         return fmt.Errorf(\"failed to push tag: %w\", err)",
                "// Line 68:     }"
            ]
        }
    ]
}