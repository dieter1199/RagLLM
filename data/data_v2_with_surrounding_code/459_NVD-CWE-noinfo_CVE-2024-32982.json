{
    "cve_id": "CVE-2024-32982",
    "cve_description": "Litestar and Starlite is an Asynchronous Server Gateway Interface (ASGI) framework. Prior to 2.8.3, 2.7.2, and 2.6.4, a Local File Inclusion (LFI) vulnerability has been discovered in the static file serving component of LiteStar. This vulnerability allows attackers to exploit path traversal flaws, enabling unauthorized access to sensitive files outside the designated directories. Such access can lead to the disclosure of sensitive information or potentially compromise the server. The vulnerability is located in the file path handling mechanism within the static content serving function, specifically at `litestar/static_files/base.py`. This vulnerability is fixed in versions 2.8.3, 2.7.2, and 2.6.4.",
    "cve_publish_date": "2024-05-06T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-83pv-qr33-2vcf\n\nFix for vulnerability introduced in #739, caused by failure to normalize the path part extracted from URL before serving data from a static directory.\n\nSee https://github.com/litestar-org/litestar/security/advisories/GHSA-83pv-qr33-2vcf for specific details.\n\nCo-authored-by: Brian Edgar RÃ© <brian@192.168.1.4>\nCo-authored-by: Peter Schutt <peter.github@proton.me>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "base.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "15",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: from __future__ import annotations",
                "// Line 2: ",
                "// vulnerable line: 3: from os.path import commonpath",
                "// Line 4: from pathlib import Path",
                "// Line 5: from typing import TYPE_CHECKING, Literal, Sequence",
                "// Line 6: ",
                "// Line 7: from litestar.enums import ScopeType",
                "// Line 8: from litestar.exceptions import MethodNotAllowedException, NotFoundException",
                "// Line 9: from litestar.file_system import FileSystemAdapter",
                "// Line 10: from litestar.response.file import ASGIFileResponse",
                "// Line 11: from litestar.status_codes import HTTP_404_NOT_FOUND",
                "// Line 12: ",
                "// Line 13: __all__ = (\"StaticFiles\",)",
                "// Line 38:         Args:",
                "// Line 39:             is_html_mode: Flag dictating whether serving html. If true, the default file will be ``index.html``.",
                "// Line 40:             directories: A list of directories to serve files from.",
                "// Line 41:             file_system: The file_system spec to use for serving files.",
                "// Line 42:             send_as_attachment: Whether to send the file with a ``content-disposition`` header of",
                "// Line 43:              ``attachment`` or ``inline``",
                "// Line 44:             resolve_symlinks: Resolve symlinks to the directories",
                "// Line 45:             headers: Headers that will be sent with every response.",
                "// Line 46:         \"\"\"",
                "// Line 47:         self.adapter = FileSystemAdapter(file_system)",
                "// vulnerable line: 48: self.directories = tuple(Path(p).resolve() if resolve_symlinks else Path(p) for p in directories)",
                "// Line 49:         self.is_html_mode = is_html_mode",
                "// Line 50:         self.send_as_attachment = send_as_attachment",
                "// Line 51:         self.headers = headers",
                "// Line 52: ",
                "// Line 53:     async def get_fs_info(",
                "// Line 54:         self, directories: Sequence[PathType], file_path: PathType",
                "// Line 55:     ) -> tuple[Path, FileInfo] | tuple[None, None]:",
                "// Line 56:         \"\"\"Return the resolved path and a :class:`stat_result <os.stat_result>`.",
                "// Line 57: ",
                "// Line 58:         Args:",
                "// Line 59:             directories: A list of directory paths.",
                "// Line 60:             file_path: A file path to resolve",
                "// Line 61: ",
                "// Line 62:         Returns:",
                "// Line 63:             A tuple with an optional resolved :class:`Path <anyio.Path>` instance and an optional",
                "// Line 64:             :class:`stat_result <os.stat_result>`.",
                "// Line 65:         \"\"\"",
                "// Line 66:         for directory in directories:",
                "// Line 67:             try:",
                "// Line 68:                 joined_path = Path(directory, file_path)",
                "// vulnerable line: 69: file_info = await self.adapter.info(joined_path)",
                "// vulnerable line: 70: if file_info and commonpath([str(directory), file_info[\"name\"], joined_path]) == str(directory):",
                "// Line 71:                     return joined_path, file_info",
                "// Line 72:             except FileNotFoundError:",
                "// Line 73:                 continue",
                "// Line 74:         return None, None",
                "// Line 75: ",
                "// Line 76:     async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
                "// Line 77:         \"\"\"ASGI callable.",
                "// Line 78: ",
                "// Line 79:         Args:",
                "// Line 80:             scope: ASGI scope"
            ]
        },
        {
            "filename_of_changes": "test_file_serving_resolution.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "29",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 3: import gzip",
                "// Line 4: import mimetypes",
                "// Line 5: from pathlib import Path",
                "// Line 6: from typing import TYPE_CHECKING, Callable",
                "// Line 7: ",
                "// Line 8: import brotli",
                "// Line 9: import pytest",
                "// Line 10: from typing_extensions import TypeAlias",
                "// Line 11: ",
                "// Line 12: from litestar import MediaType, Router, get",
                "// vulnerable line: 13: from litestar.static_files import StaticFilesConfig, create_static_files_router",
                "// Line 14: from litestar.status_codes import HTTP_200_OK",
                "// Line 15: from litestar.testing import create_test_client",
                "// Line 16: from tests.unit.test_static_files.conftest import MakeConfig",
                "// Line 17: ",
                "// Line 18: if TYPE_CHECKING:",
                "// Line 19:     from litestar.types import FileSystemProtocol",
                "// Line 20: ",
                "// Line 21: ",
                "// Line 22: def test_default_static_files_config(tmpdir: Path, make_config: MakeConfig) -> None:",
                "// Line 23:     path = tmpdir / \"test.txt\""
            ]
        }
    ]
}