{
    "cve_id": "CVE-2024-32886",
    "cve_description": "Vitess is a database clustering system for horizontal scaling of MySQL. When executing the following simple query, the `vtgate` will go into an endless loop that also keeps consuming memory and eventually will run out of memory. This vulnerability is fixed in 19.0.4, 18.0.5, and 17.0.7.",
    "cve_publish_date": "2024-05-08T14:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-649x-hxfx-57j2\n\n* collations: Fix OOM and handle padding for multibyte\n\nThis fixes the OOM issue where a simple query can trigger a denial of\nservice attack. It also ensures we return the right result for these\nqueries by doing the correct padding.\n\nSigned-off-by: Dirkjan Bussink <d.bussink@gmail.com>\n\n* Address review comments\n\nSigned-off-by: Dirkjan Bussink <d.bussink@gmail.com>\n\n---------\n\nSigned-off-by: Dirkjan Bussink <d.bussink@gmail.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "compiler_asm.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1045:         arg := env.vm.stack[env.vm.sp-offset].(*evalUint64)",
                "// Line 1046:         env.vm.stack[env.vm.sp-offset] = env.vm.arena.newEvalInt64(int64(arg.u))",
                "// Line 1047:         return 1",
                "// Line 1048:     }, \"CONV UINT64(SP-%d), INT64\", offset)",
                "// Line 1049: }",
                "// Line 1050: ",
                "// Line 1051: func (asm *assembler) Convert_xb(offset int, t sqltypes.Type, length *int) {",
                "// Line 1052:     if length != nil {",
                "// Line 1053:         l := *length",
                "// Line 1054:         asm.emit(func(env *ExpressionEnv) int {",
                "// vulnerable line: 1055: arg := evalToBinary(env.vm.stack[env.vm.sp-offset])",
                "// Line 1056:             arg.truncateInPlace(l)",
                "// Line 1057:             arg.tt = int16(t)",
                "// Line 1058:             env.vm.stack[env.vm.sp-offset] = arg",
                "// Line 1059:             return 1",
                "// Line 1060:         }, \"CONV (SP-%d), VARBINARY[%d]\", offset, l)",
                "// Line 1061:     } else {",
                "// Line 1062:         asm.emit(func(env *ExpressionEnv) int {",
                "// vulnerable line: 1063: arg := evalToBinary(env.vm.stack[env.vm.sp-offset])",
                "// Line 1064:             arg.tt = int16(t)",
                "// Line 1065:             env.vm.stack[env.vm.sp-offset] = arg",
                "// Line 1066:             return 1",
                "// Line 1067:         }, \"CONV (SP-%d), VARBINARY\", offset)",
                "// Line 1068:     }",
                "// Line 1069: }",
                "// Line 1070: ",
                "// Line 1071: func (asm *assembler) Convert_xc(offset int, t sqltypes.Type, collation collations.ID, length *int) {",
                "// Line 1072:     if length != nil {",
                "// Line 1073:         l := *length",
                "// Line 5061:         } else {",
                "// Line 5062:             env.vm.stack[env.vm.sp-offset-1] = env.vm.arena.newEvalRaw(b, sqltypes.Text, resultCollation(merged))",
                "// Line 5063:         }",
                "// Line 5064:         env.vm.sp -= offset",
                "// Line 5065:         return 1",
                "// Line 5066:     }, \"FN REGEXP_REPLACE_SLOW VARCHAR(SP-2), VARCHAR(SP-1)\")",
                "// Line 5067: }",
                "// Line 5068: ",
                "// Line 5069: func (asm *assembler) Introduce(offset int, t sqltypes.Type, col collations.TypedCollation) {",
                "// Line 5070:     asm.emit(func(env *ExpressionEnv) int {",
                "// vulnerable line: 5071: arg := evalToBinary(env.vm.stack[env.vm.sp-offset])",
                "// Line 5072:         arg.tt = int16(t)",
                "// Line 5073:         arg.col = col",
                "// Line 5074:         env.vm.stack[env.vm.sp-offset] = arg",
                "// Line 5075:         return 1",
                "// Line 5076:     }, \"INTRODUCE (SP-1)\")",
                "// Line 5077: }"
            ]
        },
        {
            "filename_of_changes": "compiler_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "24",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "convert.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 65: ",
                "// Line 66:     if dst == nil {",
                "// Line 67:         dst = make([]byte, len(src)*3)",
                "// Line 68:     } else {",
                "// Line 69:         nDst = len(dst)",
                "// Line 70:         dst = dst[:cap(dst)]",
                "// Line 71:     }",
                "// Line 72: ",
                "// Line 73:     for len(src) > 0 {",
                "// Line 74:         cp, width := srcCharset.DecodeRune(src)",
                "// vulnerable line: 75: if cp == utf8.RuneError && width < 3 {",
                "// Line 76:             failed++",
                "// Line 77:             cp = '?'",
                "// Line 78:         }",
                "// Line 79:         src = src[width:]",
                "// Line 80: ",
                "// Line 81:         if len(dst)-nDst < 4 {",
                "// Line 82:             newDst := make([]byte, len(dst)*2)",
                "// Line 83:             copy(newDst, dst[:nDst])",
                "// Line 84:             dst = newDst",
                "// Line 85:         }"
            ]
        },
        {
            "filename_of_changes": "helpers.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 17: package charset",
                "// Line 18: ",
                "// Line 19: func Slice(charset Charset, input []byte, from, to int) []byte {",
                "// Line 20:     if charset, ok := charset.(interface{ Slice([]byte, int, int) []byte }); ok {",
                "// Line 21:         return charset.Slice(input, from, to)",
                "// Line 22:     }",
                "// Line 23:     iter := input",
                "// Line 24:     start := 0",
                "// Line 25:     for i := 0; i < to; i++ {",
                "// Line 26:         r, size := charset.DecodeRune(iter)",
                "// vulnerable line: 27: if r == RuneError && size < 2 {",
                "// Line 28:             break",
                "// Line 29:         }",
                "// Line 30:         if i < from {",
                "// Line 31:             start += size",
                "// Line 32:         }",
                "// Line 33:         iter = iter[size:]",
                "// Line 34:     }",
                "// Line 35:     return input[start : len(input)-len(iter)]",
                "// Line 36: }",
                "// Line 37: ",
                "// Line 38: func Validate(charset Charset, input []byte) bool {",
                "// Line 39:     if charset, ok := charset.(interface{ Validate([]byte) bool }); ok {",
                "// Line 40:         return charset.Validate(input)",
                "// Line 41:     }",
                "// Line 42:     for len(input) > 0 {",
                "// Line 43:         r, size := charset.DecodeRune(input)",
                "// vulnerable line: 44: if r == RuneError && size < 2 {",
                "// Line 45:             return false",
                "// Line 46:         }",
                "// Line 47:         input = input[size:]",
                "// Line 48:     }",
                "// Line 49:     return true",
                "// Line 50: }",
                "// Line 51: ",
                "// Line 52: func Length(charset Charset, input []byte) int {",
                "// Line 53:     if charset, ok := charset.(interface{ Length([]byte) int }); ok {",
                "// Line 54:         return charset.Length(input)"
            ]
        },
        {
            "filename_of_changes": "translate.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 366:         }",
                "// Line 367:         collation = defaultCollation",
                "// Line 368:     }",
                "// Line 369: ",
                "// Line 370:     switch lit := expr.(type) {",
                "// Line 371:     case *Literal:",
                "// Line 372:         switch collation {",
                "// Line 373:         case collations.CollationBinaryID:",
                "// Line 374:             lit.inner = evalToBinary(lit.inner)",
                "// Line 375:         default:",
                "// vulnerable line: 376: lit.inner, err = evalToVarchar(lit.inner, collation, false)",
                "// Line 377:             if err != nil {",
                "// Line 378:                 return nil, err",
                "// Line 379:             }",
                "// Line 380:         }",
                "// Line 381:         return expr, nil",
                "// Line 382:     case *BindVariable:",
                "// Line 383:         if lit.Type == sqltypes.Tuple {",
                "// Line 384:             panic(\"parser allowed introducer before tuple\")",
                "// Line 385:         }",
                "// Line 386: "
            ]
        },
        {
            "filename_of_changes": "utf16.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 60:         dst[0] = uint8(r1 >> 8)",
                "// Line 61:         dst[1] = uint8(r1)",
                "// Line 62:         dst[2] = uint8(r2 >> 8)",
                "// Line 63:         dst[3] = uint8(r2)",
                "// Line 64:         return 4",
                "// Line 65:     }",
                "// Line 66: }",
                "// Line 67: ",
                "// Line 68: func (Charset_utf16be) DecodeRune(b []byte) (rune, int) {",
                "// Line 69:     if len(b) < 2 {",
                "// vulnerable line: 70: return utf8.RuneError, 0",
                "// Line 71:     }",
                "// Line 72: ",
                "// Line 73:     r1 := uint16(b[1]) | uint16(b[0])<<8",
                "// Line 74:     if r1 < surr1 || surr3 <= r1 {",
                "// Line 75:         return rune(r1), 2",
                "// Line 76:     }",
                "// Line 77: ",
                "// Line 78:     if len(b) < 4 {",
                "// vulnerable line: 79: return utf8.RuneError, 0",
                "// Line 80:     }",
                "// Line 81: ",
                "// Line 82:     r2 := uint16(b[3]) | uint16(b[2])<<8",
                "// Line 83:     if surr1 <= r1 && r1 < surr2 && surr2 <= r2 && r2 < surr3 {",
                "// Line 84:         return (rune(r1)-surr1)<<10 | (rune(r2) - surr2) + surrSelf, 4",
                "// Line 85:     }",
                "// Line 86: ",
                "// Line 87:     return utf8.RuneError, 1",
                "// Line 88: }",
                "// Line 89: ",
                "// Line 122:         dst[0] = uint8(r1)",
                "// Line 123:         dst[1] = uint8(r1 >> 8)",
                "// Line 124:         dst[2] = uint8(r2)",
                "// Line 125:         dst[3] = uint8(r2 >> 8)",
                "// Line 126:         return 4",
                "// Line 127:     }",
                "// Line 128: }",
                "// Line 129: ",
                "// Line 130: func (Charset_utf16le) DecodeRune(b []byte) (rune, int) {",
                "// Line 131:     if len(b) < 2 {",
                "// vulnerable line: 132: return utf8.RuneError, 0",
                "// Line 133:     }",
                "// Line 134: ",
                "// Line 135:     r1 := uint16(b[0]) | uint16(b[1])<<8",
                "// Line 136:     if r1 < surr1 || surr3 <= r1 {",
                "// Line 137:         return rune(r1), 2",
                "// Line 138:     }",
                "// Line 139: ",
                "// Line 140:     if len(b) < 4 {",
                "// vulnerable line: 141: return utf8.RuneError, 0",
                "// Line 142:     }",
                "// Line 143: ",
                "// Line 144:     r2 := uint16(b[2]) | uint16(b[3])<<8",
                "// Line 145:     if surr1 <= r1 && r1 < surr2 && surr2 <= r2 && r2 < surr3 {",
                "// Line 146:         return (rune(r1)-surr1)<<10 | (rune(r2) - surr2) + surrSelf, 4",
                "// Line 147:     }",
                "// Line 148: ",
                "// Line 149:     return utf8.RuneError, 1",
                "// Line 150: }",
                "// Line 151: ",
                "// Line 178:     if r <= 0xffff {",
                "// Line 179:         dst[0] = uint8(r >> 8)",
                "// Line 180:         dst[1] = uint8(r)",
                "// Line 181:         return 2",
                "// Line 182:     }",
                "// Line 183:     return -1",
                "// Line 184: }",
                "// Line 185: ",
                "// Line 186: func (Charset_ucs2) DecodeRune(p []byte) (rune, int) {",
                "// Line 187:     if len(p) < 2 {",
                "// vulnerable line: 188: return utf8.RuneError, 0",
                "// Line 189:     }",
                "// Line 190:     return rune(p[0])<<8 | rune(p[1]), 2",
                "// Line 191: }",
                "// Line 192: ",
                "// Line 193: func (Charset_ucs2) SupportsSupplementaryChars() bool {",
                "// Line 194:     return false",
                "// Line 195: }",
                "// Line 196: ",
                "// Line 197: func (Charset_ucs2) Length(src []byte) int {",
                "// Line 198:     cnt := len(src)"
            ]
        },
        {
            "filename_of_changes": "utf32.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 42: ",
                "// Line 43:     dst[0] = uint8(r >> 24)",
                "// Line 44:     dst[1] = uint8(r >> 16)",
                "// Line 45:     dst[2] = uint8(r >> 8)",
                "// Line 46:     dst[3] = uint8(r)",
                "// Line 47:     return 4",
                "// Line 48: }",
                "// Line 49: ",
                "// Line 50: func (Charset_utf32) DecodeRune(p []byte) (rune, int) {",
                "// Line 51:     if len(p) < 4 {",
                "// vulnerable line: 52: return utf8.RuneError, 0",
                "// Line 53:     }",
                "// Line 54:     return (rune(p[0]) << 24) | (rune(p[1]) << 16) | (rune(p[2]) << 8) | rune(p[3]), 4",
                "// Line 55: }",
                "// Line 56: ",
                "// Line 57: func (Charset_utf32) SupportsSupplementaryChars() bool {",
                "// Line 58:     return true",
                "// Line 59: }",
                "// Line 60: ",
                "// Line 61: func (Charset_utf32) CharLen(src []byte) int {",
                "// Line 62:     cnt := len(src)"
            ]
        }
    ]
}