{
    "cve_id": "CVE-2024-27306",
    "cve_description": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. A XSS vulnerability exists on index pages for static file handling. This vulnerability is fixed in 3.9.4. We have always recommended using a reverse proxy server (e.g. nginx) for serving static files. Users following the recommendation are unaffected. Other users can disable `show_index` if unable to upgrade.",
    "cve_publish_date": "2024-04-18T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Escape filenames and paths in HTML when generating index pages (#8317) (#8319)\n\nCo-authored-by: J. Nick Koston <nick@koston.org>\r\n(cherry picked from commit ffbc43233209df302863712b511a11bdb6001b0f)",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "web_urldispatcher.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "7",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 27:     NoReturn,",
                "// Line 28:     Optional,",
                "// Line 29:     Pattern,",
                "// Line 30:     Set,",
                "// Line 31:     Sized,",
                "// Line 32:     Tuple,",
                "// Line 33:     Type,",
                "// Line 34:     TypedDict,",
                "// Line 35:     Union,",
                "// Line 36:     cast,",
                "// vulnerable line: 37: )",
                "// Line 38: ",
                "// Line 39: from yarl import URL, __version__ as yarl_version  # type: ignore[attr-defined]",
                "// Line 40: ",
                "// Line 41: from . import hdrs",
                "// Line 42: from .abc import AbstractMatchInfo, AbstractRouter, AbstractView",
                "// Line 43: from .helpers import DEBUG",
                "// Line 44: from .http import HttpVersion11",
                "// Line 45: from .typedefs import Handler, PathLike",
                "// Line 46: from .web_exceptions import (",
                "// Line 47:     HTTPException,",
                "// Line 48:     HTTPExpectationFailed,",
                "// Line 49:     HTTPForbidden,",
                "// Line 50:     HTTPMethodNotAllowed,",
                "// Line 51:     HTTPNotFound,",
                "// vulnerable line: 52: )",
                "// Line 53: from .web_fileresponse import FileResponse",
                "// Line 54: from .web_request import Request",
                "// Line 55: from .web_response import Response, StreamResponse",
                "// Line 56: from .web_routedef import AbstractRouteDef",
                "// Line 57: ",
                "// Line 58: __all__ = (",
                "// Line 59:     \"UrlDispatcher\",",
                "// Line 60:     \"UrlMappingMatchInfo\",",
                "// Line 61:     \"AbstractResource\",",
                "// Line 62:     \"Resource\",",
                "// Line 63:     \"PlainResource\",",
                "// Line 64:     \"DynamicResource\",",
                "// Line 65:     \"AbstractRoute\",",
                "// Line 66:     \"ResourceRoute\",",
                "// Line 67:     \"StaticResource\",",
                "// Line 68:     \"View\",",
                "// vulnerable line: 69: )",
                "// Line 70: ",
                "// Line 71: ",
                "// Line 72: if TYPE_CHECKING:",
                "// Line 73:     from .web_app import Application",
                "// Line 74: ",
                "// Line 75:     BaseDict = Dict[str, str]",
                "// Line 76: else:",
                "// Line 77:     BaseDict = dict",
                "// Line 78: ",
                "// Line 79: YARL_VERSION: Final[Tuple[int, ...]] = tuple(map(int, yarl_version.split(\".\")[:2]))",
                "// Line 80: ",
                "// Line 81: HTTP_METHOD_RE: Final[Pattern[str]] = re.compile(",
                "// Line 82:     r\"^[0-9A-Za-z!#\\$%&'\\*\\+\\-\\.\\^_`\\|~]+$\"",
                "// vulnerable line: 83: )",
                "// Line 84: ROUTE_RE: Final[Pattern[str]] = re.compile(",
                "// Line 85:     r\"(\\{[_a-zA-Z][^{}]*(?:\\{[^{}]*\\}[^{}]*)*\\})\"",
                "// vulnerable line: 86: )",
                "// Line 87: PATH_SEP: Final[str] = re.escape(\"/\")",
                "// Line 88: ",
                "// Line 89: ",
                "// Line 90: _ExpectHandler = Callable[[Request], Awaitable[Optional[StreamResponse]]]",
                "// Line 91: _Resolve = Tuple[Optional[\"UrlMappingMatchInfo\"], Set[str]]",
                "// Line 92: ",
                "// Line 93: ",
                "// Line 94: class _InfoDict(TypedDict, total=False):",
                "// Line 95:     path: str",
                "// Line 96: ",
                "// Line 178:         if not HTTP_METHOD_RE.match(method):",
                "// Line 179:             raise ValueError(f\"{method} is not allowed HTTP method\")",
                "// Line 180: ",
                "// Line 181:         assert callable(handler), handler",
                "// Line 182:         if asyncio.iscoroutinefunction(handler):",
                "// Line 183:             pass",
                "// Line 184:         elif inspect.isgeneratorfunction(handler):",
                "// Line 185:             warnings.warn(",
                "// Line 186:                 \"Bare generators are deprecated, \" \"use @coroutine wrapper\",",
                "// Line 187:                 DeprecationWarning,",
                "// vulnerable line: 188: )",
                "// Line 189:         elif isinstance(handler, type) and issubclass(handler, AbstractView):",
                "// Line 190:             pass",
                "// Line 191:         else:",
                "// Line 192:             warnings.warn(",
                "// Line 193:                 \"Bare functions are deprecated, \" \"use async ones\", DeprecationWarning",
                "// vulnerable line: 194: )",
                "// Line 195: ",
                "// Line 196:             @wraps(handler)",
                "// Line 197:             async def handler_wrapper(request: Request) -> StreamResponse:",
                "// Line 198:                 result = old_handler(request)",
                "// Line 199:                 if asyncio.iscoroutine(result):",
                "// Line 200:                     result = await result",
                "// Line 201:                 assert isinstance(result, StreamResponse)",
                "// Line 202:                 return result",
                "// Line 203: ",
                "// Line 204:             old_handler = handler",
                "// Line 282:         assert app is not None",
                "// Line 283:         return app",
                "// Line 284: ",
                "// Line 285:     @contextmanager",
                "// Line 286:     def set_current_app(self, app: \"Application\") -> Generator[None, None, None]:",
                "// Line 287:         if DEBUG:  # pragma: no cover",
                "// Line 288:             if app not in self._apps:",
                "// Line 289:                 raise RuntimeError(",
                "// Line 290:                     \"Expected one of the following apps {!r}, got {!r}\".format(",
                "// Line 291:                         self._apps, app",
                "// vulnerable line: 292: )",
                "// vulnerable line: 293: )",
                "// Line 294:         prev = self._current_app",
                "// Line 295:         self._current_app = app",
                "// Line 296:         try:",
                "// Line 297:             yield",
                "// Line 298:         finally:",
                "// Line 299:             self._current_app = prev",
                "// Line 300: ",
                "// Line 301:     def freeze(self) -> None:",
                "// Line 302:         self._frozen = True",
                "// Line 303: ",
                "// Line 310:         self._exception = http_exception",
                "// Line 311:         super().__init__({}, SystemRoute(self._exception))",
                "// Line 312: ",
                "// Line 313:     @property",
                "// Line 314:     def http_exception(self) -> HTTPException:",
                "// Line 315:         return self._exception",
                "// Line 316: ",
                "// Line 317:     def __repr__(self) -> str:",
                "// Line 318:         return \"<MatchInfoError {}: {}>\".format(",
                "// Line 319:             self._exception.status, self._exception.reason",
                "// vulnerable line: 320: )",
                "// Line 321: ",
                "// Line 322: ",
                "// Line 323: async def _default_expect_handler(request: Request) -> None:",
                "// Line 324:     \"\"\"Default handler for Expect header.",
                "// Line 325: ",
                "// Line 326:     Just send \"100 Continue\" to client.",
                "// Line 327:     raise HTTPExpectationFailed if value of header is not \"100-continue\"",
                "// Line 328:     \"\"\"",
                "// Line 329:     expect = request.headers.get(hdrs.EXPECT, \"\")",
                "// Line 330:     if request.version == HttpVersion11:",
                "// Line 348:         *,",
                "// Line 349:         expect_handler: Optional[_ExpectHandler] = None,",
                "// Line 350:     ) -> \"ResourceRoute\":",
                "// Line 351: ",
                "// Line 352:         for route_obj in self._routes:",
                "// Line 353:             if route_obj.method == method or route_obj.method == hdrs.METH_ANY:",
                "// Line 354:                 raise RuntimeError(",
                "// Line 355:                     \"Added route will never be executed, \"",
                "// Line 356:                     \"method {route.method} is already \"",
                "// Line 357:                     \"registered\".format(route=route_obj)",
                "// vulnerable line: 358: )",
                "// Line 359: ",
                "// Line 360:         route_obj = ResourceRoute(method, handler, self, expect_handler=expect_handler)",
                "// Line 361:         self.register_route(route_obj)",
                "// Line 362:         return route_obj",
                "// Line 363: ",
                "// Line 364:     def register_route(self, route: \"ResourceRoute\") -> None:",
                "// Line 365:         assert isinstance(",
                "// Line 366:             route, ResourceRoute",
                "// Line 367:         ), f\"Instance of Route class is required, got {route!r}\"",
                "// Line 368:         self._routes.append(route)",
                "// Line 503:         return {\"formatter\": self._formatter, \"pattern\": self._pattern}",
                "// Line 504: ",
                "// Line 505:     def url_for(self, **parts: str) -> URL:",
                "// Line 506:         url = self._formatter.format_map({k: _quote_path(v) for k, v in parts.items()})",
                "// Line 507:         return URL.build(path=url, encoded=True)",
                "// Line 508: ",
                "// Line 509:     def __repr__(self) -> str:",
                "// Line 510:         name = \"'\" + self.name + \"' \" if self.name is not None else \"\"",
                "// Line 511:         return \"<DynamicResource {name} {formatter}>\".format(",
                "// Line 512:             name=name, formatter=self._formatter",
                "// vulnerable line: 513: )",
                "// Line 514: ",
                "// Line 515: ",
                "// Line 516: class PrefixResource(AbstractResource):",
                "// Line 517:     def __init__(self, prefix: str, *, name: Optional[str] = None) -> None:",
                "// Line 518:         assert not prefix or prefix.startswith(\"/\"), prefix",
                "// Line 519:         assert prefix in (\"\", \"/\") or not prefix.endswith(\"/\"), prefix",
                "// Line 520:         super().__init__(name=name)",
                "// Line 521:         self._prefix = _requote_path(prefix)",
                "// Line 522:         self._prefix2 = self._prefix + \"/\"",
                "// Line 523: ",
                "// Line 632:             \"directory\": self._directory,",
                "// Line 633:             \"prefix\": self._prefix,",
                "// Line 634:             \"routes\": self._routes,",
                "// Line 635:         }",
                "// Line 636: ",
                "// Line 637:     def set_options_route(self, handler: Handler) -> None:",
                "// Line 638:         if \"OPTIONS\" in self._routes:",
                "// Line 639:             raise RuntimeError(\"OPTIONS route was set already\")",
                "// Line 640:         self._routes[\"OPTIONS\"] = ResourceRoute(",
                "// Line 641:             \"OPTIONS\", handler, self, expect_handler=self._expect_handler",
                "// vulnerable line: 642: )",
                "// Line 643: ",
                "// Line 644:     async def resolve(self, request: Request) -> _Resolve:",
                "// Line 645:         path = request.rel_url.raw_path",
                "// Line 646:         method = request.method",
                "// Line 647:         allowed_methods = set(self._routes)",
                "// Line 648:         if not path.startswith(self._prefix2) and path != self._prefix:",
                "// Line 649:             return None, set()",
                "// Line 650: ",
                "// Line 651:         if method not in allowed_methods:",
                "// Line 652:             return None, allowed_methods",
                "// Line 686:             # perm error or other kind!",
                "// Line 687:             request.app.logger.exception(error)",
                "// Line 688:             raise HTTPNotFound() from error",
                "// Line 689: ",
                "// Line 690:         # on opening a dir, load its contents if allowed",
                "// Line 691:         if filepath.is_dir():",
                "// Line 692:             if self._show_index:",
                "// Line 693:                 try:",
                "// Line 694:                     return Response(",
                "// Line 695:                         text=self._directory_as_html(filepath), content_type=\"text/html\"",
                "// vulnerable line: 696: )",
                "// Line 697:                 except PermissionError:",
                "// Line 698:                     raise HTTPForbidden()",
                "// Line 699:             else:",
                "// Line 700:                 raise HTTPForbidden()",
                "// Line 701:         elif filepath.is_file():",
                "// Line 702:             return FileResponse(filepath, chunk_size=self._chunk_size)",
                "// Line 703:         else:",
                "// Line 704:             raise HTTPNotFound",
                "// Line 705: ",
                "// Line 706:     def _directory_as_html(self, filepath: Path) -> str:",
                "// Line 707:         # returns directory's index as html",
                "// Line 708: ",
                "// Line 709:         # sanity check",
                "// Line 710:         assert filepath.is_dir()",
                "// Line 711: ",
                "// Line 712:         relative_path_to_dir = filepath.relative_to(self._directory).as_posix()",
                "// vulnerable line: 713: index_of = f\"Index of /{relative_path_to_dir}\"",
                "// Line 714:         h1 = f\"<h1>{index_of}</h1>\"",
                "// Line 715: ",
                "// Line 716:         index_list = []",
                "// Line 717:         dir_index = filepath.iterdir()",
                "// Line 718:         for _file in sorted(dir_index):",
                "// Line 719:             # show file url as relative to static path",
                "// Line 720:             rel_path = _file.relative_to(self._directory).as_posix()",
                "// vulnerable line: 721: file_url = self._prefix + \"/\" + rel_path",
                "// Line 722: ",
                "// Line 723:             # if file is a directory, add '/' to the end of the name",
                "// Line 724:             if _file.is_dir():",
                "// Line 725:                 file_name = f\"{_file.name}/\"",
                "// Line 726:             else:",
                "// Line 727:                 file_name = _file.name",
                "// Line 728: ",
                "// Line 729:             index_list.append(",
                "// vulnerable line: 730: '<li><a href=\"{url}\">{name}</a></li>'.format(",
                "// vulnerable line: 731: url=file_url, name=file_name",
                "// vulnerable line: 732: )",
                "// vulnerable line: 733: )",
                "// Line 734:         ul = \"<ul>",
                "// Line 735: {}",
                "// Line 736: </ul>\".format(\"",
                "// Line 737: \".join(index_list))",
                "// Line 738:         body = f\"<body>",
                "// Line 739: {h1}",
                "// Line 740: {ul}",
                "// Line 741: </body>\"",
                "// Line 742: ",
                "// Line 743:         head_str = f\"<head>",
                "// Line 747: {head_str}",
                "// Line 748: {body}",
                "// Line 749: </html>\"",
                "// Line 750: ",
                "// Line 751:         return html",
                "// Line 752: ",
                "// Line 753:     def __repr__(self) -> str:",
                "// Line 754:         name = \"'\" + self.name + \"'\" if self.name is not None else \"\"",
                "// Line 755:         return \"<StaticResource {name} {path} -> {directory!r}>\".format(",
                "// Line 756:             name=name, path=self._prefix, directory=self._directory",
                "// vulnerable line: 757: )",
                "// Line 758: ",
                "// Line 759: ",
                "// Line 760: class PrefixedSubAppResource(PrefixResource):",
                "// Line 761:     def __init__(self, prefix: str, app: \"Application\") -> None:",
                "// Line 762:         super().__init__(prefix)",
                "// Line 763:         self._app = app",
                "// Line 764:         for resource in app.router.resources():",
                "// Line 765:             resource.add_prefix(prefix)",
                "// Line 766: ",
                "// Line 767:     def add_prefix(self, prefix: str) -> None:",
                "// Line 791: ",
                "// Line 792:     def __len__(self) -> int:",
                "// Line 793:         return len(self._app.router.routes())",
                "// Line 794: ",
                "// Line 795:     def __iter__(self) -> Iterator[AbstractRoute]:",
                "// Line 796:         return iter(self._app.router.routes())",
                "// Line 797: ",
                "// Line 798:     def __repr__(self) -> str:",
                "// Line 799:         return \"<PrefixedSubAppResource {prefix} -> {app!r}>\".format(",
                "// Line 800:             prefix=self._prefix, app=self._app",
                "// vulnerable line: 801: )",
                "// Line 802: ",
                "// Line 803: ",
                "// Line 804: class AbstractRuleMatching(abc.ABC):",
                "// Line 805:     @abc.abstractmethod  # pragma: no branch",
                "// Line 806:     async def match(self, request: Request) -> bool:",
                "// Line 807:         \"\"\"Return bool if the request satisfies the criteria\"\"\"",
                "// Line 808: ",
                "// Line 809:     @abc.abstractmethod  # pragma: no branch",
                "// Line 810:     def get_info(self) -> _InfoDict:",
                "// Line 811:         \"\"\"Return a dict with additional info useful for introspection\"\"\"",
                "// Line 907:     def __init__(",
                "// Line 908:         self,",
                "// Line 909:         method: str,",
                "// Line 910:         handler: Union[Handler, Type[AbstractView]],",
                "// Line 911:         resource: AbstractResource,",
                "// Line 912:         *,",
                "// Line 913:         expect_handler: Optional[_ExpectHandler] = None,",
                "// Line 914:     ) -> None:",
                "// Line 915:         super().__init__(",
                "// Line 916:             method, handler, expect_handler=expect_handler, resource=resource",
                "// vulnerable line: 917: )",
                "// Line 918: ",
                "// Line 919:     def __repr__(self) -> str:",
                "// Line 920:         return \"<ResourceRoute [{method}] {resource} -> {handler!r}\".format(",
                "// Line 921:             method=self.method, resource=self._resource, handler=self.handler",
                "// vulnerable line: 922: )",
                "// Line 923: ",
                "// Line 924:     @property",
                "// Line 925:     def name(self) -> Optional[str]:",
                "// Line 926:         if self._resource is None:",
                "// Line 927:             return None",
                "// Line 928:         return self._resource.name",
                "// Line 929: ",
                "// Line 930:     def url_for(self, *args: str, **kwargs: str) -> URL:",
                "// Line 931:         \"\"\"Construct url for route with additional params.\"\"\"",
                "// Line 932:         assert self._resource is not None",
                "// Line 1074:         name = resource.name",
                "// Line 1075: ",
                "// Line 1076:         if name is not None:",
                "// Line 1077:             parts = self.NAME_SPLIT_RE.split(name)",
                "// Line 1078:             for part in parts:",
                "// Line 1079:                 if keyword.iskeyword(part):",
                "// Line 1080:                     raise ValueError(",
                "// Line 1081:                         f\"Incorrect route name {name!r}, \"",
                "// Line 1082:                         \"python keywords cannot be used \"",
                "// Line 1083:                         \"for route name\"",
                "// vulnerable line: 1084: )",
                "// Line 1085:                 if not part.isidentifier():",
                "// Line 1086:                     raise ValueError(",
                "// Line 1087:                         \"Incorrect route name {!r}, \"",
                "// Line 1088:                         \"the name should be a sequence of \"",
                "// Line 1089:                         \"python identifiers separated \"",
                "// Line 1090:                         \"by dash, dot or column\".format(name)",
                "// vulnerable line: 1091: )",
                "// Line 1092:             if name in self._named_resources:",
                "// Line 1093:                 raise ValueError(",
                "// Line 1094:                     \"Duplicate {!r}, \"",
                "// Line 1095:                     \"already handled by {!r}\".format(name, self._named_resources[name])",
                "// vulnerable line: 1096: )",
                "// Line 1097:             self._named_resources[name] = resource",
                "// Line 1098:         self._resources.append(resource)",
                "// Line 1099: ",
                "// Line 1100:     def add_resource(self, path: str, *, name: Optional[str] = None) -> Resource:",
                "// Line 1101:         if path and not path.startswith(\"/\"):",
                "// Line 1102:             raise ValueError(\"path should be started with / or be empty\")",
                "// Line 1103:         # Reuse last added resource if path and name are the same",
                "// Line 1104:         if self._resources:",
                "// Line 1105:             resource = self._resources[-1]",
                "// Line 1106:             if resource.name == name and resource.raw_match(path):",
                "// Line 1148:             prefix = prefix[:-1]",
                "// Line 1149:         resource = StaticResource(",
                "// Line 1150:             prefix,",
                "// Line 1151:             path,",
                "// Line 1152:             name=name,",
                "// Line 1153:             expect_handler=expect_handler,",
                "// Line 1154:             chunk_size=chunk_size,",
                "// Line 1155:             show_index=show_index,",
                "// Line 1156:             follow_symlinks=follow_symlinks,",
                "// Line 1157:             append_version=append_version,",
                "// vulnerable line: 1158: )",
                "// Line 1159:         self.register_resource(resource)",
                "// Line 1160:         return resource",
                "// Line 1161: ",
                "// Line 1162:     def add_head(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:",
                "// Line 1163:         \"\"\"Shortcut for add_route with method HEAD.\"\"\"",
                "// Line 1164:         return self.add_route(hdrs.METH_HEAD, path, handler, **kwargs)",
                "// Line 1165: ",
                "// Line 1166:     def add_options(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:",
                "// Line 1167:         \"\"\"Shortcut for add_route with method OPTIONS.\"\"\"",
                "// Line 1168:         return self.add_route(hdrs.METH_OPTIONS, path, handler, **kwargs)"
            ]
        }
    ]
}