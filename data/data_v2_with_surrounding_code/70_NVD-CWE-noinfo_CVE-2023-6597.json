{
    "cve_id": "CVE-2023-6597",
    "cve_description": "An issue was found in the CPython `tempfile.TemporaryDirectory` class affecting versions 3.12.1, 3.11.7, 3.10.13, 3.9.18, and 3.8.18 and prior.\n\nThe tempfile.TemporaryDirectory class would dereference symlinks during cleanup of permissions-related errors. This means users which can run privileged programs are potentially able to modify permissions of files referenced by symlinks in some circumstances.\n",
    "cve_publish_date": "2024-03-19T16:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "gh-91133: tempfile.TemporaryDirectory: fix symlink bug in cleanup (GH-99930)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "tempfile.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "18",
            "number_of_lines_deleted_vulnerable_to_cve": "9",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 68: # have a possibly desirable side effect...  But we do not want to support",
                "// Line 69: # that as an API.  It is undocumented on purpose.  Do not depend on this.",
                "// Line 70: template = \"tmp\"",
                "// Line 71: ",
                "// Line 72: # Internal routines.",
                "// Line 73: ",
                "// Line 74: _once_lock = _allocate_lock()",
                "// Line 75: ",
                "// Line 76: ",
                "// Line 77: def _exists(fn):",
                "// vulnerable line: 78: try:",
                "// Line 79:         _os.lstat(fn)",
                "// Line 80:     except OSError:",
                "// Line 81:         return False",
                "// Line 82:     else:",
                "// Line 83:         return True",
                "// Line 84: ",
                "// Line 85: ",
                "// Line 86: def _infer_return_type(*args):",
                "// Line 87:     \"\"\"Look at the type of all args and divine their implied return type.\"\"\"",
                "// Line 88:     return_type = None",
                "// Line 167: ",
                "// Line 168:     # Failing that, try OS-specific locations.",
                "// Line 169:     if _os.name == 'nt':",
                "// Line 170:         dirlist.extend([ _os.path.expanduser(r'~\\AppData\\Local\\Temp'),",
                "// Line 171:                          _os.path.expandvars(r'%SYSTEMROOT%\\Temp'),",
                "// Line 172:                          r'c:    emp', r'c:    mp', r'    emp', r'    mp' ])",
                "// Line 173:     else:",
                "// Line 174:         dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])",
                "// Line 175: ",
                "// Line 176:     # As a last resort, the current directory.",
                "// vulnerable line: 177: try:",
                "// Line 178:         dirlist.append(_os.getcwd())",
                "// Line 179:     except (AttributeError, OSError):",
                "// Line 180:         dirlist.append(_os.curdir)",
                "// Line 181: ",
                "// Line 182:     return dirlist",
                "// Line 183: ",
                "// Line 184: def _get_default_tempdir():",
                "// Line 185:     \"\"\"Calculate the default directory to use for temporary files.",
                "// Line 186:     This routine should be called exactly once.",
                "// Line 187: ",
                "// Line 193:     namer = _RandomNameSequence()",
                "// Line 194:     dirlist = _candidate_tempdir_list()",
                "// Line 195: ",
                "// Line 196:     for dir in dirlist:",
                "// Line 197:         if dir != _os.curdir:",
                "// Line 198:             dir = _os.path.abspath(dir)",
                "// Line 199:         # Try only a few names per directory.",
                "// Line 200:         for seq in range(100):",
                "// Line 201:             name = next(namer)",
                "// Line 202:             filename = _os.path.join(dir, name)",
                "// vulnerable line: 203: try:",
                "// Line 204:                 fd = _os.open(filename, _bin_openflags, 0o600)",
                "// vulnerable line: 205: try:",
                "// vulnerable line: 206: try:",
                "// Line 207:                         _os.write(fd, b'blat')",
                "// Line 208:                     finally:",
                "// Line 209:                         _os.close(fd)",
                "// Line 210:                 finally:",
                "// Line 211:                     _os.unlink(filename)",
                "// Line 212:                 return dir",
                "// Line 213:             except FileExistsError:",
                "// vulnerable line: 214: pass",
                "// Line 215:             except PermissionError:",
                "// Line 216:                 # This exception is thrown when a directory with the chosen name",
                "// Line 217:                 # already exists on windows.",
                "// Line 218:                 if (_os.name == 'nt' and _os.path.isdir(dir) and",
                "// Line 219:                     _os.access(dir, _os.W_OK)):",
                "// Line 220:                     continue",
                "// Line 221:                 break   # no point trying more names in this directory",
                "// Line 222:             except OSError:",
                "// Line 223:                 break   # no point trying more names in this directory",
                "// Line 224:     raise FileNotFoundError(_errno.ENOENT,",
                "// Line 226:                             dirlist)",
                "// Line 227: ",
                "// Line 228: _name_sequence = None",
                "// Line 229: ",
                "// Line 230: def _get_candidate_names():",
                "// Line 231:     \"\"\"Common setup sequence for all user-callable interfaces.\"\"\"",
                "// Line 232: ",
                "// Line 233:     global _name_sequence",
                "// Line 234:     if _name_sequence is None:",
                "// Line 235:         _once_lock.acquire()",
                "// vulnerable line: 236: try:",
                "// Line 237:             if _name_sequence is None:",
                "// Line 238:                 _name_sequence = _RandomNameSequence()",
                "// Line 239:         finally:",
                "// Line 240:             _once_lock.release()",
                "// Line 241:     return _name_sequence",
                "// Line 242: ",
                "// Line 243: ",
                "// Line 244: def _mkstemp_inner(dir, pre, suf, flags, output_type):",
                "// Line 245:     \"\"\"Code common to mkstemp, TemporaryFile, and NamedTemporaryFile.\"\"\"",
                "// Line 246: ",
                "// Line 247:     dir = _os.path.abspath(dir)",
                "// Line 248:     names = _get_candidate_names()",
                "// Line 249:     if output_type is bytes:",
                "// Line 250:         names = map(_os.fsencode, names)",
                "// Line 251: ",
                "// Line 252:     for seq in range(TMP_MAX):",
                "// Line 253:         name = next(names)",
                "// Line 254:         file = _os.path.join(dir, pre + name + suf)",
                "// Line 255:         _sys.audit(\"tempfile.mkstemp\", file)",
                "// vulnerable line: 256: try:",
                "// Line 257:             fd = _os.open(file, flags, 0o600)",
                "// Line 258:         except FileExistsError:",
                "// Line 259:             continue    # try again",
                "// Line 260:         except PermissionError:",
                "// Line 261:             # This exception is thrown when a directory with the chosen name",
                "// Line 262:             # already exists on windows.",
                "// Line 263:             if (_os.name == 'nt' and _os.path.isdir(dir) and",
                "// Line 264:                 _os.access(dir, _os.W_OK)):",
                "// Line 265:                 continue",
                "// Line 266:             else:",
                "// Line 281:     \"\"\"The default prefix for temporary directories as bytes.\"\"\"",
                "// Line 282:     return _os.fsencode(template)",
                "// Line 283: ",
                "// Line 284: tempdir = None",
                "// Line 285: ",
                "// Line 286: def _gettempdir():",
                "// Line 287:     \"\"\"Private accessor for tempfile.tempdir.\"\"\"",
                "// Line 288:     global tempdir",
                "// Line 289:     if tempdir is None:",
                "// Line 290:         _once_lock.acquire()",
                "// vulnerable line: 291: try:",
                "// Line 292:             if tempdir is None:",
                "// Line 293:                 tempdir = _get_default_tempdir()",
                "// Line 294:         finally:",
                "// Line 295:             _once_lock.release()",
                "// Line 296:     return tempdir",
                "// Line 297: ",
                "// Line 298: def gettempdir():",
                "// Line 299:     \"\"\"Returns tempfile.tempdir as str.\"\"\"",
                "// Line 300:     return _os.fsdecode(_gettempdir())",
                "// Line 301: ",
                "// Line 358:     prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)",
                "// Line 359: ",
                "// Line 360:     names = _get_candidate_names()",
                "// Line 361:     if output_type is bytes:",
                "// Line 362:         names = map(_os.fsencode, names)",
                "// Line 363: ",
                "// Line 364:     for seq in range(TMP_MAX):",
                "// Line 365:         name = next(names)",
                "// Line 366:         file = _os.path.join(dir, prefix + name + suffix)",
                "// Line 367:         _sys.audit(\"tempfile.mkdtemp\", file)",
                "// vulnerable line: 368: try:",
                "// Line 369:             _os.mkdir(file, 0o700)",
                "// Line 370:         except FileExistsError:",
                "// Line 371:             continue    # try again",
                "// Line 372:         except PermissionError:",
                "// Line 373:             # This exception is thrown when a directory with the chosen name",
                "// Line 374:             # already exists on windows.",
                "// Line 375:             if (_os.name == 'nt' and _os.path.isdir(dir) and",
                "// Line 376:                 _os.access(dir, _os.W_OK)):",
                "// Line 377:                 continue",
                "// Line 378:             else:",
                "// Line 424: ",
                "// Line 425:     def __init__(self, file, name, delete=True, delete_on_close=True):",
                "// Line 426:         self.file = file",
                "// Line 427:         self.name = name",
                "// Line 428:         self.delete = delete",
                "// Line 429:         self.delete_on_close = delete_on_close",
                "// Line 430: ",
                "// Line 431:     def cleanup(self, windows=(_os.name == 'nt'), unlink=_os.unlink):",
                "// Line 432:         if not self.cleanup_called:",
                "// Line 433:             self.cleanup_called = True",
                "// vulnerable line: 434: try:",
                "// Line 435:                 if not self.close_called:",
                "// Line 436:                     self.close_called = True",
                "// Line 437:                     self.file.close()",
                "// Line 438:             finally:",
                "// Line 439:                 # Windows provides delete-on-close as a primitive, in which",
                "// Line 440:                 # case the file was deleted by self.file.close().",
                "// Line 441:                 if self.delete and not (windows and self.delete_on_close):",
                "// vulnerable line: 442: try:",
                "// Line 443:                         unlink(self.name)",
                "// Line 444:                     except FileNotFoundError:",
                "// vulnerable line: 445: pass",
                "// Line 446: ",
                "// Line 447:     def close(self):",
                "// Line 448:         if not self.close_called:",
                "// Line 449:             self.close_called = True",
                "// vulnerable line: 450: try:",
                "// Line 451:                 self.file.close()",
                "// Line 452:             finally:",
                "// Line 453:                 if self.delete and self.delete_on_close:",
                "// Line 454:                     self.cleanup()",
                "// Line 455: ",
                "// Line 456:     def __del__(self):",
                "// Line 457:         self.cleanup()",
                "// Line 458: ",
                "// Line 459: ",
                "// Line 460: class _TemporaryFileWrapper:",
                "// Line 556:         flags |= _os.O_TEMPORARY",
                "// Line 557: ",
                "// Line 558:     if \"b\" not in mode:",
                "// Line 559:         encoding = _io.text_encoding(encoding)",
                "// Line 560: ",
                "// Line 561:     name = None",
                "// Line 562:     def opener(*args):",
                "// Line 563:         nonlocal name",
                "// Line 564:         fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)",
                "// Line 565:         return fd",
                "// vulnerable line: 566: try:",
                "// Line 567:         file = _io.open(dir, mode, buffering=buffering,",
                "// Line 568:                         newline=newline, encoding=encoding, errors=errors,",
                "// Line 569:                         opener=opener)",
                "// vulnerable line: 570: try:",
                "// Line 571:             raw = getattr(file, 'buffer', file)",
                "// Line 572:             raw = getattr(raw, 'raw', raw)",
                "// Line 573:             raw.name = name",
                "// Line 574:             return _TemporaryFileWrapper(file, name, delete, delete_on_close)",
                "// Line 575:         except:",
                "// Line 576:             file.close()",
                "// Line 577:             raise",
                "// Line 578:     except:",
                "// Line 579:         if name is not None and not (",
                "// Line 580:             _os.name == 'nt' and delete and delete_on_close):",
                "// Line 616:         prefix, suffix, dir, output_type = _sanitize_params(prefix, suffix, dir)",
                "// Line 617: ",
                "// Line 618:         flags = _bin_openflags",
                "// Line 619:         if _O_TMPFILE_WORKS:",
                "// Line 620:             fd = None",
                "// Line 621:             def opener(*args):",
                "// Line 622:                 nonlocal fd",
                "// Line 623:                 flags2 = (flags | _os.O_TMPFILE) & ~_os.O_CREAT",
                "// Line 624:                 fd = _os.open(dir, flags2, 0o600)",
                "// Line 625:                 return fd",
                "// vulnerable line: 626: try:",
                "// Line 627:                 file = _io.open(dir, mode, buffering=buffering,",
                "// Line 628:                                 newline=newline, encoding=encoding,",
                "// Line 629:                                 errors=errors, opener=opener)",
                "// Line 630:                 raw = getattr(file, 'buffer', file)",
                "// Line 631:                 raw = getattr(raw, 'raw', raw)",
                "// Line 632:                 raw.name = fd",
                "// Line 633:                 return file",
                "// Line 634:             except IsADirectoryError:",
                "// Line 635:                 # Linux kernel older than 3.11 ignores the O_TMPFILE flag:",
                "// Line 636:                 # O_TMPFILE is read as O_DIRECTORY. Trying to open a directory",
                "// Line 639:                 # try again.",
                "// Line 640:                 _O_TMPFILE_WORKS = False",
                "// Line 641:             except OSError:",
                "// Line 642:                 # The filesystem of the directory does not support O_TMPFILE.",
                "// Line 643:                 # For example, OSError(95, 'Operation not supported').",
                "// Line 644:                 #",
                "// Line 645:                 # On Linux kernel older than 3.11, trying to open a regular",
                "// Line 646:                 # file (or a symbolic link to a regular file) with O_TMPFILE",
                "// Line 647:                 # fails with NotADirectoryError, because O_TMPFILE is read as",
                "// Line 648:                 # O_DIRECTORY.",
                "// vulnerable line: 649: pass",
                "// Line 650:             # Fallback to _mkstemp_inner().",
                "// Line 651: ",
                "// Line 652:         fd = None",
                "// Line 653:         def opener(*args):",
                "// Line 654:             nonlocal fd",
                "// Line 655:             fd, name = _mkstemp_inner(dir, prefix, suffix, flags, output_type)",
                "// vulnerable line: 656: try:",
                "// Line 657:                 _os.unlink(name)",
                "// Line 658:             except BaseException as e:",
                "// Line 659:                 _os.close(fd)",
                "// Line 660:                 raise",
                "// Line 661:             return fd",
                "// Line 662:         file = _io.open(dir, mode, buffering=buffering,",
                "// Line 663:                         newline=newline, encoding=encoding, errors=errors,",
                "// Line 664:                         opener=opener)",
                "// Line 665:         raw = getattr(file, 'buffer', file)",
                "// Line 666:         raw = getattr(raw, 'raw', raw)",
                "// Line 762:         return self._file.fileno()",
                "// Line 763: ",
                "// Line 764:     def flush(self):",
                "// Line 765:         self._file.flush()",
                "// Line 766: ",
                "// Line 767:     def isatty(self):",
                "// Line 768:         return self._file.isatty()",
                "// Line 769: ",
                "// Line 770:     @property",
                "// Line 771:     def mode(self):",
                "// vulnerable line: 772: try:",
                "// Line 773:             return self._file.mode",
                "// vulnerable line: 774: except AttributeError:",
                "// Line 775:             return self._TemporaryFileArgs['mode']",
                "// Line 776: ",
                "// Line 777:     @property",
                "// Line 778:     def name(self):",
                "// vulnerable line: 779: try:",
                "// Line 780:             return self._file.name",
                "// vulnerable line: 781: except AttributeError:",
                "// Line 782:             return None",
                "// Line 783: ",
                "// Line 784:     @property",
                "// Line 785:     def newlines(self):",
                "// Line 786:         return self._file.newlines",
                "// Line 787: ",
                "// Line 788:     def readable(self):",
                "// Line 789:         return self._file.readable()",
                "// Line 790: ",
                "// Line 791:     def read(self, *args):",
                "// Line 869:         self._delete = delete",
                "// Line 870:         self._finalizer = _weakref.finalize(",
                "// Line 871:             self, self._cleanup, self.name,",
                "// Line 872:             warn_message=\"Implicitly cleaning up {!r}\".format(self),",
                "// Line 873:             ignore_errors=self._ignore_cleanup_errors, delete=self._delete)",
                "// Line 874: ",
                "// Line 875:     @classmethod",
                "// Line 876:     def _rmtree(cls, name, ignore_errors=False):",
                "// Line 877:         def onexc(func, path, exc):",
                "// Line 878:             if isinstance(exc, PermissionError):",
                "// vulnerable line: 879: def resetperms(path):",
                "// vulnerable line: 880: try:",
                "// vulnerable line: 881: _os.chflags(path, 0)",
                "// vulnerable line: 882: except AttributeError:",
                "// vulnerable line: 883: pass",
                "// vulnerable line: 884: _os.chmod(path, 0o700)",
                "// Line 885: ",
                "// vulnerable line: 886: try:",
                "// Line 887:                     if path != name:",
                "// vulnerable line: 888: resetperms(_os.path.dirname(path))",
                "// vulnerable line: 889: resetperms(path)",
                "// Line 890: ",
                "// vulnerable line: 891: try:",
                "// Line 892:                         _os.unlink(path)",
                "// Line 893:                     except IsADirectoryError:",
                "// Line 894:                         cls._rmtree(path, ignore_errors=ignore_errors)",
                "// Line 895:                     except PermissionError:",
                "// Line 896:                         # The PermissionError handler was originally added for",
                "// Line 897:                         # FreeBSD in directories, but it seems that it is raised",
                "// Line 898:                         # on Windows too.",
                "// Line 899:                         # bpo-43153: Calling _rmtree again may",
                "// Line 900:                         # raise NotADirectoryError and mask the PermissionError.",
                "// Line 901:                         # So we must re-raise the current PermissionError if",
                "// Line 902:                         # path is not a directory.",
                "// vulnerable line: 903: try:",
                "// Line 904:                             st = _os.lstat(path)",
                "// Line 905:                         except OSError:",
                "// Line 906:                             if ignore_errors:",
                "// Line 907:                                 return",
                "// Line 908:                             raise",
                "// Line 909:                         if (_stat.S_ISLNK(st.st_mode) or",
                "// Line 910:                             not _stat.S_ISDIR(st.st_mode) or",
                "// Line 911:                             (hasattr(st, 'st_file_attributes') and",
                "// Line 912:                              st.st_file_attributes & _stat.FILE_ATTRIBUTE_REPARSE_POINT and",
                "// Line 913:                              st.st_reparse_tag == _stat.IO_REPARSE_TAG_MOUNT_POINT)",
                "// Line 914:                         ):",
                "// Line 915:                             if ignore_errors:",
                "// Line 916:                                 return",
                "// Line 917:                             raise",
                "// Line 918:                         cls._rmtree(path, ignore_errors=ignore_errors)",
                "// Line 919:                 except FileNotFoundError:",
                "// vulnerable line: 920: pass",
                "// Line 921:             elif isinstance(exc, FileNotFoundError):",
                "// vulnerable line: 922: pass",
                "// Line 923:             else:",
                "// Line 924:                 if not ignore_errors:",
                "// Line 925:                     raise",
                "// Line 926: ",
                "// Line 927:         _shutil.rmtree(name, onexc=onexc)",
                "// Line 928: ",
                "// Line 929:     @classmethod",
                "// Line 930:     def _cleanup(cls, name, warn_message, ignore_errors=False, delete=True):",
                "// Line 931:         if delete:",
                "// Line 932:             cls._rmtree(name, ignore_errors=ignore_errors)"
            ]
        }
    ]
}