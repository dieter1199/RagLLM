{
    "cve_id": "CVE-2024-22365",
    "cve_description": "linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.",
    "cve_publish_date": "2024-02-06T08:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "pam_namespace: protect_dir(): use O_DIRECTORY to prevent local DoS situations\n\nWithout O_DIRECTORY the path crawling logic is subject to e.g. FIFOs\nbeing placed in user controlled directories, causing the PAM module to\nblock indefinitely during `openat()`.\n\nPass O_DIRECTORY to cause the `openat()` to fail if the path does not\nrefer to a directory.\n\nWith this the check whether the final path element is a directory\nbecomes unnecessary, drop it.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "pam_namespace.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "17",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 37: #include \"pam_cc_compat.h\"",
                "// Line 38: #include \"pam_inline.h\"",
                "// Line 39: #include \"pam_namespace.h\"",
                "// Line 40: #include \"argv_parse.h\"",
                "// Line 41: ",
                "// Line 42: /* --- evaluating all files in VENDORDIR/security/namespace.d and /etc/security/namespace.d --- */",
                "// Line 43: static const char *base_name(const char *path)",
                "// Line 44: {",
                "// Line 45:     const char *base = strrchr(path, '/');",
                "// Line 46:     return base ? base+1 : path;",
                "// vulnerable line: 47: }",
                "// Line 48: ",
                "// Line 49: static int",
                "// Line 50: compare_filename(const void *a, const void *b)",
                "// Line 51: {",
                "// Line 52:     return strcmp(base_name(* (char * const *) a),",
                "// Line 53:               base_name(* (char * const *) b));",
                "// vulnerable line: 54: }",
                "// Line 55: ",
                "// Line 56: static void close_fds_pre_exec(struct instance_data *idata)",
                "// Line 57: {",
                "// Line 58:     if (pam_modutil_sanitize_helper_fds(idata->pamh, PAM_MODUTIL_IGNORE_FD,",
                "// Line 59:             PAM_MODUTIL_IGNORE_FD, PAM_MODUTIL_IGNORE_FD) < 0) {",
                "// Line 60:         _exit(1);",
                "// vulnerable line: 61: }",
                "// vulnerable line: 62: }",
                "// Line 63: ",
                "// Line 64: /* Evaluating a list of files which have to be parsed in the right order:",
                "// Line 65:  *",
                "// Line 66:  * - If etc/security/namespace.d/@filename@.conf exists, then",
                "// Line 67:  *   %vendordir%/security/namespace.d/@filename@.conf should not be used.",
                "// Line 68:  * - All files in both namespace.d directories are sorted by their @filename@.conf in",
                "// Line 69:  *   lexicographic order regardless of which of the directories they reside in. */",
                "// Line 70: static char **read_namespace_dir(struct instance_data *idata)",
                "// Line 71: {",
                "// Line 72:     glob_t globbuf;",
                "// Line 84:     file_list = malloc((file_list_size + 1) * sizeof(char*));",
                "// Line 85:     if (file_list == NULL) {",
                "// Line 86:         pam_syslog(idata->pamh, LOG_ERR, \"Cannot allocate memory for file list: %m\");",
                "// Line 87: #ifdef VENDOR_NAMESPACE_D_GLOB",
                "// Line 88:         if (glob_rv_vendor == 0)",
                "// Line 89:         globfree(&globbuf_vendor);",
                "// Line 90: #endif",
                "// Line 91:         if (glob_rv == 0)",
                "// Line 92:         globfree(&globbuf);",
                "// Line 93:         return NULL;",
                "// vulnerable line: 94: }",
                "// Line 95: ",
                "// Line 96:     if (glob_rv == 0) {",
                "// Line 97:         for (i = 0; i < globbuf.gl_pathc; i++) {",
                "// Line 98:         file_list[i] = strdup(globbuf.gl_pathv[i]);",
                "// Line 99:         if (file_list[i] == NULL) {",
                "// Line 100:             pam_syslog(idata->pamh, LOG_ERR, \"strdup failed: %m\");",
                "// Line 101:             break;",
                "// vulnerable line: 102: }",
                "// vulnerable line: 103: }",
                "// vulnerable line: 104: }",
                "// Line 105: #ifdef VENDOR_NAMESPACE_D_GLOB",
                "// Line 106:     if (glob_rv_vendor == 0) {",
                "// Line 107:         for (size_t j = 0; j < globbuf_vendor.gl_pathc; j++) {",
                "// Line 108:         if (glob_rv == 0 && globbuf.gl_pathc > 0) {",
                "// Line 109:             int double_found = 0;",
                "// Line 110:             for (size_t k = 0; k < globbuf.gl_pathc; k++) {",
                "// Line 111:             if (strcmp(base_name(globbuf.gl_pathv[k]),",
                "// Line 112:                    base_name(globbuf_vendor.gl_pathv[j])) == 0) {",
                "// Line 113:                 double_found = 1;",
                "// Line 114:                 break;",
                "// vulnerable line: 115: }",
                "// vulnerable line: 116: }",
                "// Line 117:             if (double_found)",
                "// Line 118:             continue;",
                "// vulnerable line: 119: }",
                "// Line 120:         file_list[i] = strdup(globbuf_vendor.gl_pathv[j]);",
                "// Line 121:         if (file_list[i] == NULL) {",
                "// Line 122:             pam_syslog(idata->pamh, LOG_ERR, \"strdup failed: %m\");",
                "// Line 123:             break;",
                "// vulnerable line: 124: }",
                "// Line 125:         i++;",
                "// vulnerable line: 126: }",
                "// Line 127:         globfree(&globbuf_vendor);",
                "// vulnerable line: 128: }",
                "// Line 129: #endif",
                "// Line 130:     file_list[i] = NULL;",
                "// Line 131:     qsort(file_list, i, sizeof(char *), compare_filename);",
                "// Line 132:     if (glob_rv == 0)",
                "// Line 133:         globfree(&globbuf);",
                "// Line 134: ",
                "// Line 135:     return file_list;",
                "// vulnerable line: 136: }",
                "// Line 137: ",
                "// Line 138: /*",
                "// Line 139:  * Adds an entry for a polyinstantiated directory to the linked list of",
                "// Line 140:  * polyinstantiated directories. It is called from process_line() while",
                "// Line 141:  * parsing the namespace configuration file.",
                "// Line 142:  */",
                "// Line 143: static void add_polydir_entry(struct instance_data *idata,",
                "// Line 144:     struct polydir_s *ent)",
                "// Line 145: {",
                "// Line 146:     /* Now attach to linked list */",
                "// Line 147:     ent->next = NULL;",
                "// Line 148:     if (idata->polydirs_ptr == NULL)",
                "// Line 149:         idata->polydirs_ptr = ent;",
                "// Line 150:     else {",
                "// Line 151:         struct polydir_s *tail;",
                "// Line 152: ",
                "// Line 153:         tail = idata->polydirs_ptr;",
                "// Line 154:         while (tail->next)",
                "// Line 155:             tail = tail->next;",
                "// Line 156:         tail->next = ent;",
                "// vulnerable line: 157: }",
                "// vulnerable line: 158: }",
                "// Line 159: ",
                "// Line 160: static void del_polydir(struct polydir_s *poly)",
                "// Line 161: {",
                "// Line 162:     if (poly) {",
                "// Line 163:         free(poly->uid);",
                "// Line 164:         free(poly->init_script);",
                "// Line 165:         free(poly->mount_opts);",
                "// Line 166:         free(poly);",
                "// vulnerable line: 167: }",
                "// vulnerable line: 168: }",
                "// Line 169: ",
                "// Line 170: /*",
                "// Line 171:  * Deletes all the entries in the linked list.",
                "// Line 172:  */",
                "// Line 173: static void del_polydir_list(struct polydir_s *polydirs_ptr)",
                "// Line 174: {",
                "// Line 175:         struct polydir_s *dptr = polydirs_ptr;",
                "// Line 176: ",
                "// Line 177:     while (dptr) {",
                "// Line 178:         struct polydir_s *tptr = dptr;",
                "// Line 179:         dptr = dptr->next;",
                "// Line 180:         del_polydir(tptr);",
                "// vulnerable line: 181: }",
                "// vulnerable line: 182: }",
                "// Line 183: ",
                "// Line 184: static void unprotect_dirs(struct protect_dir_s *dir)",
                "// Line 185: {",
                "// Line 186:     struct protect_dir_s *next;",
                "// Line 187: ",
                "// Line 188:     while (dir != NULL) {",
                "// Line 189:         umount(dir->dir);",
                "// Line 190:         free(dir->dir);",
                "// Line 191:         next = dir->next;",
                "// Line 192:         free(dir);",
                "// Line 193:         dir = next;",
                "// vulnerable line: 194: }",
                "// vulnerable line: 195: }",
                "// Line 196: ",
                "// Line 197: static void cleanup_polydir_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)",
                "// Line 198: {",
                "// Line 199:     del_polydir_list(data);",
                "// vulnerable line: 200: }",
                "// Line 201: ",
                "// Line 202: static void cleanup_protect_data(pam_handle_t *pamh UNUSED , void *data, int err UNUSED)",
                "// Line 203: {",
                "// Line 204:     unprotect_dirs(data);",
                "// vulnerable line: 205: }",
                "// Line 206: ",
                "// Line 207: static char *expand_variables(const char *orig, const char *var_names[], const char *var_values[])",
                "// Line 208: {",
                "// Line 209:     const char *src = orig;",
                "// Line 210:     char *dst;",
                "// Line 211:     char *expanded;",
                "// Line 212:     char c;",
                "// Line 213:     size_t dstlen = 0;",
                "// Line 214:     while (*src) {",
                "// Line 215:         if (*src == '$') {",
                "// Line 216:             int i;",
                "// Line 217:             for (i = 0; var_names[i]; i++) {",
                "// Line 218:                 size_t namelen = strlen(var_names[i]);",
                "// Line 219:                 if (strncmp(var_names[i], src+1, namelen) == 0) {",
                "// Line 220:                     dstlen += strlen(var_values[i]) - 1; /* $ */",
                "// Line 221:                     src += namelen;",
                "// Line 222:                     break;",
                "// vulnerable line: 223: }",
                "// vulnerable line: 224: }",
                "// vulnerable line: 225: }",
                "// Line 226:         ++dstlen;",
                "// Line 227:         ++src;",
                "// vulnerable line: 228: }",
                "// Line 229:     if ((dst=expanded=malloc(dstlen + 1)) == NULL)",
                "// Line 230:         return NULL;",
                "// Line 231:     src = orig;",
                "// Line 232:     while ((c=*src) != '\u0000') {",
                "// Line 233:         if (c == '$') {",
                "// Line 234:             int i;",
                "// Line 235:             for (i = 0; var_names[i]; i++) {",
                "// Line 236:                 size_t namelen = strlen(var_names[i]);",
                "// Line 237:                 if (strncmp(var_names[i], src+1, namelen) == 0) {",
                "// Line 238:                     dst = stpcpy(dst, var_values[i]);",
                "// Line 239:                     --dst;",
                "// Line 240:                     c = *dst; /* replace $ */",
                "// Line 241:                     src += namelen;",
                "// Line 242:                     break;",
                "// vulnerable line: 243: }",
                "// vulnerable line: 244: }",
                "// vulnerable line: 245: }",
                "// Line 246:         *dst = c;",
                "// Line 247:         ++dst;",
                "// Line 248:         ++src;",
                "// vulnerable line: 249: }",
                "// Line 250:     *dst = '\u0000';",
                "// Line 251:     return expanded;",
                "// vulnerable line: 252: }",
                "// Line 253: ",
                "// Line 254: static int parse_create_params(char *params, struct polydir_s *poly)",
                "// Line 255: {",
                "// Line 256:     char *next;",
                "// Line 257:     struct passwd *pwd = NULL;",
                "// Line 258:     struct group *grp;",
                "// Line 259: ",
                "// Line 260:     poly->mode = (mode_t)ULONG_MAX;",
                "// Line 261:     poly->owner = (uid_t)ULONG_MAX;",
                "// Line 262:     poly->group = (gid_t)ULONG_MAX;",
                "// Line 263: ",
                "// Line 264:     if (*params != '=')",
                "// Line 265:     return 0;",
                "// Line 266:     params++;",
                "// Line 267: ",
                "// Line 268:     next = strchr(params, ',');",
                "// Line 269:     if (next != NULL) {",
                "// Line 270:     *next = '\u0000';",
                "// Line 271:     next++;",
                "// vulnerable line: 272: }",
                "// Line 273: ",
                "// Line 274:     if (*params != '\u0000') {",
                "// Line 275:     errno = 0;",
                "// Line 276:     poly->mode = (mode_t)strtoul(params, NULL, 0);",
                "// Line 277:     if (errno != 0) {",
                "// Line 278:         poly->mode = (mode_t)ULONG_MAX;",
                "// vulnerable line: 279: }",
                "// vulnerable line: 280: }",
                "// Line 281: ",
                "// Line 282:     params = next;",
                "// Line 283:     if (params == NULL)",
                "// Line 284:     return 0;",
                "// Line 285:     next = strchr(params, ',');",
                "// Line 286:     if (next != NULL) {",
                "// Line 287:     *next = '\u0000';",
                "// Line 288:     next++;",
                "// vulnerable line: 289: }",
                "// Line 290: ",
                "// Line 291:     if (*params != '\u0000') {",
                "// Line 292:     pwd = getpwnam(params); /* session modules are not reentrant */",
                "// Line 293:     if (pwd == NULL)",
                "// Line 294:         return -1;",
                "// Line 295:     poly->owner = pwd->pw_uid;",
                "// vulnerable line: 296: }",
                "// Line 297: ",
                "// Line 298:     params = next;",
                "// Line 299:     if (params == NULL || *params == '\u0000') {",
                "// Line 300:     if (pwd != NULL)",
                "// Line 301:         poly->group = pwd->pw_gid;",
                "// Line 302:     return 0;",
                "// vulnerable line: 303: }",
                "// Line 304:     grp = getgrnam(params);",
                "// Line 305:     if (grp == NULL)",
                "// Line 306:     return -1;",
                "// Line 307:     poly->group = grp->gr_gid;",
                "// Line 308: ",
                "// Line 309:     return 0;",
                "// vulnerable line: 310: }",
                "// Line 311: ",
                "// Line 312: static int parse_iscript_params(char *params, struct polydir_s *poly)",
                "// Line 313: {",
                "// Line 314:     if (*params != '=')",
                "// Line 315:     return 0;",
                "// Line 316:     params++;",
                "// Line 317: ",
                "// Line 318:     if (*params != '\u0000') {",
                "// Line 319:     if (*params != '/') { /* path is relative to NAMESPACE_D_DIR */",
                "// Line 320:         if (asprintf(&poly->init_script, \"%s%s\", NAMESPACE_D_DIR, params) == -1)",
                "// Line 321:             return -1;",
                "// Line 322:     } else {",
                "// Line 323:         poly->init_script = strdup(params);",
                "// vulnerable line: 324: }",
                "// Line 325:     if (poly->init_script == NULL)",
                "// Line 326:         return -1;",
                "// vulnerable line: 327: }",
                "// Line 328:     return 0;",
                "// vulnerable line: 329: }",
                "// Line 330: ",
                "// Line 331: struct mntflag {",
                "// Line 332:     const char *name;",
                "// Line 333:     size_t len;",
                "// Line 334:     unsigned long flag;",
                "// Line 335: };",
                "// Line 336: ",
                "// Line 337: #define LITERAL_AND_LEN(x) x, sizeof(x) - 1",
                "// Line 338: ",
                "// Line 339: static const struct mntflag mntflags[] = {",
                "// Line 357: ",
                "// Line 358:     do {",
                "// Line 359:     size_t len;",
                "// Line 360:     unsigned int i;",
                "// Line 361: ",
                "// Line 362:     end = strchr(opts, ',');",
                "// Line 363:     if (end == NULL) {",
                "// Line 364:         len = strlen(opts);",
                "// Line 365:     } else {",
                "// Line 366:         len = end - opts;",
                "// vulnerable line: 367: }",
                "// Line 368: ",
                "// Line 369:     for (i = 0; i < PAM_ARRAY_SIZE(mntflags); i++) {",
                "// Line 370:         if (mntflags[i].len != len)",
                "// Line 371:         continue;",
                "// Line 372:         if (memcmp(mntflags[i].name, opts, len) == 0) {",
                "// Line 373:         *mountflags |= mntflags[i].flag;",
                "// Line 374:         opts = end;",
                "// Line 375:         break;",
                "// vulnerable line: 376: }",
                "// vulnerable line: 377: }",
                "// Line 378: ",
                "// Line 379:     if (opts != end) {",
                "// Line 380:         if (dest != NULL) {",
                "// Line 381:         *dest = ',';",
                "// Line 382:         ++dest;",
                "// Line 383:         } else {",
                "// Line 384:         dest = *filtered = calloc(1, origlen + 1);",
                "// Line 385:         if (dest == NULL)",
                "// Line 386:             return -1;",
                "// vulnerable line: 387: }",
                "// Line 388:         memcpy(dest, opts, len);",
                "// Line 389:         dest += len;",
                "// vulnerable line: 390: }",
                "// Line 391: ",
                "// Line 392:     opts = end + 1;",
                "// Line 393:     } while (end != NULL);",
                "// Line 394: ",
                "// Line 395:     return 0;",
                "// vulnerable line: 396: }",
                "// Line 397: ",
                "// Line 398: static int parse_method(char *method, struct polydir_s *poly,",
                "// Line 399:         struct instance_data *idata)",
                "// Line 400: {",
                "// Line 401:     enum polymethod pm;",
                "// Line 402:     char *sptr = NULL;",
                "// Line 403:     static const char *method_names[] = { \"user\", \"context\", \"level\", \"tmpdir\",",
                "// Line 404:     \"tmpfs\", NULL };",
                "// Line 405:     static const char *flag_names[] = { \"create\", \"noinit\", \"iscript\",",
                "// Line 406:     \"shared\", \"mntopts\", NULL };",
                "// Line 408:     POLYDIR_ISCRIPT, POLYDIR_SHARED, POLYDIR_MNTOPTS };",
                "// Line 409:     int i;",
                "// Line 410:     char *flag;",
                "// Line 411: ",
                "// Line 412:     method = strtok_r(method, \":\", &sptr);",
                "// Line 413:     pm = NONE;",
                "// Line 414: ",
                "// Line 415:     for (i = 0; method_names[i]; i++) {",
                "// Line 416:     if (strcmp(method, method_names[i]) == 0) {",
                "// Line 417:         pm = i + 1; /* 0 = NONE */",
                "// vulnerable line: 418: }",
                "// vulnerable line: 419: }",
                "// Line 420: ",
                "// Line 421:     if (pm == NONE) {",
                "// Line 422:         pam_syslog(idata->pamh, LOG_NOTICE, \"Unknown method\");",
                "// Line 423:         return -1;",
                "// vulnerable line: 424: }",
                "// Line 425: ",
                "// Line 426:     poly->method = pm;",
                "// Line 427: ",
                "// Line 428:     while ((flag=strtok_r(NULL, \":\", &sptr)) != NULL) {",
                "// Line 429:     for (i = 0; flag_names[i]; i++) {",
                "// Line 430:         size_t namelen = strlen(flag_names[i]);",
                "// Line 431: ",
                "// Line 432:         if (strncmp(flag, flag_names[i], namelen) == 0) {",
                "// Line 433:             poly->flags |= flag_values[i];",
                "// Line 434:             switch (flag_values[i]) {",
                "// Line 435:                 case POLYDIR_CREATE:",
                "// Line 436:                 if (parse_create_params(flag+namelen, poly) != 0) {",
                "// Line 437:                         pam_syslog(idata->pamh, LOG_CRIT, \"Invalid create parameters\");",
                "// Line 438:                     return -1;",
                "// vulnerable line: 439: }",
                "// Line 440:                 break;",
                "// Line 441: ",
                "// Line 442:                 case POLYDIR_ISCRIPT:",
                "// Line 443:                 if (parse_iscript_params(flag+namelen, poly) != 0) {",
                "// Line 444:                         pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");",
                "// Line 445:                     return -1;",
                "// Line 446:                 };",
                "// Line 447:                 break;",
                "// Line 448: ",
                "// Line 449:                 case POLYDIR_MNTOPTS:",
                "// Line 450:                 if (flag[namelen] != '=')",
                "// Line 451:                     break;",
                "// Line 452:                 if (poly->method != TMPFS) {",
                "// Line 453:                     pam_syslog(idata->pamh, LOG_WARNING, \"Mount options applicable only to tmpfs method\");",
                "// Line 454:                     break;",
                "// vulnerable line: 455: }",
                "// Line 456:                 free(poly->mount_opts); /* if duplicate mntopts specified */",
                "// Line 457:                 poly->mount_opts = NULL;",
                "// Line 458:                 if (filter_mntopts(flag+namelen+1, &poly->mount_opts, &poly->mount_flags) != 0) {",
                "// Line 459:                     pam_syslog(idata->pamh, LOG_CRIT, \"Memory allocation error\");",
                "// Line 460:                     return -1;",
                "// vulnerable line: 461: }",
                "// Line 462:                 break;",
                "// vulnerable line: 463: }",
                "// vulnerable line: 464: }",
                "// vulnerable line: 465: }",
                "// vulnerable line: 466: }",
                "// Line 467: ",
                "// Line 468:     return 0;",
                "// vulnerable line: 469: }",
                "// Line 470: ",
                "// Line 471: /*",
                "// Line 472:  * Called from parse_config_file, this function processes a single line",
                "// Line 473:  * of the namespace configuration file. It skips over comments and incomplete",
                "// Line 474:  * or malformed lines. It processes a valid line with information on",
                "// Line 475:  * polyinstantiating a directory by populating appropriate fields of a",
                "// Line 476:  * polyinstantiated directory structure and then calling add_polydir_entry to",
                "// Line 477:  * add that entry to the linked list of polyinstantiated directories.",
                "// Line 478:  */",
                "// Line 479: static int process_line(char *line, const char *home, const char *rhome,",
                "// Line 521:     if (poly == NULL)",
                "// Line 522:     goto erralloc;",
                "// Line 523: ",
                "// Line 524:     /*",
                "// Line 525:      * Initialize and scan the five strings from the line from the",
                "// Line 526:      * namespace configuration file.",
                "// Line 527:      */",
                "// Line 528:     retval = argv_parse(line, NULL, &config_options);",
                "// Line 529:     if (retval != 0) {",
                "// Line 530:         goto erralloc;",
                "// vulnerable line: 531: }",
                "// Line 532: ",
                "// Line 533:     dir = config_options[0];",
                "// Line 534:     if (dir == NULL) {",
                "// Line 535:         pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing polydir\");",
                "// Line 536:         goto skipping;",
                "// vulnerable line: 537: }",
                "// Line 538:     instance_prefix = config_options[1];",
                "// Line 539:     if (instance_prefix == NULL) {",
                "// Line 540:         pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing instance_prefix\");",
                "// Line 541:         dir = NULL;",
                "// Line 542:         goto skipping;",
                "// vulnerable line: 543: }",
                "// Line 544:     method = config_options[2];",
                "// Line 545:     if (method == NULL) {",
                "// Line 546:         pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid line missing method\");",
                "// Line 547:         instance_prefix = NULL;",
                "// Line 548:         dir = NULL;",
                "// Line 549:         goto skipping;",
                "// vulnerable line: 550: }",
                "// Line 551: ",
                "// Line 552:     /*",
                "// Line 553:      * Only the uids field is allowed to be blank, to indicate no",
                "// Line 554:      * override users for polyinstantiation of that directory. If",
                "// Line 555:      * any of the other fields are blank, the line is incomplete so",
                "// Line 556:      * skip it.",
                "// Line 557:      */",
                "// Line 558:     uids = config_options[3];",
                "// Line 559: ",
                "// Line 560:     /*",
                "// Line 561:      * Expand $HOME and $USER in poly dir and instance dir prefix",
                "// Line 562:      */",
                "// Line 563:     if ((rdir=expand_variables(dir, var_names, rvar_values)) == NULL) {",
                "// Line 564:         instance_prefix = NULL;",
                "// Line 565:         dir = NULL;",
                "// Line 566:         goto erralloc;",
                "// vulnerable line: 567: }",
                "// Line 568: ",
                "// Line 569:     if ((dir=expand_variables(dir, var_names, var_values)) == NULL) {",
                "// Line 570:         instance_prefix = NULL;",
                "// Line 571:         goto erralloc;",
                "// vulnerable line: 572: }",
                "// Line 573: ",
                "// Line 574:     if ((instance_prefix=expand_variables(instance_prefix, var_names, var_values))",
                "// Line 575:         == NULL) {",
                "// Line 576:         goto erralloc;",
                "// vulnerable line: 577: }",
                "// Line 578: ",
                "// Line 579:     if (idata->flags & PAMNS_DEBUG) {",
                "// Line 580:         pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded polydir: '%s'\", dir);",
                "// Line 581:         pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded ruser polydir: '%s'\", rdir);",
                "// Line 582:         pam_syslog(idata->pamh, LOG_DEBUG, \"Expanded instance prefix: '%s'\", instance_prefix);",
                "// vulnerable line: 583: }",
                "// Line 584: ",
                "// Line 585:     len = strlen(dir);",
                "// Line 586:     if (len > 0 && dir[len-1] == '/') {",
                "// Line 587:         dir[len-1] = '\u0000';",
                "// vulnerable line: 588: }",
                "// Line 589: ",
                "// Line 590:     len = strlen(rdir);",
                "// Line 591:     if (len > 0 && rdir[len-1] == '/') {",
                "// Line 592:         rdir[len-1] = '\u0000';",
                "// vulnerable line: 593: }",
                "// Line 594: ",
                "// Line 595:     if (dir[0] == '\u0000' || rdir[0] == '\u0000') {",
                "// Line 596:         pam_syslog(idata->pamh, LOG_NOTICE, \"Invalid polydir\");",
                "// Line 597:         goto skipping;",
                "// vulnerable line: 598: }",
                "// Line 599: ",
                "// Line 600:     /*",
                "// Line 601:      * Populate polyinstantiated directory structure with appropriate",
                "// Line 602:      * pathnames and the method with which to polyinstantiate.",
                "// Line 603:      */",
                "// Line 604:     if (parse_method(method, poly, idata) != 0) {",
                "// Line 605:         goto skipping;",
                "// vulnerable line: 606: }",
                "// Line 607: ",
                "// Line 608: #define COPY_STR(dst, src, apd)                                    (snprintf((dst), sizeof(dst), \"%s%s\", (src), (apd)) !=           (ssize_t) (strlen(src) + strlen(apd)))",
                "// Line 609: ",
                "// Line 610:     if (COPY_STR(poly->dir, dir, \"\")",
                "// Line 611:     || COPY_STR(poly->rdir, rdir, \"\")",
                "// Line 612:     || COPY_STR(poly->instance_prefix, instance_prefix,",
                "// Line 613:             poly->method == TMPDIR ? \"XXXXXX\" : \"\")) {",
                "// Line 614:     pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames too long\");",
                "// Line 615:     goto skipping;",
                "// vulnerable line: 616: }",
                "// Line 617: ",
                "// Line 618:     /*",
                "// Line 619:      * Ensure that all pathnames are absolute path names.",
                "// Line 620:      */",
                "// Line 621:     if ((poly->dir[0] != '/') || (poly->method != TMPFS && poly->instance_prefix[0] != '/')) {",
                "// Line 622:         pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must start with '/'\");",
                "// Line 623:         goto skipping;",
                "// vulnerable line: 624: }",
                "// Line 625:     if (strstr(dir, \"..\") || strstr(poly->instance_prefix, \"..\")) {",
                "// Line 626:         pam_syslog(idata->pamh, LOG_NOTICE, \"Pathnames must not contain '..'\");",
                "// Line 627:         goto skipping;",
                "// vulnerable line: 628: }",
                "// Line 629: ",
                "// Line 630:     /*",
                "// Line 631:      * If the line in namespace.conf for a directory to polyinstantiate",
                "// Line 632:      * contains a list of override users (users for whom polyinstantiation",
                "// Line 633:      * is not performed), read the user ids, convert names into uids, and",
                "// Line 634:      * add to polyinstantiated directory structure.",
                "// Line 635:      */",
                "// Line 636:     if (uids) {",
                "// Line 637:         uid_t *uidptr;",
                "// Line 638:         const char *ustr, *sstr;",
                "// Line 639:         size_t count, i;",
                "// Line 640: ",
                "// Line 641:     if (*uids == '~') {",
                "// Line 642:         poly->flags |= POLYDIR_EXCLUSIVE;",
                "// Line 643:         uids++;",
                "// vulnerable line: 644: }",
                "// Line 645:         for (count = 0, ustr = sstr = uids; sstr; ustr = sstr + 1, count++)",
                "// Line 646:            sstr = strchr(ustr, ',');",
                "// Line 647: ",
                "// Line 648:         if (count > UINT_MAX || count > SIZE_MAX / sizeof(uid_t)) {",
                "// Line 649:             pam_syslog(idata->pamh, LOG_ERR, \"Too many uids encountered in configuration\");",
                "// Line 650:             goto skipping;",
                "// vulnerable line: 651: }",
                "// Line 652: ",
                "// Line 653:         poly->num_uids = count;",
                "// Line 654:         poly->uid = malloc(count * sizeof (uid_t));",
                "// Line 655:         uidptr = poly->uid;",
                "// Line 656:         if (uidptr == NULL) {",
                "// Line 657:             goto erralloc;",
                "// vulnerable line: 658: }",
                "// Line 659: ",
                "// Line 660:         ustr = uids;",
                "// Line 661:         for (i = 0; i < count; i++) {",
                "// Line 662:             struct passwd *pwd;",
                "// Line 663: ",
                "// Line 664:             tptr = strchr(ustr, ',');",
                "// Line 665:             if (tptr)",
                "// Line 666:                 *tptr = '\u0000';",
                "// Line 667: ",
                "// Line 668:             pwd = pam_modutil_getpwnam(idata->pamh, ustr);",
                "// Line 669:             if (pwd == NULL) {",
                "// Line 670:         pam_syslog(idata->pamh, LOG_ERR, \"Unknown user %s in configuration\", ustr);",
                "// Line 671:         poly->num_uids--;",
                "// Line 672:             } else {",
                "// Line 673:                 *uidptr = pwd->pw_uid;",
                "// Line 674:                 uidptr++;",
                "// vulnerable line: 675: }",
                "// Line 676:             ustr = tptr + 1;",
                "// vulnerable line: 677: }",
                "// vulnerable line: 678: }",
                "// Line 679: ",
                "// Line 680:     /*",
                "// Line 681:      * Add polyinstantiated directory structure to the linked list",
                "// Line 682:      * of all polyinstantiated directory structures.",
                "// Line 683:      */",
                "// Line 684:     add_polydir_entry(idata, poly);",
                "// Line 685: ",
                "// Line 686:     goto out;",
                "// Line 687: ",
                "// Line 688: erralloc:",
                "// Line 693:         retval = 0;",
                "// Line 694:     else",
                "// Line 695:         retval = PAM_SERVICE_ERR;",
                "// Line 696:     del_polydir(poly);",
                "// Line 697: out:",
                "// Line 698:     free(rdir);",
                "// Line 699:     free(dir);",
                "// Line 700:     free(instance_prefix);",
                "// Line 701:     argv_free(config_options);",
                "// Line 702:     return retval;",
                "// vulnerable line: 703: }",
                "// Line 704: ",
                "// Line 705: ",
                "// Line 706: /*",
                "// Line 707:  * Parses /etc/security/namespace.conf file to build a linked list of",
                "// Line 708:  * polyinstantiated directory structures of type polydir_s. Each entry",
                "// Line 709:  * in the linked list contains information needed to polyinstantiate",
                "// Line 710:  * one directory.",
                "// Line 711:  */",
                "// Line 712: static int parse_config_file(struct instance_data *idata)",
                "// Line 713: {",
                "// Line 722: ",
                "// Line 723:     /*",
                "// Line 724:      * Extract the user's home directory to resolve $HOME entries",
                "// Line 725:      * in the namespace configuration file.",
                "// Line 726:      */",
                "// Line 727:     cpwd = pam_modutil_getpwnam(idata->pamh, idata->user);",
                "// Line 728:     if (!cpwd) {",
                "// Line 729:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 730:                \"Error getting home dir for '%s'\", idata->user);",
                "// Line 731:         return PAM_SESSION_ERR;",
                "// vulnerable line: 732: }",
                "// Line 733:     if ((home=strdup(cpwd->pw_dir)) == NULL) {",
                "// Line 734:     pam_syslog(idata->pamh, LOG_CRIT,",
                "// Line 735:         \"Memory allocation error\");",
                "// Line 736:     return PAM_SESSION_ERR;",
                "// vulnerable line: 737: }",
                "// Line 738: ",
                "// Line 739:     cpwd = pam_modutil_getpwnam(idata->pamh, idata->ruser);",
                "// Line 740:     if (!cpwd) {",
                "// Line 741:     pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 742:             \"Error getting home dir for '%s'\", idata->ruser);",
                "// Line 743:     free(home);",
                "// Line 744:     return PAM_SESSION_ERR;",
                "// vulnerable line: 745: }",
                "// Line 746: ",
                "// Line 747:     if ((rhome=strdup(cpwd->pw_dir)) == NULL) {",
                "// Line 748:     pam_syslog(idata->pamh, LOG_CRIT,",
                "// Line 749:         \"Memory allocation error\");",
                "// Line 750:     free(home);",
                "// Line 751:     return PAM_SESSION_ERR;",
                "// vulnerable line: 752: }",
                "// Line 753: ",
                "// Line 754:     /*",
                "// Line 755:      * Open configuration file, read one line at a time and call",
                "// Line 756:      * process_line to process each line.",
                "// Line 757:      */",
                "// Line 758: ",
                "// Line 759:     confname = PAM_NAMESPACE_CONFIG;",
                "// Line 760: #ifdef VENDOR_PAM_NAMESPACE_CONFIG",
                "// Line 761:     /* Check whether PAM_NAMESPACE_CONFIG file is available.",
                "// Line 762:      * If it does not exist, fall back to VENDOR_PAM_NAMESPACE_CONFIG file. */",
                "// Line 763:     struct stat buffer;",
                "// Line 764:     if (stat(confname, &buffer) != 0 && errno == ENOENT) {",
                "// Line 765:     confname = VENDOR_PAM_NAMESPACE_CONFIG;",
                "// vulnerable line: 766: }",
                "// Line 767: #endif",
                "// Line 768:     char **filename_list = read_namespace_dir(idata);",
                "// Line 769:     n = 0;",
                "// Line 770:     for (;;) {",
                "// Line 771:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 772:         pam_syslog(idata->pamh, LOG_DEBUG, \"Parsing config file %s\",",
                "// Line 773:             confname);",
                "// Line 774:     fil = fopen(confname, \"r\");",
                "// Line 775:     if (fil == NULL) {",
                "// Line 776:         pam_syslog(idata->pamh, LOG_ERR, \"Error opening config file %s\",",
                "// Line 777:         confname);",
                "// Line 778:         free(rhome);",
                "// Line 779:         free(home);",
                "// Line 780:         return PAM_SERVICE_ERR;",
                "// vulnerable line: 781: }",
                "// Line 782: ",
                "// Line 783:     /* Use unlocked IO */",
                "// Line 784:     __fsetlocking(fil, FSETLOCKING_BYCALLER);",
                "// Line 785: ",
                "// Line 786:     line = NULL;",
                "// Line 787:     /* loop reading the file */",
                "// Line 788:     while (getline(&line, &len, fil) > 0) {",
                "// Line 789:         retval = process_line(line, home, rhome, idata);",
                "// Line 790:         if (retval) {",
                "// Line 791:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 792:         \"Error processing conf file %s line %s\", confname, line);",
                "// Line 793:             fclose(fil);",
                "// Line 794:             free(line);",
                "// Line 795:             free(rhome);",
                "// Line 796:             free(home);",
                "// Line 797:             return PAM_SERVICE_ERR;",
                "// vulnerable line: 798: }",
                "// vulnerable line: 799: }",
                "// Line 800:     fclose(fil);",
                "// Line 801:     free(line);",
                "// Line 802: ",
                "// Line 803:     if (filename_list == NULL || filename_list[n] == NULL)",
                "// Line 804:         break;",
                "// Line 805: ",
                "// Line 806:     confname = filename_list[n++];",
                "// vulnerable line: 807: }",
                "// Line 808: ",
                "// Line 809:     if (filename_list != NULL) {",
                "// Line 810:     for (size_t i = 0; filename_list[i] != NULL; i++)",
                "// Line 811:         free(filename_list[i]);",
                "// Line 812:     free(filename_list);",
                "// vulnerable line: 813: }",
                "// Line 814: ",
                "// Line 815:     free(rhome);",
                "// Line 816:     free(home);",
                "// Line 817: ",
                "// Line 818:     /* All done...just some debug stuff */",
                "// Line 819:     if (idata->flags & PAMNS_DEBUG) {",
                "// Line 820:         struct polydir_s *dptr = idata->polydirs_ptr;",
                "// Line 821:         uid_t *iptr;",
                "// Line 822:         uid_t i;",
                "// Line 823: ",
                "// Line 824:         pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 825:         dptr?\"Configured poly dirs:\":\"No configured poly dirs\");",
                "// Line 826:         while (dptr) {",
                "// Line 827:             pam_syslog(idata->pamh, LOG_DEBUG, \"dir='%s' iprefix='%s' meth=%d\",",
                "// Line 828:            dptr->dir, dptr->instance_prefix, dptr->method);",
                "// Line 829:             for (i = 0, iptr = dptr->uid; i < dptr->num_uids; i++, iptr++)",
                "// Line 830:                 pam_syslog(idata->pamh, LOG_DEBUG, \"override user %d \", *iptr);",
                "// Line 831:             dptr = dptr->next;",
                "// vulnerable line: 832: }",
                "// vulnerable line: 833: }",
                "// Line 834: ",
                "// Line 835:     return PAM_SUCCESS;",
                "// vulnerable line: 836: }",
                "// Line 837: ",
                "// Line 838: ",
                "// Line 839: /*",
                "// Line 840:  * This function returns true if a given uid is present in the polyinstantiated",
                "// Line 841:  * directory's list of override uids. If the uid is one of the override",
                "// Line 842:  * uids for the polyinstantiated directory, polyinstantiation is not",
                "// Line 843:  * performed for that user for that directory.",
                "// Line 844:  * If exclusive is set the returned values are opposite.",
                "// Line 845:  */",
                "// Line 846: static int ns_override(struct polydir_s *polyptr, struct instance_data *idata,",
                "// Line 849:     unsigned int i;",
                "// Line 850: ",
                "// Line 851:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 852:     pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 853:         \"Checking for ns override in dir %s for uid %d\",",
                "// Line 854:         polyptr->dir, uid);",
                "// Line 855: ",
                "// Line 856:     for (i = 0; i < polyptr->num_uids; i++) {",
                "// Line 857:         if (uid == polyptr->uid[i]) {",
                "// Line 858:             return !(polyptr->flags & POLYDIR_EXCLUSIVE);",
                "// vulnerable line: 859: }",
                "// vulnerable line: 860: }",
                "// Line 861: ",
                "// Line 862:     return !!(polyptr->flags & POLYDIR_EXCLUSIVE);",
                "// vulnerable line: 863: }",
                "// Line 864: ",
                "// Line 865: /*",
                "// Line 866:  * md5hash generates a hash of the passed in instance directory name.",
                "// Line 867:  */",
                "// Line 868: static char *md5hash(const char *instname, struct instance_data *idata)",
                "// Line 869: {",
                "// Line 870:     int i;",
                "// Line 871:     char *md5inst = NULL;",
                "// Line 872:     char *to;",
                "// Line 873:     unsigned char inst_digest[MD5_DIGEST_LENGTH];",
                "// Line 874: ",
                "// Line 875:     /*",
                "// Line 876:      * Create MD5 hashes for instance pathname.",
                "// Line 877:      */",
                "// Line 878: ",
                "// Line 879:     MD5((const unsigned char *)instname, strlen(instname), inst_digest);",
                "// Line 880: ",
                "// Line 881:     if ((md5inst = malloc(MD5_DIGEST_LENGTH * 2 + 1)) == NULL) {",
                "// Line 882:         pam_syslog(idata->pamh, LOG_CRIT, \"Unable to allocate buffer\");",
                "// Line 883:         return NULL;",
                "// vulnerable line: 884: }",
                "// Line 885: ",
                "// Line 886:     to = md5inst;",
                "// Line 887:     for (i = 0; i < MD5_DIGEST_LENGTH; i++) {",
                "// Line 888:         snprintf(to, 3, \"%02x\", (unsigned int)inst_digest[i]);",
                "// Line 889:         to += 2;",
                "// vulnerable line: 890: }",
                "// Line 891: ",
                "// Line 892:     return md5inst;",
                "// vulnerable line: 893: }",
                "// Line 894: ",
                "// Line 895: #ifdef WITH_SELINUX",
                "// Line 896: static int form_context(const struct polydir_s *polyptr,",
                "// Line 897:         char **i_context, char **origcon,",
                "// Line 898:         struct instance_data *idata)",
                "// Line 899: {",
                "// Line 900:     int rc = PAM_SUCCESS;",
                "// Line 901:     char *scon = NULL;",
                "// Line 902:     security_class_t tclass;",
                "// Line 903: ",
                "// Line 904:     /*",
                "// Line 905:      * Get the security context of the directory to polyinstantiate.",
                "// Line 906:      */",
                "// Line 907:     rc = getfilecon(polyptr->dir, origcon);",
                "// Line 908:     if (rc < 0 || *origcon == NULL) {",
                "// Line 909:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 910:                 \"Error getting poly dir context, %m\");",
                "// Line 911:         return PAM_SESSION_ERR;",
                "// vulnerable line: 912: }",
                "// Line 913: ",
                "// Line 914:     if (polyptr->method == USER) return PAM_SUCCESS;",
                "// Line 915: ",
                "// Line 916:     if (idata->flags & PAMNS_USE_CURRENT_CONTEXT) {",
                "// Line 917:         rc = getcon(&scon);",
                "// Line 918:     } else if (idata->flags & PAMNS_USE_DEFAULT_CONTEXT) {",
                "// Line 919:         char *seuser = NULL, *level = NULL;",
                "// Line 920: ",
                "// Line 921:         if ((rc=getseuserbyname(idata->user, &seuser, &level)) == 0) {",
                "// Line 922:             rc = get_default_context_with_level(seuser, level, NULL, &scon);",
                "// Line 923:             free(seuser);",
                "// Line 924:             free(level);",
                "// vulnerable line: 925: }",
                "// Line 926:     } else {",
                "// Line 927:         rc = getexeccon(&scon);",
                "// vulnerable line: 928: }",
                "// Line 929:     if (rc < 0 || scon == NULL) {",
                "// Line 930:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 931:                \"Error getting exec context, %m\");",
                "// Line 932:         return PAM_SESSION_ERR;",
                "// vulnerable line: 933: }",
                "// Line 934: ",
                "// Line 935:     /*",
                "// Line 936:      * If polyinstantiating based on security context, get current",
                "// Line 937:      * process security context, get security class for directories,",
                "// Line 938:      * and ask the policy to provide security context of the",
                "// Line 939:      * polyinstantiated instance directory.",
                "// Line 940:      */",
                "// Line 941: ",
                "// Line 942:     if (polyptr->method == CONTEXT) {",
                "// Line 943:         tclass = string_to_security_class(\"dir\");",
                "// Line 944:         if (tclass == 0) {",
                "// Line 945:             pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 946:                    \"Error getting dir security class\");",
                "// Line 947:             freecon(scon);",
                "// Line 948:             return PAM_SESSION_ERR;",
                "// vulnerable line: 949: }",
                "// Line 950: ",
                "// Line 951:         if (security_compute_member(scon, *origcon, tclass,",
                "// Line 952:                     i_context) < 0) {",
                "// Line 953:             pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 954:                     \"Error computing poly dir member context\");",
                "// Line 955:             freecon(scon);",
                "// Line 956:             return PAM_SESSION_ERR;",
                "// Line 957:         } else if (idata->flags & PAMNS_DEBUG)",
                "// Line 958:             pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 959:                     \"member context returned by policy %s\", *i_context);",
                "// Line 960:         freecon(scon);",
                "// Line 961:         return PAM_SUCCESS;",
                "// vulnerable line: 962: }",
                "// Line 963: ",
                "// Line 964:     /*",
                "// Line 965:      * If polyinstantiating based on security level, get current",
                "// Line 966:      * process security context, get security class for directories,",
                "// Line 967:      * and change the directories MLS Level to match process.",
                "// Line 968:      */",
                "// Line 969: ",
                "// Line 970:     if (polyptr->method == LEVEL) {",
                "// Line 971:         context_t scontext = NULL;",
                "// Line 972:         context_t fcontext = NULL;",
                "// Line 973:         rc = PAM_SESSION_ERR;",
                "// Line 974: ",
                "// Line 975:         scontext = context_new(scon);",
                "// Line 976:         if (! scontext) {",
                "// Line 977:             pam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");",
                "// Line 978:             goto fail;",
                "// vulnerable line: 979: }",
                "// Line 980:         fcontext = context_new(*origcon);",
                "// Line 981:         if (! fcontext) {",
                "// Line 982:             pam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");",
                "// Line 983:             goto fail;",
                "// vulnerable line: 984: }",
                "// Line 985:         if (context_range_set(fcontext, context_range_get(scontext)) != 0) {",
                "// Line 986:             pam_syslog(idata->pamh, LOG_ERR, \"Unable to set MLS Component of context\");",
                "// Line 987:             goto fail;",
                "// vulnerable line: 988: }",
                "// Line 989:         *i_context=strdup(context_str(fcontext));",
                "// Line 990:         if (! *i_context) {",
                "// Line 991:             pam_syslog(idata->pamh, LOG_CRIT, \"out of memory\");",
                "// Line 992:             goto fail;",
                "// vulnerable line: 993: }",
                "// Line 994: ",
                "// Line 995:         rc = PAM_SUCCESS;",
                "// Line 996:  fail:",
                "// Line 997:         context_free(scontext);",
                "// Line 998:         context_free(fcontext);",
                "// Line 999:         freecon(scon);",
                "// Line 1000:         return rc;",
                "// vulnerable line: 1001: }",
                "// Line 1002:     /* Should never get here */",
                "// Line 1003:     return PAM_SUCCESS;",
                "// vulnerable line: 1004: }",
                "// Line 1005: #endif",
                "// Line 1006: ",
                "// Line 1007: /*",
                "// Line 1008:  * poly_name returns the name of the polyinstantiated instance directory",
                "// Line 1009:  * based on the method used for polyinstantiation (user, context or level)",
                "// Line 1010:  * In addition, the function also returns the security contexts of the",
                "// Line 1011:  * original directory to polyinstantiate and the polyinstantiated instance",
                "// Line 1012:  * directory.",
                "// Line 1013:  */",
                "// Line 1014: #ifdef WITH_SELINUX",
                "// Line 1027:     char *rawcon = NULL;",
                "// Line 1028: #endif",
                "// Line 1029: ",
                "// Line 1030:     *i_name = NULL;",
                "// Line 1031: #ifdef WITH_SELINUX",
                "// Line 1032:     *i_context = NULL;",
                "// Line 1033:     *origcon = NULL;",
                "// Line 1034:     if ((idata->flags & PAMNS_SELINUX_ENABLED) &&",
                "// Line 1035:     (rc=form_context(polyptr, i_context, origcon, idata)) != PAM_SUCCESS) {",
                "// Line 1036:         return rc;",
                "// vulnerable line: 1037: }",
                "// Line 1038: #endif",
                "// Line 1039: ",
                "// Line 1040:     rc = PAM_SESSION_ERR;",
                "// Line 1041:     /*",
                "// Line 1042:      * Set the name of the polyinstantiated instance dir based on the",
                "// Line 1043:      * polyinstantiation method.",
                "// Line 1044:      */",
                "// Line 1045: ",
                "// Line 1046:     pm = polyptr->method;",
                "// Line 1047:     if (pm == LEVEL || pm == CONTEXT)",
                "// Line 1048: #ifdef WITH_SELINUX",
                "// Line 1049:         if (!(idata->flags & PAMNS_CTXT_BASED_INST)) {",
                "// Line 1050: #else",
                "// Line 1051:     {",
                "// Line 1052:     pam_syslog(idata->pamh, LOG_NOTICE,",
                "// Line 1053:         \"Context and level methods not available, using user method\");",
                "// Line 1054: #endif",
                "// Line 1055:     if (polyptr->flags & POLYDIR_SHARED) {",
                "// Line 1056:         rc = PAM_IGNORE;",
                "// Line 1057:         goto fail;",
                "// vulnerable line: 1058: }",
                "// Line 1059:         pm = USER;",
                "// vulnerable line: 1060: }",
                "// Line 1061: ",
                "// Line 1062:     switch (pm) {",
                "// Line 1063:         case USER:",
                "// Line 1064:         if (asprintf(i_name, \"%s\", idata->user) < 0) {",
                "// Line 1065:         *i_name = NULL;",
                "// Line 1066:         goto fail;",
                "// vulnerable line: 1067: }",
                "// Line 1068:         break;",
                "// Line 1069: ",
                "// Line 1070: #ifdef WITH_SELINUX",
                "// Line 1071:     case LEVEL:",
                "// Line 1072:         case CONTEXT:",
                "// Line 1073:         if (selinux_trans_to_raw_context(*i_context, &rawcon) < 0) {",
                "// Line 1074:         pam_syslog(idata->pamh, LOG_ERR, \"Error translating directory context\");",
                "// Line 1075:         goto fail;",
                "// vulnerable line: 1076: }",
                "// Line 1077:         if (polyptr->flags & POLYDIR_SHARED) {",
                "// Line 1078:         if (asprintf(i_name, \"%s\", rawcon) < 0) {",
                "// Line 1079:             *i_name = NULL;",
                "// Line 1080:             goto fail;",
                "// vulnerable line: 1081: }",
                "// Line 1082:         } else {",
                "// Line 1083:         if (asprintf(i_name, \"%s_%s\", rawcon, idata->user) < 0) {",
                "// Line 1084:             *i_name = NULL;",
                "// Line 1085:             goto fail;",
                "// vulnerable line: 1086: }",
                "// vulnerable line: 1087: }",
                "// Line 1088:         break;",
                "// Line 1089: ",
                "// Line 1090: #endif /* WITH_SELINUX */",
                "// Line 1091: ",
                "// Line 1092:     case TMPDIR:",
                "// Line 1093:     case TMPFS:",
                "// Line 1094:         if ((*i_name=strdup(\"\")) == NULL)",
                "// Line 1095:         goto fail;",
                "// Line 1096:         return PAM_SUCCESS;",
                "// Line 1097: ",
                "// Line 1098:     default:",
                "// Line 1099:         if (idata->flags & PAMNS_DEBUG)",
                "// Line 1100:             pam_syslog(idata->pamh, LOG_ERR, \"Unknown method\");",
                "// Line 1101:         goto fail;",
                "// vulnerable line: 1102: }",
                "// Line 1103: ",
                "// Line 1104:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 1105:         pam_syslog(idata->pamh, LOG_DEBUG, \"poly_name %s\", *i_name);",
                "// Line 1106: ",
                "// Line 1107:     if ((idata->flags & PAMNS_GEN_HASH) || strlen(*i_name) > NAMESPACE_MAX_DIR_LEN) {",
                "// Line 1108:         hash = md5hash(*i_name, idata);",
                "// Line 1109:         if (hash == NULL) {",
                "// Line 1110:         goto fail;",
                "// vulnerable line: 1111: }",
                "// Line 1112:         if (idata->flags & PAMNS_GEN_HASH) {",
                "// Line 1113:         free(*i_name);",
                "// Line 1114:         *i_name = hash;",
                "// Line 1115:         hash = NULL;",
                "// Line 1116:         } else {",
                "// Line 1117:         char *newname;",
                "// Line 1118:         if (asprintf(&newname, \"%.*s_%s\", NAMESPACE_MAX_DIR_LEN-1-(int)strlen(hash),",
                "// Line 1119:         *i_name, hash) < 0) {",
                "// Line 1120:         goto fail;",
                "// vulnerable line: 1121: }",
                "// Line 1122:         free(*i_name);",
                "// Line 1123:         *i_name = newname;",
                "// vulnerable line: 1124: }",
                "// vulnerable line: 1125: }",
                "// Line 1126:     rc = PAM_SUCCESS;",
                "// Line 1127: ",
                "// Line 1128: fail:",
                "// Line 1129:     free(hash);",
                "// Line 1130: #ifdef WITH_SELINUX",
                "// Line 1131:     freecon(rawcon);",
                "// Line 1132: #endif",
                "// Line 1133:     if (rc != PAM_SUCCESS) {",
                "// Line 1134: #ifdef WITH_SELINUX",
                "// Line 1135:     freecon(*i_context);",
                "// Line 1136:     *i_context = NULL;",
                "// Line 1137:     freecon(*origcon);",
                "// Line 1138:     *origcon = NULL;",
                "// Line 1139: #endif",
                "// Line 1140:     free(*i_name);",
                "// Line 1141:     *i_name = NULL;",
                "// vulnerable line: 1142: }",
                "// Line 1143:     return rc;",
                "// vulnerable line: 1144: }",
                "// Line 1145: ",
                "// Line 1146: static int protect_mount(int dfd, const char *path, struct instance_data *idata)",
                "// Line 1147: {",
                "// Line 1148:     struct protect_dir_s *dir = idata->protect_dirs;",
                "// Line 1149:     char tmpbuf[64];",
                "// Line 1150: ",
                "// Line 1151:     while (dir != NULL) {",
                "// Line 1152:         if (strcmp(path, dir->dir) == 0) {",
                "// Line 1153:             return 0;",
                "// vulnerable line: 1154: }",
                "// Line 1155:         dir = dir->next;",
                "// vulnerable line: 1156: }",
                "// Line 1157: ",
                "// Line 1158:     dir = calloc(1, sizeof(*dir));",
                "// Line 1159: ",
                "// Line 1160:     if (dir == NULL) {",
                "// Line 1161:         return -1;",
                "// vulnerable line: 1162: }",
                "// Line 1163: ",
                "// Line 1164:     dir->dir = strdup(path);",
                "// Line 1165: ",
                "// Line 1166:     if (dir->dir == NULL) {",
                "// Line 1167:         free(dir);",
                "// Line 1168:         return -1;",
                "// vulnerable line: 1169: }",
                "// Line 1170: ",
                "// Line 1171:     snprintf(tmpbuf, sizeof(tmpbuf), \"/proc/self/fd/%d\", dfd);",
                "// Line 1172: ",
                "// Line 1173:     if (idata->flags & PAMNS_DEBUG) {",
                "// Line 1174:         pam_syslog(idata->pamh, LOG_INFO,",
                "// Line 1175:             \"Protect mount of %s over itself\", path);",
                "// vulnerable line: 1176: }",
                "// Line 1177: ",
                "// Line 1178:     if (mount(tmpbuf, tmpbuf, NULL, MS_BIND, NULL) != 0) {",
                "// Line 1179:         int save_errno = errno;",
                "// Line 1180:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1181:             \"Protect mount of %s failed: %m\", tmpbuf);",
                "// Line 1182:         free(dir->dir);",
                "// Line 1183:         free(dir);",
                "// vulnerable line: 1184: errno = save_errno;",
                "// Line 1185:         return -1;",
                "// vulnerable line: 1186: }",
                "// Line 1187: ",
                "// Line 1188:     dir->next = idata->protect_dirs;",
                "// Line 1189:     idata->protect_dirs = dir;",
                "// Line 1190: ",
                "// Line 1191:     return 0;",
                "// vulnerable line: 1192: }",
                "// Line 1193: ",
                "// Line 1194: static int protect_dir(const char *path, mode_t mode, int do_mkdir,",
                "// Line 1195:     struct instance_data *idata)",
                "// Line 1196: {",
                "// Line 1197:     char *p = strdup(path);",
                "// Line 1198:     char *d;",
                "// Line 1199:     char *dir = p;",
                "// Line 1200:     int dfd = AT_FDCWD;",
                "// Line 1201:     int dfd_next;",
                "// Line 1202:     int save_errno;",
                "// vulnerable line: 1203: int flags = O_RDONLY;",
                "// Line 1204:     int rv = -1;",
                "// Line 1205:     struct stat st;",
                "// Line 1206: ",
                "// Line 1207:     if (p == NULL) {",
                "// vulnerable line: 1208: goto error;",
                "// vulnerable line: 1209: }",
                "// Line 1210: ",
                "// Line 1211:     if (*dir == '/') {",
                "// Line 1212:         dfd = open(\"/\", flags);",
                "// Line 1213:         if (dfd == -1) {",
                "// vulnerable line: 1214: goto error;",
                "// vulnerable line: 1215: }",
                "// Line 1216:         dir++;    /* assume / is safe */",
                "// vulnerable line: 1217: }",
                "// Line 1218: ",
                "// Line 1219:     while ((d=strchr(dir, '/')) != NULL) {",
                "// Line 1220:         *d = '\u0000';",
                "// Line 1221:         dfd_next = openat(dfd, dir, flags);",
                "// Line 1222:         if (dfd_next == -1) {",
                "// vulnerable line: 1223: goto error;",
                "// vulnerable line: 1224: }",
                "// Line 1225: ",
                "// Line 1226:         if (dfd != AT_FDCWD)",
                "// Line 1227:             close(dfd);",
                "// Line 1228:         dfd = dfd_next;",
                "// Line 1229: ",
                "// Line 1230:         if (fstat(dfd, &st) != 0) {",
                "// vulnerable line: 1231: goto error;",
                "// vulnerable line: 1232: }",
                "// Line 1233: ",
                "// Line 1234:         if (flags & O_NOFOLLOW) {",
                "// Line 1235:             /* we are inside user-owned dir - protect */",
                "// Line 1236:             if (protect_mount(dfd, p, idata) == -1)",
                "// vulnerable line: 1237: goto error;",
                "// Line 1238:         } else if (st.st_uid != 0 || st.st_gid != 0 ||",
                "// Line 1239:             (st.st_mode & S_IWOTH)) {",
                "// Line 1240:             /* do not follow symlinks on subdirectories */",
                "// Line 1241:             flags |= O_NOFOLLOW;",
                "// vulnerable line: 1242: }",
                "// Line 1243: ",
                "// Line 1244:         *d = '/';",
                "// Line 1245:         dir = d + 1;",
                "// vulnerable line: 1246: }",
                "// Line 1247: ",
                "// Line 1248:     rv = openat(dfd, dir, flags);",
                "// Line 1249: ",
                "// Line 1250:     if (rv == -1) {",
                "// Line 1251:         if (!do_mkdir || mkdirat(dfd, dir, mode) != 0) {",
                "// vulnerable line: 1252: goto error;",
                "// vulnerable line: 1253: }",
                "// Line 1254:         rv = openat(dfd, dir, flags);",
                "// vulnerable line: 1255: }",
                "// Line 1256: ",
                "// vulnerable line: 1257: if (rv != -1) {",
                "// vulnerable line: 1258: if (fstat(rv, &st) != 0) {",
                "// vulnerable line: 1259: save_errno = errno;",
                "// vulnerable line: 1260: close(rv);",
                "// vulnerable line: 1261: rv = -1;",
                "// vulnerable line: 1262: errno = save_errno;",
                "// vulnerable line: 1263: goto error;",
                "// vulnerable line: 1264: }",
                "// vulnerable line: 1265: if (!S_ISDIR(st.st_mode)) {",
                "// vulnerable line: 1266: close(rv);",
                "// vulnerable line: 1267: errno = ENOTDIR;",
                "// vulnerable line: 1268: rv = -1;",
                "// vulnerable line: 1269: goto error;",
                "// vulnerable line: 1270: }",
                "// vulnerable line: 1271: }",
                "// Line 1272: ",
                "// Line 1273:     if (flags & O_NOFOLLOW) {",
                "// Line 1274:         /* we are inside user-owned dir - protect */",
                "// Line 1275:         if (protect_mount(rv, p, idata) == -1) {",
                "// vulnerable line: 1276: save_errno = errno;",
                "// vulnerable line: 1277: close(rv);",
                "// vulnerable line: 1278: rv = -1;",
                "// vulnerable line: 1279: errno = save_errno;",
                "// vulnerable line: 1280: }",
                "// vulnerable line: 1281: }",
                "// Line 1282: ",
                "// Line 1283: error:",
                "// vulnerable line: 1284: save_errno = errno;",
                "// Line 1285:     free(p);",
                "// Line 1286:     if (dfd != AT_FDCWD && dfd >= 0)",
                "// Line 1287:         close(dfd);",
                "// vulnerable line: 1288: errno = save_errno;",
                "// Line 1289: ",
                "// Line 1290:     return rv;",
                "// vulnerable line: 1291: }",
                "// Line 1292: ",
                "// Line 1293: static int check_inst_parent(char *ipath, struct instance_data *idata)",
                "// Line 1294: {",
                "// Line 1295:     struct stat instpbuf;",
                "// Line 1296:     char *inst_parent, *trailing_slash;",
                "// Line 1297:     int dfd;",
                "// Line 1298:     /*",
                "// Line 1299:      * stat the instance parent path to make sure it exists",
                "// Line 1300:      * and is a directory. Check that its mode is 000 (unless the",
                "// Line 1301:      * admin explicitly instructs to ignore the instance parent",
                "// Line 1302:      * mode by the \"ignore_instance_parent_mode\" argument).",
                "// Line 1303:      */",
                "// Line 1304:     inst_parent = strdup(ipath);",
                "// Line 1305:     if (!inst_parent) {",
                "// Line 1306:         pam_syslog(idata->pamh, LOG_CRIT, \"Error allocating pathname string\");",
                "// Line 1307:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1308: }",
                "// Line 1309: ",
                "// Line 1310:     trailing_slash = strrchr(inst_parent, '/');",
                "// Line 1311:     if (trailing_slash)",
                "// Line 1312:         *trailing_slash = '\u0000';",
                "// Line 1313: ",
                "// Line 1314:     dfd = protect_dir(inst_parent, 0, 1, idata);",
                "// Line 1315: ",
                "// Line 1316:     if (dfd == -1 || fstat(dfd, &instpbuf) < 0) {",
                "// Line 1317:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1318:             \"Error creating or accessing instance parent %s, %m\", inst_parent);",
                "// Line 1319:         if (dfd != -1)",
                "// Line 1320:             close(dfd);",
                "// Line 1321:         free(inst_parent);",
                "// Line 1322:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1323: }",
                "// Line 1324: ",
                "// Line 1325:     if ((idata->flags & PAMNS_IGN_INST_PARENT_MODE) == 0) {",
                "// Line 1326:         if ((instpbuf.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) || instpbuf.st_uid != 0) {",
                "// Line 1327:             pam_syslog(idata->pamh, LOG_ERR, \"Mode of inst parent %s not 000 or owner not root\",",
                "// Line 1328:                     inst_parent);",
                "// Line 1329:             close(dfd);",
                "// Line 1330:             free(inst_parent);",
                "// Line 1331:             return PAM_SESSION_ERR;",
                "// vulnerable line: 1332: }",
                "// vulnerable line: 1333: }",
                "// Line 1334:     close(dfd);",
                "// Line 1335:     free(inst_parent);",
                "// Line 1336:     return PAM_SUCCESS;",
                "// vulnerable line: 1337: }",
                "// Line 1338: ",
                "// Line 1339: /*",
                "// Line 1340: * Check to see if there is a namespace initialization script in",
                "// Line 1341: * the /etc/security directory. If such a script exists",
                "// Line 1342: * execute it and pass directory to polyinstantiate and instance",
                "// Line 1343: * directory as arguments.",
                "// Line 1344: */",
                "// Line 1345: static int inst_init(const struct polydir_s *polyptr, const char *ipath,",
                "// Line 1346:        struct instance_data *idata, int newdir)",
                "// Line 1347: {",
                "// Line 1348:     pid_t rc, pid;",
                "// Line 1349:     int status;",
                "// Line 1350:     const char *init_script = NAMESPACE_INIT_SCRIPT;",
                "// Line 1351: ",
                "// Line 1352: #ifdef VENDOR_NAMESPACE_INIT_SCRIPT",
                "// Line 1353:     /* Check whether NAMESPACE_INIT_SCRIPT file is available.",
                "// Line 1354:      * If it does not exist, fall back to VENDOR_NAMESPACE_INIT_SCRIPT file. */",
                "// Line 1355:     struct stat buffer;",
                "// Line 1356:     if (stat(init_script, &buffer) != 0 && errno == ENOENT) {",
                "// Line 1357:         init_script = VENDOR_NAMESPACE_INIT_SCRIPT;",
                "// vulnerable line: 1358: }",
                "// Line 1359: #endif",
                "// Line 1360: ",
                "// Line 1361:     if ((polyptr->flags & POLYDIR_ISCRIPT) && polyptr->init_script)",
                "// Line 1362:         init_script = polyptr->init_script;",
                "// Line 1363: ",
                "// Line 1364:     if (access(init_script, F_OK) == 0) {",
                "// Line 1365:         if (access(init_script, X_OK) < 0) {",
                "// Line 1366:             if (idata->flags & PAMNS_DEBUG)",
                "// Line 1367:                 pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1368:                         \"Namespace init script not executable\");",
                "// Line 1369:             return PAM_SESSION_ERR;",
                "// Line 1370:         } else {",
                "// Line 1371:             struct sigaction newsa, oldsa;",
                "// Line 1372: ",
                "// Line 1373:             memset(&newsa, '\u0000', sizeof(newsa));",
                "// Line 1374:             newsa.sa_handler = SIG_DFL;",
                "// Line 1375:             if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {",
                "// Line 1376:                 pam_syslog(idata->pamh, LOG_ERR, \"failed to reset SIGCHLD handler\");",
                "// Line 1377:                 return PAM_SESSION_ERR;",
                "// vulnerable line: 1378: }",
                "// Line 1379: ",
                "// Line 1380:             pid = fork();",
                "// Line 1381:             if (pid == 0) {",
                "// Line 1382:                 static char *envp[] = { NULL };",
                "// Line 1383: #ifdef WITH_SELINUX",
                "// Line 1384:                 if (idata->flags & PAMNS_SELINUX_ENABLED) {",
                "// Line 1385:                     if (setexeccon(NULL) < 0)",
                "// Line 1386:                         _exit(1);",
                "// vulnerable line: 1387: }",
                "// Line 1388: #endif",
                "// Line 1389:                 /* Pass maximum privs when we exec() */",
                "// Line 1390:                 if (setuid(geteuid()) < 0) {",
                "// Line 1391:                     /* ignore failures, they don't matter */",
                "// vulnerable line: 1392: }",
                "// Line 1393: ",
                "// Line 1394:                 close_fds_pre_exec(idata);",
                "// Line 1395: ",
                "// Line 1396:                 if (execle(init_script, init_script,",
                "// Line 1397:                     polyptr->dir, ipath, newdir?\"1\":\"0\", idata->user, NULL, envp) < 0)",
                "// Line 1398:                     _exit(1);",
                "// Line 1399:             } else if (pid > 0) {",
                "// Line 1400:                 while (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&",
                "// Line 1401:                         (errno == EINTR));",
                "// Line 1402:                 if (rc == (pid_t)-1) {",
                "// Line 1403:                     pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed- %m\");",
                "// Line 1404:                     rc = PAM_SESSION_ERR;",
                "// Line 1405:                     goto out;",
                "// vulnerable line: 1406: }",
                "// Line 1407:                 if (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {",
                "// Line 1408:                     pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1409:                             \"Error initializing instance\");",
                "// Line 1410:                     rc = PAM_SESSION_ERR;",
                "// Line 1411:                     goto out;",
                "// vulnerable line: 1412: }",
                "// Line 1413:             } else if (pid < 0) {",
                "// Line 1414:                 pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1415:                         \"Cannot fork to run namespace init script, %m\");",
                "// Line 1416:                 rc = PAM_SESSION_ERR;",
                "// Line 1417:                 goto out;",
                "// vulnerable line: 1418: }",
                "// Line 1419:             rc = PAM_SUCCESS;",
                "// Line 1420: out:",
                "// Line 1421:             (void) sigaction(SIGCHLD, &oldsa, NULL);",
                "// Line 1422:             return rc;",
                "// vulnerable line: 1423: }",
                "// vulnerable line: 1424: }",
                "// Line 1425:     return PAM_SUCCESS;",
                "// vulnerable line: 1426: }",
                "// Line 1427: ",
                "// Line 1428: static int create_polydir(struct polydir_s *polyptr,",
                "// Line 1429:     struct instance_data *idata)",
                "// Line 1430: {",
                "// Line 1431:     mode_t mode;",
                "// Line 1432:     int rc;",
                "// Line 1433: #ifdef WITH_SELINUX",
                "// Line 1434:     char *dircon_raw, *oldcon_raw = NULL;",
                "// Line 1435:     struct selabel_handle *label_handle;",
                "// Line 1436: #endif",
                "// Line 1457:         pam_syslog(idata->pamh, LOG_NOTICE,",
                "// Line 1458:                        \"Unable to get default context for directory %s, check your policy: %m\", dir);",
                "// Line 1459:         } else {",
                "// Line 1460:         if (idata->flags & PAMNS_DEBUG)",
                "// Line 1461:             pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1462:                                \"Polydir %s context: %s\", dir, dircon_raw);",
                "// Line 1463:         if (setfscreatecon_raw(dircon_raw) != 0)",
                "// Line 1464:             pam_syslog(idata->pamh, LOG_NOTICE,",
                "// Line 1465:                                \"Error setting context for directory %s: %m\", dir);",
                "// Line 1466:         freecon(dircon_raw);",
                "// vulnerable line: 1467: }",
                "// Line 1468:         selabel_close(label_handle);",
                "// vulnerable line: 1469: }",
                "// vulnerable line: 1470: }",
                "// Line 1471: #endif",
                "// Line 1472: ",
                "// Line 1473:     rc = protect_dir(dir, mode, 1, idata);",
                "// Line 1474:     if (rc == -1) {",
                "// Line 1475:             pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1476:                        \"Error creating directory %s: %m\", dir);",
                "// Line 1477:             return PAM_SESSION_ERR;",
                "// vulnerable line: 1478: }",
                "// Line 1479: ",
                "// Line 1480: #ifdef WITH_SELINUX",
                "// Line 1481:     if (idata->flags & PAMNS_SELINUX_ENABLED) {",
                "// Line 1482:         if (setfscreatecon_raw(oldcon_raw) != 0)",
                "// Line 1483:         pam_syslog(idata->pamh, LOG_NOTICE,",
                "// Line 1484:                        \"Error resetting fs create context: %m\");",
                "// Line 1485:         freecon(oldcon_raw);",
                "// vulnerable line: 1486: }",
                "// Line 1487: #endif",
                "// Line 1488: ",
                "// Line 1489:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 1490:             pam_syslog(idata->pamh, LOG_DEBUG, \"Created polydir %s\", dir);",
                "// Line 1491: ",
                "// Line 1492:     if (polyptr->mode != (mode_t)ULONG_MAX) {",
                "// Line 1493:     /* explicit mode requested */",
                "// Line 1494:     if (fchmod(rc, mode) != 0) {",
                "// Line 1495:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1496:                \"Error changing mode of directory %s: %m\", dir);",
                "// Line 1497:                 close(rc);",
                "// Line 1498:                 umount(dir); /* undo the eventual protection bind mount */",
                "// Line 1499:         rmdir(dir);",
                "// Line 1500:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1501: }",
                "// vulnerable line: 1502: }",
                "// Line 1503: ",
                "// Line 1504:     if (polyptr->owner != (uid_t)ULONG_MAX)",
                "// Line 1505:     uid = polyptr->owner;",
                "// Line 1506:     else",
                "// Line 1507:     uid = idata->uid;",
                "// Line 1508: ",
                "// Line 1509:     if (polyptr->group != (gid_t)ULONG_MAX)",
                "// Line 1510:     gid = polyptr->group;",
                "// Line 1511:     else",
                "// Line 1512:     gid = idata->gid;",
                "// Line 1513: ",
                "// Line 1514:     if (fchown(rc, uid, gid) != 0) {",
                "// Line 1515:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1516:                    \"Unable to change owner on directory %s: %m\", dir);",
                "// Line 1517:         close(rc);",
                "// Line 1518:         umount(dir); /* undo the eventual protection bind mount */",
                "// Line 1519:     rmdir(dir);",
                "// Line 1520:     return PAM_SESSION_ERR;",
                "// vulnerable line: 1521: }",
                "// Line 1522: ",
                "// Line 1523:     close(rc);",
                "// Line 1524: ",
                "// Line 1525:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 1526:     pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1527:                \"Polydir owner %u group %u\", uid, gid);",
                "// Line 1528: ",
                "// Line 1529:     return PAM_SUCCESS;",
                "// vulnerable line: 1530: }",
                "// Line 1531: ",
                "// Line 1532: /*",
                "// Line 1533:  * Create polyinstantiated instance directory (ipath).",
                "// Line 1534:  */",
                "// Line 1535: #ifdef WITH_SELINUX",
                "// Line 1536: static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,",
                "// Line 1537:         const char *icontext, const char *ocontext,",
                "// Line 1538:     struct instance_data *idata)",
                "// Line 1539: #else",
                "// Line 1540: static int create_instance(struct polydir_s *polyptr, char *ipath, struct stat *statbuf,",
                "// Line 1556:      * attributes to match that of the original directory that is being",
                "// Line 1557:      * polyinstantiated.",
                "// Line 1558:      */",
                "// Line 1559: ",
                "// Line 1560:     if (polyptr->method == TMPDIR) {",
                "// Line 1561:     if (mkdtemp(polyptr->instance_prefix) == NULL) {",
                "// Line 1562:             pam_syslog(idata->pamh, LOG_ERR, \"Error creating temporary instance %s, %m\",",
                "// Line 1563:             polyptr->instance_prefix);",
                "// Line 1564:         polyptr->method = NONE; /* do not clean up! */",
                "// Line 1565:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1566: }",
                "// Line 1567:     /* copy the actual directory name to ipath */",
                "// Line 1568:     strcpy(ipath, polyptr->instance_prefix);",
                "// Line 1569:     } else if (mkdir(ipath, S_IRUSR) < 0) {",
                "// Line 1570:         if (errno == EEXIST)",
                "// Line 1571:             return PAM_IGNORE;",
                "// Line 1572:         else {",
                "// Line 1573:             pam_syslog(idata->pamh, LOG_ERR, \"Error creating %s, %m\",",
                "// Line 1574:             ipath);",
                "// Line 1575:             return PAM_SESSION_ERR;",
                "// vulnerable line: 1576: }",
                "// vulnerable line: 1577: }",
                "// Line 1578: ",
                "// Line 1579:     /* Open a descriptor to it to prevent races */",
                "// Line 1580:     fd = open(ipath, O_DIRECTORY | O_RDONLY);",
                "// Line 1581:     if (fd < 0) {",
                "// Line 1582:     pam_syslog(idata->pamh, LOG_ERR, \"Error opening %s, %m\", ipath);",
                "// Line 1583:     rmdir(ipath);",
                "// Line 1584:     return PAM_SESSION_ERR;",
                "// vulnerable line: 1585: }",
                "// Line 1586: #ifdef WITH_SELINUX",
                "// Line 1587:     /* If SE Linux is disabled, no need to label it */",
                "// Line 1588:     if (idata->flags & PAMNS_SELINUX_ENABLED) {",
                "// Line 1589:         /* If method is USER, icontext is NULL */",
                "// Line 1590:         if (icontext) {",
                "// Line 1591:             if (fsetfilecon(fd, icontext) < 0) {",
                "// Line 1592:                 pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1593:             \"Error setting context of %s to %s\", ipath, icontext);",
                "// Line 1594:                 close(fd);",
                "// Line 1595:         rmdir(ipath);",
                "// Line 1596:                 return PAM_SESSION_ERR;",
                "// vulnerable line: 1597: }",
                "// Line 1598:         } else {",
                "// Line 1599:             if (fsetfilecon(fd, ocontext) < 0) {",
                "// Line 1600:                 pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1601:             \"Error setting context of %s to %s\", ipath, ocontext);",
                "// Line 1602:         close(fd);",
                "// Line 1603:         rmdir(ipath);",
                "// Line 1604:                 return PAM_SESSION_ERR;",
                "// vulnerable line: 1605: }",
                "// vulnerable line: 1606: }",
                "// vulnerable line: 1607: }",
                "// Line 1608: #endif",
                "// Line 1609:     if (fstat(fd, &newstatbuf) < 0) {",
                "// Line 1610:         pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s, %m\",",
                "// Line 1611:         ipath);",
                "// Line 1612:     close(fd);",
                "// Line 1613:     rmdir(ipath);",
                "// Line 1614:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1615: }",
                "// Line 1616:     if (newstatbuf.st_uid != statbuf->st_uid ||",
                "// Line 1617:              newstatbuf.st_gid != statbuf->st_gid) {",
                "// Line 1618:         if (fchown(fd, statbuf->st_uid, statbuf->st_gid) < 0) {",
                "// Line 1619:             pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1620:             \"Error changing owner for %s, %m\",",
                "// Line 1621:             ipath);",
                "// Line 1622:         close(fd);",
                "// Line 1623:         rmdir(ipath);",
                "// Line 1624:             return PAM_SESSION_ERR;",
                "// vulnerable line: 1625: }",
                "// vulnerable line: 1626: }",
                "// Line 1627:     if (fchmod(fd, statbuf->st_mode & 07777) < 0) {",
                "// Line 1628:         pam_syslog(idata->pamh, LOG_ERR, \"Error changing mode for %s, %m\",",
                "// Line 1629:             ipath);",
                "// Line 1630:     close(fd);",
                "// Line 1631:     rmdir(ipath);",
                "// Line 1632:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1633: }",
                "// Line 1634:     close(fd);",
                "// Line 1635:     return PAM_SUCCESS;",
                "// vulnerable line: 1636: }",
                "// Line 1637: ",
                "// Line 1638: ",
                "// Line 1639: /*",
                "// Line 1640:  * This function performs the namespace setup for a particular directory",
                "// Line 1641:  * that is being polyinstantiated. It calls poly_name to create name of instance",
                "// Line 1642:  * directory, calls create_instance to mkdir it with appropriate",
                "// Line 1643:  * security attributes, and performs bind mount to setup the process",
                "// Line 1644:  * namespace.",
                "// Line 1645:  */",
                "// Line 1646: static int ns_setup(struct polydir_s *polyptr,",
                "// Line 1658:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 1659:         pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1660:                \"Set namespace for directory %s\", polyptr->dir);",
                "// Line 1661: ",
                "// Line 1662:     retval = protect_dir(polyptr->dir, 0, 0, idata);",
                "// Line 1663: ",
                "// Line 1664:     if (retval < 0 && errno != ENOENT) {",
                "// Line 1665:     pam_syslog(idata->pamh, LOG_ERR, \"Polydir %s access error: %m\",",
                "// Line 1666:         polyptr->dir);",
                "// Line 1667:     return PAM_SESSION_ERR;",
                "// vulnerable line: 1668: }",
                "// Line 1669: ",
                "// Line 1670:     if (retval < 0) {",
                "// Line 1671:     if ((polyptr->flags & POLYDIR_CREATE) &&",
                "// Line 1672:         create_polydir(polyptr, idata) != PAM_SUCCESS)",
                "// Line 1673:         return PAM_SESSION_ERR;",
                "// Line 1674:     } else {",
                "// Line 1675:     close(retval);",
                "// vulnerable line: 1676: }",
                "// Line 1677: ",
                "// Line 1678:     if (polyptr->method == TMPFS) {",
                "// Line 1679:     if (mount(\"tmpfs\", polyptr->dir, \"tmpfs\", polyptr->mount_flags, polyptr->mount_opts) < 0) {",
                "// Line 1680:         pam_syslog(idata->pamh, LOG_ERR, \"Error mounting tmpfs on %s, %m\",",
                "// Line 1681:         polyptr->dir);",
                "// Line 1682:             return PAM_SESSION_ERR;",
                "// vulnerable line: 1683: }",
                "// Line 1684: ",
                "// Line 1685:     if (polyptr->flags & POLYDIR_NOINIT)",
                "// Line 1686:         return PAM_SUCCESS;",
                "// Line 1687: ",
                "// Line 1688:     return inst_init(polyptr, \"tmpfs\", idata, 1);",
                "// vulnerable line: 1689: }",
                "// Line 1690: ",
                "// Line 1691:     if (stat(polyptr->dir, &statbuf) < 0) {",
                "// Line 1692:     pam_syslog(idata->pamh, LOG_ERR, \"Error stating %s: %m\",",
                "// Line 1693:         polyptr->dir);",
                "// Line 1694:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1695: }",
                "// Line 1696: ",
                "// Line 1697:     /*",
                "// Line 1698:      * Obtain the name of instance pathname based on the",
                "// Line 1699:      * polyinstantiation method and instance context returned by",
                "// Line 1700:      * security policy.",
                "// Line 1701:      */",
                "// Line 1702: #ifdef WITH_SELINUX",
                "// Line 1703:     retval = poly_name(polyptr, &instname, &instcontext,",
                "// Line 1704:             &origcontext, idata);",
                "// Line 1705: #else",
                "// Line 1710:     if (retval != PAM_IGNORE)",
                "// Line 1711:         pam_syslog(idata->pamh, LOG_ERR, \"Error getting instance name\");",
                "// Line 1712:         goto cleanup;",
                "// Line 1713:     } else {",
                "// Line 1714: #ifdef WITH_SELINUX",
                "// Line 1715:         if ((idata->flags & PAMNS_DEBUG) &&",
                "// Line 1716:             (idata->flags & PAMNS_SELINUX_ENABLED))",
                "// Line 1717:             pam_syslog(idata->pamh, LOG_DEBUG, \"Inst ctxt %s Orig ctxt %s\",",
                "// Line 1718:          instcontext, origcontext);",
                "// Line 1719: #endif",
                "// vulnerable line: 1720: }",
                "// Line 1721: ",
                "// Line 1722:     if (asprintf(&inst_dir, \"%s%s\", polyptr->instance_prefix, instname) < 0)",
                "// Line 1723:     goto error_out;",
                "// Line 1724: ",
                "// Line 1725:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 1726:         pam_syslog(idata->pamh, LOG_DEBUG, \"instance_dir %s\",",
                "// Line 1727:         inst_dir);",
                "// Line 1728: ",
                "// Line 1729:     /*",
                "// Line 1730:      * Create instance directory with appropriate security",
                "// Line 1733: #ifdef WITH_SELINUX",
                "// Line 1734:     retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,",
                "// Line 1735:              origcontext, idata);",
                "// Line 1736: #else",
                "// Line 1737:     retval = create_instance(polyptr, inst_dir, &statbuf, idata);",
                "// Line 1738: #endif",
                "// Line 1739: ",
                "// Line 1740:     if (retval == PAM_IGNORE) {",
                "// Line 1741:     newdir = 0;",
                "// Line 1742:     retval = PAM_SUCCESS;",
                "// vulnerable line: 1743: }",
                "// Line 1744: ",
                "// Line 1745:     if (retval != PAM_SUCCESS) {",
                "// Line 1746:         goto error_out;",
                "// vulnerable line: 1747: }",
                "// Line 1748: ",
                "// Line 1749:     /*",
                "// Line 1750:      * Bind mount instance directory on top of the polyinstantiated",
                "// Line 1751:      * directory to provide an instance of polyinstantiated directory",
                "// Line 1752:      * based on polyinstantiated method.",
                "// Line 1753:      */",
                "// Line 1754:     if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {",
                "// Line 1755:         pam_syslog(idata->pamh, LOG_ERR, \"Error mounting %s on %s, %m\",",
                "// Line 1756:                    inst_dir, polyptr->dir);",
                "// Line 1757:         goto error_out;",
                "// vulnerable line: 1758: }",
                "// Line 1759: ",
                "// Line 1760:     if (!(polyptr->flags & POLYDIR_NOINIT))",
                "// Line 1761:     retval = inst_init(polyptr, inst_dir, idata, newdir);",
                "// Line 1762: ",
                "// Line 1763:     goto cleanup;",
                "// Line 1764: ",
                "// Line 1765:     /*",
                "// Line 1766:      * various error exit points. Free allocated memory and set return",
                "// Line 1767:      * value to indicate a pam session error.",
                "// Line 1768:      */",
                "// Line 1770:     retval = PAM_SESSION_ERR;",
                "// Line 1771: ",
                "// Line 1772: cleanup:",
                "// Line 1773:     free(inst_dir);",
                "// Line 1774:     free(instname);",
                "// Line 1775: #ifdef WITH_SELINUX",
                "// Line 1776:     freecon(instcontext);",
                "// Line 1777:     freecon(origcontext);",
                "// Line 1778: #endif",
                "// Line 1779:     return retval;",
                "// vulnerable line: 1780: }",
                "// Line 1781: ",
                "// Line 1782: ",
                "// Line 1783: /*",
                "// Line 1784:  * This function checks to see if the current working directory is",
                "// Line 1785:  * inside the directory passed in as the first argument.",
                "// Line 1786:  */",
                "// Line 1787: static int cwd_in(char *dir, struct instance_data *idata)",
                "// Line 1788: {",
                "// Line 1789:     int retval = 0;",
                "// Line 1790:     char cwd[PATH_MAX];",
                "// Line 1791: ",
                "// Line 1792:     if (getcwd(cwd, PATH_MAX) == NULL) {",
                "// Line 1793:         pam_syslog(idata->pamh, LOG_ERR, \"Can't get current dir, %m\");",
                "// Line 1794:         return -1;",
                "// vulnerable line: 1795: }",
                "// Line 1796: ",
                "// Line 1797:     if (strncmp(cwd, dir, strlen(dir)) == 0) {",
                "// Line 1798:         if (idata->flags & PAMNS_DEBUG)",
                "// Line 1799:             pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is inside %s\", dir);",
                "// Line 1800:         retval = 1;",
                "// Line 1801:     } else {",
                "// Line 1802:         if (idata->flags & PAMNS_DEBUG)",
                "// Line 1803:             pam_syslog(idata->pamh, LOG_DEBUG, \"cwd is outside %s\", dir);",
                "// vulnerable line: 1804: }",
                "// Line 1805: ",
                "// Line 1806:     return retval;",
                "// vulnerable line: 1807: }",
                "// Line 1808: ",
                "// Line 1809: static int cleanup_tmpdirs(struct instance_data *idata)",
                "// Line 1810: {",
                "// Line 1811:     struct polydir_s *pptr;",
                "// Line 1812:     pid_t rc, pid;",
                "// Line 1813:     struct sigaction newsa, oldsa;",
                "// Line 1814:     int status;",
                "// Line 1815: ",
                "// Line 1816:     memset(&newsa, '\u0000', sizeof(newsa));",
                "// Line 1817:     newsa.sa_handler = SIG_DFL;",
                "// Line 1818:     if (sigaction(SIGCHLD, &newsa, &oldsa) == -1) {",
                "// Line 1819:     pam_syslog(idata->pamh, LOG_ERR, \"Cannot set signal value\");",
                "// Line 1820:     return PAM_SESSION_ERR;",
                "// vulnerable line: 1821: }",
                "// Line 1822: ",
                "// Line 1823:     for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {",
                "// Line 1824:     if (pptr->method == TMPDIR && access(pptr->instance_prefix, F_OK) == 0) {",
                "// Line 1825:         pid = fork();",
                "// Line 1826:         if (pid == 0) {",
                "// Line 1827:         static char *envp[] = { NULL };",
                "// Line 1828: #ifdef WITH_SELINUX",
                "// Line 1829:         if (idata->flags & PAMNS_SELINUX_ENABLED) {",
                "// Line 1830:             if (setexeccon(NULL) < 0)",
                "// Line 1831:             _exit(1);",
                "// vulnerable line: 1832: }",
                "// Line 1833: #endif",
                "// Line 1834:         close_fds_pre_exec(idata);",
                "// Line 1835:         if (execle(\"/bin/rm\", \"/bin/rm\", \"-rf\", pptr->instance_prefix, NULL, envp) < 0)",
                "// Line 1836:             _exit(1);",
                "// Line 1837:         } else if (pid > 0) {",
                "// Line 1838:         while (((rc = waitpid(pid, &status, 0)) == (pid_t)-1) &&",
                "// Line 1839:             (errno == EINTR));",
                "// Line 1840:         if (rc == (pid_t)-1) {",
                "// Line 1841:             pam_syslog(idata->pamh, LOG_ERR, \"waitpid failed: %m\");",
                "// Line 1842:             rc = PAM_SESSION_ERR;",
                "// Line 1843:             goto out;",
                "// vulnerable line: 1844: }",
                "// Line 1845:         if (!WIFEXITED(status) || WIFSIGNALED(status) > 0) {",
                "// Line 1846:             pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1847:             \"Error removing %s\", pptr->instance_prefix);",
                "// vulnerable line: 1848: }",
                "// Line 1849:         } else if (pid < 0) {",
                "// Line 1850:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1851:             \"Cannot fork to cleanup temporary directory, %m\");",
                "// Line 1852:         rc = PAM_SESSION_ERR;",
                "// Line 1853:         goto out;",
                "// vulnerable line: 1854: }",
                "// vulnerable line: 1855: }",
                "// vulnerable line: 1856: }",
                "// Line 1857: ",
                "// Line 1858:     rc = PAM_SUCCESS;",
                "// Line 1859: out:",
                "// Line 1860:     sigaction(SIGCHLD, &oldsa, NULL);",
                "// Line 1861:     return rc;",
                "// vulnerable line: 1862: }",
                "// Line 1863: ",
                "// Line 1864: /*",
                "// Line 1865:  * This function checks to see if polyinstantiation is needed for any",
                "// Line 1866:  * of the directories listed in the configuration file. If needed,",
                "// Line 1867:  * cycles through all polyinstantiated directory entries and calls",
                "// Line 1868:  * ns_setup to setup polyinstantiation for each one of them.",
                "// Line 1869:  */",
                "// Line 1870: static int setup_namespace(struct instance_data *idata, enum unmnt_op unmnt)",
                "// Line 1871: {",
                "// Line 1872:     int retval = 0, need_poly = 0, changing_dir = 0;",
                "// Line 1888:             pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1889:             \"Overriding poly for user %d for dir %s\",",
                "// Line 1890:             idata->uid, pptr->dir);",
                "// Line 1891:         } else {",
                "// Line 1892:         if (idata->flags & PAMNS_DEBUG)",
                "// Line 1893:             pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1894:             \"Need unmount ns for user %d for dir %s\",",
                "// Line 1895:             idata->ruid, pptr->dir);",
                "// Line 1896:         need_poly = 1;",
                "// Line 1897:         break;",
                "// vulnerable line: 1898: }",
                "// Line 1899:             continue;",
                "// Line 1900:         } else {",
                "// Line 1901:             if (idata->flags & PAMNS_DEBUG)",
                "// Line 1902:                 pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1903:             \"Need poly ns for user %d for dir %s\",",
                "// Line 1904:             idata->uid, pptr->dir);",
                "// Line 1905:             need_poly = 1;",
                "// Line 1906:             break;",
                "// vulnerable line: 1907: }",
                "// vulnerable line: 1908: }",
                "// Line 1909: ",
                "// Line 1910:     /*",
                "// Line 1911:      * If polyinstantiation is needed, call the unshare system call to",
                "// Line 1912:      * disassociate from the parent namespace.",
                "// Line 1913:      */",
                "// Line 1914:     if (need_poly) {",
                "// Line 1915:         if (unshare(CLONE_NEWNS) < 0) {",
                "// Line 1916:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1917:         \"Unable to unshare from parent namespace, %m\");",
                "// Line 1918:             return PAM_SESSION_ERR;",
                "// vulnerable line: 1919: }",
                "// Line 1920:     if (idata->flags & PAMNS_MOUNT_PRIVATE) {",
                "// Line 1921:         /*",
                "// Line 1922:          * Remount / as SLAVE so that nothing mounted in the namespace",
                "// Line 1923:          * shows up in the parent",
                "// Line 1924:          */",
                "// Line 1925:         if (mount(\"/\", \"/\", NULL, MS_SLAVE | MS_REC , NULL) < 0) {",
                "// Line 1926:         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1927:             \"Failed to mark / as a slave mount point, %m\");",
                "// Line 1928:         return PAM_SESSION_ERR;",
                "// vulnerable line: 1929: }",
                "// Line 1930:         if (idata->flags & PAMNS_DEBUG)",
                "// Line 1931:         pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1932:             \"The / mount point was marked as slave\");",
                "// vulnerable line: 1933: }",
                "// Line 1934:     } else {",
                "// Line 1935:     del_polydir_list(idata->polydirs_ptr);",
                "// Line 1936:         return PAM_SUCCESS;",
                "// vulnerable line: 1937: }",
                "// Line 1938: ",
                "// Line 1939:     /*",
                "// Line 1940:      * Again cycle through all polyinstantiated directories, this time,",
                "// Line 1941:      * call ns_setup to setup polyinstantiation for a particular entry.",
                "// Line 1942:      */",
                "// Line 1943:     for (pptr = idata->polydirs_ptr; pptr; pptr = pptr->next) {",
                "// Line 1944:     enum unmnt_op dir_unmnt = unmnt;",
                "// Line 1945: ",
                "// Line 1946:     if (ns_override(pptr, idata, idata->ruid)) {",
                "// Line 1947:         dir_unmnt = NO_UNMNT;",
                "// vulnerable line: 1948: }",
                "// Line 1949:     if (ns_override(pptr, idata, idata->uid)) {",
                "// Line 1950:         if (dir_unmnt == NO_UNMNT) {",
                "// Line 1951:         continue;",
                "// Line 1952:         } else {",
                "// Line 1953:         dir_unmnt = UNMNT_ONLY;",
                "// vulnerable line: 1954: }",
                "// vulnerable line: 1955: }",
                "// Line 1956: ",
                "// Line 1957:     if (idata->flags & PAMNS_DEBUG)",
                "// Line 1958:                 pam_syslog(idata->pamh, LOG_DEBUG,",
                "// Line 1959:             \"Setting poly ns for user %d for dir %s\",",
                "// Line 1960:                       idata->uid, pptr->dir);",
                "// Line 1961: ",
                "// Line 1962:     if ((dir_unmnt == UNMNT_REMNT) || (dir_unmnt == UNMNT_ONLY)) {",
                "// Line 1963:                 /*",
                "// Line 1964:                  * Check to see if process current directory is in the",
                "// Line 1965:                  * bind mounted instance_parent directory that we are trying to",
                "// Line 1981:                     strcpy(poly_parent, pptr->rdir);",
                "// Line 1982:             fptr = strchr(poly_parent, '/');",
                "// Line 1983:             cptr = strrchr(poly_parent, '/');",
                "// Line 1984:             if (fptr && cptr && (fptr == cptr))",
                "// Line 1985:             strcpy(poly_parent, \"/\");",
                "// Line 1986:             else if (cptr)",
                "// Line 1987:             *cptr = '\u0000';",
                "// Line 1988:                     if (chdir(poly_parent) < 0) {",
                "// Line 1989:                         pam_syslog(idata->pamh, LOG_ERR,",
                "// Line 1990:                 \"Can't chdir to %s, %m\", poly_parent);",
                "// vulnerable line: 1991: }",
                "// vulnerable line: 1992: }",
                "// Line 1993: ",
                "// Line 1994:                 if (umount(pptr->rdir) < 0) {",
                "// Line 1995:             int saved_errno = errno;",
                "// Line 1996:             pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",",
                "// Line 1997:             pptr->rdir);",
                "// Line 1998:             if (saved_errno != EINVAL) {",
                "// Line 1999:             retval = PAM_SESSION_ERR;",
                "// Line 2000:             goto out;",
                "// vulnerable line: 2001: }",
                "// Line 2002:                 } else if (idata->flags & PAMNS_DEBUG)",
                "// Line 2003:                     pam_syslog(idata->pamh, LOG_DEBUG, \"Umount succeeded %s\",",
                "// Line 2004:                 pptr->rdir);",
                "// vulnerable line: 2005: }",
                "// Line 2006: ",
                "// Line 2007:     if (dir_unmnt != UNMNT_ONLY) {",
                "// Line 2008:                 retval = ns_setup(pptr, idata);",
                "// Line 2009:                 if (retval == PAM_IGNORE)",
                "// Line 2010:                      retval = PAM_SUCCESS;",
                "// Line 2011:                 if (retval != PAM_SUCCESS)",
                "// Line 2012:                      break;",
                "// vulnerable line: 2013: }",
                "// vulnerable line: 2014: }",
                "// Line 2015: out:",
                "// Line 2016:     if (retval != PAM_SUCCESS) {",
                "// Line 2017:     cleanup_tmpdirs(idata);",
                "// Line 2018:     unprotect_dirs(idata->protect_dirs);",
                "// Line 2019:     } else if (pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, idata->protect_dirs,",
                "// Line 2020:         cleanup_protect_data) != PAM_SUCCESS) {",
                "// Line 2021:     pam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace protect data\");",
                "// Line 2022:     cleanup_tmpdirs(idata);",
                "// Line 2023:     unprotect_dirs(idata->protect_dirs);",
                "// Line 2024:     return PAM_SYSTEM_ERR;",
                "// Line 2025:     } else if (pam_set_data(idata->pamh, NAMESPACE_POLYDIR_DATA, idata->polydirs_ptr,",
                "// Line 2026:         cleanup_polydir_data) != PAM_SUCCESS) {",
                "// Line 2027:     pam_syslog(idata->pamh, LOG_ERR, \"Unable to set namespace polydir data\");",
                "// Line 2028:     cleanup_tmpdirs(idata);",
                "// Line 2029:     pam_set_data(idata->pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);",
                "// Line 2030:     idata->protect_dirs = NULL;",
                "// Line 2031:     return PAM_SYSTEM_ERR;",
                "// vulnerable line: 2032: }",
                "// Line 2033:     return retval;",
                "// vulnerable line: 2034: }",
                "// Line 2035: ",
                "// Line 2036: ",
                "// Line 2037: /*",
                "// Line 2038:  * Orig namespace. This function is called from when closing a pam",
                "// Line 2039:  * session. If authorized, it unmounts instance directory.",
                "// Line 2040:  */",
                "// Line 2041: static int orig_namespace(struct instance_data *idata)",
                "// Line 2042: {",
                "// Line 2043:     struct polydir_s *pptr;",
                "// Line 2044: ",
                "// Line 2061:             \"Unmounting instance dir for user %d & dir %s\",",
                "// Line 2062:                        idata->uid, pptr->dir);",
                "// Line 2063: ",
                "// Line 2064:             if (umount(pptr->dir) < 0) {",
                "// Line 2065:                 pam_syslog(idata->pamh, LOG_ERR, \"Unmount of %s failed, %m\",",
                "// Line 2066:                        pptr->dir);",
                "// Line 2067:                 return PAM_SESSION_ERR;",
                "// Line 2068:             } else if (idata->flags & PAMNS_DEBUG)",
                "// Line 2069:                 pam_syslog(idata->pamh, LOG_DEBUG, \"Unmount of %s succeeded\",",
                "// Line 2070:             pptr->dir);",
                "// vulnerable line: 2071: }",
                "// vulnerable line: 2072: }",
                "// Line 2073: ",
                "// Line 2074:     cleanup_tmpdirs(idata);",
                "// Line 2075:     return 0;",
                "// vulnerable line: 2076: }",
                "// Line 2077: ",
                "// Line 2078: ",
                "// Line 2079: #ifdef WITH_SELINUX",
                "// Line 2080: /*",
                "// Line 2081:  * This function checks if the calling program has requested context",
                "// Line 2082:  * change by calling setexeccon(). If context change is not requested",
                "// Line 2083:  * then it does not make sense to polyinstantiate based on context.",
                "// Line 2084:  * The return value from this function is used when selecting the",
                "// Line 2085:  * polyinstantiation method. If context change is not requested then",
                "// Line 2086:  * the polyinstantiation method is set to USER, even if the configuration",
                "// Line 2090: {",
                "// Line 2091:     char *scon = NULL;",
                "// Line 2092:     int rc = 0;",
                "// Line 2093: ",
                "// Line 2094:     rc = getexeccon(&scon);",
                "// Line 2095:     if (rc < 0 || scon == NULL)",
                "// Line 2096:         return 0;",
                "// Line 2097:     else {",
                "// Line 2098:         freecon(scon);",
                "// Line 2099:         return 1;",
                "// vulnerable line: 2100: }",
                "// vulnerable line: 2101: }",
                "// Line 2102: #endif",
                "// Line 2103: ",
                "// Line 2104: static int root_shared(void)",
                "// Line 2105: {",
                "// Line 2106:     FILE *f;",
                "// Line 2107:     char *line = NULL;",
                "// Line 2108:     size_t n = 0;",
                "// Line 2109:     int rv = 0;",
                "// Line 2110: ",
                "// Line 2111:     f = fopen(\"/proc/self/mountinfo\", \"r\");",
                "// Line 2132:              if (i == 4 && strcmp(tok, \"/\") != 0)",
                "// Line 2133:                  /* next mountinfo line */",
                "// Line 2134:                  break;",
                "// Line 2135: ",
                "// Line 2136:              if (i == 6) {",
                "// Line 2137:                 if (pam_str_skip_prefix(tok, \"shared:\") != NULL)",
                "// Line 2138:                  /* there might be more / mounts, the last one counts */",
                "// Line 2139:                     rv = 1;",
                "// Line 2140:                 else",
                "// Line 2141:                     rv = 0;",
                "// vulnerable line: 2142: }",
                "// vulnerable line: 2143: }",
                "// vulnerable line: 2144: }",
                "// Line 2145: ",
                "// Line 2146:     free(line);",
                "// Line 2147:     fclose(f);",
                "// Line 2148: ",
                "// Line 2149:     return rv;",
                "// vulnerable line: 2150: }",
                "// Line 2151: ",
                "// Line 2152: static int get_user_data(struct instance_data *idata)",
                "// Line 2153: {",
                "// Line 2154:     int retval;",
                "// Line 2155:     char *user_name;",
                "// Line 2156:     struct passwd *pwd;",
                "// Line 2157:     /*",
                "// Line 2158:      * Lookup user and fill struct items",
                "// Line 2159:      */",
                "// Line 2160:     retval = pam_get_item(idata->pamh, PAM_USER, (void*) &user_name );",
                "// Line 2161:     if ( user_name == NULL || retval != PAM_SUCCESS ) {",
                "// Line 2162:         pam_syslog(idata->pamh, LOG_ERR, \"Error recovering pam user name\");",
                "// Line 2163:         return PAM_SESSION_ERR;",
                "// vulnerable line: 2164: }",
                "// Line 2165: ",
                "// Line 2166:     pwd = pam_modutil_getpwnam(idata->pamh, user_name);",
                "// Line 2167:     if (!pwd) {",
                "// Line 2168:         pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);",
                "// Line 2169:         return PAM_USER_UNKNOWN;",
                "// vulnerable line: 2170: }",
                "// Line 2171: ",
                "// Line 2172:     /*",
                "// Line 2173:      * Add the user info to the instance data so we can refer to them later.",
                "// Line 2174:      */",
                "// Line 2175:     idata->user[0] = 0;",
                "// Line 2176:     strncat(idata->user, user_name, sizeof(idata->user) - 1);",
                "// Line 2177:     idata->uid = pwd->pw_uid;",
                "// Line 2178:     idata->gid = pwd->pw_gid;",
                "// Line 2179: ",
                "// Line 2180:     /* Fill in RUSER too */",
                "// Line 2181:     retval = pam_get_item(idata->pamh, PAM_RUSER, (void*) &user_name );",
                "// Line 2182:     if ( user_name != NULL && retval == PAM_SUCCESS && user_name[0] != '\u0000' ) {",
                "// Line 2183:     strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);",
                "// Line 2184:     pwd = pam_modutil_getpwnam(idata->pamh, user_name);",
                "// Line 2185:     } else {",
                "// Line 2186:     pwd = pam_modutil_getpwuid(idata->pamh, getuid());",
                "// vulnerable line: 2187: }",
                "// Line 2188:     if (!pwd) {",
                "// Line 2189:     pam_syslog(idata->pamh, LOG_ERR, \"user unknown '%s'\", user_name);",
                "// Line 2190:     return PAM_USER_UNKNOWN;",
                "// vulnerable line: 2191: }",
                "// Line 2192:     user_name = pwd->pw_name;",
                "// Line 2193: ",
                "// Line 2194:     idata->ruser[0] = 0;",
                "// Line 2195:     strncat(idata->ruser, user_name, sizeof(idata->ruser) - 1);",
                "// Line 2196:     idata->ruid = pwd->pw_uid;",
                "// Line 2197: ",
                "// Line 2198:     return PAM_SUCCESS;",
                "// vulnerable line: 2199: }",
                "// Line 2200: ",
                "// Line 2201: /*",
                "// Line 2202:  * Entry point from pam_open_session call.",
                "// Line 2203:  */",
                "// Line 2204: int pam_sm_open_session(pam_handle_t *pamh, int flags UNUSED,",
                "// Line 2205:                                    int argc, const char **argv)",
                "// Line 2206: {",
                "// Line 2207:     int i, retval;",
                "// Line 2208:     struct instance_data idata;",
                "// Line 2209:     enum unmnt_op unmnt = NO_UNMNT;",
                "// Line 2226:             idata.flags |= PAMNS_DEBUG;",
                "// Line 2227:         if (strcmp(argv[i], \"gen_hash\") == 0)",
                "// Line 2228:             idata.flags |= PAMNS_GEN_HASH;",
                "// Line 2229:         if (strcmp(argv[i], \"ignore_config_error\") == 0)",
                "// Line 2230:             idata.flags |= PAMNS_IGN_CONFIG_ERR;",
                "// Line 2231:         if (strcmp(argv[i], \"ignore_instance_parent_mode\") == 0)",
                "// Line 2232:             idata.flags |= PAMNS_IGN_INST_PARENT_MODE;",
                "// Line 2233:         if (strcmp(argv[i], \"use_current_context\") == 0) {",
                "// Line 2234:             idata.flags |= PAMNS_USE_CURRENT_CONTEXT;",
                "// Line 2235:             idata.flags |= PAMNS_CTXT_BASED_INST;",
                "// vulnerable line: 2236: }",
                "// Line 2237:         if (strcmp(argv[i], \"use_default_context\") == 0) {",
                "// Line 2238:             idata.flags |= PAMNS_USE_DEFAULT_CONTEXT;",
                "// Line 2239:             idata.flags |= PAMNS_CTXT_BASED_INST;",
                "// vulnerable line: 2240: }",
                "// Line 2241:         if (strcmp(argv[i], \"mount_private\") == 0) {",
                "// Line 2242:             idata.flags |= PAMNS_MOUNT_PRIVATE;",
                "// vulnerable line: 2243: }",
                "// Line 2244:         if (strcmp(argv[i], \"unmnt_remnt\") == 0)",
                "// Line 2245:             unmnt = UNMNT_REMNT;",
                "// Line 2246:         if (strcmp(argv[i], \"unmnt_only\") == 0)",
                "// Line 2247:             unmnt = UNMNT_ONLY;",
                "// Line 2248:     if (strcmp(argv[i], \"require_selinux\") == 0) {",
                "// Line 2249:         if (!(idata.flags & PAMNS_SELINUX_ENABLED)) {",
                "// Line 2250:             pam_syslog(idata.pamh, LOG_ERR,",
                "// Line 2251:             \"selinux_required option given and selinux is disabled\");",
                "// Line 2252:             return PAM_SESSION_ERR;",
                "// vulnerable line: 2253: }",
                "// vulnerable line: 2254: }",
                "// vulnerable line: 2255: }",
                "// Line 2256:     if (idata.flags & PAMNS_DEBUG)",
                "// Line 2257:         pam_syslog(idata.pamh, LOG_DEBUG, \"open_session - start\");",
                "// Line 2258: ",
                "// Line 2259:     retval = get_user_data(&idata);",
                "// Line 2260:     if (retval != PAM_SUCCESS)",
                "// Line 2261:     return retval;",
                "// Line 2262: ",
                "// Line 2263:     if (root_shared()) {",
                "// Line 2264:     idata.flags |= PAMNS_MOUNT_PRIVATE;",
                "// vulnerable line: 2265: }",
                "// Line 2266: ",
                "// Line 2267:     /*",
                "// Line 2268:      * Parse namespace configuration file which lists directories to",
                "// Line 2269:      * polyinstantiate, directory where instance directories are to",
                "// Line 2270:      * be created and the method used for polyinstantiation.",
                "// Line 2271:      */",
                "// Line 2272:     retval = parse_config_file(&idata);",
                "// Line 2273:     if (retval != PAM_SUCCESS) {",
                "// Line 2274:     del_polydir_list(idata.polydirs_ptr);",
                "// Line 2275:         return PAM_SESSION_ERR;",
                "// vulnerable line: 2276: }",
                "// Line 2277: ",
                "// Line 2278:     if (idata.polydirs_ptr) {",
                "// Line 2279:         retval = setup_namespace(&idata, unmnt);",
                "// Line 2280:         if (idata.flags & PAMNS_DEBUG) {",
                "// Line 2281:             if (retval)",
                "// Line 2282:                 pam_syslog(idata.pamh, LOG_DEBUG,",
                "// Line 2283:             \"namespace setup failed for pid %d\", getpid());",
                "// Line 2284:             else",
                "// Line 2285:                 pam_syslog(idata.pamh, LOG_DEBUG,",
                "// Line 2286:             \"namespace setup ok for pid %d\", getpid());",
                "// vulnerable line: 2287: }",
                "// Line 2288:     } else if (idata.flags & PAMNS_DEBUG)",
                "// Line 2289:         pam_syslog(idata.pamh, LOG_DEBUG, \"Nothing to polyinstantiate\");",
                "// Line 2290: ",
                "// Line 2291:     if (retval != PAM_SUCCESS)",
                "// Line 2292:     del_polydir_list(idata.polydirs_ptr);",
                "// Line 2293:     return retval;",
                "// vulnerable line: 2294: }",
                "// Line 2295: ",
                "// Line 2296: ",
                "// Line 2297: /*",
                "// Line 2298:  * Entry point from pam_close_session call.",
                "// Line 2299:  */",
                "// Line 2300: int pam_sm_close_session(pam_handle_t *pamh, int flags UNUSED,",
                "// Line 2301:                                     int argc, const char **argv)",
                "// Line 2302: {",
                "// Line 2303:     int i, retval;",
                "// Line 2304:     struct instance_data idata;",
                "// Line 2316: #endif",
                "// Line 2317: ",
                "// Line 2318:     /* Parse arguments. */",
                "// Line 2319:     for (i = 0; i < argc; i++) {",
                "// Line 2320:         if (strcmp(argv[i], \"debug\") == 0)",
                "// Line 2321:             idata.flags |= PAMNS_DEBUG;",
                "// Line 2322:         if (strcmp(argv[i], \"ignore_config_error\") == 0)",
                "// Line 2323:             idata.flags |= PAMNS_IGN_CONFIG_ERR;",
                "// Line 2324:         if (strcmp(argv[i], \"unmount_on_close\") == 0)",
                "// Line 2325:             idata.flags |= PAMNS_UNMOUNT_ON_CLOSE;",
                "// vulnerable line: 2326: }",
                "// Line 2327: ",
                "// Line 2328:     if (idata.flags & PAMNS_DEBUG)",
                "// Line 2329:         pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - start\");",
                "// Line 2330: ",
                "// Line 2331:     /*",
                "// Line 2332:      * Normally the unmount is implicitly done when the last",
                "// Line 2333:      * process in the private namespace exits.",
                "// Line 2334:      * If it is ensured that there are no child processes left in",
                "// Line 2335:      * the private namespace by other means and if there are",
                "// Line 2336:      * multiple sessions opened and closed sequentially by the",
                "// Line 2337:      * same process, the \"unmount_on_close\" option might be",
                "// Line 2338:      * used to unmount the polydirs explicitly.",
                "// Line 2339:      */",
                "// Line 2340:     if (!(idata.flags & PAMNS_UNMOUNT_ON_CLOSE)) {",
                "// Line 2341:     pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);",
                "// Line 2342:     pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);",
                "// Line 2343: ",
                "// Line 2344:     if (idata.flags & PAMNS_DEBUG)",
                "// Line 2345:         pam_syslog(idata.pamh, LOG_DEBUG, \"close_session - successful\");",
                "// Line 2346:         return PAM_SUCCESS;",
                "// vulnerable line: 2347: }",
                "// Line 2348: ",
                "// Line 2349:     retval = get_user_data(&idata);",
                "// Line 2350:     if (retval != PAM_SUCCESS)",
                "// Line 2351:     return retval;",
                "// Line 2352: ",
                "// Line 2353:     retval = pam_get_data(idata.pamh, NAMESPACE_POLYDIR_DATA, &polyptr);",
                "// Line 2354:     if (retval != PAM_SUCCESS || polyptr == NULL)",
                "// Line 2355:     /* nothing to reset */",
                "// Line 2356:     return PAM_SUCCESS;",
                "// Line 2357: ",
                "// Line 2364:         getpid());",
                "// Line 2365: ",
                "// Line 2366:     retval = orig_namespace(&idata);",
                "// Line 2367:     if (idata.flags & PAMNS_DEBUG) {",
                "// Line 2368:         if (retval)",
                "// Line 2369:             pam_syslog(idata.pamh, LOG_DEBUG,",
                "// Line 2370:         \"resetting namespace failed for pid %d\", getpid());",
                "// Line 2371:         else",
                "// Line 2372:             pam_syslog(idata.pamh, LOG_DEBUG,",
                "// Line 2373:         \"resetting namespace ok for pid %d\", getpid());",
                "// vulnerable line: 2374: }",
                "// Line 2375: ",
                "// Line 2376:     pam_set_data(idata.pamh, NAMESPACE_POLYDIR_DATA, NULL, NULL);",
                "// Line 2377:     pam_set_data(idata.pamh, NAMESPACE_PROTECT_DATA, NULL, NULL);",
                "// Line 2378: ",
                "// Line 2379:     return PAM_SUCCESS;",
                "// vulnerable line: 2380: }"
            ]
        }
    ]
}