{
    "cve_id": "CVE-2023-51779",
    "cve_description": "bt_sock_recvmsg in net/bluetooth/af_bluetooth.c in the Linux kernel through 6.6.8 has a use-after-free because of a bt_sock_ioctl race condition.",
    "cve_publish_date": "2024-02-29T01:42Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Bluetooth: af_bluetooth: Fix Use-After-Free in bt_sock_recvmsg\n\nThis can cause a race with bt_sock_ioctl() because\nbt_sock_recvmsg() gets the skb from sk->sk_receive_queue\nand then frees it without holding lock_sock.\nA use-after-free for a skb occurs with the following flow.\n```\nbt_sock_recvmsg() -> skb_recv_datagram() -> skb_free_datagram()\nbt_sock_ioctl() -> skb_peek()\n```\nAdd lock_sock to bt_sock_recvmsg() to fix this issue.\n\nCc: stable@vger.kernel.org\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nSigned-off-by: Hyunwoo Kim <v4bel@theori.io>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "af_bluetooth.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 305:     int err;",
                "// Line 306: ",
                "// Line 307:     BT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);",
                "// Line 308: ",
                "// Line 309:     if (flags & MSG_OOB)",
                "// Line 310:         return -EOPNOTSUPP;",
                "// Line 311: ",
                "// Line 312:     skb = skb_recv_datagram(sk, flags, &err);",
                "// Line 313:     if (!skb) {",
                "// Line 314:         if (sk->sk_shutdown & RCV_SHUTDOWN)",
                "// vulnerable line: 315: return 0;",
                "// Line 316: ",
                "// Line 317:         return err;",
                "// Line 318:     }",
                "// Line 319: ",
                "// Line 320:     skblen = skb->len;",
                "// Line 321:     copied = skb->len;",
                "// Line 322:     if (len < copied) {",
                "// Line 323:         msg->msg_flags |= MSG_TRUNC;",
                "// Line 324:         copied = len;",
                "// Line 325:     }",
                "// Line 490:     struct sock *sk;",
                "// Line 491: ",
                "// Line 492:     list_for_each_entry_safe(s, n, &bt_sk(parent)->accept_q, accept_q) {",
                "// Line 493:         sk = (struct sock *)s;",
                "// Line 494:         if (sk->sk_state == BT_CONNECTED ||",
                "// Line 495:             (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags) &&",
                "// Line 496:              sk->sk_state == BT_CONNECT2))",
                "// Line 497:             return EPOLLIN | EPOLLRDNORM;",
                "// Line 498:     }",
                "// Line 499: ",
                "// vulnerable line: 500: return 0;",
                "// Line 501: }",
                "// Line 502: ",
                "// Line 503: __poll_t bt_sock_poll(struct file *file, struct socket *sock,",
                "// Line 504:               poll_table *wait)",
                "// Line 505: {",
                "// Line 506:     struct sock *sk = sock->sk;",
                "// Line 507:     __poll_t mask = 0;",
                "// Line 508: ",
                "// Line 509:     poll_wait(file, sk_sleep(sk), wait);",
                "// Line 510: ",
                "// Line 711:                bt->parent ? sock_i_ino(bt->parent) : 0LU);",
                "// Line 712: ",
                "// Line 713:         if (l->custom_seq_show) {",
                "// Line 714:             seq_putc(seq, ' ');",
                "// Line 715:             l->custom_seq_show(seq, v);",
                "// Line 716:         }",
                "// Line 717: ",
                "// Line 718:         seq_putc(seq, '",
                "// Line 719: ');",
                "// Line 720:     }",
                "// vulnerable line: 721: return 0;",
                "// Line 722: }",
                "// Line 723: ",
                "// Line 724: static const struct seq_operations bt_seq_ops = {",
                "// Line 725:     .start = bt_seq_start,",
                "// Line 726:     .next  = bt_seq_next,",
                "// Line 727:     .stop  = bt_seq_stop,",
                "// Line 728:     .show  = bt_seq_show,",
                "// Line 729: };",
                "// Line 730: ",
                "// Line 731: int bt_procfs_init(struct net *net, const char *name,",
                "// Line 732:            struct bt_sock_list *sk_list,",
                "// Line 733:            int (*seq_show)(struct seq_file *, void *))",
                "// Line 734: {",
                "// Line 735:     sk_list->custom_seq_show = seq_show;",
                "// Line 736: ",
                "// Line 737:     if (!proc_create_seq_data(name, 0, net->proc_net, &bt_seq_ops, sk_list))",
                "// Line 738:         return -ENOMEM;",
                "// vulnerable line: 739: return 0;",
                "// Line 740: }",
                "// Line 741: ",
                "// Line 742: void bt_procfs_cleanup(struct net *net, const char *name)",
                "// Line 743: {",
                "// Line 744:     remove_proc_entry(name, net->proc_net);",
                "// Line 745: }",
                "// Line 746: #else",
                "// Line 747: int bt_procfs_init(struct net *net, const char *name,",
                "// Line 748:            struct bt_sock_list *sk_list,",
                "// Line 749:            int (*seq_show)(struct seq_file *, void *))",
                "// Line 750: {",
                "// vulnerable line: 751: return 0;",
                "// Line 752: }",
                "// Line 753: ",
                "// Line 754: void bt_procfs_cleanup(struct net *net, const char *name)",
                "// Line 755: {",
                "// Line 756: }",
                "// Line 757: #endif",
                "// Line 758: EXPORT_SYMBOL(bt_procfs_init);",
                "// Line 759: EXPORT_SYMBOL(bt_procfs_cleanup);",
                "// Line 760: ",
                "// Line 761: static const struct net_proto_family bt_sock_family_ops = {",
                "// Line 804:         goto cleanup_socket;",
                "// Line 805: ",
                "// Line 806:     err = sco_init();",
                "// Line 807:     if (err)",
                "// Line 808:         goto cleanup_cap;",
                "// Line 809: ",
                "// Line 810:     err = mgmt_init();",
                "// Line 811:     if (err)",
                "// Line 812:         goto cleanup_sco;",
                "// Line 813: ",
                "// vulnerable line: 814: return 0;",
                "// Line 815: ",
                "// Line 816: cleanup_sco:",
                "// Line 817:     sco_exit();",
                "// Line 818: cleanup_cap:",
                "// Line 819:     l2cap_exit();",
                "// Line 820: cleanup_socket:",
                "// Line 821:     hci_sock_cleanup();",
                "// Line 822: unregister_socket:",
                "// Line 823:     sock_unregister(PF_BLUETOOTH);",
                "// Line 824: cleanup_sysfs:"
            ]
        }
    ]
}