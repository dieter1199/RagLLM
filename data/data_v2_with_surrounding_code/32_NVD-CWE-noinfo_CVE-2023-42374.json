{
    "cve_id": "CVE-2023-42374",
    "cve_description": "An issue in mystenlabs Sui Blockchain before v.1.6.3 allow a remote attacker to execute arbitrary code and cause a denial of service via a crafted compressed script to the Sui node component.",
    "cve_publish_date": "2024-02-13T01:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Reduce anemo message limit to 1G (#13231)",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "codec.rs",
            "code_language": "Rust",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 89: ",
                "// Line 90: impl<U: serde::de::DeserializeOwned> Decoder for BcsSnappyDecoder<U> {",
                "// Line 91:     type Item = U;",
                "// Line 92:     type Error = Status;",
                "// Line 93: ",
                "// Line 94:     fn decode(&mut self, buf: &mut DecodeBuf<'_>) -> Result<Option<Self::Item>, Self::Error> {",
                "// Line 95:         let compressed_size = buf.remaining();",
                "// Line 96:         if compressed_size == 0 {",
                "// Line 97:             return Ok(None);",
                "// Line 98:         }",
                "// vulnerable line: 99: let mut snappy_decoder = snap::read::FrameDecoder::new(buf.reader());",
                "// Line 100:         let mut bytes = Vec::with_capacity(compressed_size);",
                "// Line 101:         snappy_decoder.read_to_end(&mut bytes)?;",
                "// Line 102:         let item =",
                "// Line 103:             bcs::from_bytes(bytes.as_slice()).map_err(|e| Status::internal(e.to_string()))?;",
                "// Line 104:         Ok(Some(item))",
                "// Line 105:     }",
                "// Line 106: }",
                "// Line 107: ",
                "// Line 108: /// A [`Codec`] that implements `bcs` encoding/decoding and snappy compression/decompression",
                "// Line 109: /// via the serde library.",
                "// Line 159: ",
                "// Line 160:     #[derive(Debug)]",
                "// Line 161:     pub struct BcsSnappyDecoder<U>(PhantomData<U>);",
                "// Line 162: ",
                "// Line 163:     impl<U: serde::de::DeserializeOwned> Decoder for BcsSnappyDecoder<U> {",
                "// Line 164:         type Item = U;",
                "// Line 165:         type Error = bcs::Error;",
                "// Line 166: ",
                "// Line 167:         fn decode(&mut self, buf: bytes::Bytes) -> Result<Self::Item, Self::Error> {",
                "// Line 168:             let compressed_size = buf.len();",
                "// vulnerable line: 169: let mut snappy_decoder = snap::read::FrameDecoder::new(buf.reader());",
                "// Line 170:             let mut bytes = Vec::with_capacity(compressed_size);",
                "// Line 171:             snappy_decoder.read_to_end(&mut bytes)?;",
                "// Line 172:             bcs::from_bytes(bytes.as_slice())",
                "// Line 173:         }",
                "// Line 174:     }",
                "// Line 175: ",
                "// Line 176:     /// A [`Codec`] that implements `bcs` encoding/decoding via the serde library.",
                "// Line 177:     #[derive(Debug, Clone)]",
                "// Line 178:     pub struct BcsSnappyCodec<T, U>(PhantomData<(T, U)>);",
                "// Line 179: "
            ]
        },
        {
            "filename_of_changes": "lib.rs",
            "code_language": "Rust",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 790:                         .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))",
                "// Line 791:                         .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),",
                "// Line 792:                 )",
                "// Line 793:                 .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(",
                "// Line 794:                     Arc::new(outbound_network_metrics),",
                "// Line 795:                     config.p2p_config.excessive_message_size(),",
                "// Line 796:                 )))",
                "// Line 797:                 .into_inner();",
                "// Line 798: ",
                "// Line 799:             let mut anemo_config = config.p2p_config.anemo_config.clone().unwrap_or_default();",
                "// vulnerable line: 800: // Set the max_frame_size to be 2 GB to work around the issue of there being too many",
                "// Line 801:             // staking events in the epoch change txn.",
                "// vulnerable line: 802: anemo_config.max_frame_size = Some(2 << 30);",
                "// Line 803: ",
                "// Line 804:             // Set a higher default value for socket send/receive buffers if not already",
                "// Line 805:             // configured.",
                "// Line 806:             let mut quic_config = anemo_config.quic.unwrap_or_default();",
                "// Line 807:             if quic_config.socket_send_buffer_size.is_none() {",
                "// Line 808:                 quic_config.socket_send_buffer_size = Some(20 << 20);",
                "// Line 809:             }",
                "// Line 810:             if quic_config.socket_receive_buffer_size.is_none() {",
                "// Line 811:                 quic_config.socket_receive_buffer_size = Some(20 << 20);",
                "// Line 812:             }"
            ]
        },
        {
            "filename_of_changes": "primary.rs",
            "code_language": "Rust",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 311:             quic_config.send_window = Some(200 << 20);",
                "// Line 312:             quic_config.crypto_buffer_size = Some(1 << 20);",
                "// Line 313:             quic_config.socket_receive_buffer_size = Some(20 << 20);",
                "// Line 314:             quic_config.socket_send_buffer_size = Some(20 << 20);",
                "// Line 315:             quic_config.allow_failed_socket_buffer_size_setting = true;",
                "// Line 316:             quic_config.max_idle_timeout_ms = Some(30_000);",
                "// Line 317:             // Enable keep alives every 5s",
                "// Line 318:             quic_config.keep_alive_interval_ms = Some(5_000);",
                "// Line 319:             let mut config = anemo::Config::default();",
                "// Line 320:             config.quic = Some(quic_config);",
                "// vulnerable line: 321: // Set the max_frame_size to be 2 GB to work around the issue of there being too many",
                "// Line 322:             // delegation events in the epoch change txn.",
                "// vulnerable line: 323: config.max_frame_size = Some(2 << 30);",
                "// Line 324:             // Set a default timeout of 300s for all RPC requests",
                "// Line 325:             config.inbound_request_timeout_ms = Some(300_000);",
                "// Line 326:             config.outbound_request_timeout_ms = Some(300_000);",
                "// Line 327:             config.shutdown_idle_timeout_ms = Some(1_000);",
                "// Line 328:             config.connectivity_check_interval_ms = Some(2_000);",
                "// Line 329:             config.connection_backoff_ms = Some(1_000);",
                "// Line 330:             config.max_connection_backoff_ms = Some(20_000);",
                "// Line 331:             config",
                "// Line 332:         };",
                "// Line 333: "
            ]
        },
        {
            "filename_of_changes": "worker.rs",
            "code_language": "Rust",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 235:             quic_config.send_window = Some(200 << 20);",
                "// Line 236:             quic_config.crypto_buffer_size = Some(1 << 20);",
                "// Line 237:             quic_config.socket_receive_buffer_size = Some(20 << 20);",
                "// Line 238:             quic_config.socket_send_buffer_size = Some(20 << 20);",
                "// Line 239:             quic_config.allow_failed_socket_buffer_size_setting = true;",
                "// Line 240:             quic_config.max_idle_timeout_ms = Some(30_000);",
                "// Line 241:             // Enable keep alives every 5s",
                "// Line 242:             quic_config.keep_alive_interval_ms = Some(5_000);",
                "// Line 243:             let mut config = anemo::Config::default();",
                "// Line 244:             config.quic = Some(quic_config);",
                "// vulnerable line: 245: // Set the max_frame_size to be 2 GB to work around the issue of there being too many",
                "// Line 246:             // delegation events in the epoch change txn.",
                "// vulnerable line: 247: config.max_frame_size = Some(2 << 30);",
                "// Line 248:             // Set a default timeout of 300s for all RPC requests",
                "// Line 249:             config.inbound_request_timeout_ms = Some(300_000);",
                "// Line 250:             config.outbound_request_timeout_ms = Some(300_000);",
                "// Line 251:             config.shutdown_idle_timeout_ms = Some(1_000);",
                "// Line 252:             config.connectivity_check_interval_ms = Some(2_000);",
                "// Line 253:             config.connection_backoff_ms = Some(1_000);",
                "// Line 254:             config.max_connection_backoff_ms = Some(20_000);",
                "// Line 255:             config",
                "// Line 256:         };",
                "// Line 257: "
            ]
        }
    ]
}