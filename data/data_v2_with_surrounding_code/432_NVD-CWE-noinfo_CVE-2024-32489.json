{
    "cve_id": "CVE-2024-32489",
    "cve_description": "TCPDF before 6.7.4 mishandles calls that use HTML syntax.",
    "cve_publish_date": "2024-04-15T06:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Squash multiple fixes",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "example_049.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "18",
            "number_of_lines_deleted_vulnerable_to_cve": "16",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: <?php",
                "// Line 2: //============================================================+",
                "// Line 3: // File name   : example_049.php",
                "// Line 4: // Begin       : 2009-04-03",
                "// vulnerable line: 5: // Last Update : 2014-12-10",
                "// Line 6: //",
                "// Line 7: // Description : Example 049 for TCPDF class",
                "// Line 8: //               WriteHTML with TCPDF callback functions",
                "// Line 9: //",
                "// Line 10: // Author: Nicola Asuni",
                "// Line 11: //",
                "// Line 12: // (c) Copyright:",
                "// Line 13: //               Nicola Asuni",
                "// Line 14: //               Tecnick.com LTD",
                "// Line 15: //               www.tecnick.com",
                "// Line 71: // set font",
                "// Line 72: $pdf->setFont('helvetica', '', 10);",
                "// Line 73: ",
                "// Line 74: // add a page",
                "// Line 75: $pdf->AddPage();",
                "// Line 76: ",
                "// Line 77: ",
                "// Line 78: /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *",
                "// Line 79: ",
                "// Line 80: IMPORTANT:",
                "// vulnerable line: 81: If you are printing user-generated content, tcpdf tag can be unsafe.",
                "// vulnerable line: 82: You can disable this tag by setting to false the K_TCPDF_CALLS_IN_HTML",
                "// vulnerable line: 83: constant on TCPDF configuration file.",
                "// Line 84: ",
                "// vulnerable line: 85: For security reasons, the parameters for the 'params' attribute of TCPDF",
                "// Line 86: tag must be prepared as an array and encoded with the",
                "// Line 87: serializeTCPDFtagParameters() method (see the example below).",
                "// Line 88: ",
                "// Line 89:  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */",
                "// Line 90: ",
                "// Line 91: ",
                "// Line 92: $html = '<h1>Test TCPDF Methods in HTML</h1>",
                "// Line 93: <h2 style=\"color:red;\">IMPORTANT:</h2>",
                "// vulnerable line: 94: <span style=\"color:red;\">If you are using user-generated content, the tcpdf tag can be unsafe.<br />",
                "// vulnerable line: 95: You can disable this tag by setting to false the <b>K_TCPDF_CALLS_IN_HTML</b> constant on TCPDF configuration file.</span>",
                "// Line 96: <h2>write1DBarcode method in HTML</h2>';",
                "// Line 97: ",
                "// vulnerable line: 98: $params = $pdf->serializeTCPDFtagParameters(array('CODE 39', 'C39', '', '', 80, 30, 0.4, array('position'=>'S', 'border'=>true, 'padding'=>4, 'fgcolor'=>array(0,0,0), 'bgcolor'=>array(255,255,255), 'text'=>true, 'font'=>'helvetica', 'fontsize'=>8, 'stretchtext'=>4), 'N'));",
                "// vulnerable line: 99: $html .= '<tcpdf method=\"write1DBarcode\" params=\"'.$params.'\" />';",
                "// Line 100: ",
                "// vulnerable line: 101: $params = $pdf->serializeTCPDFtagParameters(array('CODE 128', 'C128', '', '', 80, 30, 0.4, array('position'=>'S', 'border'=>true, 'padding'=>4, 'fgcolor'=>array(0,0,0), 'bgcolor'=>array(255,255,255), 'text'=>true, 'font'=>'helvetica', 'fontsize'=>8, 'stretchtext'=>4), 'N'));",
                "// vulnerable line: 102: $html .= '<tcpdf method=\"write1DBarcode\" params=\"'.$params.'\" />';",
                "// Line 103: ",
                "// vulnerable line: 104: $html .= '<tcpdf method=\"AddPage\" /><h2>Graphic Functions</h2>';",
                "// Line 105: ",
                "// vulnerable line: 106: $params = $pdf->serializeTCPDFtagParameters(array(0));",
                "// vulnerable line: 107: $html .= '<tcpdf method=\"SetDrawColor\" params=\"'.$params.'\" />';",
                "// Line 108: ",
                "// vulnerable line: 109: $params = $pdf->serializeTCPDFtagParameters(array(50, 50, 40, 10, 'DF', array(), array(0,128,255)));",
                "// vulnerable line: 110: $html .= '<tcpdf method=\"Rect\" params=\"'.$params.'\" />';",
                "// Line 111: ",
                "// Line 112: ",
                "// Line 113: // output the HTML content",
                "// Line 114: $pdf->writeHTML($html, true, 0, true, 0);",
                "// Line 115: ",
                "// Line 116: // - - - - - - - - - - - - - - - - - - - - - - - - - - - - -",
                "// Line 117: ",
                "// Line 118: // reset pointer to the last page",
                "// Line 119: $pdf->lastPage();",
                "// Line 120: "
            ]
        },
        {
            "filename_of_changes": "example_066.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 11: /**",
                "// Line 12:  * Creates an example PDF/A-1b document using TCPDF",
                "// Line 13:  *",
                "// Line 14:  * @abstract TCPDF - Example: PDF/A-1b mode",
                "// Line 15:  * @author Nicola Asuni",
                "// Line 16:  * @since 2021-03-26",
                "// Line 17:  * @group A-1b",
                "// Line 18:  * @group pdf",
                "// Line 19:  */",
                "// Line 20: ",
                "// vulnerable line: 21: // Load the autoloader, move one folder back from examples",
                "// vulnerable line: 22: require_once __DIR__ . '/../vendor/autoload.php';",
                "// Line 23: ",
                "// Line 24: // create new PDF document",
                "// Line 25: $pdf = new TCPDF(PDF_PAGE_ORIENTATION, PDF_UNIT, PDF_PAGE_FORMAT, true, 'UTF-8', false, true);",
                "// Line 26: ",
                "// Line 27: // set document information",
                "// Line 28: $pdf->setCreator(PDF_CREATOR);",
                "// Line 29: $pdf->setAuthor('Nicola Asuni');",
                "// Line 30: $pdf->setTitle('TCPDF Example 066');",
                "// Line 31: $pdf->setSubject('TCPDF Tutorial');",
                "// Line 32: $pdf->setKeywords('TCPDF, PDF, example, test, guide');"
            ]
        },
        {
            "filename_of_changes": "qrcode.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "tcpdf_autoconfig.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "tcpdf_barcodes_1d.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "3",
            "number_of_lines_deleted_vulnerable_to_cve": "3",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 832:      */",
                "// Line 833:     protected function barcode_s25($code, $checksum=false) {",
                "// Line 834:         $chr['0'] = '10101110111010';",
                "// Line 835:         $chr['1'] = '11101010101110';",
                "// Line 836:         $chr['2'] = '10111010101110';",
                "// Line 837:         $chr['3'] = '11101110101010';",
                "// Line 838:         $chr['4'] = '10101110101110';",
                "// Line 839:         $chr['5'] = '11101011101010';",
                "// Line 840:         $chr['6'] = '10111011101010';",
                "// Line 841:         $chr['7'] = '10101011101110';",
                "// vulnerable line: 842: $chr['8'] = '10101110111010';",
                "// Line 843:         $chr['9'] = '10111010111010';",
                "// Line 844:         if ($checksum) {",
                "// Line 845:             // add checksum",
                "// Line 846:             $code .= $this->checksum_s25($code);",
                "// Line 847:         }",
                "// Line 848:         if((strlen($code) % 2) != 0) {",
                "// Line 849:             // add leading zero if code-length is odd",
                "// Line 850:             $code = '0'.$code;",
                "// Line 851:         }",
                "// vulnerable line: 852: $seq = '11011010';",
                "// Line 853:         $clen = strlen($code);",
                "// Line 854:         for ($i = 0; $i < $clen; ++$i) {",
                "// Line 855:             $digit = $code[$i];",
                "// Line 856:             if (!isset($chr[$digit])) {",
                "// Line 857:                 // invalid character",
                "// Line 858:                 return false;",
                "// Line 859:             }",
                "// Line 860:             $seq .= $chr[$digit];",
                "// Line 861:         }",
                "// vulnerable line: 862: $seq .= '1101011';",
                "// Line 863:         $bararray = array('code' => $code, 'maxw' => 0, 'maxh' => 1, 'bcode' => array());",
                "// Line 864:         return $this->binseq_to_array($seq, $bararray);",
                "// Line 865:     }",
                "// Line 866: ",
                "// Line 867:     /**",
                "// Line 868:      * Convert binary barcode sequence to WarnockPDF barcode array.",
                "// Line 869:      * @param string $seq barcode as binary sequence.",
                "// Line 870:      * @param array $bararray barcode array to fill up",
                "// Line 871:      * @return array barcode representation.",
                "// Line 872:      * @protected"
            ]
        },
        {
            "filename_of_changes": "tcpdf_config.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "tcpdf_config_alt.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "8",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "tcpdf_fonts.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "25",
            "number_of_lines_deleted_vulnerable_to_cve": "25",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 66:      * @param boolean $link If true link to system font instead of copying the font data (not transportable) - Note: do not work with Type1 fonts.",
                "// Line 67:      * @return string|false TCPDF font name or boolean false in case of error.",
                "// Line 68:      * @author Nicola Asuni",
                "// Line 69:      * @since 5.9.123 (2010-09-30)",
                "// Line 70:      * @public static",
                "// Line 71:      */",
                "// Line 72:     public static function addTTFfont($fontfile, $fonttype='', $enc='', $flags=32, $outpath='', $platid=3, $encid=1, $addcbbox=false, $link=false) {",
                "// Line 73:         if (!TCPDF_STATIC::file_exists($fontfile)) {",
                "// Line 74:             // Could not find file",
                "// Line 75:             return false;",
                "// vulnerable line: 76: }",
                "// Line 77:         // font metrics",
                "// Line 78:         $fmetric = array();",
                "// Line 79:         // build new font name for TCPDF compatibility",
                "// Line 80:         $font_path_parts = pathinfo($fontfile);",
                "// Line 81:         if (!isset($font_path_parts['filename'])) {",
                "// Line 82:             $font_path_parts['filename'] = substr($font_path_parts['basename'], 0, -(strlen($font_path_parts['extension']) + 1));",
                "// vulnerable line: 83: }",
                "// Line 84:         $font_name = strtolower($font_path_parts['filename']);",
                "// Line 85:         $font_name = preg_replace('/[^a-z0-9_]/', '', $font_name);",
                "// Line 86:         $search  = array('bold', 'oblique', 'italic', 'regular');",
                "// Line 87:         $replace = array('b', 'i', 'i', '');",
                "// Line 88:         $font_name = str_replace($search, $replace, $font_name);",
                "// Line 89:         if (empty($font_name)) {",
                "// Line 90:             // set generic name",
                "// Line 91:             $font_name = 'tcpdffont';",
                "// vulnerable line: 92: }",
                "// Line 93:         // set output path",
                "// Line 94:         if (empty($outpath)) {",
                "// Line 95:             $outpath = self::_getfontpath();",
                "// vulnerable line: 96: }",
                "// Line 97:         // check if this font already exist",
                "// Line 98:         if (@TCPDF_STATIC::file_exists($outpath.$font_name.'.php')) {",
                "// Line 99:             // this font already exist (delete it from fonts folder to rebuild it)",
                "// Line 100:             return $font_name;",
                "// vulnerable line: 101: }",
                "// Line 102:         $fmetric['file'] = $font_name;",
                "// Line 103:         $fmetric['ctg'] = $font_name.'.ctg.z';",
                "// Line 104:         // get font data",
                "// Line 105:         $font = file_get_contents($fontfile);",
                "// Line 106:         $fmetric['originalsize'] = strlen($font);",
                "// Line 107:         // autodetect font type",
                "// Line 108:         if (empty($fonttype)) {",
                "// Line 109:             if (TCPDF_STATIC::_getULONG($font, 0) == 0x10000) {",
                "// Line 110:                 // True Type (Unicode or not)",
                "// Line 111:                 $fonttype = 'TrueTypeUnicode';",
                "// Line 112:             } elseif (substr($font, 0, 4) == 'OTTO') {",
                "// Line 113:                 // Open Type (Unicode or not)",
                "// Line 114:                 //Unsupported font format: OpenType with CFF data",
                "// Line 115:                 return false;",
                "// Line 116:             } else {",
                "// Line 117:                 // Type 1",
                "// Line 118:                 $fonttype = 'Type1';",
                "// vulnerable line: 119: }",
                "// vulnerable line: 120: }",
                "// Line 121:         // set font type",
                "// Line 122:         switch ($fonttype) {",
                "// Line 123:             case 'CID0CT':",
                "// Line 124:             case 'CID0CS':",
                "// Line 125:             case 'CID0KR':",
                "// Line 126:             case 'CID0JP': {",
                "// Line 127:                 $fmetric['type'] = 'cidfont0';",
                "// Line 128:                 break;",
                "// vulnerable line: 129: }",
                "// Line 130:             case 'Type1': {",
                "// Line 131:                 $fmetric['type'] = 'Type1';",
                "// Line 132:                 if (empty($enc) AND (($flags & 4) == 0)) {",
                "// Line 133:                     $enc = 'cp1252';",
                "// vulnerable line: 134: }",
                "// Line 135:                 break;",
                "// vulnerable line: 136: }",
                "// Line 137:             case 'TrueType': {",
                "// Line 138:                 $fmetric['type'] = 'TrueType';",
                "// Line 139:                 break;",
                "// vulnerable line: 140: }",
                "// Line 141:             case 'TrueTypeUnicode':",
                "// Line 142:             default: {",
                "// Line 143:                 $fmetric['type'] = 'TrueTypeUnicode';",
                "// Line 144:                 break;",
                "// vulnerable line: 145: }",
                "// vulnerable line: 146: }",
                "// Line 147:         // set encoding maps (if any)",
                "// Line 148:         $fmetric['enc'] = preg_replace('/[^A-Za-z0-9_\\-]/', '', $enc);",
                "// Line 149:         $fmetric['diff'] = '';",
                "// Line 150:         if (($fmetric['type'] == 'TrueType') OR ($fmetric['type'] == 'Type1')) {",
                "// Line 151:             if (!empty($enc) AND ($enc != 'cp1252') AND isset(TCPDF_FONT_DATA::$encmap[$enc])) {",
                "// Line 152:                 // build differences from reference encoding",
                "// Line 153:                 $enc_ref = TCPDF_FONT_DATA::$encmap['cp1252'];",
                "// Line 154:                 $enc_target = TCPDF_FONT_DATA::$encmap[$enc];",
                "// Line 155:                 $last = 0;",
                "// Line 156:                 for ($i = 32; $i <= 255; ++$i) {",
                "// Line 157:                     if ($enc_target[$i] != $enc_ref[$i]) {",
                "// Line 158:                         if ($i != ($last + 1)) {",
                "// Line 159:                             $fmetric['diff'] .= $i.' ';",
                "// vulnerable line: 160: }",
                "// Line 161:                         $last = $i;",
                "// Line 162:                         $fmetric['diff'] .= '/'.$enc_target[$i].' ';",
                "// vulnerable line: 163: }",
                "// vulnerable line: 164: }",
                "// vulnerable line: 165: }",
                "// vulnerable line: 166: }",
                "// Line 167:         // parse the font by type",
                "// Line 168:         if ($fmetric['type'] == 'Type1') {",
                "// Line 169:             // ---------- TYPE 1 ----------",
                "// Line 170:             // read first segment",
                "// Line 171:             $a = unpack('Cmarker/Ctype/Vsize', substr($font, 0, 6));",
                "// Line 172:             if ($a['marker'] != 128) {",
                "// Line 173:                 // Font file is not a valid binary Type1",
                "// Line 174:                 return false;",
                "// vulnerable line: 175: }",
                "// Line 176:             $fmetric['size1'] = $a['size'];",
                "// Line 177:             $data = substr($font, 6, $fmetric['size1']);",
                "// Line 178:             // read second segment",
                "// Line 179:             $a = unpack('Cmarker/Ctype/Vsize', substr($font, (6 + $fmetric['size1']), 6));",
                "// Line 180:             if ($a['marker'] != 128) {",
                "// Line 181:                 // Font file is not a valid binary Type1",
                "// Line 182:                 return false;",
                "// vulnerable line: 183: }",
                "// Line 184:             $fmetric['size2'] = $a['size'];",
                "// Line 185:             $encrypted = substr($font, (12 + $fmetric['size1']), $fmetric['size2']);",
                "// Line 186:             $data .= $encrypted;",
                "// Line 187:             // store compressed font",
                "// Line 188:             $fmetric['file'] .= '.z';",
                "// Line 189:             $fp = TCPDF_STATIC::fopenLocal($outpath.$fmetric['file'], 'wb');",
                "// Line 190:             fwrite($fp, gzcompress($data));",
                "// Line 191:             fclose($fp);",
                "// Line 192:             // get font info",
                "// Line 193:             $fmetric['Flags'] = $flags;",
                "// Line 195:             $fmetric['name'] = preg_replace('/[^a-zA-Z0-9_\\-]/', '', $matches[1]);",
                "// Line 196:             preg_match('#/FontBBox[\\s]*{([^}]*)#', $font, $matches);",
                "// Line 197:             $fmetric['bbox'] = trim($matches[1]);",
                "// Line 198:             $bv = explode(' ', $fmetric['bbox']);",
                "// Line 199:             $fmetric['Ascent'] = intval($bv[3]);",
                "// Line 200:             $fmetric['Descent'] = intval($bv[1]);",
                "// Line 201:             preg_match('#/ItalicAngle[\\s]*([0-9\\+\\-]*)#', $font, $matches);",
                "// Line 202:             $fmetric['italicAngle'] = intval($matches[1]);",
                "// Line 203:             if ($fmetric['italicAngle'] != 0) {",
                "// Line 204:                 $fmetric['Flags'] |= 64;",
                "// vulnerable line: 205: }",
                "// Line 206:             preg_match('#/UnderlinePosition[\\s]*([0-9\\+\\-]*)#', $font, $matches);",
                "// Line 207:             $fmetric['underlinePosition'] = intval($matches[1]);",
                "// Line 208:             preg_match('#/UnderlineThickness[\\s]*([0-9\\+\\-]*)#', $font, $matches);",
                "// Line 209:             $fmetric['underlineThickness'] = intval($matches[1]);",
                "// Line 210:             preg_match('#/isFixedPitch[\\s]*([^\\s]*)#', $font, $matches);",
                "// Line 211:             if ($matches[1] == 'true') {",
                "// Line 212:                 $fmetric['Flags'] |= 1;",
                "// vulnerable line: 213: }",
                "// Line 214:             // get internal map",
                "// Line 215:             $imap = array();",
                "// Line 216:             if (preg_match_all('#dup[\\s]([0-9]+)[\\s]*/([^\\s]*)[\\s]put#sU', $font, $fmap, PREG_SET_ORDER) > 0) {",
                "// Line 217:                 foreach ($fmap as $v) {",
                "// Line 218:                     $imap[$v[2]] = $v[1];",
                "// vulnerable line: 219: }",
                "// vulnerable line: 220: }",
                "// Line 221:             // decrypt eexec encrypted part",
                "// Line 222:             $r = 55665; // eexec encryption constant",
                "// Line 223:             $c1 = 52845;",
                "// Line 224:             $c2 = 22719;",
                "// Line 225:             $elen = strlen($encrypted);",
                "// Line 226:             $eplain = '';",
                "// Line 227:             for ($i = 0; $i < $elen; ++$i) {",
                "// Line 228:                 $chr = ord($encrypted[$i]);",
                "// Line 229:                 $eplain .= chr($chr ^ ($r >> 8));",
                "// Line 230:                 $r = ((($chr + $r) * $c1 + $c2) % 65536);",
                "// vulnerable line: 231: }",
                "// Line 232:             if (preg_match('#/ForceBold[\\s]*([^\\s]*)#', $eplain, $matches) > 0) {",
                "// Line 233:                 if ($matches[1] == 'true') {",
                "// Line 234:                     $fmetric['Flags'] |= 0x40000;",
                "// vulnerable line: 235: }",
                "// vulnerable line: 236: }",
                "// Line 237:             if (preg_match('#/StdVW[\\s]*\\[([^\\]]*)#', $eplain, $matches) > 0) {",
                "// Line 238:                 $fmetric['StemV'] = intval($matches[1]);",
                "// Line 239:             } else {",
                "// Line 240:                 $fmetric['StemV'] = 70;",
                "// vulnerable line: 241: }",
                "// Line 242:             if (preg_match('#/StdHW[\\s]*\\[([^\\]]*)#', $eplain, $matches) > 0) {",
                "// Line 243:                 $fmetric['StemH'] = intval($matches[1]);",
                "// Line 244:             } else {",
                "// Line 245:                 $fmetric['StemH'] = 30;",
                "// vulnerable line: 246: }",
                "// Line 247:             if (preg_match('#/BlueValues[\\s]*\\[([^\\]]*)#', $eplain, $matches) > 0) {",
                "// Line 248:                 $bv = explode(' ', $matches[1]);",
                "// Line 249:                 if (count($bv) >= 6) {",
                "// Line 250:                     $v1 = intval($bv[2]);",
                "// Line 251:                     $v2 = intval($bv[4]);",
                "// Line 252:                     if ($v1 <= $v2) {",
                "// Line 253:                         $fmetric['XHeight'] = $v1;",
                "// Line 254:                         $fmetric['CapHeight'] = $v2;",
                "// Line 255:                     } else {",
                "// Line 256:                         $fmetric['XHeight'] = $v2;",
                "// Line 257:                         $fmetric['CapHeight'] = $v1;",
                "// vulnerable line: 258: }",
                "// Line 259:                 } else {",
                "// Line 260:                     $fmetric['XHeight'] = 450;",
                "// Line 261:                     $fmetric['CapHeight'] = 700;",
                "// vulnerable line: 262: }",
                "// Line 263:             } else {",
                "// Line 264:                 $fmetric['XHeight'] = 450;",
                "// Line 265:                 $fmetric['CapHeight'] = 700;",
                "// vulnerable line: 266: }",
                "// Line 267:             // get the number of random bytes at the beginning of charstrings",
                "// Line 268:             if (preg_match('#/lenIV[\\s]*([0-9]*)#', $eplain, $matches) > 0) {",
                "// Line 269:                 $lenIV = intval($matches[1]);",
                "// Line 270:             } else {",
                "// Line 271:                 $lenIV = 4;",
                "// vulnerable line: 272: }",
                "// Line 273:             $fmetric['Leading'] = 0;",
                "// Line 274:             // get charstring data",
                "// Line 275:             $eplain = substr($eplain, (strpos($eplain, '/CharStrings') + 1));",
                "// Line 276:             preg_match_all('#/([A-Za-z0-9\\.]*)[\\s][0-9]+[\\s]RD[\\s](.*)[\\s]ND#sU', $eplain, $matches, PREG_SET_ORDER);",
                "// Line 277:             if (!empty($enc) AND isset(TCPDF_FONT_DATA::$encmap[$enc])) {",
                "// Line 278:                 $enc_map = TCPDF_FONT_DATA::$encmap[$enc];",
                "// Line 279:             } else {",
                "// Line 280:                 $enc_map = false;",
                "// vulnerable line: 281: }",
                "// Line 282:             $fmetric['cw'] = '';",
                "// Line 283:             $fmetric['MaxWidth'] = 0;",
                "// Line 284:             $cwidths = array();",
                "// Line 285:             foreach ($matches as $k => $v) {",
                "// Line 286:                 $cid = 0;",
                "// Line 287:                 if (isset($imap[$v[1]])) {",
                "// Line 288:                     $cid = $imap[$v[1]];",
                "// Line 289:                 } elseif ($enc_map !== false) {",
                "// Line 290:                     $cid = array_search($v[1], $enc_map);",
                "// Line 291:                     if ($cid === false) {",
                "// Line 292:                         $cid = 0;",
                "// Line 293:                     } elseif ($cid > 1000) {",
                "// Line 294:                         $cid -= 1000;",
                "// vulnerable line: 295: }",
                "// vulnerable line: 296: }",
                "// Line 297:                 // decrypt charstring encrypted part",
                "// Line 298:                 $r = 4330; // charstring encryption constant",
                "// Line 299:                 $c1 = 52845;",
                "// Line 300:                 $c2 = 22719;",
                "// Line 301:                 $cd = $v[2];",
                "// Line 302:                 $clen = strlen($cd);",
                "// Line 303:                 $ccom = array();",
                "// Line 304:                 for ($i = 0; $i < $clen; ++$i) {",
                "// Line 305:                     $chr = ord($cd[$i]);",
                "// Line 306:                     $ccom[] = ($chr ^ ($r >> 8));",
                "// Line 307:                     $r = ((($chr + $r) * $c1 + $c2) % 65536);",
                "// vulnerable line: 308: }",
                "// Line 309:                 // decode numbers",
                "// Line 310:                 $cdec = array();",
                "// Line 311:                 $ck = 0;",
                "// Line 312:                 $i = $lenIV;",
                "// Line 313:                 while ($i < $clen) {",
                "// Line 314:                     if ($ccom[$i] < 32) {",
                "// Line 315:                         $cdec[$ck] = $ccom[$i];",
                "// Line 316:                         if (($ck > 0) AND ($cdec[$ck] == 13)) {",
                "// Line 317:                             // hsbw command: update width",
                "// Line 318:                             $cwidths[$cid] = $cdec[($ck - 1)];",
                "// vulnerable line: 319: }",
                "// Line 320:                         ++$i;",
                "// Line 321:                     } elseif (($ccom[$i] >= 32) AND ($ccom[$i] <= 246)) {",
                "// Line 322:                         $cdec[$ck] = ($ccom[$i] - 139);",
                "// Line 323:                         ++$i;",
                "// Line 324:                     } elseif (($ccom[$i] >= 247) AND ($ccom[$i] <= 250)) {",
                "// Line 325:                         $cdec[$ck] = ((($ccom[$i] - 247) * 256) + $ccom[($i + 1)] + 108);",
                "// Line 326:                         $i += 2;",
                "// Line 327:                     } elseif (($ccom[$i] >= 251) AND ($ccom[$i] <= 254)) {",
                "// Line 328:                         $cdec[$ck] = ((-($ccom[$i] - 251) * 256) - $ccom[($i + 1)] - 108);",
                "// Line 329:                         $i += 2;",
                "// Line 330:                     } elseif ($ccom[$i] == 255) {",
                "// Line 331:                         $sval = chr($ccom[($i + 1)]).chr($ccom[($i + 2)]).chr($ccom[($i + 3)]).chr($ccom[($i + 4)]);",
                "// Line 332:                         $vsval = unpack('li', $sval);",
                "// Line 333:                         $cdec[$ck] = $vsval['i'];",
                "// Line 334:                         $i += 5;",
                "// vulnerable line: 335: }",
                "// Line 336:                     ++$ck;",
                "// vulnerable line: 337: }",
                "// Line 338:             } // end for each matches",
                "// Line 339:             $fmetric['MissingWidth'] = $cwidths[0];",
                "// Line 340:             $fmetric['MaxWidth'] = $fmetric['MissingWidth'];",
                "// Line 341:             $fmetric['AvgWidth'] = 0;",
                "// Line 342:             // set chars widths",
                "// Line 343:             for ($cid = 0; $cid <= 255; ++$cid) {",
                "// Line 344:                 if (isset($cwidths[$cid])) {",
                "// Line 345:                     if ($cwidths[$cid] > $fmetric['MaxWidth']) {",
                "// Line 346:                         $fmetric['MaxWidth'] = $cwidths[$cid];",
                "// vulnerable line: 347: }",
                "// Line 348:                     $fmetric['AvgWidth'] += $cwidths[$cid];",
                "// Line 349:                     $fmetric['cw'] .= ','.$cid.'=>'.$cwidths[$cid];",
                "// Line 350:                 } else {",
                "// Line 351:                     $fmetric['cw'] .= ','.$cid.'=>'.$fmetric['MissingWidth'];",
                "// vulnerable line: 352: }",
                "// vulnerable line: 353: }",
                "// Line 354:             $fmetric['AvgWidth'] = round($fmetric['AvgWidth'] / count($cwidths));",
                "// Line 355:         } else {",
                "// Line 356:             // ---------- TRUE TYPE ----------",
                "// Line 357:             $offset = 0; // offset position of the font data",
                "// Line 358:             if (TCPDF_STATIC::_getULONG($font, $offset) != 0x10000) {",
                "// Line 359:                 // sfnt version must be 0x00010000 for TrueType version 1.0.",
                "// Line 360:                 return false;",
                "// vulnerable line: 361: }",
                "// Line 362:             if ($fmetric['type'] != 'cidfont0') {",
                "// Line 363:                 if ($link) {",
                "// Line 364:                     // creates a symbolic link to the existing font",
                "// Line 365:                     symlink($fontfile, $outpath.$fmetric['file']);",
                "// Line 366:                 } else {",
                "// Line 367:                     // store compressed font",
                "// Line 368:                     $fmetric['file'] .= '.z';",
                "// Line 369:                     $fp = TCPDF_STATIC::fopenLocal($outpath.$fmetric['file'], 'wb');",
                "// Line 370:                     fwrite($fp, gzcompress($font));",
                "// Line 371:                     fclose($fp);",
                "// vulnerable line: 372: }",
                "// vulnerable line: 373: }",
                "// Line 374:             $offset += 4;",
                "// Line 375:             // get number of tables",
                "// Line 376:             $numTables = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 377:             $offset += 2;",
                "// Line 378:             // skip searchRange, entrySelector and rangeShift",
                "// Line 379:             $offset += 6;",
                "// Line 380:             // tables array",
                "// Line 381:             $table = array();",
                "// Line 382:             // ---------- get tables ----------",
                "// Line 383:             for ($i = 0; $i < $numTables; ++$i) {",
                "// Line 384:                 // get table info",
                "// Line 385:                 $tag = substr($font, $offset, 4);",
                "// Line 386:                 $offset += 4;",
                "// Line 387:                 $table[$tag] = array();",
                "// Line 388:                 $table[$tag]['checkSum'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 389:                 $offset += 4;",
                "// Line 390:                 $table[$tag]['offset'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 391:                 $offset += 4;",
                "// Line 392:                 $table[$tag]['length'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 393:                 $offset += 4;",
                "// vulnerable line: 394: }",
                "// Line 395:             // check magicNumber",
                "// Line 396:             $offset = $table['head']['offset'] + 12;",
                "// Line 397:             if (TCPDF_STATIC::_getULONG($font, $offset) != 0x5F0F3CF5) {",
                "// Line 398:                 // magicNumber must be 0x5F0F3CF5",
                "// Line 399:                 return false;",
                "// vulnerable line: 400: }",
                "// Line 401:             $offset += 4;",
                "// Line 402:             $offset += 2; // skip flags",
                "// Line 403:             // get FUnits",
                "// Line 404:             $fmetric['unitsPerEm'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 405:             $offset += 2;",
                "// Line 406:             // units ratio constant",
                "// Line 407:             $urk = (1000 / $fmetric['unitsPerEm']);",
                "// Line 408:             $offset += 16; // skip created, modified",
                "// Line 409:             $xMin = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 410:             $offset += 2;",
                "// Line 415:             $yMax = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 416:             $offset += 2;",
                "// Line 417:             $fmetric['bbox'] = ''.$xMin.' '.$yMin.' '.$xMax.' '.$yMax.'';",
                "// Line 418:             $macStyle = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 419:             $offset += 2;",
                "// Line 420:             // PDF font flags",
                "// Line 421:             $fmetric['Flags'] = $flags;",
                "// Line 422:             if (($macStyle & 2) == 2) {",
                "// Line 423:                 // italic flag",
                "// Line 424:                 $fmetric['Flags'] |= 64;",
                "// vulnerable line: 425: }",
                "// Line 426:             // get offset mode (indexToLocFormat : 0 = short, 1 = long)",
                "// Line 427:             $offset = $table['head']['offset'] + 50;",
                "// Line 428:             $short_offset = (TCPDF_STATIC::_getSHORT($font, $offset) == 0);",
                "// Line 429:             $offset += 2;",
                "// Line 430:             // get the offsets to the locations of the glyphs in the font, relative to the beginning of the glyphData table",
                "// Line 431:             $indexToLoc = array();",
                "// Line 432:             $offset = $table['loca']['offset'];",
                "// Line 433:             if ($short_offset) {",
                "// Line 434:                 // short version",
                "// Line 435:                 $tot_num_glyphs = floor($table['loca']['length'] / 2); // numGlyphs + 1",
                "// Line 436:                 for ($i = 0; $i < $tot_num_glyphs; ++$i) {",
                "// Line 437:                     $indexToLoc[$i] = TCPDF_STATIC::_getUSHORT($font, $offset) * 2;",
                "// Line 438:                     if (isset($indexToLoc[($i - 1)]) && ($indexToLoc[$i] == $indexToLoc[($i - 1)])) {",
                "// Line 439:                         // the last glyph didn't have an outline",
                "// Line 440:                         unset($indexToLoc[($i - 1)]);",
                "// vulnerable line: 441: }",
                "// Line 442:                     $offset += 2;",
                "// vulnerable line: 443: }",
                "// Line 444:             } else {",
                "// Line 445:                 // long version",
                "// Line 446:                 $tot_num_glyphs = floor($table['loca']['length'] / 4); // numGlyphs + 1",
                "// Line 447:                 for ($i = 0; $i < $tot_num_glyphs; ++$i) {",
                "// Line 448:                     $indexToLoc[$i] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 449:                     if (isset($indexToLoc[($i - 1)]) && ($indexToLoc[$i] == $indexToLoc[($i - 1)])) {",
                "// Line 450:                         // the last glyph didn't have an outline",
                "// Line 451:                         unset($indexToLoc[($i - 1)]);",
                "// vulnerable line: 452: }",
                "// Line 453:                     $offset += 4;",
                "// vulnerable line: 454: }",
                "// vulnerable line: 455: }",
                "// Line 456:             // get glyphs indexes of chars from cmap table",
                "// Line 457:             $offset = $table['cmap']['offset'] + 2;",
                "// Line 458:             $numEncodingTables = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 459:             $offset += 2;",
                "// Line 460:             $encodingTables = array();",
                "// Line 461:             for ($i = 0; $i < $numEncodingTables; ++$i) {",
                "// Line 462:                 $encodingTables[$i]['platformID'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 463:                 $offset += 2;",
                "// Line 464:                 $encodingTables[$i]['encodingID'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 465:                 $offset += 2;",
                "// Line 466:                 $encodingTables[$i]['offset'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 467:                 $offset += 4;",
                "// vulnerable line: 468: }",
                "// Line 469:             // ---------- get os/2 metrics ----------",
                "// Line 470:             $offset = $table['OS/2']['offset'];",
                "// Line 471:             $offset += 2; // skip version",
                "// Line 472:             // xAvgCharWidth",
                "// Line 473:             $fmetric['AvgWidth'] = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 474:             $offset += 2;",
                "// Line 475:             // usWeightClass",
                "// Line 476:             $usWeightClass = round(TCPDF_STATIC::_getUFWORD($font, $offset) * $urk);",
                "// Line 477:             // estimate StemV and StemH (400 = usWeightClass for Normal - Regular font)",
                "// Line 478:             $fmetric['StemV'] = round((70 * $usWeightClass) / 400);",
                "// Line 479:             $fmetric['StemH'] = round((30 * $usWeightClass) / 400);",
                "// Line 480:             $offset += 2;",
                "// Line 481:             $offset += 2; // usWidthClass",
                "// Line 482:             $fsType = TCPDF_STATIC::_getSHORT($font, $offset);",
                "// Line 483:             $offset += 2;",
                "// Line 484:             if ($fsType == 2) {",
                "// Line 485:                 // This Font cannot be modified, embedded or exchanged in any manner without first obtaining permission of the legal owner.",
                "// Line 486:                 return false;",
                "// vulnerable line: 487: }",
                "// Line 488:             // ---------- get font name ----------",
                "// Line 489:             $fmetric['name'] = '';",
                "// Line 490:             $offset = $table['name']['offset'];",
                "// Line 491:             $offset += 2; // skip Format selector (=0).",
                "// Line 492:             // Number of NameRecords that follow n.",
                "// Line 493:             $numNameRecords = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 494:             $offset += 2;",
                "// Line 495:             // Offset to start of string storage (from start of table).",
                "// Line 496:             $stringStorageOffset = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 497:             $offset += 2;",
                "// Line 506:                     $offset += 2;",
                "// Line 507:                     // String offset from start of storage area (in bytes).",
                "// Line 508:                     $stringOffset = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 509:                     $offset += 2;",
                "// Line 510:                     $offset = ($table['name']['offset'] + $stringStorageOffset + $stringOffset);",
                "// Line 511:                     $fmetric['name'] = substr($font, $offset, $stringLength);",
                "// Line 512:                     $fmetric['name'] = preg_replace('/[^a-zA-Z0-9_\\-]/', '', $fmetric['name']);",
                "// Line 513:                     break;",
                "// Line 514:                 } else {",
                "// Line 515:                     $offset += 4; // skip String length, String offset",
                "// vulnerable line: 516: }",
                "// vulnerable line: 517: }",
                "// Line 518:             if (empty($fmetric['name'])) {",
                "// Line 519:                 $fmetric['name'] = $font_name;",
                "// vulnerable line: 520: }",
                "// Line 521:             // ---------- get post data ----------",
                "// Line 522:             $offset = $table['post']['offset'];",
                "// Line 523:             $offset += 4; // skip Format Type",
                "// Line 524:             $fmetric['italicAngle'] = TCPDF_STATIC::_getFIXED($font, $offset);",
                "// Line 525:             $offset += 4;",
                "// Line 526:             $fmetric['underlinePosition'] = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 527:             $offset += 2;",
                "// Line 528:             $fmetric['underlineThickness'] = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 529:             $offset += 2;",
                "// Line 530:             $isFixedPitch = (TCPDF_STATIC::_getULONG($font, $offset) == 0) ? false : true;",
                "// Line 531:             $offset += 2;",
                "// Line 532:             if ($isFixedPitch) {",
                "// Line 533:                 $fmetric['Flags'] |= 1;",
                "// vulnerable line: 534: }",
                "// Line 535:             // ---------- get hhea data ----------",
                "// Line 536:             $offset = $table['hhea']['offset'];",
                "// Line 537:             $offset += 4; // skip Table version number",
                "// Line 538:             // Ascender",
                "// Line 539:             $fmetric['Ascent'] = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 540:             $offset += 2;",
                "// Line 541:             // Descender",
                "// Line 542:             $fmetric['Descent'] = round(TCPDF_STATIC::_getFWORD($font, $offset) * $urk);",
                "// Line 543:             $offset += 2;",
                "// Line 544:             // LineGap",
                "// Line 564:                     $offset = $table['cmap']['offset'] + $enctable['offset'];",
                "// Line 565:                     $format = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 566:                     $offset += 2;",
                "// Line 567:                     switch ($format) {",
                "// Line 568:                         case 0: { // Format 0: Byte encoding table",
                "// Line 569:                             $offset += 4; // skip length and version/language",
                "// Line 570:                             for ($c = 0; $c < 256; ++$c) {",
                "// Line 571:                                 $g = TCPDF_STATIC::_getBYTE($font, $offset);",
                "// Line 572:                                 $ctg[$c] = $g;",
                "// Line 573:                                 ++$offset;",
                "// vulnerable line: 574: }",
                "// Line 575:                             break;",
                "// vulnerable line: 576: }",
                "// Line 577:                         case 2: { // Format 2: High-byte mapping through table",
                "// Line 578:                             $offset += 4; // skip length and version/language",
                "// Line 579:                             $numSubHeaders = 0;",
                "// Line 580:                             for ($i = 0; $i < 256; ++$i) {",
                "// Line 581:                                 // Array that maps high bytes to subHeaders: value is subHeader index * 8.",
                "// Line 582:                                 $subHeaderKeys[$i] = (TCPDF_STATIC::_getUSHORT($font, $offset) / 8);",
                "// Line 583:                                 $offset += 2;",
                "// Line 584:                                 if ($numSubHeaders < $subHeaderKeys[$i]) {",
                "// Line 585:                                     $numSubHeaders = $subHeaderKeys[$i];",
                "// vulnerable line: 586: }",
                "// vulnerable line: 587: }",
                "// Line 588:                             // the number of subHeaders is equal to the max of subHeaderKeys + 1",
                "// Line 589:                             ++$numSubHeaders;",
                "// Line 590:                             // read subHeader structures",
                "// Line 591:                             $subHeaders = array();",
                "// Line 592:                             $numGlyphIndexArray = 0;",
                "// Line 593:                             for ($k = 0; $k < $numSubHeaders; ++$k) {",
                "// Line 594:                                 $subHeaders[$k]['firstCode'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 595:                                 $offset += 2;",
                "// Line 596:                                 $subHeaders[$k]['entryCount'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 597:                                 $offset += 2;",
                "// Line 598:                                 $subHeaders[$k]['idDelta'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 599:                                 $offset += 2;",
                "// Line 600:                                 $subHeaders[$k]['idRangeOffset'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 601:                                 $offset += 2;",
                "// Line 602:                                 $subHeaders[$k]['idRangeOffset'] -= (2 + (($numSubHeaders - $k - 1) * 8));",
                "// Line 603:                                 $subHeaders[$k]['idRangeOffset'] /= 2;",
                "// Line 604:                                 $numGlyphIndexArray += $subHeaders[$k]['entryCount'];",
                "// vulnerable line: 605: }",
                "// Line 606:                             for ($k = 0; $k < $numGlyphIndexArray; ++$k) {",
                "// Line 607:                                 $glyphIndexArray[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 608:                                 $offset += 2;",
                "// vulnerable line: 609: }",
                "// Line 610:                             for ($i = 0; $i < 256; ++$i) {",
                "// Line 611:                                 $k = $subHeaderKeys[$i];",
                "// Line 612:                                 if ($k == 0) {",
                "// Line 613:                                     // one byte code",
                "// Line 614:                                     $c = $i;",
                "// Line 615:                                     $g = $glyphIndexArray[0];",
                "// Line 616:                                     $ctg[$c] = $g;",
                "// Line 617:                                 } else {",
                "// Line 618:                                     // two bytes code",
                "// Line 619:                                     $start_byte = $subHeaders[$k]['firstCode'];",
                "// Line 620:                                     $end_byte = $start_byte + $subHeaders[$k]['entryCount'];",
                "// Line 621:                                     for ($j = $start_byte; $j < $end_byte; ++$j) {",
                "// Line 622:                                         // combine high and low bytes",
                "// Line 623:                                         $c = (($i << 8) + $j);",
                "// Line 624:                                         $idRangeOffset = ($subHeaders[$k]['idRangeOffset'] + $j - $subHeaders[$k]['firstCode']);",
                "// Line 625:                                         $g = ($glyphIndexArray[$idRangeOffset] + $subHeaders[$k]['idDelta']) % 65536;",
                "// Line 626:                                         if ($g < 0) {",
                "// Line 627:                                             $g = 0;",
                "// vulnerable line: 628: }",
                "// Line 629:                                         $ctg[$c] = $g;",
                "// vulnerable line: 630: }",
                "// vulnerable line: 631: }",
                "// vulnerable line: 632: }",
                "// Line 633:                             break;",
                "// vulnerable line: 634: }",
                "// Line 635:                         case 4: { // Format 4: Segment mapping to delta values",
                "// Line 636:                             $length = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 637:                             $offset += 2;",
                "// Line 638:                             $offset += 2; // skip version/language",
                "// Line 639:                             $segCount = floor(TCPDF_STATIC::_getUSHORT($font, $offset) / 2);",
                "// Line 640:                             $offset += 2;",
                "// Line 641:                             $offset += 6; // skip searchRange, entrySelector, rangeShift",
                "// Line 642:                             $endCount = array(); // array of end character codes for each segment",
                "// Line 643:                             for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 644:                                 $endCount[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 645:                                 $offset += 2;",
                "// vulnerable line: 646: }",
                "// Line 647:                             $offset += 2; // skip reservedPad",
                "// Line 648:                             $startCount = array(); // array of start character codes for each segment",
                "// Line 649:                             for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 650:                                 $startCount[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 651:                                 $offset += 2;",
                "// vulnerable line: 652: }",
                "// Line 653:                             $idDelta = array(); // delta for all character codes in segment",
                "// Line 654:                             for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 655:                                 $idDelta[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 656:                                 $offset += 2;",
                "// vulnerable line: 657: }",
                "// Line 658:                             $idRangeOffset = array(); // Offsets into glyphIdArray or 0",
                "// Line 659:                             for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 660:                                 $idRangeOffset[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 661:                                 $offset += 2;",
                "// vulnerable line: 662: }",
                "// Line 663:                             $gidlen = (floor($length / 2) - 8 - (4 * $segCount));",
                "// Line 664:                             $glyphIdArray = array(); // glyph index array",
                "// Line 665:                             for ($k = 0; $k < $gidlen; ++$k) {",
                "// Line 666:                                 $glyphIdArray[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 667:                                 $offset += 2;",
                "// vulnerable line: 668: }",
                "// Line 669:                             for ($k = 0; $k < $segCount - 1; ++$k) {",
                "// Line 670:                                 for ($c = $startCount[$k]; $c <= $endCount[$k]; ++$c) {",
                "// Line 671:                                     if ($idRangeOffset[$k] == 0) {",
                "// Line 672:                                         $g = ($idDelta[$k] + $c) % 65536;",
                "// Line 673:                                     } else {",
                "// Line 674:                                         $gid = (floor($idRangeOffset[$k] / 2) + ($c - $startCount[$k]) - ($segCount - $k));",
                "// Line 675:                                         $g = ($glyphIdArray[$gid] + $idDelta[$k]) % 65536;",
                "// vulnerable line: 676: }",
                "// Line 677:                                     if ($g < 0) {",
                "// Line 678:                                         $g = 0;",
                "// vulnerable line: 679: }",
                "// Line 680:                                     $ctg[$c] = $g;",
                "// vulnerable line: 681: }",
                "// vulnerable line: 682: }",
                "// Line 683:                             break;",
                "// vulnerable line: 684: }",
                "// Line 685:                         case 6: { // Format 6: Trimmed table mapping",
                "// Line 686:                             $offset += 4; // skip length and version/language",
                "// Line 687:                             $firstCode = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 688:                             $offset += 2;",
                "// Line 689:                             $entryCount = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 690:                             $offset += 2;",
                "// Line 691:                             for ($k = 0; $k < $entryCount; ++$k) {",
                "// Line 692:                                 $c = ($k + $firstCode);",
                "// Line 693:                                 $g = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 694:                                 $offset += 2;",
                "// Line 695:                                 $ctg[$c] = $g;",
                "// vulnerable line: 696: }",
                "// Line 697:                             break;",
                "// vulnerable line: 698: }",
                "// Line 699:                         case 8: { // Format 8: Mixed 16-bit and 32-bit coverage",
                "// Line 700:                             $offset += 10; // skip reserved, length and version/language",
                "// Line 701:                             for ($k = 0; $k < 8192; ++$k) {",
                "// Line 702:                                 $is32[$k] = TCPDF_STATIC::_getBYTE($font, $offset);",
                "// Line 703:                                 ++$offset;",
                "// vulnerable line: 704: }",
                "// Line 705:                             $nGroups = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 706:                             $offset += 4;",
                "// Line 707:                             for ($i = 0; $i < $nGroups; ++$i) {",
                "// Line 708:                                 $startCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 709:                                 $offset += 4;",
                "// Line 710:                                 $endCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 711:                                 $offset += 4;",
                "// Line 712:                                 $startGlyphID = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 713:                                 $offset += 4;",
                "// Line 714:                                 for ($k = $startCharCode; $k <= $endCharCode; ++$k) {",
                "// Line 715:                                     $is32idx = floor($c / 8);",
                "// Line 716:                                     if ((isset($is32[$is32idx])) AND (($is32[$is32idx] & (1 << (7 - ($c % 8)))) == 0)) {",
                "// Line 717:                                         $c = $k;",
                "// Line 718:                                     } else {",
                "// Line 719:                                         // 32 bit format",
                "// Line 720:                                         // convert to decimal (http://www.unicode.org/faq//utf_bom.html#utf16-4)",
                "// Line 721:                                         //LEAD_OFFSET = (0xD800 - (0x10000 >> 10)) = 55232",
                "// Line 722:                                         //SURROGATE_OFFSET = (0x10000 - (0xD800 << 10) - 0xDC00) = -56613888",
                "// Line 723:                                         $c = ((55232 + ($k >> 10)) << 10) + (0xDC00 + ($k & 0x3FF)) -56613888;",
                "// vulnerable line: 724: }",
                "// Line 725:                                     $ctg[$c] = 0;",
                "// Line 726:                                     ++$startGlyphID;",
                "// vulnerable line: 727: }",
                "// vulnerable line: 728: }",
                "// Line 729:                             break;",
                "// vulnerable line: 730: }",
                "// Line 731:                         case 10: { // Format 10: Trimmed array",
                "// Line 732:                             $offset += 10; // skip reserved, length and version/language",
                "// Line 733:                             $startCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 734:                             $offset += 4;",
                "// Line 735:                             $numChars = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 736:                             $offset += 4;",
                "// Line 737:                             for ($k = 0; $k < $numChars; ++$k) {",
                "// Line 738:                                 $c = ($k + $startCharCode);",
                "// Line 739:                                 $g = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 740:                                 $ctg[$c] = $g;",
                "// Line 741:                                 $offset += 2;",
                "// vulnerable line: 742: }",
                "// Line 743:                             break;",
                "// vulnerable line: 744: }",
                "// Line 745:                         case 12: { // Format 12: Segmented coverage",
                "// Line 746:                             $offset += 10; // skip length and version/language",
                "// Line 747:                             $nGroups = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 748:                             $offset += 4;",
                "// Line 749:                             for ($k = 0; $k < $nGroups; ++$k) {",
                "// Line 750:                                 $startCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 751:                                 $offset += 4;",
                "// Line 752:                                 $endCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 753:                                 $offset += 4;",
                "// Line 754:                                 $startGlyphCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 755:                                 $offset += 4;",
                "// Line 756:                                 for ($c = $startCharCode; $c <= $endCharCode; ++$c) {",
                "// Line 757:                                     $ctg[$c] = $startGlyphCode;",
                "// Line 758:                                     ++$startGlyphCode;",
                "// vulnerable line: 759: }",
                "// vulnerable line: 760: }",
                "// Line 761:                             break;",
                "// vulnerable line: 762: }",
                "// Line 763:                         case 13: { // Format 13: Many-to-one range mappings",
                "// Line 764:                             // to be implemented ...",
                "// Line 765:                             break;",
                "// vulnerable line: 766: }",
                "// Line 767:                         case 14: { // Format 14: Unicode Variation Sequences",
                "// Line 768:                             // to be implemented ...",
                "// Line 769:                             break;",
                "// vulnerable line: 770: }",
                "// vulnerable line: 771: }",
                "// vulnerable line: 772: }",
                "// vulnerable line: 773: }",
                "// Line 774:             if (!isset($ctg[0])) {",
                "// Line 775:                 $ctg[0] = 0;",
                "// vulnerable line: 776: }",
                "// Line 777:             // get xHeight (height of x)",
                "// Line 778:             $offset = ($table['glyf']['offset'] + $indexToLoc[$ctg[120]] + 4);",
                "// Line 779:             $yMin = TCPDF_STATIC::_getFWORD($font, $offset);",
                "// Line 780:             $offset += 4;",
                "// Line 781:             $yMax = TCPDF_STATIC::_getFWORD($font, $offset);",
                "// Line 782:             $offset += 2;",
                "// Line 783:             $fmetric['XHeight'] = round(($yMax - $yMin) * $urk);",
                "// Line 784:             // get CapHeight (height of H)",
                "// Line 785:             $offset = ($table['glyf']['offset'] + $indexToLoc[$ctg[72]] + 4);",
                "// Line 786:             $yMin = TCPDF_STATIC::_getFWORD($font, $offset);",
                "// Line 787:             $offset += 4;",
                "// Line 788:             $yMax = TCPDF_STATIC::_getFWORD($font, $offset);",
                "// Line 789:             $offset += 2;",
                "// Line 790:             $fmetric['CapHeight'] = round(($yMax - $yMin) * $urk);",
                "// Line 791:             // ceate widths array",
                "// Line 792:             $cw = array();",
                "// Line 793:             $offset = $table['hmtx']['offset'];",
                "// Line 794:             for ($i = 0 ; $i < $numberOfHMetrics; ++$i) {",
                "// Line 795:                 $cw[$i] = round(TCPDF_STATIC::_getUFWORD($font, $offset) * $urk);",
                "// Line 796:                 $offset += 4; // skip lsb",
                "// vulnerable line: 797: }",
                "// Line 798:             if ($numberOfHMetrics < $numGlyphs) {",
                "// Line 799:                 // fill missing widths with the last value",
                "// Line 800:                 $cw = array_pad($cw, $numGlyphs, $cw[($numberOfHMetrics - 1)]);",
                "// vulnerable line: 801: }",
                "// Line 802:             $fmetric['MissingWidth'] = $cw[0];",
                "// Line 803:             $fmetric['cw'] = '';",
                "// Line 804:             $fmetric['cbbox'] = '';",
                "// Line 805:             for ($cid = 0; $cid <= 65535; ++$cid) {",
                "// Line 806:                 if (isset($ctg[$cid])) {",
                "// Line 807:                     if (isset($cw[$ctg[$cid]])) {",
                "// Line 808:                         $fmetric['cw'] .= ','.$cid.'=>'.$cw[$ctg[$cid]];",
                "// vulnerable line: 809: }",
                "// Line 810:                     if ($addcbbox AND isset($indexToLoc[$ctg[$cid]])) {",
                "// Line 811:                         $offset = ($table['glyf']['offset'] + $indexToLoc[$ctg[$cid]]);",
                "// Line 812:                         $xMin = round(TCPDF_STATIC::_getFWORD($font, $offset + 2) * $urk);",
                "// Line 813:                         $yMin = round(TCPDF_STATIC::_getFWORD($font, $offset + 4) * $urk);",
                "// Line 814:                         $xMax = round(TCPDF_STATIC::_getFWORD($font, $offset + 6) * $urk);",
                "// Line 815:                         $yMax = round(TCPDF_STATIC::_getFWORD($font, $offset + 8) * $urk);",
                "// Line 816:                         $fmetric['cbbox'] .= ','.$cid.'=>array('.$xMin.','.$yMin.','.$xMax.','.$yMax.')';",
                "// vulnerable line: 817: }",
                "// vulnerable line: 818: }",
                "// vulnerable line: 819: }",
                "// Line 820:         } // end of true type",
                "// Line 821:         if (($fmetric['type'] == 'TrueTypeUnicode') AND (count($ctg) == 256)) {",
                "// Line 822:             $fmetric['type'] = 'TrueType';",
                "// vulnerable line: 823: }",
                "// Line 824:         // ---------- create php font file ----------",
                "// Line 825:         $pfile = '<'.'?'.'php'.\"",
                "// Line 826: \";",
                "// Line 827:         $pfile .= '// TCPDF FONT FILE DESCRIPTION'.\"",
                "// Line 828: \";",
                "// Line 829:         $pfile .= '$type=''.$fmetric['type'].'';'.\"",
                "// Line 830: \";",
                "// Line 831:         $pfile .= '$name=''.$fmetric['name'].'';'.\"",
                "// Line 832: \";",
                "// Line 833:         $pfile .= '$up='.$fmetric['underlinePosition'].';'.\"",
                "// Line 834: \";",
                "// Line 835:         $pfile .= '$ut='.$fmetric['underlineThickness'].';'.\"",
                "// Line 836: \";",
                "// Line 837:         if ($fmetric['MissingWidth'] > 0) {",
                "// Line 838:             $pfile .= '$dw='.$fmetric['MissingWidth'].';'.\"",
                "// Line 839: \";",
                "// Line 840:         } else {",
                "// Line 841:             $pfile .= '$dw='.$fmetric['AvgWidth'].';'.\"",
                "// Line 842: \";",
                "// vulnerable line: 843: }",
                "// Line 844:         $pfile .= '$diff=''.$fmetric['diff'].'';'.\"",
                "// Line 845: \";",
                "// Line 846:         if ($fmetric['type'] == 'Type1') {",
                "// Line 847:             // Type 1",
                "// Line 848:             $pfile .= '$enc=''.$fmetric['enc'].'';'.\"",
                "// Line 849: \";",
                "// Line 850:             $pfile .= '$file=''.$fmetric['file'].'';'.\"",
                "// Line 851: \";",
                "// Line 852:             $pfile .= '$size1='.$fmetric['size1'].';'.\"",
                "// Line 853: \";",
                "// Line 862:                     case 'CID0JP': {",
                "// Line 863:                         $pfile .= '// Japanese'.\"",
                "// Line 864: \";",
                "// Line 865:                         $pfile .= '$enc='UniJIS-UTF16-H';'.\"",
                "// Line 866: \";",
                "// Line 867:                         $pfile .= '$cidinfo=array('Registry'=>'Adobe', 'Ordering'=>'Japan1','Supplement'=>5);'.\"",
                "// Line 868: \";",
                "// Line 869:                         $pfile .= 'include(dirname(__FILE__).'/uni2cid_aj16.php');'.\"",
                "// Line 870: \";",
                "// Line 871:                         break;",
                "// vulnerable line: 872: }",
                "// Line 873:                     case 'CID0KR': {",
                "// Line 874:                         $pfile .= '// Korean'.\"",
                "// Line 875: \";",
                "// Line 876:                         $pfile .= '$enc='UniKS-UTF16-H';'.\"",
                "// Line 877: \";",
                "// Line 878:                         $pfile .= '$cidinfo=array('Registry'=>'Adobe', 'Ordering'=>'Korea1','Supplement'=>0);'.\"",
                "// Line 879: \";",
                "// Line 880:                         $pfile .= 'include(dirname(__FILE__).'/uni2cid_ak12.php');'.\"",
                "// Line 881: \";",
                "// Line 882:                         break;",
                "// vulnerable line: 883: }",
                "// Line 884:                     case 'CID0CS': {",
                "// Line 885:                         $pfile .= '// Chinese Simplified'.\"",
                "// Line 886: \";",
                "// Line 887:                         $pfile .= '$enc='UniGB-UTF16-H';'.\"",
                "// Line 888: \";",
                "// Line 889:                         $pfile .= '$cidinfo=array('Registry'=>'Adobe', 'Ordering'=>'GB1','Supplement'=>2);'.\"",
                "// Line 890: \";",
                "// Line 891:                         $pfile .= 'include(dirname(__FILE__).'/uni2cid_ag15.php');'.\"",
                "// Line 892: \";",
                "// Line 893:                         break;",
                "// vulnerable line: 894: }",
                "// Line 895:                     case 'CID0CT':",
                "// Line 896:                     default: {",
                "// Line 897:                         $pfile .= '// Chinese Traditional'.\"",
                "// Line 898: \";",
                "// Line 899:                         $pfile .= '$enc='UniCNS-UTF16-H';'.\"",
                "// Line 900: \";",
                "// Line 901:                         $pfile .= '$cidinfo=array('Registry'=>'Adobe', 'Ordering'=>'CNS1','Supplement'=>0);'.\"",
                "// Line 902: \";",
                "// Line 903:                         $pfile .= 'include(dirname(__FILE__).'/uni2cid_aj16.php');'.\"",
                "// Line 904: \";",
                "// Line 905:                         break;",
                "// vulnerable line: 906: }",
                "// vulnerable line: 907: }",
                "// Line 908:             } else {",
                "// Line 909:                 // TrueType",
                "// Line 910:                 $pfile .= '$enc=''.$fmetric['enc'].'';'.\"",
                "// Line 911: \";",
                "// Line 912:                 $pfile .= '$file=''.$fmetric['file'].'';'.\"",
                "// Line 913: \";",
                "// Line 914:                 $pfile .= '$ctg=''.$fmetric['ctg'].'';'.\"",
                "// Line 915: \";",
                "// Line 916:                 // create CIDToGIDMap",
                "// Line 917:                 $cidtogidmap = str_pad('', 131072, \"\u0000\"); // (256 * 256 * 2) = 131072",
                "// Line 918:                 foreach ($ctg as $cid => $gid) {",
                "// Line 919:                     $cidtogidmap = self::updateCIDtoGIDmap($cidtogidmap, $cid, $ctg[$cid]);",
                "// vulnerable line: 920: }",
                "// Line 921:                 // store compressed CIDToGIDMap",
                "// Line 922:                 $fp = TCPDF_STATIC::fopenLocal($outpath.$fmetric['ctg'], 'wb');",
                "// Line 923:                 fwrite($fp, gzcompress($cidtogidmap));",
                "// Line 924:                 fclose($fp);",
                "// vulnerable line: 925: }",
                "// vulnerable line: 926: }",
                "// Line 927:         $pfile .= '$desc=array(';",
                "// Line 928:         $pfile .= ''Flags'=>'.$fmetric['Flags'].',';",
                "// Line 929:         $pfile .= ''FontBBox'=>'['.$fmetric['bbox'].']',';",
                "// Line 930:         $pfile .= ''ItalicAngle'=>'.$fmetric['italicAngle'].',';",
                "// Line 931:         $pfile .= ''Ascent'=>'.$fmetric['Ascent'].',';",
                "// Line 932:         $pfile .= ''Descent'=>'.$fmetric['Descent'].',';",
                "// Line 933:         $pfile .= ''Leading'=>'.$fmetric['Leading'].',';",
                "// Line 934:         $pfile .= ''CapHeight'=>'.$fmetric['CapHeight'].',';",
                "// Line 935:         $pfile .= ''XHeight'=>'.$fmetric['XHeight'].',';",
                "// Line 936:         $pfile .= ''StemV'=>'.$fmetric['StemV'].',';",
                "// Line 937:         $pfile .= ''StemH'=>'.$fmetric['StemH'].',';",
                "// Line 938:         $pfile .= ''AvgWidth'=>'.$fmetric['AvgWidth'].',';",
                "// Line 939:         $pfile .= ''MaxWidth'=>'.$fmetric['MaxWidth'].',';",
                "// Line 940:         $pfile .= ''MissingWidth'=>'.$fmetric['MissingWidth'].'';",
                "// Line 941:         $pfile .= ');'.\"",
                "// Line 942: \";",
                "// Line 943:         if (!empty($fmetric['cbbox'])) {",
                "// Line 944:             $pfile .= '$cbbox=array('.substr($fmetric['cbbox'], 1).');'.\"",
                "// Line 945: \";",
                "// vulnerable line: 946: }",
                "// Line 947:         $pfile .= '$cw=array('.substr($fmetric['cw'], 1).');'.\"",
                "// Line 948: \";",
                "// Line 949:         $pfile .= '// --- EOF ---'.\"",
                "// Line 950: \";",
                "// Line 951:         // store file",
                "// Line 952:         $fp = TCPDF_STATIC::fopenLocal($outpath.$font_name.'.php', 'w');",
                "// Line 953:         fwrite($fp, $pfile);",
                "// Line 954:         fclose($fp);",
                "// Line 955:         // return TCPDF font name",
                "// Line 956:         return $font_name;",
                "// vulnerable line: 957: }",
                "// Line 958: ",
                "// Line 959:     /**",
                "// Line 960:      * Returs the checksum of a TTF table.",
                "// Line 961:      * @param string $table table to check",
                "// Line 962:      * @param int $length length of table in bytes",
                "// Line 963:      * @return int checksum",
                "// Line 964:      * @author Nicola Asuni",
                "// Line 965:      * @since 5.2.000 (2010-06-02)",
                "// Line 966:      * @public static",
                "// Line 967:      */",
                "// Line 968:     public static function _getTTFtableChecksum($table, $length) {",
                "// Line 969:         $sum = 0;",
                "// Line 970:         $tlen = ($length / 4);",
                "// Line 971:         $offset = 0;",
                "// Line 972:         for ($i = 0; $i < $tlen; ++$i) {",
                "// Line 973:             $v = unpack('Ni', substr($table, $offset, 4));",
                "// Line 974:             $sum += $v['i'];",
                "// Line 975:             $offset += 4;",
                "// vulnerable line: 976: }",
                "// Line 977:         $sum = unpack('Ni', pack('N', $sum));",
                "// Line 978:         return $sum['i'];",
                "// vulnerable line: 979: }",
                "// Line 980: ",
                "// Line 981:     /**",
                "// Line 982:      * Returns a subset of the TrueType font data without the unused glyphs.",
                "// Line 983:      * @param string $font TrueType font data.",
                "// Line 984:      * @param array $subsetchars Array of used characters (the glyphs to keep).",
                "// Line 985:      * @return string A subset of TrueType font data without the unused glyphs.",
                "// Line 986:      * @author Nicola Asuni",
                "// Line 987:      * @since 5.2.000 (2010-06-02)",
                "// Line 988:      * @public static",
                "// Line 989:      */",
                "// Line 990:     public static function _getTrueTypeFontSubset($font, $subsetchars) {",
                "// Line 991:         ksort($subsetchars);",
                "// Line 992:         $offset = 0; // offset position of the font data",
                "// Line 993:         if (TCPDF_STATIC::_getULONG($font, $offset) != 0x10000) {",
                "// Line 994:             // sfnt version must be 0x00010000 for TrueType version 1.0.",
                "// Line 995:             return $font;",
                "// vulnerable line: 996: }",
                "// Line 997:         $c = 0;",
                "// Line 998:         $offset += 4;",
                "// Line 999:         // get number of tables",
                "// Line 1000:         $numTables = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1001:         $offset += 2;",
                "// Line 1002:         // skip searchRange, entrySelector and rangeShift",
                "// Line 1003:         $offset += 6;",
                "// Line 1004:         // tables array",
                "// Line 1005:         $table = array();",
                "// Line 1006:         // for each table",
                "// Line 1008:             // get table info",
                "// Line 1009:             $tag = substr($font, $offset, 4);",
                "// Line 1010:             $offset += 4;",
                "// Line 1011:             $table[$tag] = array();",
                "// Line 1012:             $table[$tag]['checkSum'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1013:             $offset += 4;",
                "// Line 1014:             $table[$tag]['offset'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1015:             $offset += 4;",
                "// Line 1016:             $table[$tag]['length'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1017:             $offset += 4;",
                "// vulnerable line: 1018: }",
                "// Line 1019:         // check magicNumber",
                "// Line 1020:         $offset = $table['head']['offset'] + 12;",
                "// Line 1021:         if (TCPDF_STATIC::_getULONG($font, $offset) != 0x5F0F3CF5) {",
                "// Line 1022:             // magicNumber must be 0x5F0F3CF5",
                "// Line 1023:             return $font;",
                "// vulnerable line: 1024: }",
                "// Line 1025:         $offset += 4;",
                "// Line 1026:         // get offset mode (indexToLocFormat : 0 = short, 1 = long)",
                "// Line 1027:         $offset = $table['head']['offset'] + 50;",
                "// Line 1028:         $short_offset = (TCPDF_STATIC::_getSHORT($font, $offset) == 0);",
                "// Line 1029:         $offset += 2;",
                "// Line 1030:         // get the offsets to the locations of the glyphs in the font, relative to the beginning of the glyphData table",
                "// Line 1031:         $indexToLoc = array();",
                "// Line 1032:         $offset = $table['loca']['offset'];",
                "// Line 1033:         if ($short_offset) {",
                "// Line 1034:             // short version",
                "// Line 1035:             $tot_num_glyphs = floor($table['loca']['length'] / 2); // numGlyphs + 1",
                "// Line 1036:             for ($i = 0; $i < $tot_num_glyphs; ++$i) {",
                "// Line 1037:                 $indexToLoc[$i] = TCPDF_STATIC::_getUSHORT($font, $offset) * 2;",
                "// Line 1038:                 $offset += 2;",
                "// vulnerable line: 1039: }",
                "// Line 1040:         } else {",
                "// Line 1041:             // long version",
                "// Line 1042:             $tot_num_glyphs = ($table['loca']['length'] / 4); // numGlyphs + 1",
                "// Line 1043:             for ($i = 0; $i < $tot_num_glyphs; ++$i) {",
                "// Line 1044:                 $indexToLoc[$i] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1045:                 $offset += 4;",
                "// vulnerable line: 1046: }",
                "// vulnerable line: 1047: }",
                "// Line 1048:         // get glyphs indexes of chars from cmap table",
                "// Line 1049:         $subsetglyphs = array(); // glyph IDs on key",
                "// Line 1050:         $subsetglyphs[0] = true; // character codes that do not correspond to any glyph in the font should be mapped to glyph index 0",
                "// Line 1051:         $offset = $table['cmap']['offset'] + 2;",
                "// Line 1052:         $numEncodingTables = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1053:         $offset += 2;",
                "// Line 1054:         $encodingTables = array();",
                "// Line 1055:         for ($i = 0; $i < $numEncodingTables; ++$i) {",
                "// Line 1056:             $encodingTables[$i]['platformID'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1057:             $offset += 2;",
                "// Line 1058:             $encodingTables[$i]['encodingID'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1059:             $offset += 2;",
                "// Line 1060:             $encodingTables[$i]['offset'] = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1061:             $offset += 4;",
                "// vulnerable line: 1062: }",
                "// Line 1063:         foreach ($encodingTables as $enctable) {",
                "// Line 1064:             // get all platforms and encodings",
                "// Line 1065:             $offset = $table['cmap']['offset'] + $enctable['offset'];",
                "// Line 1066:             $format = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1067:             $offset += 2;",
                "// Line 1068:             switch ($format) {",
                "// Line 1069:                 case 0: { // Format 0: Byte encoding table",
                "// Line 1070:                     $offset += 4; // skip length and version/language",
                "// Line 1071:                     for ($c = 0; $c < 256; ++$c) {",
                "// Line 1072:                         if (isset($subsetchars[$c])) {",
                "// Line 1073:                             $g = TCPDF_STATIC::_getBYTE($font, $offset);",
                "// Line 1074:                             $subsetglyphs[$g] = true;",
                "// vulnerable line: 1075: }",
                "// Line 1076:                         ++$offset;",
                "// vulnerable line: 1077: }",
                "// Line 1078:                     break;",
                "// vulnerable line: 1079: }",
                "// Line 1080:                 case 2: { // Format 2: High-byte mapping through table",
                "// Line 1081:                     $offset += 4; // skip length and version/language",
                "// Line 1082:                     $numSubHeaders = 0;",
                "// Line 1083:                     for ($i = 0; $i < 256; ++$i) {",
                "// Line 1084:                         // Array that maps high bytes to subHeaders: value is subHeader index * 8.",
                "// Line 1085:                         $subHeaderKeys[$i] = (TCPDF_STATIC::_getUSHORT($font, $offset) / 8);",
                "// Line 1086:                         $offset += 2;",
                "// Line 1087:                         if ($numSubHeaders < $subHeaderKeys[$i]) {",
                "// Line 1088:                             $numSubHeaders = $subHeaderKeys[$i];",
                "// vulnerable line: 1089: }",
                "// vulnerable line: 1090: }",
                "// Line 1091:                     // the number of subHeaders is equal to the max of subHeaderKeys + 1",
                "// Line 1092:                     ++$numSubHeaders;",
                "// Line 1093:                     // read subHeader structures",
                "// Line 1094:                     $subHeaders = array();",
                "// Line 1095:                     $numGlyphIndexArray = 0;",
                "// Line 1096:                     for ($k = 0; $k < $numSubHeaders; ++$k) {",
                "// Line 1097:                         $subHeaders[$k]['firstCode'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1098:                         $offset += 2;",
                "// Line 1099:                         $subHeaders[$k]['entryCount'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1100:                         $offset += 2;",
                "// Line 1101:                         $subHeaders[$k]['idDelta'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1102:                         $offset += 2;",
                "// Line 1103:                         $subHeaders[$k]['idRangeOffset'] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1104:                         $offset += 2;",
                "// Line 1105:                         $subHeaders[$k]['idRangeOffset'] -= (2 + (($numSubHeaders - $k - 1) * 8));",
                "// Line 1106:                         $subHeaders[$k]['idRangeOffset'] /= 2;",
                "// Line 1107:                         $numGlyphIndexArray += $subHeaders[$k]['entryCount'];",
                "// vulnerable line: 1108: }",
                "// Line 1109:                     for ($k = 0; $k < $numGlyphIndexArray; ++$k) {",
                "// Line 1110:                         $glyphIndexArray[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1111:                         $offset += 2;",
                "// vulnerable line: 1112: }",
                "// Line 1113:                     for ($i = 0; $i < 256; ++$i) {",
                "// Line 1114:                         $k = $subHeaderKeys[$i];",
                "// Line 1115:                         if ($k == 0) {",
                "// Line 1116:                             // one byte code",
                "// Line 1117:                             $c = $i;",
                "// Line 1118:                             if (isset($subsetchars[$c])) {",
                "// Line 1119:                                 $g = $glyphIndexArray[0];",
                "// Line 1120:                                 $subsetglyphs[$g] = true;",
                "// vulnerable line: 1121: }",
                "// Line 1122:                         } else {",
                "// Line 1123:                             // two bytes code",
                "// Line 1124:                             $start_byte = $subHeaders[$k]['firstCode'];",
                "// Line 1125:                             $end_byte = $start_byte + $subHeaders[$k]['entryCount'];",
                "// Line 1126:                             for ($j = $start_byte; $j < $end_byte; ++$j) {",
                "// Line 1127:                                 // combine high and low bytes",
                "// Line 1128:                                 $c = (($i << 8) + $j);",
                "// Line 1129:                                 if (isset($subsetchars[$c])) {",
                "// Line 1130:                                     $idRangeOffset = ($subHeaders[$k]['idRangeOffset'] + $j - $subHeaders[$k]['firstCode']);",
                "// Line 1131:                                     $g = ($glyphIndexArray[$idRangeOffset] + $subHeaders[$k]['idDelta']) % 65536;",
                "// Line 1132:                                     if ($g < 0) {",
                "// Line 1133:                                         $g = 0;",
                "// vulnerable line: 1134: }",
                "// Line 1135:                                     $subsetglyphs[$g] = true;",
                "// vulnerable line: 1136: }",
                "// vulnerable line: 1137: }",
                "// vulnerable line: 1138: }",
                "// vulnerable line: 1139: }",
                "// Line 1140:                     break;",
                "// vulnerable line: 1141: }",
                "// Line 1142:                 case 4: { // Format 4: Segment mapping to delta values",
                "// Line 1143:                     $length = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1144:                     $offset += 2;",
                "// Line 1145:                     $offset += 2; // skip version/language",
                "// Line 1146:                     $segCount = floor(TCPDF_STATIC::_getUSHORT($font, $offset) / 2);",
                "// Line 1147:                     $offset += 2;",
                "// Line 1148:                     $offset += 6; // skip searchRange, entrySelector, rangeShift",
                "// Line 1149:                     $endCount = array(); // array of end character codes for each segment",
                "// Line 1150:                     for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 1151:                         $endCount[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1152:                         $offset += 2;",
                "// vulnerable line: 1153: }",
                "// Line 1154:                     $offset += 2; // skip reservedPad",
                "// Line 1155:                     $startCount = array(); // array of start character codes for each segment",
                "// Line 1156:                     for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 1157:                         $startCount[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1158:                         $offset += 2;",
                "// vulnerable line: 1159: }",
                "// Line 1160:                     $idDelta = array(); // delta for all character codes in segment",
                "// Line 1161:                     for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 1162:                         $idDelta[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1163:                         $offset += 2;",
                "// vulnerable line: 1164: }",
                "// Line 1165:                     $idRangeOffset = array(); // Offsets into glyphIdArray or 0",
                "// Line 1166:                     for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 1167:                         $idRangeOffset[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1168:                         $offset += 2;",
                "// vulnerable line: 1169: }",
                "// Line 1170:                     $gidlen = (floor($length / 2) - 8 - (4 * $segCount));",
                "// Line 1171:                     $glyphIdArray = array(); // glyph index array",
                "// Line 1172:                     for ($k = 0; $k < $gidlen; ++$k) {",
                "// Line 1173:                         $glyphIdArray[$k] = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1174:                         $offset += 2;",
                "// vulnerable line: 1175: }",
                "// Line 1176:                     for ($k = 0; $k < $segCount; ++$k) {",
                "// Line 1177:                         for ($c = $startCount[$k]; $c <= $endCount[$k]; ++$c) {",
                "// Line 1178:                             if (isset($subsetchars[$c])) {",
                "// Line 1179:                                 if ($idRangeOffset[$k] == 0) {",
                "// Line 1180:                                     $g = ($idDelta[$k] + $c) % 65536;",
                "// Line 1181:                                 } else {",
                "// Line 1182:                                     $gid = (floor($idRangeOffset[$k] / 2) + ($c - $startCount[$k]) - ($segCount - $k));",
                "// Line 1183:                                     $g = ($glyphIdArray[$gid] + $idDelta[$k]) % 65536;",
                "// vulnerable line: 1184: }",
                "// Line 1185:                                 if ($g < 0) {",
                "// Line 1186:                                     $g = 0;",
                "// vulnerable line: 1187: }",
                "// Line 1188:                                 $subsetglyphs[$g] = true;",
                "// vulnerable line: 1189: }",
                "// vulnerable line: 1190: }",
                "// vulnerable line: 1191: }",
                "// Line 1192:                     break;",
                "// vulnerable line: 1193: }",
                "// Line 1194:                 case 6: { // Format 6: Trimmed table mapping",
                "// Line 1195:                     $offset += 4; // skip length and version/language",
                "// Line 1196:                     $firstCode = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1197:                     $offset += 2;",
                "// Line 1198:                     $entryCount = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1199:                     $offset += 2;",
                "// Line 1200:                     for ($k = 0; $k < $entryCount; ++$k) {",
                "// Line 1201:                         $c = ($k + $firstCode);",
                "// Line 1202:                         if (isset($subsetchars[$c])) {",
                "// Line 1203:                             $g = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1204:                             $subsetglyphs[$g] = true;",
                "// vulnerable line: 1205: }",
                "// Line 1206:                         $offset += 2;",
                "// vulnerable line: 1207: }",
                "// Line 1208:                     break;",
                "// vulnerable line: 1209: }",
                "// Line 1210:                 case 8: { // Format 8: Mixed 16-bit and 32-bit coverage",
                "// Line 1211:                     $offset += 10; // skip reserved, length and version/language",
                "// Line 1212:                     for ($k = 0; $k < 8192; ++$k) {",
                "// Line 1213:                         $is32[$k] = TCPDF_STATIC::_getBYTE($font, $offset);",
                "// Line 1214:                         ++$offset;",
                "// vulnerable line: 1215: }",
                "// Line 1216:                     $nGroups = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1217:                     $offset += 4;",
                "// Line 1218:                     for ($i = 0; $i < $nGroups; ++$i) {",
                "// Line 1219:                         $startCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1220:                         $offset += 4;",
                "// Line 1221:                         $endCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1222:                         $offset += 4;",
                "// Line 1223:                         $startGlyphID = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1224:                         $offset += 4;",
                "// Line 1225:                         for ($k = $startCharCode; $k <= $endCharCode; ++$k) {",
                "// Line 1226:                             $is32idx = floor($c / 8);",
                "// Line 1227:                             if ((isset($is32[$is32idx])) AND (($is32[$is32idx] & (1 << (7 - ($c % 8)))) == 0)) {",
                "// Line 1228:                                 $c = $k;",
                "// Line 1229:                             } else {",
                "// Line 1230:                                 // 32 bit format",
                "// Line 1231:                                 // convert to decimal (http://www.unicode.org/faq//utf_bom.html#utf16-4)",
                "// Line 1232:                                 //LEAD_OFFSET = (0xD800 - (0x10000 >> 10)) = 55232",
                "// Line 1233:                                 //SURROGATE_OFFSET = (0x10000 - (0xD800 << 10) - 0xDC00) = -56613888",
                "// Line 1234:                                 $c = ((55232 + ($k >> 10)) << 10) + (0xDC00 + ($k & 0x3FF)) -56613888;",
                "// vulnerable line: 1235: }",
                "// Line 1236:                             if (isset($subsetchars[$c])) {",
                "// Line 1237:                                 $subsetglyphs[$startGlyphID] = true;",
                "// vulnerable line: 1238: }",
                "// Line 1239:                             ++$startGlyphID;",
                "// vulnerable line: 1240: }",
                "// vulnerable line: 1241: }",
                "// Line 1242:                     break;",
                "// vulnerable line: 1243: }",
                "// Line 1244:                 case 10: { // Format 10: Trimmed array",
                "// Line 1245:                     $offset += 10; // skip reserved, length and version/language",
                "// Line 1246:                     $startCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1247:                     $offset += 4;",
                "// Line 1248:                     $numChars = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1249:                     $offset += 4;",
                "// Line 1250:                     for ($k = 0; $k < $numChars; ++$k) {",
                "// Line 1251:                         $c = ($k + $startCharCode);",
                "// Line 1252:                         if (isset($subsetchars[$c])) {",
                "// Line 1253:                             $g = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1254:                             $subsetglyphs[$g] = true;",
                "// vulnerable line: 1255: }",
                "// Line 1256:                         $offset += 2;",
                "// vulnerable line: 1257: }",
                "// Line 1258:                     break;",
                "// vulnerable line: 1259: }",
                "// Line 1260:                 case 12: { // Format 12: Segmented coverage",
                "// Line 1261:                     $offset += 10; // skip length and version/language",
                "// Line 1262:                     $nGroups = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1263:                     $offset += 4;",
                "// Line 1264:                     for ($k = 0; $k < $nGroups; ++$k) {",
                "// Line 1265:                         $startCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1266:                         $offset += 4;",
                "// Line 1267:                         $endCharCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1268:                         $offset += 4;",
                "// Line 1269:                         $startGlyphCode = TCPDF_STATIC::_getULONG($font, $offset);",
                "// Line 1270:                         $offset += 4;",
                "// Line 1271:                         for ($c = $startCharCode; $c <= $endCharCode; ++$c) {",
                "// Line 1272:                             if (isset($subsetchars[$c])) {",
                "// Line 1273:                                 $subsetglyphs[$startGlyphCode] = true;",
                "// vulnerable line: 1274: }",
                "// Line 1275:                             ++$startGlyphCode;",
                "// vulnerable line: 1276: }",
                "// vulnerable line: 1277: }",
                "// Line 1278:                     break;",
                "// vulnerable line: 1279: }",
                "// Line 1280:                 case 13: { // Format 13: Many-to-one range mappings",
                "// Line 1281:                     // to be implemented ...",
                "// Line 1282:                     break;",
                "// vulnerable line: 1283: }",
                "// Line 1284:                 case 14: { // Format 14: Unicode Variation Sequences",
                "// Line 1285:                     // to be implemented ...",
                "// Line 1286:                     break;",
                "// vulnerable line: 1287: }",
                "// vulnerable line: 1288: }",
                "// vulnerable line: 1289: }",
                "// Line 1290:         // include all parts of composite glyphs",
                "// Line 1291:         $new_sga = $subsetglyphs;",
                "// Line 1292:         while (!empty($new_sga)) {",
                "// Line 1293:             $sga = $new_sga;",
                "// Line 1294:             $new_sga = array();",
                "// Line 1295:             foreach ($sga as $key => $val) {",
                "// Line 1296:                 if (isset($indexToLoc[$key])) {",
                "// Line 1297:                     $offset = ($table['glyf']['offset'] + $indexToLoc[$key]);",
                "// Line 1298:                     $numberOfContours = TCPDF_STATIC::_getSHORT($font, $offset);",
                "// Line 1299:                     $offset += 2;",
                "// Line 1300:                     if ($numberOfContours < 0) { // composite glyph",
                "// Line 1301:                         $offset += 8; // skip xMin, yMin, xMax, yMax",
                "// Line 1302:                         do {",
                "// Line 1303:                             $flags = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1304:                             $offset += 2;",
                "// Line 1305:                             $glyphIndex = TCPDF_STATIC::_getUSHORT($font, $offset);",
                "// Line 1306:                             $offset += 2;",
                "// Line 1307:                             if (!isset($subsetglyphs[$glyphIndex])) {",
                "// Line 1308:                                 // add missing glyphs",
                "// Line 1309:                                 $new_sga[$glyphIndex] = true;",
                "// vulnerable line: 1310: }",
                "// Line 1311:                             // skip some bytes by case",
                "// Line 1312:                             if ($flags & 1) {",
                "// Line 1313:                                 $offset += 4;",
                "// Line 1314:                             } else {",
                "// Line 1315:                                 $offset += 2;",
                "// vulnerable line: 1316: }",
                "// Line 1317:                             if ($flags & 8) {",
                "// Line 1318:                                 $offset += 2;",
                "// Line 1319:                             } elseif ($flags & 64) {",
                "// Line 1320:                                 $offset += 4;",
                "// Line 1321:                             } elseif ($flags & 128) {",
                "// Line 1322:                                 $offset += 8;",
                "// vulnerable line: 1323: }",
                "// Line 1324:                         } while ($flags & 32);",
                "// vulnerable line: 1325: }",
                "// vulnerable line: 1326: }",
                "// vulnerable line: 1327: }",
                "// Line 1328:             $subsetglyphs += $new_sga;",
                "// vulnerable line: 1329: }",
                "// Line 1330:         // sort glyphs by key (and remove duplicates)",
                "// Line 1331:         ksort($subsetglyphs);",
                "// Line 1332:         // build new glyf and loca tables",
                "// Line 1333:         $glyf = '';",
                "// Line 1334:         $loca = '';",
                "// Line 1335:         $offset = 0;",
                "// Line 1336:         $glyf_offset = $table['glyf']['offset'];",
                "// Line 1337:         for ($i = 0; $i < $tot_num_glyphs; ++$i) {",
                "// Line 1338:             if (isset($subsetglyphs[$i])) {",
                "// Line 1339:                 $length = ($indexToLoc[($i + 1)] - $indexToLoc[$i]);",
                "// Line 1340:                 $glyf .= substr($font, ($glyf_offset + $indexToLoc[$i]), $length);",
                "// Line 1341:             } else {",
                "// Line 1342:                 $length = 0;",
                "// vulnerable line: 1343: }",
                "// Line 1344:             if ($short_offset) {",
                "// Line 1345:                 $loca .= pack('n', floor($offset / 2));",
                "// Line 1346:             } else {",
                "// Line 1347:                 $loca .= pack('N', $offset);",
                "// vulnerable line: 1348: }",
                "// Line 1349:             $offset += $length;",
                "// vulnerable line: 1350: }",
                "// Line 1351:         // array of table names to preserve (loca and glyf tables will be added later)",
                "// Line 1352:         // the cmap table is not needed and shall not be present, since the mapping from character codes to glyph descriptions is provided separately",
                "// Line 1353:         $table_names = array ('head', 'hhea', 'hmtx', 'maxp', 'cvt ', 'fpgm', 'prep'); // minimum required table names",
                "// Line 1354:         // get the tables to preserve",
                "// Line 1355:         $offset = 12;",
                "// Line 1356:         foreach ($table as $tag => $val) {",
                "// Line 1357:             if (in_array($tag, $table_names)) {",
                "// Line 1358:                 $table[$tag]['data'] = substr($font, $table[$tag]['offset'], $table[$tag]['length']);",
                "// Line 1359:                 if ($tag == 'head') {",
                "// Line 1360:                     // set the checkSumAdjustment to 0",
                "// Line 1361:                     $table[$tag]['data'] = substr($table[$tag]['data'], 0, 8).\"\".substr($table[$tag]['data'], 12);",
                "// vulnerable line: 1362: }",
                "// vulnerable line: 1363: $pad = 4 - ($table[$tag]['length'] % 4);",
                "// vulnerable line: 1364: if ($pad != 4) {",
                "// vulnerable line: 1365: // the length of a table must be a multiple of four bytes",
                "// vulnerable line: 1366: $table[$tag]['length'] += $pad;",
                "// Line 1367:                     $table[$tag]['data'] .= str_repeat(\"\", $pad);",
                "// vulnerable line: 1368: }",
                "// Line 1369:                 $table[$tag]['offset'] = $offset;",
                "// Line 1370:                 $offset += $table[$tag]['length'];",
                "// Line 1371:                 // check sum is not changed (so keep the following line commented)",
                "// vulnerable line: 1372: //$table[$tag]['checkSum'] = self::_getTTFtableChecksum($table[$tag]['data'], $table[$tag]['length']);",
                "// Line 1373:             } else {",
                "// Line 1374:                 unset($table[$tag]);",
                "// vulnerable line: 1375: }",
                "// vulnerable line: 1376: }",
                "// Line 1377:         // add loca",
                "// Line 1378:         $table['loca']['data'] = $loca;",
                "// Line 1379:         $table['loca']['length'] = strlen($loca);",
                "// vulnerable line: 1380: $pad = 4 - ($table['loca']['length'] % 4);",
                "// vulnerable line: 1381: if ($pad != 4) {",
                "// vulnerable line: 1382: // the length of a table must be a multiple of four bytes",
                "// vulnerable line: 1383: $table['loca']['length'] += $pad;",
                "// Line 1384:             $table['loca']['data'] .= str_repeat(\"\", $pad);",
                "// vulnerable line: 1385: }",
                "// Line 1386:         $table['loca']['offset'] = $offset;",
                "// vulnerable line: 1387: $table['loca']['checkSum'] = self::_getTTFtableChecksum($table['loca']['data'], $table['loca']['length']);",
                "// Line 1388:         $offset += $table['loca']['length'];",
                "// Line 1389:         // add glyf",
                "// Line 1390:         $table['glyf']['data'] = $glyf;",
                "// Line 1391:         $table['glyf']['length'] = strlen($glyf);",
                "// vulnerable line: 1392: $pad = 4 - ($table['glyf']['length'] % 4);",
                "// vulnerable line: 1393: if ($pad != 4) {",
                "// vulnerable line: 1394: // the length of a table must be a multiple of four bytes",
                "// vulnerable line: 1395: $table['glyf']['length'] += $pad;",
                "// Line 1396:             $table['glyf']['data'] .= str_repeat(\"\", $pad);",
                "// vulnerable line: 1397: }",
                "// Line 1398:         $table['glyf']['offset'] = $offset;",
                "// vulnerable line: 1399: $table['glyf']['checkSum'] = self::_getTTFtableChecksum($table['glyf']['data'], $table['glyf']['length']);",
                "// Line 1400:         // rebuild font",
                "// Line 1401:         $font = '';",
                "// Line 1402:         $font .= pack('N', 0x10000); // sfnt version",
                "// Line 1403:         $numTables = count($table);",
                "// Line 1404:         $font .= pack('n', $numTables); // numTables",
                "// Line 1405:         $entrySelector = floor(log($numTables, 2));",
                "// Line 1406:         $searchRange = pow(2, $entrySelector) * 16;",
                "// Line 1407:         $rangeShift = ($numTables * 16) - $searchRange;",
                "// Line 1408:         $font .= pack('n', $searchRange); // searchRange",
                "// Line 1409:         $font .= pack('n', $entrySelector); // entrySelector",
                "// Line 1410:         $font .= pack('n', $rangeShift); // rangeShift",
                "// Line 1411:         $offset = ($numTables * 16);",
                "// Line 1412:         foreach ($table as $tag => $data) {",
                "// Line 1413:             $font .= $tag; // tag",
                "// Line 1414:             $font .= pack('N', $data['checkSum']); // checkSum",
                "// Line 1415:             $font .= pack('N', ($data['offset'] + $offset)); // offset",
                "// Line 1416:             $font .= pack('N', $data['length']); // length",
                "// vulnerable line: 1417: }",
                "// Line 1418:         foreach ($table as $data) {",
                "// Line 1419:             $font .= $data['data'];",
                "// vulnerable line: 1420: }",
                "// Line 1421:         // set checkSumAdjustment on head table",
                "// Line 1422:         $checkSumAdjustment = 0xB1B0AFBA - self::_getTTFtableChecksum($font, strlen($font));",
                "// vulnerable line: 1423: $font = substr($font, 0, $table['head']['offset'] + 8).pack('N', $checkSumAdjustment).substr($font, $table['head']['offset'] + 12);",
                "// Line 1424:         return $font;",
                "// vulnerable line: 1425: }",
                "// Line 1426: ",
                "// Line 1427:     /**",
                "// Line 1428:      * Outputs font widths",
                "// Line 1429:      * @param array $font font data",
                "// Line 1430:      * @param int $cidoffset offset for CID values",
                "// Line 1431:      * @return string PDF command string for font widths",
                "// Line 1432:      * @author Nicola Asuni",
                "// Line 1433:      * @since 4.4.000 (2008-12-07)",
                "// Line 1434:      * @public static",
                "// Line 1435:      */",
                "// Line 1439:         $range = array();",
                "// Line 1440:         $prevcid = -2;",
                "// Line 1441:         $prevwidth = -1;",
                "// Line 1442:         $interval = false;",
                "// Line 1443:         // for each character",
                "// Line 1444:         foreach ($font['cw'] as $cid => $width) {",
                "// Line 1445:             $cid -= $cidoffset;",
                "// Line 1446:             if ($font['subset'] AND (!isset($font['subsetchars'][$cid]))) {",
                "// Line 1447:                 // ignore the unused characters (font subsetting)",
                "// Line 1448:                 continue;",
                "// vulnerable line: 1449: }",
                "// Line 1450:             if ($width != $font['dw']) {",
                "// Line 1451:                 if ($cid == ($prevcid + 1)) {",
                "// Line 1452:                     // consecutive CID",
                "// Line 1453:                     if ($width == $prevwidth) {",
                "// Line 1454:                         if ($width == $range[$rangeid][0]) {",
                "// Line 1455:                             $range[$rangeid][] = $width;",
                "// Line 1456:                         } else {",
                "// Line 1457:                             array_pop($range[$rangeid]);",
                "// Line 1458:                             // new range",
                "// Line 1459:                             $rangeid = $prevcid;",
                "// Line 1460:                             $range[$rangeid] = array();",
                "// Line 1461:                             $range[$rangeid][] = $prevwidth;",
                "// Line 1462:                             $range[$rangeid][] = $width;",
                "// vulnerable line: 1463: }",
                "// Line 1464:                         $interval = true;",
                "// Line 1465:                         $range[$rangeid]['interval'] = true;",
                "// Line 1466:                     } else {",
                "// Line 1467:                         if ($interval) {",
                "// Line 1468:                             // new range",
                "// Line 1469:                             $rangeid = $cid;",
                "// Line 1470:                             $range[$rangeid] = array();",
                "// Line 1471:                             $range[$rangeid][] = $width;",
                "// Line 1472:                         } else {",
                "// Line 1473:                             $range[$rangeid][] = $width;",
                "// vulnerable line: 1474: }",
                "// Line 1475:                         $interval = false;",
                "// vulnerable line: 1476: }",
                "// Line 1477:                 } else {",
                "// Line 1478:                     // new range",
                "// Line 1479:                     $rangeid = $cid;",
                "// Line 1480:                     $range[$rangeid] = array();",
                "// Line 1481:                     $range[$rangeid][] = $width;",
                "// Line 1482:                     $interval = false;",
                "// vulnerable line: 1483: }",
                "// Line 1484:                 $prevcid = $cid;",
                "// Line 1485:                 $prevwidth = $width;",
                "// vulnerable line: 1486: }",
                "// vulnerable line: 1487: }",
                "// Line 1488:         // optimize ranges",
                "// Line 1489:         $prevk = -1;",
                "// Line 1490:         $nextk = -1;",
                "// Line 1491:         $prevint = false;",
                "// Line 1492:         foreach ($range as $k => $ws) {",
                "// Line 1493:             $cws = count($ws);",
                "// Line 1494:             if (($k == $nextk) AND (!$prevint) AND ((!isset($ws['interval'])) OR ($cws < 4))) {",
                "// Line 1495:                 if (isset($range[$k]['interval'])) {",
                "// Line 1496:                     unset($range[$k]['interval']);",
                "// vulnerable line: 1497: }",
                "// Line 1498:                 $range[$prevk] = array_merge($range[$prevk], $range[$k]);",
                "// Line 1499:                 unset($range[$k]);",
                "// Line 1500:             } else {",
                "// Line 1501:                 $prevk = $k;",
                "// vulnerable line: 1502: }",
                "// Line 1503:             $nextk = $k + $cws;",
                "// Line 1504:             if (isset($ws['interval'])) {",
                "// Line 1505:                 if ($cws > 3) {",
                "// Line 1506:                     $prevint = true;",
                "// Line 1507:                 } else {",
                "// Line 1508:                     $prevint = false;",
                "// vulnerable line: 1509: }",
                "// Line 1510:                 if (isset($range[$k]['interval'])) {",
                "// Line 1511:                     unset($range[$k]['interval']);",
                "// vulnerable line: 1512: }",
                "// Line 1513:                 --$nextk;",
                "// Line 1514:             } else {",
                "// Line 1515:                 $prevint = false;",
                "// vulnerable line: 1516: }",
                "// vulnerable line: 1517: }",
                "// Line 1518:         // output data",
                "// Line 1519:         $w = '';",
                "// Line 1520:         foreach ($range as $k => $ws) {",
                "// Line 1521:             if (count(array_count_values($ws)) == 1) {",
                "// Line 1522:                 // interval mode is more compact",
                "// Line 1523:                 $w .= ' '.$k.' '.($k + count($ws) - 1).' '.$ws[0];",
                "// Line 1524:             } else {",
                "// Line 1525:                 // range mode",
                "// Line 1526:                 $w .= ' '.$k.' [ '.implode(' ', $ws).' ]';",
                "// vulnerable line: 1527: }",
                "// vulnerable line: 1528: }",
                "// Line 1529:         return '/W ['.$w.' ]';",
                "// vulnerable line: 1530: }",
                "// Line 1531: ",
                "// Line 1532: ",
                "// Line 1533: ",
                "// Line 1534: ",
                "// Line 1535:     /**",
                "// Line 1536:      * Update the CIDToGIDMap string with a new value.",
                "// Line 1537:      * @param string $map CIDToGIDMap.",
                "// Line 1538:      * @param int $cid CID value.",
                "// Line 1539:      * @param int $gid GID value.",
                "// Line 1540:      * @return string CIDToGIDMap.",
                "// Line 1541:      * @author Nicola Asuni",
                "// Line 1542:      * @since 5.9.123 (2011-09-29)",
                "// Line 1543:      * @public static",
                "// Line 1544:      */",
                "// Line 1545:     public static function updateCIDtoGIDmap($map, $cid, $gid) {",
                "// Line 1546:         if (($cid >= 0) AND ($cid <= 0xFFFF) AND ($gid >= 0)) {",
                "// Line 1547:             if ($gid > 0xFFFF) {",
                "// Line 1548:                 $gid -= 0x10000;",
                "// vulnerable line: 1549: }",
                "// Line 1550:             $map[($cid * 2)] = chr($gid >> 8);",
                "// Line 1551:             $map[(($cid * 2) + 1)] = chr($gid & 0xFF);",
                "// vulnerable line: 1552: }",
                "// Line 1553:         return $map;",
                "// vulnerable line: 1554: }",
                "// Line 1555: ",
                "// Line 1556:     /**",
                "// Line 1557:      * Return fonts path",
                "// Line 1558:      * @return string",
                "// Line 1559:      * @public static",
                "// Line 1560:      */",
                "// Line 1561:     public static function _getfontpath() {",
                "// Line 1562:         if (!defined('K_PATH_FONTS') AND is_dir($fdir = realpath(dirname(__FILE__).'/../fonts'))) {",
                "// Line 1563:             if (substr($fdir, -1) != '/') {",
                "// Line 1564:                 $fdir .= '/';",
                "// vulnerable line: 1565: }",
                "// Line 1566:             define('K_PATH_FONTS', $fdir);",
                "// vulnerable line: 1567: }",
                "// Line 1568:         return defined('K_PATH_FONTS') ? K_PATH_FONTS : '';",
                "// vulnerable line: 1569: }",
                "// Line 1570: ",
                "// Line 1571: ",
                "// Line 1572: ",
                "// Line 1573:     /**",
                "// Line 1574:      * Return font full path",
                "// Line 1575:      * @param string $file Font file name.",
                "// Line 1576:      * @param string $fontdir Font directory (set to false fto search on default directories)",
                "// Line 1577:      * @return string Font full path or empty string",
                "// Line 1578:      * @author Nicola Asuni",
                "// Line 1579:      * @since 6.0.025",
                "// Line 1581:      */",
                "// Line 1582:     public static function getFontFullPath($file, $fontdir=false) {",
                "// Line 1583:         $fontfile = '';",
                "// Line 1584:         // search files on various directories",
                "// Line 1585:         if (($fontdir !== false) AND @TCPDF_STATIC::file_exists($fontdir.$file)) {",
                "// Line 1586:             $fontfile = $fontdir.$file;",
                "// Line 1587:         } elseif (@TCPDF_STATIC::file_exists(self::_getfontpath().$file)) {",
                "// Line 1588:             $fontfile = self::_getfontpath().$file;",
                "// Line 1589:         } elseif (@TCPDF_STATIC::file_exists($file)) {",
                "// Line 1590:             $fontfile = $file;",
                "// vulnerable line: 1591: }",
                "// Line 1592:         return $fontfile;",
                "// vulnerable line: 1593: }",
                "// Line 1594: ",
                "// Line 1595: ",
                "// Line 1596: ",
                "// Line 1597: ",
                "// Line 1598:     /**",
                "// Line 1599:      * Get a reference font size.",
                "// Line 1600:      * @param string $size String containing font size value.",
                "// Line 1601:      * @param float $refsize Reference font size in points.",
                "// Line 1602:      * @return float value in points",
                "// Line 1603:      * @public static",
                "// Line 1604:      */",
                "// Line 1605:     public static function getFontRefSize($size, $refsize=12) {",
                "// Line 1606:         switch ($size) {",
                "// Line 1607:             case 'xx-small': {",
                "// Line 1608:                 $size = ($refsize - 4);",
                "// Line 1609:                 break;",
                "// vulnerable line: 1610: }",
                "// Line 1611:             case 'x-small': {",
                "// Line 1612:                 $size = ($refsize - 3);",
                "// Line 1613:                 break;",
                "// vulnerable line: 1614: }",
                "// Line 1615:             case 'small': {",
                "// Line 1616:                 $size = ($refsize - 2);",
                "// Line 1617:                 break;",
                "// vulnerable line: 1618: }",
                "// Line 1619:             case 'medium': {",
                "// Line 1620:                 $size = $refsize;",
                "// Line 1621:                 break;",
                "// vulnerable line: 1622: }",
                "// Line 1623:             case 'large': {",
                "// Line 1624:                 $size = ($refsize + 2);",
                "// Line 1625:                 break;",
                "// vulnerable line: 1626: }",
                "// Line 1627:             case 'x-large': {",
                "// Line 1628:                 $size = ($refsize + 4);",
                "// Line 1629:                 break;",
                "// vulnerable line: 1630: }",
                "// Line 1631:             case 'xx-large': {",
                "// Line 1632:                 $size = ($refsize + 6);",
                "// Line 1633:                 break;",
                "// vulnerable line: 1634: }",
                "// Line 1635:             case 'smaller': {",
                "// Line 1636:                 $size = ($refsize - 3);",
                "// Line 1637:                 break;",
                "// vulnerable line: 1638: }",
                "// Line 1639:             case 'larger': {",
                "// Line 1640:                 $size = ($refsize + 3);",
                "// Line 1641:                 break;",
                "// vulnerable line: 1642: }",
                "// vulnerable line: 1643: }",
                "// Line 1644:         return $size;",
                "// vulnerable line: 1645: }",
                "// Line 1646: ",
                "// Line 1647: ",
                "// Line 1648: ",
                "// Line 1649: ",
                "// Line 1650: ",
                "// Line 1651: ",
                "// Line 1652: ",
                "// Line 1653: ",
                "// Line 1654: ",
                "// Line 1655: ",
                "// Line 1713:             // two bytes",
                "// Line 1714:             return chr(0xC0 | $c >> 6).chr(0x80 | $c & 0x3F);",
                "// Line 1715:         } elseif ($c <= 0xFFFF) {",
                "// Line 1716:             // three bytes",
                "// Line 1717:             return chr(0xE0 | $c >> 12).chr(0x80 | $c >> 6 & 0x3F).chr(0x80 | $c & 0x3F);",
                "// Line 1718:         } elseif ($c <= 0x10FFFF) {",
                "// Line 1719:             // four bytes",
                "// Line 1720:             return chr(0xF0 | $c >> 18).chr(0x80 | $c >> 12 & 0x3F).chr(0x80 | $c >> 6 & 0x3F).chr(0x80 | $c & 0x3F);",
                "// Line 1721:         } else {",
                "// Line 1722:             return '';",
                "// vulnerable line: 1723: }",
                "// vulnerable line: 1724: }",
                "// Line 1725: ",
                "// Line 1726:     /**",
                "// Line 1727:      * Returns the unicode caracter specified by UTF-8 value",
                "// Line 1728:      * @param int $c UTF-8 value",
                "// Line 1729:      * @return string Returns the specified character.",
                "// Line 1730:      * @public static",
                "// Line 1731:      */",
                "// Line 1732:     public static function unichrUnicode($c) {",
                "// Line 1733:         return self::unichr($c, true);",
                "// vulnerable line: 1734: }",
                "// Line 1735: ",
                "// Line 1736:     /**",
                "// Line 1737:      * Returns the unicode caracter specified by ASCII value",
                "// Line 1738:      * @param int $c UTF-8 value",
                "// Line 1739:      * @return string Returns the specified character.",
                "// Line 1740:      * @public static",
                "// Line 1741:      */",
                "// Line 1742:     public static function unichrASCII($c) {",
                "// Line 1743:         return self::unichr($c, false);",
                "// vulnerable line: 1744: }",
                "// Line 1745: ",
                "// Line 1746:     /**",
                "// Line 1747:      * Converts array of UTF-8 characters to UTF16-BE string.<br>",
                "// Line 1748:      * Based on: http://www.faqs.org/rfcs/rfc2781.html",
                "// Line 1749:      * <pre>",
                "// Line 1750:      *   Encoding UTF-16:",
                "// Line 1751:      *",
                "// Line 1752:      *   Encoding of a single character from an ISO 10646 character value to",
                "// Line 1753:      *    UTF-16 proceeds as follows. Let U be the character number, no greater",
                "// Line 1754:      *    than 0x10FFFF.",
                "// Line 1778:      * @return string",
                "// Line 1779:      * @protected",
                "// Line 1780:      * @author Nicola Asuni",
                "// Line 1781:      * @since 2.1.000 (2008-01-08)",
                "// Line 1782:      * @public static",
                "// Line 1783:      */",
                "// Line 1784:     public static function arrUTF8ToUTF16BE($unicode, $setbom=false) {",
                "// Line 1785:         $outstr = ''; // string to be returned",
                "// Line 1786:         if ($setbom) {",
                "// Line 1787:             $outstr .= \"\"; // Byte Order Mark (BOM)",
                "// vulnerable line: 1788: }",
                "// Line 1789:         foreach ($unicode as $char) {",
                "// Line 1790:             if ($char == 0x200b) {",
                "// Line 1791:                 // skip Unicode Character 'ZERO WIDTH SPACE' (DEC:8203, U+200B)",
                "// Line 1792:             } elseif ($char == 0xFFFD) {",
                "// Line 1793:                 $outstr .= \"\"; // replacement character",
                "// Line 1794:             } elseif ($char < 0x10000) {",
                "// Line 1795:                 $outstr .= chr($char >> 0x08);",
                "// Line 1796:                 $outstr .= chr($char & 0xFF);",
                "// Line 1797:             } else {",
                "// Line 1798:                 $char -= 0x10000;",
                "// Line 1799:                 $w1 = 0xD800 | ($char >> 0x0a);",
                "// Line 1800:                 $w2 = 0xDC00 | ($char & 0x3FF);",
                "// Line 1801:                 $outstr .= chr($w1 >> 0x08);",
                "// Line 1802:                 $outstr .= chr($w1 & 0xFF);",
                "// Line 1803:                 $outstr .= chr($w2 >> 0x08);",
                "// Line 1804:                 $outstr .= chr($w2 & 0xFF);",
                "// vulnerable line: 1805: }",
                "// vulnerable line: 1806: }",
                "// Line 1807:         return $outstr;",
                "// vulnerable line: 1808: }",
                "// Line 1809: ",
                "// Line 1810:     /**",
                "// Line 1811:      * Convert an array of UTF8 values to array of unicode characters",
                "// Line 1812:      * @param array $ta The input array of UTF8 values.",
                "// Line 1813:      * @param boolean $isunicode True for Unicode mode, false otherwise.",
                "// Line 1814:      * @return array Return array of unicode characters",
                "// Line 1815:      * @since 4.5.037 (2009-04-07)",
                "// Line 1816:      * @public static",
                "// Line 1817:      */",
                "// Line 1818:     public static function UTF8ArrayToUniArray($ta, $isunicode=true) {",
                "// Line 1819:         if ($isunicode) {",
                "// vulnerable line: 1820: return array_map(array('TCPDF_FONTS', 'unichrUnicode'), $ta);",
                "// vulnerable line: 1821: }",
                "// vulnerable line: 1822: return array_map(array('TCPDF_FONTS', 'unichrASCII'), $ta);",
                "// vulnerable line: 1823: }",
                "// Line 1824: ",
                "// Line 1825:     /**",
                "// Line 1826:      * Extract a slice of the $strarr array and return it as string.",
                "// Line 1827:      * @param string[] $strarr The input array of characters.",
                "// Line 1828:      * @param int $start the starting element of $strarr.",
                "// Line 1829:      * @param int $end first element that will not be returned.",
                "// Line 1830:      * @param boolean $unicode True if we are in unicode mode, false otherwise.",
                "// Line 1831:      * @return string Return part of a string",
                "// Line 1832:      * @public static",
                "// Line 1833:      */",
                "// Line 1834:     public static function UTF8ArrSubString($strarr, $start='', $end='', $unicode=true) {",
                "// Line 1835:         if (strlen($start) == 0) {",
                "// Line 1836:             $start = 0;",
                "// vulnerable line: 1837: }",
                "// Line 1838:         if (strlen($end) == 0) {",
                "// Line 1839:             $end = count($strarr);",
                "// vulnerable line: 1840: }",
                "// Line 1841:         $string = '';",
                "// Line 1842:         for ($i = $start; $i < $end; ++$i) {",
                "// Line 1843:             $string .= self::unichr($strarr[$i], $unicode);",
                "// vulnerable line: 1844: }",
                "// Line 1845:         return $string;",
                "// vulnerable line: 1846: }",
                "// Line 1847: ",
                "// Line 1848:     /**",
                "// Line 1849:      * Extract a slice of the $uniarr array and return it as string.",
                "// Line 1850:      * @param string[] $uniarr The input array of characters.",
                "// Line 1851:      * @param int $start the starting element of $strarr.",
                "// Line 1852:      * @param int $end first element that will not be returned.",
                "// Line 1853:      * @return string Return part of a string",
                "// Line 1854:      * @since 4.5.037 (2009-04-07)",
                "// Line 1855:      * @public static",
                "// Line 1856:      */",
                "// Line 1857:     public static function UniArrSubString($uniarr, $start='', $end='') {",
                "// Line 1858:         if (strlen($start) == 0) {",
                "// Line 1859:             $start = 0;",
                "// vulnerable line: 1860: }",
                "// Line 1861:         if (strlen($end) == 0) {",
                "// Line 1862:             $end = count($uniarr);",
                "// vulnerable line: 1863: }",
                "// Line 1864:         $string = '';",
                "// Line 1865:         for ($i=$start; $i < $end; ++$i) {",
                "// Line 1866:             $string .= $uniarr[$i];",
                "// vulnerable line: 1867: }",
                "// Line 1868:         return $string;",
                "// vulnerable line: 1869: }",
                "// Line 1870: ",
                "// Line 1871:     /**",
                "// Line 1872:      * Converts UTF-8 characters array to array of Latin1 characters array<br>",
                "// Line 1873:      * @param array $unicode array containing UTF-8 unicode values",
                "// Line 1874:      * @return array",
                "// Line 1875:      * @author Nicola Asuni",
                "// Line 1876:      * @since 4.8.023 (2010-01-15)",
                "// Line 1877:      * @public static",
                "// Line 1878:      */",
                "// Line 1879:     public static function UTF8ArrToLatin1Arr($unicode) {",
                "// Line 1881:         foreach ($unicode as $char) {",
                "// Line 1882:             if ($char < 256) {",
                "// Line 1883:                 $outarr[] = $char;",
                "// Line 1884:             } elseif (array_key_exists($char, TCPDF_FONT_DATA::$uni_utf8tolatin)) {",
                "// Line 1885:                 // map from UTF-8",
                "// Line 1886:                 $outarr[] = TCPDF_FONT_DATA::$uni_utf8tolatin[$char];",
                "// Line 1887:             } elseif ($char == 0xFFFD) {",
                "// Line 1888:                 // skip",
                "// Line 1889:             } else {",
                "// Line 1890:                 $outarr[] = 63; // '?' character",
                "// vulnerable line: 1891: }",
                "// vulnerable line: 1892: }",
                "// Line 1893:         return $outarr;",
                "// vulnerable line: 1894: }",
                "// Line 1895: ",
                "// Line 1896:     /**",
                "// Line 1897:      * Converts UTF-8 characters array to Latin1 string<br>",
                "// Line 1898:      * @param array $unicode array containing UTF-8 unicode values",
                "// Line 1899:      * @return string",
                "// Line 1900:      * @author Nicola Asuni",
                "// Line 1901:      * @since 4.8.023 (2010-01-15)",
                "// Line 1902:      * @public static",
                "// Line 1903:      */",
                "// Line 1904:     public static function UTF8ArrToLatin1($unicode) {",
                "// Line 1906:         foreach ($unicode as $char) {",
                "// Line 1907:             if ($char < 256) {",
                "// Line 1908:                 $outstr .= chr($char);",
                "// Line 1909:             } elseif (array_key_exists($char, TCPDF_FONT_DATA::$uni_utf8tolatin)) {",
                "// Line 1910:                 // map from UTF-8",
                "// Line 1911:                 $outstr .= chr(TCPDF_FONT_DATA::$uni_utf8tolatin[$char]);",
                "// Line 1912:             } elseif ($char == 0xFFFD) {",
                "// Line 1913:                 // skip",
                "// Line 1914:             } else {",
                "// Line 1915:                 $outstr .= '?';",
                "// vulnerable line: 1916: }",
                "// vulnerable line: 1917: }",
                "// Line 1918:         return $outstr;",
                "// vulnerable line: 1919: }",
                "// Line 1920: ",
                "// Line 1921:     /**",
                "// Line 1922:      * Converts UTF-8 character to integer value.<br>",
                "// Line 1923:      * Uses the getUniord() method if the value is not cached.",
                "// Line 1924:      * @param string $uch character string to process.",
                "// Line 1925:      * @return int Unicode value",
                "// Line 1926:      * @public static",
                "// Line 1927:      */",
                "// Line 1928:     public static function uniord($uch) {",
                "// Line 1929:         if (!isset(self::$cache_uniord[$uch])) {",
                "// Line 1930:             self::$cache_uniord[$uch] = self::getUniord($uch);",
                "// vulnerable line: 1931: }",
                "// Line 1932:         return self::$cache_uniord[$uch];",
                "// vulnerable line: 1933: }",
                "// Line 1934: ",
                "// Line 1935:     /**",
                "// Line 1936:      * Converts UTF-8 character to integer value.<br>",
                "// Line 1937:      * Invalid byte sequences will be replaced with 0xFFFD (replacement character)<br>",
                "// Line 1938:      * Based on: http://www.faqs.org/rfcs/rfc3629.html",
                "// Line 1939:      * <pre>",
                "// Line 1940:      *    Char. number range  |        UTF-8 octet sequence",
                "// Line 1941:      *       (hexadecimal)    |              (binary)",
                "// Line 1942:      *    --------------------+-----------------------------------------------",
                "// Line 1943:      *    0000 0000-0000 007F | 0xxxxxxx",
                "// Line 1963:      * @param string $uch character string to process.",
                "// Line 1964:      * @return int Unicode value",
                "// Line 1965:      * @author Nicola Asuni",
                "// Line 1966:      * @public static",
                "// Line 1967:      */",
                "// Line 1968:     public static function getUniord($uch) {",
                "// Line 1969:         if (function_exists('mb_convert_encoding')) {",
                "// Line 1970:             list(, $char) = @unpack('N', mb_convert_encoding($uch, 'UCS-4BE', 'UTF-8'));",
                "// Line 1971:             if ($char >= 0) {",
                "// Line 1972:                 return $char;",
                "// vulnerable line: 1973: }",
                "// vulnerable line: 1974: }",
                "// Line 1975:         $bytes = array(); // array containing single character byte sequences",
                "// Line 1976:         $countbytes = 0;",
                "// Line 1977:         $numbytes = 1; // number of octetc needed to represent the UTF-8 character",
                "// Line 1978:         $length = strlen($uch);",
                "// Line 1979:         for ($i = 0; $i < $length; ++$i) {",
                "// Line 1980:             $char = ord($uch[$i]); // get one string character at time",
                "// Line 1981:             if ($countbytes == 0) { // get starting octect",
                "// Line 1982:                 if ($char <= 0x7F) {",
                "// Line 1983:                     return $char; // use the character \"as is\" because is ASCII",
                "// Line 1984:                 } elseif (($char >> 0x05) == 0x06) { // 2 bytes character (0x06 = 110 BIN)",
                "// Line 1989:                     $bytes[] = ($char - 0xE0) << 0x0C;",
                "// Line 1990:                     ++$countbytes;",
                "// Line 1991:                     $numbytes = 3;",
                "// Line 1992:                 } elseif (($char >> 0x03) == 0x1E) { // 4 bytes character (0x1E = 11110 BIN)",
                "// Line 1993:                     $bytes[] = ($char - 0xF0) << 0x12;",
                "// Line 1994:                     ++$countbytes;",
                "// Line 1995:                     $numbytes = 4;",
                "// Line 1996:                 } else {",
                "// Line 1997:                     // use replacement character for other invalid sequences",
                "// Line 1998:                     return 0xFFFD;",
                "// vulnerable line: 1999: }",
                "// Line 2000:             } elseif (($char >> 0x06) == 0x02) { // bytes 2, 3 and 4 must start with 0x02 = 10 BIN",
                "// Line 2001:                 $bytes[] = $char - 0x80;",
                "// Line 2002:                 ++$countbytes;",
                "// Line 2003:                 if ($countbytes == $numbytes) {",
                "// Line 2004:                     // compose UTF-8 bytes to a single unicode value",
                "// Line 2005:                     $char = $bytes[0];",
                "// Line 2006:                     for ($j = 1; $j < $numbytes; ++$j) {",
                "// Line 2007:                         $char += ($bytes[$j] << (($numbytes - $j - 1) * 0x06));",
                "// vulnerable line: 2008: }",
                "// Line 2009:                     if ((($char >= 0xD800) AND ($char <= 0xDFFF)) OR ($char >= 0x10FFFF)) {",
                "// Line 2010:                         // The definition of UTF-8 prohibits encoding character numbers between",
                "// Line 2011:                         // U+D800 and U+DFFF, which are reserved for use with the UTF-16",
                "// Line 2012:                         // encoding form (as surrogate pairs) and do not directly represent",
                "// Line 2013:                         // characters.",
                "// Line 2014:                         return 0xFFFD; // use replacement character",
                "// Line 2015:                     } else {",
                "// Line 2016:                         return $char;",
                "// vulnerable line: 2017: }",
                "// vulnerable line: 2018: }",
                "// Line 2019:             } else {",
                "// Line 2020:                 // use replacement character for other invalid sequences",
                "// Line 2021:                 return 0xFFFD;",
                "// vulnerable line: 2022: }",
                "// vulnerable line: 2023: }",
                "// Line 2024:         return 0xFFFD;",
                "// vulnerable line: 2025: }",
                "// Line 2026: ",
                "// Line 2027:     /**",
                "// Line 2028:      * Converts UTF-8 strings to codepoints array.<br>",
                "// Line 2029:      * Invalid byte sequences will be replaced with 0xFFFD (replacement character)<br>",
                "// Line 2030:      * @param string $str string to process.",
                "// Line 2031:      * @param boolean $isunicode True when the documetn is in Unicode mode, false otherwise.",
                "// Line 2032:      * @param array $currentfont Reference to current font array.",
                "// Line 2033:      * @return array containing codepoints (UTF-8 characters values)",
                "// Line 2034:      * @author Nicola Asuni",
                "// Line 2035:      * @public static",
                "// Line 2036:      */",
                "// Line 2037:     public static function UTF8StringToArray($str, $isunicode, &$currentfont) {",
                "// Line 2038:         $str = is_null($str) ? '' : $str;",
                "// Line 2039:         if ($isunicode) {",
                "// Line 2040:             // requires PCRE unicode support turned on",
                "// Line 2041:             $chars = TCPDF_STATIC::pregSplit('//','u', $str, -1, PREG_SPLIT_NO_EMPTY);",
                "// vulnerable line: 2042: $carr = array_map(array('TCPDF_FONTS', 'uniord'), $chars);",
                "// Line 2043:         } else {",
                "// Line 2044:             $chars = str_split($str);",
                "// Line 2045:             $carr = array_map('ord', $chars);",
                "// vulnerable line: 2046: }",
                "// Line 2047:         if (is_array($currentfont['subsetchars']) && is_array($carr)) {",
                "// Line 2048:             $currentfont['subsetchars'] += array_fill_keys($carr, true);",
                "// Line 2049:         } else {",
                "// Line 2050:             $currentfont['subsetchars'] = array_merge($currentfont['subsetchars'], $carr);",
                "// vulnerable line: 2051: }",
                "// Line 2052:         return $carr;",
                "// vulnerable line: 2053: }",
                "// Line 2054: ",
                "// Line 2055:     /**",
                "// Line 2056:      * Converts UTF-8 strings to Latin1 when using the standard 14 core fonts.<br>",
                "// Line 2057:      * @param string $str string to process.",
                "// Line 2058:      * @param boolean $isunicode True when the documetn is in Unicode mode, false otherwise.",
                "// Line 2059:      * @param array $currentfont Reference to current font array.",
                "// Line 2060:      * @return string",
                "// Line 2061:      * @since 3.2.000 (2008-06-23)",
                "// Line 2062:      * @public static",
                "// Line 2063:      */",
                "// Line 2064:     public static function UTF8ToLatin1($str, $isunicode, &$currentfont) {",
                "// Line 2065:         $unicode = self::UTF8StringToArray($str, $isunicode, $currentfont); // array containing UTF-8 unicode values",
                "// Line 2066:         return self::UTF8ArrToLatin1($unicode);",
                "// vulnerable line: 2067: }",
                "// Line 2068: ",
                "// Line 2069:     /**",
                "// Line 2070:      * Converts UTF-8 strings to UTF16-BE.<br>",
                "// Line 2071:      * @param string $str string to process.",
                "// Line 2072:      * @param boolean $setbom if true set the Byte Order Mark (BOM = 0xFEFF)",
                "// Line 2073:      * @param boolean $isunicode True when the documetn is in Unicode mode, false otherwise.",
                "// Line 2074:      * @param array $currentfont Reference to current font array.",
                "// Line 2075:      * @return string",
                "// Line 2076:      * @author Nicola Asuni",
                "// Line 2077:      * @since 1.53.0.TC005 (2005-01-05)",
                "// Line 2078:      * @public static",
                "// Line 2079:      */",
                "// Line 2080:     public static function UTF8ToUTF16BE($str, $setbom, $isunicode, &$currentfont) {",
                "// Line 2081:         if (!$isunicode) {",
                "// Line 2082:             return $str; // string is not in unicode",
                "// vulnerable line: 2083: }",
                "// Line 2084:         $unicode = self::UTF8StringToArray($str, $isunicode, $currentfont); // array containing UTF-8 unicode values",
                "// Line 2085:         return self::arrUTF8ToUTF16BE($unicode, $setbom);",
                "// vulnerable line: 2086: }",
                "// Line 2087: ",
                "// Line 2088:     /**",
                "// Line 2089:      * Reverse the RLT substrings using the Bidirectional Algorithm (http://unicode.org/reports/tr9/).",
                "// Line 2090:      * @param string $str string to manipulate.",
                "// Line 2091:      * @param bool $setbom if true set the Byte Order Mark (BOM = 0xFEFF)",
                "// Line 2092:      * @param bool $forcertl if true forces RTL text direction",
                "// Line 2093:      * @param boolean $isunicode True if the document is in Unicode mode, false otherwise.",
                "// Line 2094:      * @param array $currentfont Reference to current font array.",
                "// Line 2095:      * @return string",
                "// Line 2096:      * @author Nicola Asuni",
                "// Line 2097:      * @since 2.1.000 (2008-01-08)",
                "// Line 2098:      * @public static",
                "// Line 2099:      */",
                "// Line 2100:     public static function utf8StrRev($str, $setbom, $forcertl, $isunicode, &$currentfont) {",
                "// Line 2101:         return self::utf8StrArrRev(self::UTF8StringToArray($str, $isunicode, $currentfont), $str, $setbom, $forcertl, $isunicode, $currentfont);",
                "// vulnerable line: 2102: }",
                "// Line 2103: ",
                "// Line 2104:     /**",
                "// Line 2105:      * Reverse the RLT substrings array using the Bidirectional Algorithm (http://unicode.org/reports/tr9/).",
                "// Line 2106:      * @param array $arr array of unicode values.",
                "// Line 2107:      * @param string $str string to manipulate (or empty value).",
                "// Line 2108:      * @param bool $setbom if true set the Byte Order Mark (BOM = 0xFEFF)",
                "// Line 2109:      * @param bool $forcertl if true forces RTL text direction",
                "// Line 2110:      * @param boolean $isunicode True if the document is in Unicode mode, false otherwise.",
                "// Line 2111:      * @param array $currentfont Reference to current font array.",
                "// Line 2112:      * @return string",
                "// Line 2113:      * @author Nicola Asuni",
                "// Line 2114:      * @since 4.9.000 (2010-03-27)",
                "// Line 2115:      * @public static",
                "// Line 2116:      */",
                "// Line 2117:     public static function utf8StrArrRev($arr, $str, $setbom, $forcertl, $isunicode, &$currentfont) {",
                "// Line 2118:         return self::arrUTF8ToUTF16BE(self::utf8Bidi($arr, $str, $forcertl, $isunicode, $currentfont), $setbom);",
                "// vulnerable line: 2119: }",
                "// Line 2120: ",
                "// Line 2121:     /**",
                "// Line 2122:      * Reverse the RLT substrings using the Bidirectional Algorithm (http://unicode.org/reports/tr9/).",
                "// Line 2123:      * @param array $ta array of characters composing the string.",
                "// Line 2124:      * @param string $str string to process",
                "// Line 2125:      * @param bool $forcertl if 'R' forces RTL, if 'L' forces LTR",
                "// Line 2126:      * @param boolean $isunicode True if the document is in Unicode mode, false otherwise.",
                "// Line 2127:      * @param array $currentfont Reference to current font array.",
                "// Line 2128:      * @return array of unicode chars",
                "// Line 2129:      * @author Nicola Asuni",
                "// Line 2131:      * @public static",
                "// Line 2132:      */",
                "// Line 2133:     public static function utf8Bidi($ta, $str, $forcertl, $isunicode, &$currentfont) {",
                "// Line 2134:         // paragraph embedding level",
                "// Line 2135:         $pel = 0;",
                "// Line 2136:         // max level",
                "// Line 2137:         $maxlevel = 0;",
                "// Line 2138:         if (TCPDF_STATIC::empty_string($str)) {",
                "// Line 2139:             // create string from array",
                "// Line 2140:             $str = self::UTF8ArrSubString($ta, '', '', $isunicode);",
                "// vulnerable line: 2141: }",
                "// Line 2142:         // check if string contains arabic text",
                "// Line 2143:         if (preg_match(TCPDF_FONT_DATA::$uni_RE_PATTERN_ARABIC, $str)) {",
                "// Line 2144:             $arabic = true;",
                "// Line 2145:         } else {",
                "// Line 2146:             $arabic = false;",
                "// vulnerable line: 2147: }",
                "// Line 2148:         // check if string contains RTL text",
                "// Line 2149:         if (!($forcertl OR $arabic OR preg_match(TCPDF_FONT_DATA::$uni_RE_PATTERN_RTL, $str))) {",
                "// Line 2150:             return $ta;",
                "// vulnerable line: 2151: }",
                "// Line 2152: ",
                "// Line 2153:         // get number of chars",
                "// Line 2154:         $numchars = count($ta);",
                "// Line 2155: ",
                "// Line 2156:         if ($forcertl == 'R') {",
                "// Line 2157:             $pel = 1;",
                "// Line 2158:         } elseif ($forcertl == 'L') {",
                "// Line 2159:             $pel = 0;",
                "// Line 2160:         } else {",
                "// Line 2161:             // P2. In each paragraph, find the first character of type L, AL, or R.",
                "// Line 2162:             // P3. If a character is found in P2 and it is of type AL or R, then set the paragraph embedding level to one; otherwise, set it to zero.",
                "// Line 2163:             for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2164:                 $type = TCPDF_FONT_DATA::$uni_type[$ta[$i]];",
                "// Line 2165:                 if ($type == 'L') {",
                "// Line 2166:                     $pel = 0;",
                "// Line 2167:                     break;",
                "// Line 2168:                 } elseif (($type == 'AL') OR ($type == 'R')) {",
                "// Line 2169:                     $pel = 1;",
                "// Line 2170:                     break;",
                "// vulnerable line: 2171: }",
                "// vulnerable line: 2172: }",
                "// vulnerable line: 2173: }",
                "// Line 2174: ",
                "// Line 2175:         // Current Embedding Level",
                "// Line 2176:         $cel = $pel;",
                "// Line 2177:         // directional override status",
                "// Line 2178:         $dos = 'N';",
                "// Line 2179:         $remember = array();",
                "// Line 2180:         // start-of-level-run",
                "// Line 2181:         $sor = $pel % 2 ? 'R' : 'L';",
                "// Line 2182:         $eor = $sor;",
                "// Line 2183: ",
                "// Line 2191:                 // X2. With each RLE, compute the least greater odd embedding level.",
                "// Line 2192:                 //    a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to neutral.",
                "// Line 2193:                 //    b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.",
                "// Line 2194:                 $next_level = $cel + ($cel % 2) + 1;",
                "// Line 2195:                 if ($next_level < 62) {",
                "// Line 2196:                     $remember[] = array('num' => TCPDF_FONT_DATA::$uni_RLE, 'cel' => $cel, 'dos' => $dos);",
                "// Line 2197:                     $cel = $next_level;",
                "// Line 2198:                     $dos = 'N';",
                "// Line 2199:                     $sor = $eor;",
                "// Line 2200:                     $eor = $cel % 2 ? 'R' : 'L';",
                "// vulnerable line: 2201: }",
                "// Line 2202:             } elseif ($ta[$i] == TCPDF_FONT_DATA::$uni_LRE) {",
                "// Line 2203:                 // X3. With each LRE, compute the least greater even embedding level.",
                "// Line 2204:                 //    a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to neutral.",
                "// Line 2205:                 //    b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.",
                "// Line 2206:                 $next_level = $cel + 2 - ($cel % 2);",
                "// Line 2207:                 if ( $next_level < 62 ) {",
                "// Line 2208:                     $remember[] = array('num' => TCPDF_FONT_DATA::$uni_LRE, 'cel' => $cel, 'dos' => $dos);",
                "// Line 2209:                     $cel = $next_level;",
                "// Line 2210:                     $dos = 'N';",
                "// Line 2211:                     $sor = $eor;",
                "// Line 2212:                     $eor = $cel % 2 ? 'R' : 'L';",
                "// vulnerable line: 2213: }",
                "// Line 2214:             } elseif ($ta[$i] == TCPDF_FONT_DATA::$uni_RLO) {",
                "// Line 2215:                 // X4. With each RLO, compute the least greater odd embedding level.",
                "// Line 2216:                 //    a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to right-to-left.",
                "// Line 2217:                 //    b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.",
                "// Line 2218:                 $next_level = $cel + ($cel % 2) + 1;",
                "// Line 2219:                 if ($next_level < 62) {",
                "// Line 2220:                     $remember[] = array('num' => TCPDF_FONT_DATA::$uni_RLO, 'cel' => $cel, 'dos' => $dos);",
                "// Line 2221:                     $cel = $next_level;",
                "// Line 2222:                     $dos = 'R';",
                "// Line 2223:                     $sor = $eor;",
                "// Line 2224:                     $eor = $cel % 2 ? 'R' : 'L';",
                "// vulnerable line: 2225: }",
                "// Line 2226:             } elseif ($ta[$i] == TCPDF_FONT_DATA::$uni_LRO) {",
                "// Line 2227:                 // X5. With each LRO, compute the least greater even embedding level.",
                "// Line 2228:                 //    a. If this new level would be valid, then this embedding code is valid. Remember (push) the current embedding level and override status. Reset the current level to this new level, and reset the override status to left-to-right.",
                "// Line 2229:                 //    b. If the new level would not be valid, then this code is invalid. Do not change the current level or override status.",
                "// Line 2230:                 $next_level = $cel + 2 - ($cel % 2);",
                "// Line 2231:                 if ( $next_level < 62 ) {",
                "// Line 2232:                     $remember[] = array('num' => TCPDF_FONT_DATA::$uni_LRO, 'cel' => $cel, 'dos' => $dos);",
                "// Line 2233:                     $cel = $next_level;",
                "// Line 2234:                     $dos = 'L';",
                "// Line 2235:                     $sor = $eor;",
                "// Line 2236:                     $eor = $cel % 2 ? 'R' : 'L';",
                "// vulnerable line: 2237: }",
                "// Line 2238:             } elseif ($ta[$i] == TCPDF_FONT_DATA::$uni_PDF) {",
                "// Line 2239:                 // X7. With each PDF, determine the matching embedding or override code. If there was a valid matching code, restore (pop) the last remembered (pushed) embedding level and directional override.",
                "// Line 2240:                 if (count($remember)) {",
                "// Line 2241:                     $last = count($remember ) - 1;",
                "// Line 2242:                     if (($remember[$last]['num'] == TCPDF_FONT_DATA::$uni_RLE) OR",
                "// Line 2243:                         ($remember[$last]['num'] == TCPDF_FONT_DATA::$uni_LRE) OR",
                "// Line 2244:                         ($remember[$last]['num'] == TCPDF_FONT_DATA::$uni_RLO) OR",
                "// Line 2245:                         ($remember[$last]['num'] == TCPDF_FONT_DATA::$uni_LRO)) {",
                "// Line 2246:                         $match = array_pop($remember);",
                "// Line 2247:                         $cel = $match['cel'];",
                "// Line 2248:                         $dos = $match['dos'];",
                "// Line 2249:                         $sor = $eor;",
                "// Line 2250:                         $eor = ($cel > $match['cel'] ? $cel : $match['cel']) % 2 ? 'R' : 'L';",
                "// vulnerable line: 2251: }",
                "// vulnerable line: 2252: }",
                "// Line 2253:             } elseif (($ta[$i] != TCPDF_FONT_DATA::$uni_RLE) AND",
                "// Line 2254:                              ($ta[$i] != TCPDF_FONT_DATA::$uni_LRE) AND",
                "// Line 2255:                              ($ta[$i] != TCPDF_FONT_DATA::$uni_RLO) AND",
                "// Line 2256:                              ($ta[$i] != TCPDF_FONT_DATA::$uni_LRO) AND",
                "// Line 2257:                              ($ta[$i] != TCPDF_FONT_DATA::$uni_PDF)) {",
                "// Line 2258:                 // X6. For all types besides RLE, LRE, RLO, LRO, and PDF:",
                "// Line 2259:                 //    a. Set the level of the current character to the current embedding level.",
                "// Line 2260:                 //    b. Whenever the directional override status is not neutral, reset the current character type to the directional override status.",
                "// Line 2261:                 if ($dos != 'N') {",
                "// Line 2262:                     $chardir = $dos;",
                "// Line 2263:                 } else {",
                "// Line 2264:                     if (isset(TCPDF_FONT_DATA::$uni_type[$ta[$i]])) {",
                "// Line 2265:                         $chardir = TCPDF_FONT_DATA::$uni_type[$ta[$i]];",
                "// Line 2266:                     } else {",
                "// Line 2267:                         $chardir = 'L';",
                "// vulnerable line: 2268: }",
                "// vulnerable line: 2269: }",
                "// Line 2270:                 // stores string characters and other information",
                "// Line 2271:                 $chardata[] = array('char' => $ta[$i], 'level' => $cel, 'type' => $chardir, 'sor' => $sor, 'eor' => $eor);",
                "// vulnerable line: 2272: }",
                "// Line 2273:         } // end for each char",
                "// Line 2274: ",
                "// Line 2275:         // X8. All explicit directional embeddings and overrides are completely terminated at the end of each paragraph. Paragraph separators are not included in the embedding.",
                "// Line 2276:         // X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes.",
                "// Line 2277:         // X10. The remaining rules are applied to each run of characters at the same level. For each run, determine the start-of-level-run (sor) and end-of-level-run (eor) type, either L or R. This depends on the higher of the two levels on either side of the boundary (at the start or end of the paragraph, the level of the 'other' run is the base embedding level). If the higher level is odd, the type is R; otherwise, it is L.",
                "// Line 2278: ",
                "// Line 2279:         // 3.3.3 Resolving Weak Types",
                "// Line 2280:         // Weak types are now resolved one level run at a time. At level run boundaries where the type of the character on the other side of the boundary is required, the type assigned to sor or eor is used.",
                "// Line 2281:         // Nonspacing marks are now resolved based on the previous characters.",
                "// Line 2282:         $numchars = count($chardata);",
                "// Line 2283: ",
                "// Line 2284:         // W1. Examine each nonspacing mark (NSM) in the level run, and change the type of the NSM to the type of the previous character. If the NSM is at the start of the level run, it will get the type of sor.",
                "// Line 2285:         $prevlevel = -1; // track level changes",
                "// Line 2286:         $levcount = 0; // counts consecutive chars at the same level",
                "// Line 2287:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2288:             if ($chardata[$i]['type'] == 'NSM') {",
                "// Line 2289:                 if ($levcount) {",
                "// Line 2290:                     $chardata[$i]['type'] = $chardata[$i]['sor'];",
                "// Line 2291:                 } elseif ($i > 0) {",
                "// Line 2292:                     $chardata[$i]['type'] = $chardata[($i-1)]['type'];",
                "// vulnerable line: 2293: }",
                "// vulnerable line: 2294: }",
                "// Line 2295:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2296:                 $levcount = 0;",
                "// Line 2297:             } else {",
                "// Line 2298:                 ++$levcount;",
                "// vulnerable line: 2299: }",
                "// Line 2300:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2301: }",
                "// Line 2302: ",
                "// Line 2303:         // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sor) is found. If an AL is found, change the type of the European number to Arabic number.",
                "// Line 2304:         $prevlevel = -1;",
                "// Line 2305:         $levcount = 0;",
                "// Line 2306:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2307:             if ($chardata[$i]['char'] == 'EN') {",
                "// Line 2308:                 for ($j=$levcount; $j >= 0; $j--) {",
                "// Line 2309:                     if ($chardata[$j]['type'] == 'AL') {",
                "// Line 2310:                         $chardata[$i]['type'] = 'AN';",
                "// Line 2311:                     } elseif (($chardata[$j]['type'] == 'L') OR ($chardata[$j]['type'] == 'R')) {",
                "// Line 2312:                         break;",
                "// vulnerable line: 2313: }",
                "// vulnerable line: 2314: }",
                "// vulnerable line: 2315: }",
                "// Line 2316:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2317:                 $levcount = 0;",
                "// Line 2318:             } else {",
                "// Line 2319:                 ++$levcount;",
                "// vulnerable line: 2320: }",
                "// Line 2321:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2322: }",
                "// Line 2323: ",
                "// Line 2324:         // W3. Change all ALs to R.",
                "// Line 2325:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2326:             if ($chardata[$i]['type'] == 'AL') {",
                "// Line 2327:                 $chardata[$i]['type'] = 'R';",
                "// vulnerable line: 2328: }",
                "// vulnerable line: 2329: }",
                "// Line 2330: ",
                "// Line 2331:         // W4. A single European separator between two European numbers changes to a European number. A single common separator between two numbers of the same type changes to that type.",
                "// Line 2332:         $prevlevel = -1;",
                "// Line 2333:         $levcount = 0;",
                "// Line 2334:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2335:             if (($levcount > 0) AND (($i+1) < $numchars) AND ($chardata[($i+1)]['level'] == $prevlevel)) {",
                "// Line 2336:                 if (($chardata[$i]['type'] == 'ES') AND ($chardata[($i-1)]['type'] == 'EN') AND ($chardata[($i+1)]['type'] == 'EN')) {",
                "// Line 2337:                     $chardata[$i]['type'] = 'EN';",
                "// Line 2338:                 } elseif (($chardata[$i]['type'] == 'CS') AND ($chardata[($i-1)]['type'] == 'EN') AND ($chardata[($i+1)]['type'] == 'EN')) {",
                "// Line 2339:                     $chardata[$i]['type'] = 'EN';",
                "// Line 2340:                 } elseif (($chardata[$i]['type'] == 'CS') AND ($chardata[($i-1)]['type'] == 'AN') AND ($chardata[($i+1)]['type'] == 'AN')) {",
                "// Line 2341:                     $chardata[$i]['type'] = 'AN';",
                "// vulnerable line: 2342: }",
                "// vulnerable line: 2343: }",
                "// Line 2344:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2345:                 $levcount = 0;",
                "// Line 2346:             } else {",
                "// Line 2347:                 ++$levcount;",
                "// vulnerable line: 2348: }",
                "// Line 2349:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2350: }",
                "// Line 2351: ",
                "// Line 2352:         // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.",
                "// Line 2353:         $prevlevel = -1;",
                "// Line 2354:         $levcount = 0;",
                "// Line 2355:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2356:             if ($chardata[$i]['type'] == 'ET') {",
                "// Line 2357:                 if (($levcount > 0) AND ($chardata[($i-1)]['type'] == 'EN')) {",
                "// Line 2358:                     $chardata[$i]['type'] = 'EN';",
                "// Line 2359:                 } else {",
                "// Line 2360:                     $j = $i+1;",
                "// Line 2361:                     while (($j < $numchars) AND ($chardata[$j]['level'] == $prevlevel)) {",
                "// Line 2362:                         if ($chardata[$j]['type'] == 'EN') {",
                "// Line 2363:                             $chardata[$i]['type'] = 'EN';",
                "// Line 2364:                             break;",
                "// Line 2365:                         } elseif ($chardata[$j]['type'] != 'ET') {",
                "// Line 2366:                             break;",
                "// vulnerable line: 2367: }",
                "// Line 2368:                         ++$j;",
                "// vulnerable line: 2369: }",
                "// vulnerable line: 2370: }",
                "// vulnerable line: 2371: }",
                "// Line 2372:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2373:                 $levcount = 0;",
                "// Line 2374:             } else {",
                "// Line 2375:                 ++$levcount;",
                "// vulnerable line: 2376: }",
                "// Line 2377:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2378: }",
                "// Line 2379: ",
                "// Line 2380:         // W6. Otherwise, separators and terminators change to Other Neutral.",
                "// Line 2381:         $prevlevel = -1;",
                "// Line 2382:         $levcount = 0;",
                "// Line 2383:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2384:             if (($chardata[$i]['type'] == 'ET') OR ($chardata[$i]['type'] == 'ES') OR ($chardata[$i]['type'] == 'CS')) {",
                "// Line 2385:                 $chardata[$i]['type'] = 'ON';",
                "// vulnerable line: 2386: }",
                "// Line 2387:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2388:                 $levcount = 0;",
                "// Line 2389:             } else {",
                "// Line 2390:                 ++$levcount;",
                "// vulnerable line: 2391: }",
                "// Line 2392:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2393: }",
                "// Line 2394: ",
                "// Line 2395:         //W7. Search backward from each instance of a European number until the first strong type (R, L, or sor) is found. If an L is found, then change the type of the European number to L.",
                "// Line 2396:         $prevlevel = -1;",
                "// Line 2397:         $levcount = 0;",
                "// Line 2398:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2399:             if ($chardata[$i]['char'] == 'EN') {",
                "// Line 2400:                 for ($j=$levcount; $j >= 0; $j--) {",
                "// Line 2401:                     if ($chardata[$j]['type'] == 'L') {",
                "// Line 2402:                         $chardata[$i]['type'] = 'L';",
                "// Line 2403:                     } elseif ($chardata[$j]['type'] == 'R') {",
                "// Line 2404:                         break;",
                "// vulnerable line: 2405: }",
                "// vulnerable line: 2406: }",
                "// vulnerable line: 2407: }",
                "// Line 2408:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2409:                 $levcount = 0;",
                "// Line 2410:             } else {",
                "// Line 2411:                 ++$levcount;",
                "// vulnerable line: 2412: }",
                "// Line 2413:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2414: }",
                "// Line 2415: ",
                "// Line 2416:         // N1. A sequence of neutrals takes the direction of the surrounding strong text if the text on both sides has the same direction. European and Arabic numbers act as if they were R in terms of their influence on neutrals. Start-of-level-run (sor) and end-of-level-run (eor) are used at level run boundaries.",
                "// Line 2417:         $prevlevel = -1;",
                "// Line 2418:         $levcount = 0;",
                "// Line 2419:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2420:             if (($levcount > 0) AND (($i+1) < $numchars) AND ($chardata[($i+1)]['level'] == $prevlevel)) {",
                "// Line 2421:                 if (($chardata[$i]['type'] == 'N') AND ($chardata[($i-1)]['type'] == 'L') AND ($chardata[($i+1)]['type'] == 'L')) {",
                "// Line 2422:                     $chardata[$i]['type'] = 'L';",
                "// Line 2423:                 } elseif (($chardata[$i]['type'] == 'N') AND",
                "// Line 2424:                  (($chardata[($i-1)]['type'] == 'R') OR ($chardata[($i-1)]['type'] == 'EN') OR ($chardata[($i-1)]['type'] == 'AN')) AND",
                "// Line 2425:                  (($chardata[($i+1)]['type'] == 'R') OR ($chardata[($i+1)]['type'] == 'EN') OR ($chardata[($i+1)]['type'] == 'AN'))) {",
                "// Line 2426:                     $chardata[$i]['type'] = 'R';",
                "// Line 2427:                 } elseif ($chardata[$i]['type'] == 'N') {",
                "// Line 2428:                     // N2. Any remaining neutrals take the embedding direction",
                "// Line 2429:                     $chardata[$i]['type'] = $chardata[$i]['sor'];",
                "// vulnerable line: 2430: }",
                "// Line 2431:             } elseif (($levcount == 0) AND (($i+1) < $numchars) AND ($chardata[($i+1)]['level'] == $prevlevel)) {",
                "// Line 2432:                 // first char",
                "// Line 2433:                 if (($chardata[$i]['type'] == 'N') AND ($chardata[$i]['sor'] == 'L') AND ($chardata[($i+1)]['type'] == 'L')) {",
                "// Line 2434:                     $chardata[$i]['type'] = 'L';",
                "// Line 2435:                 } elseif (($chardata[$i]['type'] == 'N') AND",
                "// Line 2436:                  (($chardata[$i]['sor'] == 'R') OR ($chardata[$i]['sor'] == 'EN') OR ($chardata[$i]['sor'] == 'AN')) AND",
                "// Line 2437:                  (($chardata[($i+1)]['type'] == 'R') OR ($chardata[($i+1)]['type'] == 'EN') OR ($chardata[($i+1)]['type'] == 'AN'))) {",
                "// Line 2438:                     $chardata[$i]['type'] = 'R';",
                "// Line 2439:                 } elseif ($chardata[$i]['type'] == 'N') {",
                "// Line 2440:                     // N2. Any remaining neutrals take the embedding direction",
                "// Line 2441:                     $chardata[$i]['type'] = $chardata[$i]['sor'];",
                "// vulnerable line: 2442: }",
                "// Line 2443:             } elseif (($levcount > 0) AND ((($i+1) == $numchars) OR (($i+1) < $numchars) AND ($chardata[($i+1)]['level'] != $prevlevel))) {",
                "// Line 2444:                 //last char",
                "// Line 2445:                 if (($chardata[$i]['type'] == 'N') AND ($chardata[($i-1)]['type'] == 'L') AND ($chardata[$i]['eor'] == 'L')) {",
                "// Line 2446:                     $chardata[$i]['type'] = 'L';",
                "// Line 2447:                 } elseif (($chardata[$i]['type'] == 'N') AND",
                "// Line 2448:                  (($chardata[($i-1)]['type'] == 'R') OR ($chardata[($i-1)]['type'] == 'EN') OR ($chardata[($i-1)]['type'] == 'AN')) AND",
                "// Line 2449:                  (($chardata[$i]['eor'] == 'R') OR ($chardata[$i]['eor'] == 'EN') OR ($chardata[$i]['eor'] == 'AN'))) {",
                "// Line 2450:                     $chardata[$i]['type'] = 'R';",
                "// Line 2451:                 } elseif ($chardata[$i]['type'] == 'N') {",
                "// Line 2452:                     // N2. Any remaining neutrals take the embedding direction",
                "// Line 2453:                     $chardata[$i]['type'] = $chardata[$i]['sor'];",
                "// vulnerable line: 2454: }",
                "// Line 2455:             } elseif ($chardata[$i]['type'] == 'N') {",
                "// Line 2456:                 // N2. Any remaining neutrals take the embedding direction",
                "// Line 2457:                 $chardata[$i]['type'] = $chardata[$i]['sor'];",
                "// vulnerable line: 2458: }",
                "// Line 2459:             if ($chardata[$i]['level'] != $prevlevel) {",
                "// Line 2460:                 $levcount = 0;",
                "// Line 2461:             } else {",
                "// Line 2462:                 ++$levcount;",
                "// vulnerable line: 2463: }",
                "// Line 2464:             $prevlevel = $chardata[$i]['level'];",
                "// vulnerable line: 2465: }",
                "// Line 2466: ",
                "// Line 2467:         // I1. For all characters with an even (left-to-right) embedding direction, those of type R go up one level and those of type AN or EN go up two levels.",
                "// Line 2468:         // I2. For all characters with an odd (right-to-left) embedding direction, those of type L, EN or AN go up one level.",
                "// Line 2469:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2470:             $odd = $chardata[$i]['level'] % 2;",
                "// Line 2471:             if ($odd) {",
                "// Line 2472:                 if (($chardata[$i]['type'] == 'L') OR ($chardata[$i]['type'] == 'AN') OR ($chardata[$i]['type'] == 'EN')) {",
                "// Line 2473:                     $chardata[$i]['level'] += 1;",
                "// vulnerable line: 2474: }",
                "// Line 2475:             } else {",
                "// Line 2476:                 if ($chardata[$i]['type'] == 'R') {",
                "// Line 2477:                     $chardata[$i]['level'] += 1;",
                "// Line 2478:                 } elseif (($chardata[$i]['type'] == 'AN') OR ($chardata[$i]['type'] == 'EN')) {",
                "// Line 2479:                     $chardata[$i]['level'] += 2;",
                "// vulnerable line: 2480: }",
                "// vulnerable line: 2481: }",
                "// Line 2482:             $maxlevel = max($chardata[$i]['level'],$maxlevel);",
                "// vulnerable line: 2483: }",
                "// Line 2484: ",
                "// Line 2485:         // L1. On each line, reset the embedding level of the following characters to the paragraph embedding level:",
                "// Line 2486:         //    1. Segment separators,",
                "// Line 2487:         //    2. Paragraph separators,",
                "// Line 2488:         //    3. Any sequence of whitespace characters preceding a segment separator or paragraph separator, and",
                "// Line 2489:         //    4. Any sequence of white space characters at the end of the line.",
                "// Line 2490:         for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2491:             if (($chardata[$i]['type'] == 'B') OR ($chardata[$i]['type'] == 'S')) {",
                "// Line 2492:                 $chardata[$i]['level'] = $pel;",
                "// Line 2493:             } elseif ($chardata[$i]['type'] == 'WS') {",
                "// Line 2494:                 $j = $i+1;",
                "// Line 2495:                 while ($j < $numchars) {",
                "// Line 2496:                     if ((($chardata[$j]['type'] == 'B') OR ($chardata[$j]['type'] == 'S')) OR",
                "// Line 2497:                         (($j == ($numchars-1)) AND ($chardata[$j]['type'] == 'WS'))) {",
                "// Line 2498:                         $chardata[$i]['level'] = $pel;",
                "// Line 2499:                         break;",
                "// Line 2500:                     } elseif ($chardata[$j]['type'] != 'WS') {",
                "// Line 2501:                         break;",
                "// vulnerable line: 2502: }",
                "// Line 2503:                     ++$j;",
                "// vulnerable line: 2504: }",
                "// vulnerable line: 2505: }",
                "// vulnerable line: 2506: }",
                "// Line 2507: ",
                "// Line 2508:         // Arabic Shaping",
                "// Line 2509:         // Cursively connected scripts, such as Arabic or Syriac, require the selection of positional character shapes that depend on adjacent characters. Shaping is logically applied after the Bidirectional Algorithm is used and is limited to characters within the same directional run.",
                "// Line 2510:         if ($arabic) {",
                "// Line 2511:             $endedletter = array(1569,1570,1571,1572,1573,1575,1577,1583,1584,1585,1586,1608,1688);",
                "// Line 2512:             $alfletter = array(1570,1571,1573,1575);",
                "// Line 2513:             $chardata2 = $chardata;",
                "// Line 2514:             $laaletter = false;",
                "// Line 2515:             $charAL = array();",
                "// Line 2516:             $x = 0;",
                "// Line 2517:             for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2518:                 if ((TCPDF_FONT_DATA::$uni_type[$chardata[$i]['char']] == 'AL') OR ($chardata[$i]['char'] == 32) OR ($chardata[$i]['char'] == 8204)) {",
                "// Line 2519:                     $charAL[$x] = $chardata[$i];",
                "// Line 2520:                     $charAL[$x]['i'] = $i;",
                "// Line 2521:                     $chardata[$i]['x'] = $x;",
                "// Line 2522:                     ++$x;",
                "// vulnerable line: 2523: }",
                "// vulnerable line: 2524: }",
                "// Line 2525:             $numAL = $x;",
                "// Line 2526:             for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2527:                 $thischar = $chardata[$i];",
                "// Line 2528:                 if ($i > 0) {",
                "// Line 2529:                     $prevchar = $chardata[($i-1)];",
                "// Line 2530:                 } else {",
                "// Line 2531:                     $prevchar = false;",
                "// vulnerable line: 2532: }",
                "// Line 2533:                 if (($i+1) < $numchars) {",
                "// Line 2534:                     $nextchar = $chardata[($i+1)];",
                "// Line 2535:                 } else {",
                "// Line 2536:                     $nextchar = false;",
                "// vulnerable line: 2537: }",
                "// Line 2538:                 if (TCPDF_FONT_DATA::$uni_type[$thischar['char']] == 'AL') {",
                "// Line 2539:                     $x = $thischar['x'];",
                "// Line 2540:                     if ($x > 0) {",
                "// Line 2541:                         $prevchar = $charAL[($x-1)];",
                "// Line 2542:                     } else {",
                "// Line 2543:                         $prevchar = false;",
                "// vulnerable line: 2544: }",
                "// Line 2545:                     if (($x+1) < $numAL) {",
                "// Line 2546:                         $nextchar = $charAL[($x+1)];",
                "// Line 2547:                     } else {",
                "// Line 2548:                         $nextchar = false;",
                "// vulnerable line: 2549: }",
                "// Line 2550:                     // if laa letter",
                "// Line 2551:                     if (($prevchar !== false) AND ($prevchar['char'] == 1604) AND (in_array($thischar['char'], $alfletter))) {",
                "// Line 2552:                         $arabicarr = TCPDF_FONT_DATA::$uni_laa_array;",
                "// Line 2553:                         $laaletter = true;",
                "// Line 2554:                         if ($x > 1) {",
                "// Line 2555:                             $prevchar = $charAL[($x-2)];",
                "// Line 2556:                         } else {",
                "// Line 2557:                             $prevchar = false;",
                "// vulnerable line: 2558: }",
                "// Line 2559:                     } else {",
                "// Line 2560:                         $arabicarr = TCPDF_FONT_DATA::$uni_arabicsubst;",
                "// Line 2561:                         $laaletter = false;",
                "// vulnerable line: 2562: }",
                "// Line 2563:                     if (($prevchar !== false) AND ($nextchar !== false) AND",
                "// Line 2564:                         ((TCPDF_FONT_DATA::$uni_type[$prevchar['char']] == 'AL') OR (TCPDF_FONT_DATA::$uni_type[$prevchar['char']] == 'NSM')) AND",
                "// Line 2565:                         ((TCPDF_FONT_DATA::$uni_type[$nextchar['char']] == 'AL') OR (TCPDF_FONT_DATA::$uni_type[$nextchar['char']] == 'NSM')) AND",
                "// Line 2566:                         ($prevchar['type'] == $thischar['type']) AND",
                "// Line 2567:                         ($nextchar['type'] == $thischar['type']) AND",
                "// Line 2568:                         ($nextchar['char'] != 1567)) {",
                "// Line 2569:                         if (in_array($prevchar['char'], $endedletter)) {",
                "// Line 2570:                             if (isset($arabicarr[$thischar['char']][2])) {",
                "// Line 2571:                                 // initial",
                "// Line 2572:                                 $chardata2[$i]['char'] = $arabicarr[$thischar['char']][2];",
                "// vulnerable line: 2573: }",
                "// Line 2574:                         } else {",
                "// Line 2575:                             if (isset($arabicarr[$thischar['char']][3])) {",
                "// Line 2576:                                 // medial",
                "// Line 2577:                                 $chardata2[$i]['char'] = $arabicarr[$thischar['char']][3];",
                "// vulnerable line: 2578: }",
                "// vulnerable line: 2579: }",
                "// Line 2580:                     } elseif (($nextchar !== false) AND",
                "// Line 2581:                         ((TCPDF_FONT_DATA::$uni_type[$nextchar['char']] == 'AL') OR (TCPDF_FONT_DATA::$uni_type[$nextchar['char']] == 'NSM')) AND",
                "// Line 2582:                         ($nextchar['type'] == $thischar['type']) AND",
                "// Line 2583:                         ($nextchar['char'] != 1567)) {",
                "// Line 2584:                         if (isset($arabicarr[$chardata[$i]['char']][2])) {",
                "// Line 2585:                             // initial",
                "// Line 2586:                             $chardata2[$i]['char'] = $arabicarr[$thischar['char']][2];",
                "// vulnerable line: 2587: }",
                "// Line 2588:                     } elseif ((($prevchar !== false) AND",
                "// Line 2589:                         ((TCPDF_FONT_DATA::$uni_type[$prevchar['char']] == 'AL') OR (TCPDF_FONT_DATA::$uni_type[$prevchar['char']] == 'NSM')) AND",
                "// Line 2590:                         ($prevchar['type'] == $thischar['type'])) OR",
                "// Line 2591:                         (($nextchar !== false) AND ($nextchar['char'] == 1567))) {",
                "// Line 2592:                         // final",
                "// Line 2593:                         if (($i > 1) AND ($thischar['char'] == 1607) AND",
                "// Line 2594:                             ($chardata[$i-1]['char'] == 1604) AND",
                "// Line 2595:                             ($chardata[$i-2]['char'] == 1604)) {",
                "// Line 2596:                             //Allah Word",
                "// Line 2597:                             // mark characters to delete with false",
                "// Line 2598:                             $chardata2[$i-2]['char'] = false;",
                "// Line 2599:                             $chardata2[$i-1]['char'] = false;",
                "// Line 2600:                             $chardata2[$i]['char'] = 65010;",
                "// Line 2601:                         } else {",
                "// Line 2602:                             if (($prevchar !== false) AND in_array($prevchar['char'], $endedletter)) {",
                "// Line 2603:                                 if (isset($arabicarr[$thischar['char']][0])) {",
                "// Line 2604:                                     // isolated",
                "// Line 2605:                                     $chardata2[$i]['char'] = $arabicarr[$thischar['char']][0];",
                "// vulnerable line: 2606: }",
                "// Line 2607:                             } else {",
                "// Line 2608:                                 if (isset($arabicarr[$thischar['char']][1])) {",
                "// Line 2609:                                     // final",
                "// Line 2610:                                     $chardata2[$i]['char'] = $arabicarr[$thischar['char']][1];",
                "// vulnerable line: 2611: }",
                "// vulnerable line: 2612: }",
                "// vulnerable line: 2613: }",
                "// Line 2614:                     } elseif (isset($arabicarr[$thischar['char']][0])) {",
                "// Line 2615:                         // isolated",
                "// Line 2616:                         $chardata2[$i]['char'] = $arabicarr[$thischar['char']][0];",
                "// vulnerable line: 2617: }",
                "// Line 2618:                     // if laa letter",
                "// Line 2619:                     if ($laaletter) {",
                "// Line 2620:                         // mark characters to delete with false",
                "// Line 2621:                         $chardata2[($charAL[($x-1)]['i'])]['char'] = false;",
                "// vulnerable line: 2622: }",
                "// Line 2623:                 } // end if AL (Arabic Letter)",
                "// Line 2624:             } // end for each char",
                "// Line 2625:             /*",
                "// Line 2626:              * Combining characters that can occur with Arabic Shadda (0651 HEX, 1617 DEC) are replaced.",
                "// Line 2627:              * Putting the combining mark and shadda in the same glyph allows us to avoid the two marks overlapping each other in an illegible manner.",
                "// Line 2628:              */",
                "// Line 2629:             for ($i = 0; $i < ($numchars-1); ++$i) {",
                "// Line 2630:                 if (($chardata2[$i]['char'] == 1617) AND (isset(TCPDF_FONT_DATA::$uni_diacritics[($chardata2[$i+1]['char'])]))) {",
                "// Line 2631:                     // check if the subtitution font is defined on current font",
                "// Line 2632:                     if (isset($currentfont['cw'][(TCPDF_FONT_DATA::$uni_diacritics[($chardata2[$i+1]['char'])])])) {",
                "// Line 2633:                         $chardata2[$i]['char'] = false;",
                "// Line 2634:                         $chardata2[$i+1]['char'] = TCPDF_FONT_DATA::$uni_diacritics[($chardata2[$i+1]['char'])];",
                "// vulnerable line: 2635: }",
                "// vulnerable line: 2636: }",
                "// vulnerable line: 2637: }",
                "// Line 2638:             // remove marked characters",
                "// Line 2639:             foreach ($chardata2 as $key => $value) {",
                "// Line 2640:                 if ($value['char'] === false) {",
                "// Line 2641:                     unset($chardata2[$key]);",
                "// vulnerable line: 2642: }",
                "// vulnerable line: 2643: }",
                "// Line 2644:             $chardata = array_values($chardata2);",
                "// Line 2645:             $numchars = count($chardata);",
                "// Line 2646:             unset($chardata2);",
                "// Line 2647:             unset($arabicarr);",
                "// Line 2648:             unset($laaletter);",
                "// Line 2649:             unset($charAL);",
                "// vulnerable line: 2650: }",
                "// Line 2651: ",
                "// Line 2652:         // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.",
                "// Line 2653:         for ($j=$maxlevel; $j > 0; $j--) {",
                "// Line 2654:             $ordarray = Array();",
                "// Line 2655:             $revarr = Array();",
                "// Line 2656:             $onlevel = false;",
                "// Line 2657:             for ($i=0; $i < $numchars; ++$i) {",
                "// Line 2658:                 if ($chardata[$i]['level'] >= $j) {",
                "// Line 2659:                     $onlevel = true;",
                "// Line 2660:                     if (isset(TCPDF_FONT_DATA::$uni_mirror[$chardata[$i]['char']])) {",
                "// Line 2661:                         // L4. A character is depicted by a mirrored glyph if and only if (a) the resolved directionality of that character is R, and (b) the Bidi_Mirrored property value of that character is true.",
                "// Line 2662:                         $chardata[$i]['char'] = TCPDF_FONT_DATA::$uni_mirror[$chardata[$i]['char']];",
                "// vulnerable line: 2663: }",
                "// Line 2664:                     $revarr[] = $chardata[$i];",
                "// Line 2665:                 } else {",
                "// Line 2666:                     if ($onlevel) {",
                "// Line 2667:                         $revarr = array_reverse($revarr);",
                "// Line 2668:                         $ordarray = array_merge($ordarray, $revarr);",
                "// Line 2669:                         $revarr = Array();",
                "// Line 2670:                         $onlevel = false;",
                "// vulnerable line: 2671: }",
                "// Line 2672:                     $ordarray[] = $chardata[$i];",
                "// vulnerable line: 2673: }",
                "// vulnerable line: 2674: }",
                "// Line 2675:             if ($onlevel) {",
                "// Line 2676:                 $revarr = array_reverse($revarr);",
                "// Line 2677:                 $ordarray = array_merge($ordarray, $revarr);",
                "// vulnerable line: 2678: }",
                "// Line 2679:             $chardata = $ordarray;",
                "// vulnerable line: 2680: }",
                "// Line 2681:         $ordarray = array();",
                "// Line 2682:         foreach ($chardata as $cd) {",
                "// Line 2683:             $ordarray[] = $cd['char'];",
                "// Line 2684:             // store char values for subsetting",
                "// Line 2685:             $currentfont['subsetchars'][$cd['char']] = true;",
                "// vulnerable line: 2686: }",
                "// Line 2687:         return $ordarray;",
                "// vulnerable line: 2688: }",
                "// Line 2689: ",
                "// Line 2690: } // END OF TCPDF_FONTS CLASS",
                "// Line 2691: ",
                "// Line 2692: //============================================================+",
                "// Line 2693: // END OF FILE",
                "// Line 2694: //============================================================+"
            ]
        },
        {
            "filename_of_changes": "tcpdf_static.php",
            "code_language": "PHP",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: <?php",
                "// Line 2: //============================================================+",
                "// Line 3: // File name   : tcpdf_static.php",
                "// Line 4: // Version     : 1.1.4",
                "// Line 5: // Begin       : 2002-08-03",
                "// vulnerable line: 6: // Last Update : 2022-08-12",
                "// Line 7: // Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com",
                "// Line 8: // License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)",
                "// Line 9: // -------------------------------------------------------------------",
                "// vulnerable line: 10: // Copyright (C) 2002-2022 Nicola Asuni - Tecnick.com LTD",
                "// Line 11: //",
                "// Line 12: // This file is part of TCPDF software library.",
                "// Line 13: //",
                "// Line 14: // TCPDF is free software: you can redistribute it and/or modify it",
                "// Line 15: // under the terms of the GNU Lesser General Public License as",
                "// Line 16: // published by the Free Software Foundation, either version 3 of the",
                "// Line 17: // License, or (at your option) any later version.",
                "// Line 18: //",
                "// Line 19: // TCPDF is distributed in the hope that it will be useful, but",
                "// Line 20: // WITHOUT ANY WARRANTY; without even the implied warranty of",
                "// Line 48:  * @brief PHP class for generating PDF documents without requiring external extensions.",
                "// Line 49:  * @version 1.1.1",
                "// Line 50:  * @author Nicola Asuni - info@tecnick.com",
                "// Line 51:  */",
                "// Line 52: class TCPDF_STATIC {",
                "// Line 53: ",
                "// Line 54:     /**",
                "// Line 55:      * Current TCPDF version.",
                "// Line 56:      * @private static",
                "// Line 57:      */",
                "// vulnerable line: 58: private static $tcpdf_version = '6.6.2';",
                "// Line 59: ",
                "// Line 60:     /**",
                "// Line 61:      * String alias for total number of pages.",
                "// Line 62:      * @public static",
                "// Line 63:      */",
                "// Line 64:     public static $alias_tot_pages = '{:ptp:}';",
                "// Line 65: ",
                "// Line 66:     /**",
                "// Line 67:      * String alias for page number.",
                "// Line 68:      * @public static",
                "// Line 1778:         // PHP 8.1 deprecates nulls for $limit and $flags",
                "// Line 1779:         $limit = $limit === null ? -1 : $limit;",
                "// Line 1780:         $flags = $flags === null ? 0 : $flags;",
                "// Line 1781:         // the bug only happens on PHP 5.2 when using the u modifier",
                "// Line 1782:         if ((strpos($modifiers, 'u') === FALSE) OR (count(preg_split('//u', \"",
                "// Line 1783:     \", -1, PREG_SPLIT_NO_EMPTY)) == 2)) {",
                "// Line 1784:             $ret = preg_split($pattern.$modifiers, $subject, $limit, $flags);",
                "// Line 1785:             if ($ret === false) {",
                "// Line 1786:                 return array();",
                "// Line 1787:             }",
                "// vulnerable line: 1788: return $ret;",
                "// Line 1789:         }",
                "// Line 1790:         // preg_split is bugged - try alternative solution",
                "// Line 1791:         $ret = array();",
                "// Line 1792:         while (($nl = strpos($subject, \"",
                "// Line 1793: \")) !== FALSE) {",
                "// Line 1794:             $ret = array_merge($ret, preg_split($pattern.$modifiers, substr($subject, 0, $nl), $limit, $flags));",
                "// Line 1795:             $ret[] = \"",
                "// Line 1796: \";",
                "// Line 1797:             $subject = substr($subject, ($nl + 1));",
                "// Line 1798:         }",
                "// Line 1799:         if (strlen($subject) > 0) {",
                "// Line 1800:             $ret = array_merge($ret, preg_split($pattern.$modifiers, $subject, $limit, $flags));",
                "// Line 1801:         }",
                "// vulnerable line: 1802: return $ret;",
                "// Line 1803:     }",
                "// Line 1804: ",
                "// Line 1805:     /**",
                "// Line 1806:      * Wrapper to use fopen only with local files",
                "// Line 1807:      * @param string $filename Name of the file to open",
                "// Line 1808:      * @param string $mode",
                "// Line 1809:      * @return resource|false Returns a file pointer resource on success, or FALSE on error.",
                "// Line 1810:      * @public static",
                "// Line 1811:      */",
                "// Line 1812:     public static function fopenLocal($filename, $mode) {",
                "// Line 1845:             curl_setopt($crs, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS | CURLPROTO_HTTP |  CURLPROTO_FTP | CURLPROTO_FTPS);",
                "// Line 1846:         }",
                "// Line 1847:         curl_exec($crs);",
                "// Line 1848:         $code = curl_getinfo($crs, CURLINFO_HTTP_CODE);",
                "// Line 1849:         curl_close($crs);",
                "// Line 1850:         return ($code == 200);",
                "// Line 1851:     }",
                "// Line 1852: ",
                "// Line 1853:     /**",
                "// Line 1854:      * Encode query params in URL",
                "// vulnerable line: 1855: *",
                "// Line 1856:      * @param string $url",
                "// Line 1857:      * @return string",
                "// Line 1858:      * @since 6.3.3 (2019-11-01)",
                "// Line 1859:      * @public static",
                "// Line 1860:      */",
                "// Line 1861:     public static function encodeUrlQuery($url) {",
                "// Line 1862:         $urlData = parse_url($url);",
                "// Line 1863:         if (isset($urlData['query']) && $urlData['query']) {",
                "// Line 1864:             $urlQueryData = array();",
                "// Line 1865:             parse_str(urldecode($urlData['query']), $urlQueryData);",
                "// Line 1948:             $alt[] = $urldata['scheme'].'://'.$urldata['host'].(($file[0] == '/') ? '' : '/').$file;",
                "// Line 1949:         }",
                "// Line 1950:         //",
                "// Line 1951:         $alt = array_unique($alt);",
                "// Line 1952:         foreach ($alt as $path) {",
                "// Line 1953:             if (!self::file_exists($path)) {",
                "// Line 1954:                 continue;",
                "// Line 1955:             }",
                "// Line 1956:             $ret = @file_get_contents($path);",
                "// Line 1957:             if ( $ret != false ) {",
                "// vulnerable line: 1958: return $ret;",
                "// Line 1959:             }",
                "// Line 1960:             // try to use CURL for URLs",
                "// Line 1961:             if (!ini_get('allow_url_fopen')",
                "// Line 1962:                 && function_exists('curl_init')",
                "// Line 1963:                 && preg_match('%^(https?|ftp)://%', $path)",
                "// Line 1964:             ) {",
                "// Line 1965:                 // try to get remote file data using cURL",
                "// Line 1966:                 $crs = curl_init();",
                "// Line 1967:                 curl_setopt($crs, CURLOPT_URL, $path);",
                "// Line 1968:                 curl_setopt($crs, CURLOPT_BINARYTRANSFER, true);",
                "// Line 1976:                 curl_setopt($crs, CURLOPT_SSL_VERIFYPEER, false);",
                "// Line 1977:                 curl_setopt($crs, CURLOPT_SSL_VERIFYHOST, false);",
                "// Line 1978:                 curl_setopt($crs, CURLOPT_USERAGENT, 'tc-lib-file');",
                "// Line 1979:                 curl_setopt($crs, CURLOPT_MAXREDIRS, 5);",
                "// Line 1980:                 if (defined('CURLOPT_PROTOCOLS')) {",
                "// Line 1981:                     curl_setopt($crs, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS | CURLPROTO_HTTP |  CURLPROTO_FTP | CURLPROTO_FTPS);",
                "// Line 1982:                 }",
                "// Line 1983:                 $ret = curl_exec($crs);",
                "// Line 1984:                 curl_close($crs);",
                "// Line 1985:                 if ($ret !== false) {",
                "// vulnerable line: 1986: return $ret;",
                "// Line 1987:                 }",
                "// Line 1988:             }",
                "// Line 1989:         }",
                "// Line 1990:         return false;",
                "// Line 1991:     }",
                "// Line 1992: ",
                "// Line 1993:     /**",
                "// Line 1994:      * Get ULONG from string (Big Endian 32-bit unsigned integer).",
                "// Line 1995:      * @param string $str string from where to extract value",
                "// Line 1996:      * @param int $offset point from where to read the data",
                "// Line 2124:      */",
                "// Line 2125:     public static function _freadint($f) {",
                "// Line 2126:         $a = unpack('Ni', fread($f, 4));",
                "// Line 2127:         return $a['i'];",
                "// Line 2128:     }",
                "// Line 2129: ",
                "// Line 2130:     /**",
                "// Line 2131:      * Array of page formats",
                "// Line 2132:      * measures are calculated in this way: (inches * 72) or (millimeters * 72 / 25.4)",
                "// Line 2133:      * @public static",
                "// vulnerable line: 2134: * ",
                "// Line 2135:      * @var array<string,float[]>",
                "// Line 2136:      */",
                "// Line 2137:     public static $page_formats = array(",
                "// Line 2138:         // ISO 216 A Series + 2 SIS 014711 extensions",
                "// Line 2139:         'A0'                     => array( 2383.937,  3370.394), // = (  841 x 1189 ) mm  = ( 33.11 x 46.81 ) in",
                "// Line 2140:         'A1'                     => array( 1683.780,  2383.937), // = (  594 x 841  ) mm  = ( 23.39 x 33.11 ) in",
                "// Line 2141:         'A2'                     => array( 1190.551,  1683.780), // = (  420 x 594  ) mm  = ( 16.54 x 23.39 ) in",
                "// Line 2142:         'A3'                     => array(  841.890,  1190.551), // = (  297 x 420  ) mm  = ( 11.69 x 16.54 ) in",
                "// Line 2143:         'A4'                     => array(  595.276,   841.890), // = (  210 x 297  ) mm  = (  8.27 x 11.69 ) in",
                "// Line 2144:         'A5'                     => array(  419.528,   595.276), // = (  148 x 210  ) mm  = (  5.83 x 8.27  ) in"
            ]
        }
    ]
}