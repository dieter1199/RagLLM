{
    "cve_id": "CVE-2024-31452",
    "cve_description": "OpenFGA is a high-performance and flexible authorization/permission engine. Some end users of OpenFGA v1.5.0 or later are vulnerable to authorization bypass when calling Check or ListObjects APIs. You are very likely affected if your model involves exclusion (e.g. `a but not b`) or intersection (e.g. `a and b`). This vulnerability is fixed in v1.5.3.",
    "cve_publish_date": "2024-04-16T22:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-8cph-m685-6v6r\n\n* fix: error handling leading to false positives\n\n* test: add a failing test due to Check and ListObjects differences\n\n* test: change test expectation for ListObjects assertion\n\n* fix: union CheckFuncReducer and associated tests\n\n* fix: intersection CheckFuncReducer\n\n* fix: exclusion CheckFuncReducer\n\n* fix: rewire the cycle detection mechanics to avoid error propagation\n\n* test: add more edge case tests for cyclical evaluations\n\n* test: rename new test that was poorly named\n\n* chore: revert minor change that was unintended\n\n* chore: tidy up changes and drop commented out code\n\n* chore: minor touchups based on some feedback\n\n* test: add test for CloneResolveCheckResponse\n\n* test: add more tests for error around intersection\n\n* test: more test assertions around cloned cached response\n\n* test: add unit test to make sure we cache CycleDetected\n\n* test: add more assertions around CycleDetected field\n\n* chore: rename test names\n\n* chore: fix datastore query count under reporting in intersection reducer",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "cached_resolver.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "12",
            "number_of_lines_deleted_vulnerable_to_cve": "27",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 32:         Help:      \"The total number of calls to ResolveCheck.\",",
                "// Line 33:     })",
                "// Line 34: ",
                "// Line 35:     checkCacheHitCounter = promauto.NewCounter(prometheus.CounterOpts{",
                "// Line 36:         Namespace: build.ProjectName,",
                "// Line 37:         Name:      \"check_cache_hit_count\",",
                "// Line 38:         Help:      \"The total number of cache hits for ResolveCheck.\",",
                "// Line 39:     })",
                "// Line 40: )",
                "// Line 41: ",
                "// vulnerable line: 42: // CachedResolveCheckResponse is very similar to ResolveCheckResponse except we",
                "// vulnerable line: 43: // do not store the ResolutionData. This is due to the fact that the resolution metadata",
                "// vulnerable line: 44: // will be incorrect as data is served from cache instead of actual database read.",
                "// vulnerable line: 45: type CachedResolveCheckResponse struct {",
                "// vulnerable line: 46: Allowed bool",
                "// vulnerable line: 47: }",
                "// Line 48: ",
                "// vulnerable line: 49: func (c *CachedResolveCheckResponse) convertToResolveCheckResponse() *ResolveCheckResponse {",
                "// vulnerable line: 50: return &ResolveCheckResponse{",
                "// vulnerable line: 51: Allowed: c.Allowed,",
                "// vulnerable line: 52: ResolutionMetadata: &ResolveCheckResponseMetadata{",
                "// vulnerable line: 53: DatastoreQueryCount: 0,",
                "// vulnerable line: 54: },",
                "// vulnerable line: 55: }",
                "// vulnerable line: 56: }",
                "// Line 57: ",
                "// vulnerable line: 58: func newCachedResolveCheckResponse(r *ResolveCheckResponse) *CachedResolveCheckResponse {",
                "// vulnerable line: 59: return &CachedResolveCheckResponse{",
                "// vulnerable line: 60: Allowed: r.Allowed,",
                "// vulnerable line: 61: }",
                "// vulnerable line: 62: }",
                "// Line 63: ",
                "// Line 64: // CachedCheckResolver attempts to resolve check sub-problems via prior computations before",
                "// Line 65: // delegating the request to some underlying CheckResolver.",
                "// Line 66: type CachedCheckResolver struct {",
                "// Line 67:     delegate     CheckResolver",
                "// vulnerable line: 68: cache        *ccache.Cache[*CachedResolveCheckResponse]",
                "// Line 69:     maxCacheSize int64",
                "// Line 70:     cacheTTL     time.Duration",
                "// Line 71:     logger       logger.Logger",
                "// Line 72:     // allocatedCache is used to denote whether the cache is allocated by this struct.",
                "// Line 73:     // If so, CachedCheckResolver is responsible for cleaning up.",
                "// Line 74:     allocatedCache bool",
                "// vulnerable line: 75: }",
                "// Line 76: ",
                "// Line 77: var _ CheckResolver = (*CachedCheckResolver)(nil)",
                "// Line 78: ",
                "// Line 79: // CachedCheckResolverOpt defines an option that can be used to change the behavior of cachedCheckResolver",
                "// Line 80: // instance.",
                "// Line 81: type CachedCheckResolverOpt func(*CachedCheckResolver)",
                "// Line 82: ",
                "// Line 83: // WithMaxCacheSize sets the maximum size of the Check resolution cache. After this",
                "// Line 84: // maximum size is met, then cache keys will start being evicted with an LRU policy.",
                "// Line 85: func WithMaxCacheSize(size int64) CachedCheckResolverOpt {",
                "// Line 86:     return func(ccr *CachedCheckResolver) {",
                "// Line 87:         ccr.maxCacheSize = size",
                "// vulnerable line: 88: }",
                "// vulnerable line: 89: }",
                "// Line 90: ",
                "// Line 91: // WithCacheTTL sets the TTL (as a duration) for any single Check cache key value.",
                "// Line 92: func WithCacheTTL(ttl time.Duration) CachedCheckResolverOpt {",
                "// Line 93:     return func(ccr *CachedCheckResolver) {",
                "// Line 94:         ccr.cacheTTL = ttl",
                "// vulnerable line: 95: }",
                "// vulnerable line: 96: }",
                "// Line 97: ",
                "// Line 98: // WithExistingCache sets the cache to the specified cache.",
                "// Line 99: // Note that the original cache will not be stopped as it may still be used by others. It is up to the caller",
                "// Line 100: // to check whether the original cache should be stopped.",
                "// vulnerable line: 101: func WithExistingCache(cache *ccache.Cache[*CachedResolveCheckResponse]) CachedCheckResolverOpt {",
                "// Line 102:     return func(ccr *CachedCheckResolver) {",
                "// Line 103:         ccr.cache = cache",
                "// vulnerable line: 104: }",
                "// vulnerable line: 105: }",
                "// Line 106: ",
                "// Line 107: // WithLogger sets the logger for the cached check resolver",
                "// Line 108: func WithLogger(logger logger.Logger) CachedCheckResolverOpt {",
                "// Line 109:     return func(ccr *CachedCheckResolver) {",
                "// Line 110:         ccr.logger = logger",
                "// vulnerable line: 111: }",
                "// vulnerable line: 112: }",
                "// Line 113: ",
                "// Line 114: // NewCachedCheckResolver constructs a CheckResolver that delegates Check resolution to the provided delegate,",
                "// Line 115: // but before delegating the query to the delegate a cache-key lookup is made to see if the Check sub-problem",
                "// Line 116: // has already recently been computed. If the Check sub-problem is in the cache, then the response is returned",
                "// Line 117: // immediately and no re-computation is necessary.",
                "// Line 118: // NOTE: the ResolveCheck's resolution data will be set as the default values as we actually did no database lookup",
                "// Line 119: func NewCachedCheckResolver(opts ...CachedCheckResolverOpt) *CachedCheckResolver {",
                "// Line 120:     checker := &CachedCheckResolver{",
                "// Line 121:         maxCacheSize: defaultMaxCacheSize,",
                "// Line 122:         cacheTTL:     defaultCacheTTL,",
                "// Line 123:         logger:       logger.NewNoopLogger(),",
                "// vulnerable line: 124: }",
                "// Line 125:     checker.delegate = checker",
                "// Line 126: ",
                "// Line 127:     for _, opt := range opts {",
                "// Line 128:         opt(checker)",
                "// vulnerable line: 129: }",
                "// Line 130: ",
                "// Line 131:     if checker.cache == nil {",
                "// Line 132:         checker.allocatedCache = true",
                "// Line 133:         checker.cache = ccache.New(",
                "// vulnerable line: 134: ccache.Configure[*CachedResolveCheckResponse]().MaxSize(checker.maxCacheSize),",
                "// Line 135:         )",
                "// vulnerable line: 136: }",
                "// Line 137: ",
                "// Line 138:     return checker",
                "// vulnerable line: 139: }",
                "// Line 140: ",
                "// Line 141: // SetDelegate sets this CachedCheckResolver's dispatch delegate.",
                "// Line 142: func (c *CachedCheckResolver) SetDelegate(delegate CheckResolver) {",
                "// Line 143:     c.delegate = delegate",
                "// vulnerable line: 144: }",
                "// Line 145: ",
                "// Line 146: // GetDelegate returns this CachedCheckResolver's dispatch delegate.",
                "// Line 147: func (c *CachedCheckResolver) GetDelegate() CheckResolver {",
                "// Line 148:     return c.delegate",
                "// vulnerable line: 149: }",
                "// Line 150: ",
                "// Line 151: // Close will deallocate resource allocated by the CachedCheckResolver",
                "// Line 152: // It will not deallocate cache if it has been passed in from WithExistingCache",
                "// Line 153: func (c *CachedCheckResolver) Close() {",
                "// Line 154:     if c.allocatedCache {",
                "// Line 155:         c.cache.Stop()",
                "// Line 156:         c.cache = nil",
                "// vulnerable line: 157: }",
                "// vulnerable line: 158: }",
                "// Line 159: ",
                "// Line 160: func (c *CachedCheckResolver) ResolveCheck(",
                "// Line 161:     ctx context.Context,",
                "// Line 162:     req *ResolveCheckRequest,",
                "// Line 163: ) (*ResolveCheckResponse, error) {",
                "// Line 164:     ctx, span := tracer.Start(ctx, \"ResolveCheck\")",
                "// Line 165:     defer span.End()",
                "// Line 166:     span.SetAttributes(attribute.String(\"resolver_type\", \"CachedCheckResolver\"))",
                "// Line 167:     span.SetAttributes(attribute.String(\"tuple_key\", req.GetTupleKey().String()))",
                "// Line 168: ",
                "// Line 169:     checkCacheTotalCounter.Inc()",
                "// Line 170: ",
                "// Line 171:     cacheKey, err := CheckRequestCacheKey(req)",
                "// Line 172:     if err != nil {",
                "// Line 173:         c.logger.Error(\"cache key computation failed with error\", zap.Error(err))",
                "// Line 174:         telemetry.TraceError(span, err)",
                "// Line 175:         return nil, err",
                "// vulnerable line: 176: }",
                "// Line 177: ",
                "// Line 178:     cachedResp := c.cache.Get(cacheKey)",
                "// Line 179:     if cachedResp != nil && !cachedResp.Expired() {",
                "// Line 180:         checkCacheHitCounter.Inc()",
                "// Line 181:         span.SetAttributes(attribute.Bool(\"is_cached\", true))",
                "// vulnerable line: 182: return cachedResp.Value().convertToResolveCheckResponse(), nil",
                "// vulnerable line: 183: }",
                "// Line 184:     span.SetAttributes(attribute.Bool(\"is_cached\", false))",
                "// Line 185: ",
                "// Line 186:     resp, err := c.delegate.ResolveCheck(ctx, req)",
                "// Line 187:     if err != nil {",
                "// Line 188:         telemetry.TraceError(span, err)",
                "// Line 189:         return nil, err",
                "// vulnerable line: 190: }",
                "// Line 191: ",
                "// vulnerable line: 192: c.cache.Set(cacheKey, newCachedResolveCheckResponse(resp), c.cacheTTL)",
                "// Line 193:     return resp, nil",
                "// vulnerable line: 194: }",
                "// Line 195: ",
                "// Line 196: // CheckRequestCacheKey converts the ResolveCheckRequest into a canonical cache key that can be",
                "// Line 197: // used for Check resolution cache key lookups in a stable way.",
                "// Line 198: //",
                "// Line 199: // For one store and model ID, the same tuple provided with the same contextual tuples and context",
                "// Line 200: // should produce the same cache key. Contextual tuple order and context parameter order is ignored,",
                "// Line 201: // only the contents are compared.",
                "// Line 202: func CheckRequestCacheKey(req *ResolveCheckRequest) (string, error) {",
                "// Line 203:     hasher := keys.NewCacheKeyHasher(xxhash.New())",
                "// Line 204: ",
                "// Line 206:     key := fmt.Sprintf(\"%s/%s/%s#%s@%s\",",
                "// Line 207:         req.GetStoreID(),",
                "// Line 208:         req.GetAuthorizationModelID(),",
                "// Line 209:         tupleKey.GetObject(),",
                "// Line 210:         tupleKey.GetRelation(),",
                "// Line 211:         tupleKey.GetUser(),",
                "// Line 212:     )",
                "// Line 213: ",
                "// Line 214:     if err := hasher.WriteString(key); err != nil {",
                "// Line 215:         return \"\", err",
                "// vulnerable line: 216: }",
                "// Line 217: ",
                "// Line 218:     // here, and for context below, avoid hashing if we don't need to",
                "// Line 219:     contextualTuples := req.GetContextualTuples()",
                "// Line 220:     if len(contextualTuples) > 0 {",
                "// Line 221:         if err := keys.NewTupleKeysHasher(contextualTuples...).Append(hasher); err != nil {",
                "// Line 222:             return \"\", err",
                "// vulnerable line: 223: }",
                "// vulnerable line: 224: }",
                "// Line 225: ",
                "// Line 226:     if req.GetContext() != nil {",
                "// Line 227:         err := keys.NewContextHasher(req.GetContext()).Append(hasher)",
                "// Line 228:         if err != nil {",
                "// Line 229:             return \"\", err",
                "// vulnerable line: 230: }",
                "// vulnerable line: 231: }",
                "// Line 232: ",
                "// Line 233:     return strconv.FormatUint(hasher.Key().ToUInt64(), 10), nil",
                "// vulnerable line: 234: }"
            ]
        },
        {
            "filename_of_changes": "cycle_check_resolver.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 36: ",
                "// Line 37:     key := tuple.TupleKeyToString(req.GetTupleKey())",
                "// Line 38: ",
                "// Line 39:     if req.VisitedPaths == nil {",
                "// Line 40:         req.VisitedPaths = map[string]struct{}{}",
                "// Line 41:     }",
                "// Line 42: ",
                "// Line 43:     _, cycleDetected := req.VisitedPaths[key]",
                "// Line 44:     span.SetAttributes(attribute.Bool(\"cycle_detected\", cycleDetected))",
                "// Line 45:     if cycleDetected {",
                "// vulnerable line: 46: return nil, ErrCycleDetected",
                "// Line 47:     }",
                "// Line 48: ",
                "// Line 49:     req.VisitedPaths[key] = struct{}{}",
                "// Line 50: ",
                "// Line 51:     return c.delegate.ResolveCheck(ctx, &ResolveCheckRequest{",
                "// Line 52:         StoreID:              req.GetStoreID(),",
                "// Line 53:         AuthorizationModelID: req.GetAuthorizationModelID(),",
                "// Line 54:         TupleKey:             req.GetTupleKey(),",
                "// Line 55:         ContextualTuples:     req.GetContextualTuples(),",
                "// Line 56:         RequestMetadata:      req.GetRequestMetadata(),"
            ]
        },
        {
            "filename_of_changes": "cycle_check_resolver_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 35:         visitedPaths := make(map[string]struct{}, 0)",
                "// Line 36:         visitedPaths[tuple.TupleKeyToString(cyclicalTuple)] = struct{}{}",
                "// Line 37: ",
                "// Line 38:         resp, err := cycleDetectionCheckResolver.ResolveCheck(ctx, &ResolveCheckRequest{",
                "// Line 39:             StoreID:         uuid.NewString(),",
                "// Line 40:             TupleKey:        cyclicalTuple,",
                "// Line 41:             RequestMetadata: NewCheckRequestMetadata(defaultResolveNodeLimit),",
                "// Line 42:             VisitedPaths:    visitedPaths,",
                "// Line 43:         })",
                "// Line 44: ",
                "// vulnerable line: 45: require.ErrorIs(t, err, ErrCycleDetected)",
                "// Line 46:         require.False(t, resp.GetAllowed())",
                "// Line 47:     })",
                "// Line 48: ",
                "// Line 49:     t.Run(\"no_cycle_detected_delegates_request\", func(t *testing.T) {",
                "// Line 50:         ctrl := gomock.NewController(t)",
                "// Line 51:         t.Cleanup(ctrl.Finish)",
                "// Line 52: ",
                "// Line 53:         mockLocalChecker := NewMockCheckResolver(ctrl)",
                "// Line 54:         mockLocalChecker.EXPECT().ResolveCheck(gomock.Any(), gomock.Any()).Return(&ResolveCheckResponse{",
                "// Line 55:             Allowed: true,",
                "// Line 57:         cycleDetectionCheckResolver.SetDelegate(mockLocalChecker)",
                "// Line 58: ",
                "// Line 59:         resp, err := cycleDetectionCheckResolver.ResolveCheck(ctx, &ResolveCheckRequest{",
                "// Line 60:             StoreID:         uuid.NewString(),",
                "// Line 61:             TupleKey:        tuple.NewTupleKey(\"document:1\", \"viewer\", \"user:will\"),",
                "// Line 62:             RequestMetadata: NewCheckRequestMetadata(defaultResolveNodeLimit),",
                "// Line 63:             VisitedPaths:    map[string]struct{}{},",
                "// Line 64:         })",
                "// Line 65: ",
                "// Line 66:         require.NoError(t, err)",
                "// vulnerable line: 67: require.True(t, resp.GetAllowed())",
                "// Line 68:     })",
                "// Line 69: }",
                "// Line 70: ",
                "// Line 71: func TestIntegrationWithLocalChecker(t *testing.T) {",
                "// Line 72:     t.Cleanup(func() {",
                "// Line 73:         goleak.VerifyNone(t)",
                "// Line 74:     })",
                "// Line 75: ",
                "// Line 76:     cycleDetectionCheckResolver := NewCycleDetectionCheckResolver()",
                "// Line 77:     t.Cleanup(cycleDetectionCheckResolver.Close)",
                "// Line 112: ",
                "// Line 113:     ctx := storage.ContextWithRelationshipTupleReader(context.Background(), ds)",
                "// Line 114:     ctx = typesystem.ContextWithTypesystem(ctx, typesys)",
                "// Line 115:     resp, err := cycleDetectionCheckResolver.ResolveCheck(ctx, &ResolveCheckRequest{",
                "// Line 116:         StoreID:              storeID,",
                "// Line 117:         AuthorizationModelID: model.GetId(),",
                "// Line 118:         TupleKey:             tuple.NewTupleKey(\"group:1\", \"blocked\", \"user:jon\"),",
                "// Line 119:         RequestMetadata:      NewCheckRequestMetadata(25),",
                "// Line 120:     })",
                "// Line 121:     require.NoError(t, err)",
                "// vulnerable line: 122: require.True(t, resp.GetAllowed())",
                "// Line 123: }"
            ]
        },
        {
            "filename_of_changes": "graph.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        },
        {
            "filename_of_changes": "list_objects.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 326: ",
                "// Line 327:                     resp, err := q.checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{",
                "// Line 328:                         StoreID:              req.GetStoreId(),",
                "// Line 329:                         AuthorizationModelID: req.GetAuthorizationModelId(),",
                "// Line 330:                         TupleKey:             tuple.NewTupleKey(res.Object, req.GetRelation(), req.GetUser()),",
                "// Line 331:                         ContextualTuples:     req.GetContextualTuples().GetTupleKeys(),",
                "// Line 332:                         Context:              req.GetContext(),",
                "// Line 333:                         RequestMetadata:      checkRequestMetadata,",
                "// Line 334:                     })",
                "// Line 335:                     if err != nil {",
                "// vulnerable line: 336: if errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {",
                "// Line 337:                             resultsChan <- ListObjectsResult{Err: serverErrors.AuthorizationModelResolutionTooComplex}",
                "// Line 338:                             return",
                "// Line 339:                         }",
                "// Line 340: ",
                "// Line 341:                         resultsChan <- ListObjectsResult{Err: err}",
                "// Line 342:                         return",
                "// Line 343:                     }",
                "// Line 344:                     atomic.AddUint32(resolutionMetadata.DatastoreQueryCount, resp.GetResolutionMetadata().DatastoreQueryCount)",
                "// Line 345:                     atomic.AddUint32(resolutionMetadata.DispatchCount, checkRequestMetadata.DispatchCounter.Load())",
                "// Line 346: ",
                "// Line 347:                     if resp.Allowed {",
                "// Line 348:                         trySendObject(res.Object, &objectsFound, maxResults, resultsChan)",
                "// Line 349:                     }",
                "// Line 350:                 }(res)",
                "// Line 351: ",
                "// Line 352:             case err := <-errChan:",
                "// vulnerable line: 353: if errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {",
                "// Line 354:                     err = serverErrors.AuthorizationModelResolutionTooComplex",
                "// Line 355:                 }",
                "// Line 356: ",
                "// Line 357:                 resultsChan <- ListObjectsResult{Err: err}",
                "// Line 358:                 break ConsumerReadLoop",
                "// Line 359:             }",
                "// Line 360:         }",
                "// Line 361: ",
                "// Line 362:         cancel()",
                "// Line 363:         wg.Wait()"
            ]
        },
        {
            "filename_of_changes": "server.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 767:     resp, err := s.checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{",
                "// Line 768:         StoreID:              req.GetStoreId(),",
                "// Line 769:         AuthorizationModelID: typesys.GetAuthorizationModelID(), // the resolved model id",
                "// Line 770:         TupleKey:             tuple.ConvertCheckRequestTupleKeyToTupleKey(req.GetTupleKey()),",
                "// Line 771:         ContextualTuples:     req.GetContextualTuples().GetTupleKeys(),",
                "// Line 772:         Context:              req.GetContext(),",
                "// Line 773:         RequestMetadata:      checkRequestMetadata,",
                "// Line 774:     })",
                "// Line 775:     if err != nil {",
                "// Line 776:         telemetry.TraceError(span, err)",
                "// vulnerable line: 777: if errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {",
                "// Line 778:             return nil, serverErrors.AuthorizationModelResolutionTooComplex",
                "// Line 779:         }",
                "// Line 780: ",
                "// Line 781:         if errors.Is(err, condition.ErrEvaluationFailed) {",
                "// Line 782:             return nil, serverErrors.ValidationError(err)",
                "// Line 783:         }",
                "// Line 784: ",
                "// Line 785:         return nil, serverErrors.HandleError(\"\", err)",
                "// Line 786:     }",
                "// Line 787: "
            ]
        },
        {
            "filename_of_changes": "server_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "21",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 307:                 tuple.NewTupleKey(\"document:1\", \"viewer\", \"document:1#viewer\"),",
                "// Line 308:                 tuple.NewTupleKey(\"document:1\", \"editor\", \"document:1#viewer\"),",
                "// Line 309:                 tuple.NewTupleKey(\"document:1\", \"editor\", \"user:andres\"),",
                "// Line 310:             },",
                "// Line 311:         },",
                "// Line 312:     })",
                "// Line 313:     require.NoError(t, err)",
                "// Line 314: ",
                "// Line 315:     var wg sync.WaitGroup",
                "// Line 316: ",
                "// vulnerable line: 317: wg.Add(2)",
                "// Line 318: ",
                "// Line 319:     var resp1 *openfgav1.CheckResponse",
                "// Line 320:     var err1 error",
                "// Line 321:     go func() {",
                "// Line 322:         defer wg.Done()",
                "// Line 323: ",
                "// Line 324:         resp1, err1 = s.Check(context.Background(), &openfgav1.CheckRequest{",
                "// Line 325:             StoreId:              storeID,",
                "// Line 326:             AuthorizationModelId: modelID,",
                "// Line 327:             TupleKey:             tuple.NewCheckRequestTupleKey(\"document:1\", \"editor\", \"user:jon\"),",
                "// Line 339:             TupleKey:             tuple.NewCheckRequestTupleKey(\"document:1\", \"viewer\", \"user:jon\"),",
                "// Line 340:         })",
                "// Line 341:     }()",
                "// Line 342: ",
                "// Line 343:     wg.Wait()",
                "// Line 344: ",
                "// Line 345:     require.NoError(t, err1)",
                "// Line 346:     require.False(t, resp1.GetAllowed())",
                "// Line 347: ",
                "// Line 348:     require.NoError(t, err2)",
                "// vulnerable line: 349: require.False(t, resp2.GetAllowed())",
                "// Line 350: }",
                "// Line 351: ",
                "// Line 352: func TestAvoidDeadlockWithinSingleCheckRequest(t *testing.T) {",
                "// Line 353:     t.Cleanup(func() {",
                "// Line 354:         goleak.VerifyNone(t)",
                "// Line 355:     })",
                "// Line 356: ",
                "// Line 357:     _, ds, _ := util.MustBootstrapDatastore(t, \"memory\")",
                "// Line 358: ",
                "// Line 359:     s := MustNewServerWithOpts("
            ]
        }
    ]
}