{
    "cve_id": "CVE-2024-27305",
    "cve_description": "aiosmtpd is a reimplementation of the Python stdlib smtpd.py based on asyncio. aiosmtpd is vulnerable to inbound SMTP smuggling. SMTP smuggling is a novel vulnerability based on not so novel interpretation differences of the SMTP protocol. By exploiting SMTP smuggling, an attacker may send smuggle/spoof e-mails with fake sender addresses, allowing advanced phishing attacks. This issue is also existed in other SMTP software like Postfix. With the right SMTP server constellation, an attacker can send spoofed e-mails to inbound/receiving aiosmtpd instances. This issue has been addressed in version 1.4.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-12T21:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-pr2m-px7j-xg65\n\n* SMTP Smuggling Fix\n\nAdapted adherence to RFC 5321 ยง 2.3.8 to fix SMTP smuggling issues (https://www.rfc-editor.org/rfc/rfc5321#section-2.3.8)\n\n* Apply suggestions from code review\n\nCo-authored-by: Sam Bull <git@sambull.org>\n\n* Add files via upload\n\n* Update test_smtpsmuggling.py\n\n---------\n\nCo-authored-by: Sam Bull <git@sambull.org>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "smtp.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 643:                 self._call_limit_base",
                "// Line 644:             )",
                "// Line 645:         else:",
                "// Line 646:             # Not used, but this silences code inspection tools",
                "// Line 647:             call_limit = {}",
                "// Line 648:         bogus_budget = BOGUS_LIMIT",
                "// Line 649: ",
                "// Line 650:         while self.transport is not None:   # pragma: nobranch",
                "// Line 651:             try:",
                "// Line 652:                 try:",
                "// vulnerable line: 653: line: bytes = await self._reader.readuntil()",
                "// Line 654:                 except asyncio.LimitOverrunError as error:",
                "// Line 655:                     # Line too long. Read until end of line before sending 500.",
                "// Line 656:                     await self._reader.read(error.consumed)",
                "// Line 657:                     while True:",
                "// Line 658:                         try:",
                "// Line 659:                             await self._reader.readuntil()",
                "// Line 660:                             break",
                "// Line 661:                         except asyncio.LimitOverrunError as e:",
                "// Line 662:                             # Line is even longer...",
                "// Line 663:                             await self._reader.read(e.consumed)",
                "// Line 1427:         data: List[bytearray] = []",
                "// Line 1428: ",
                "// Line 1429:         num_bytes: int = 0",
                "// Line 1430:         limit: Optional[int] = self.data_size_limit",
                "// Line 1431:         line_fragments: List[bytes] = []",
                "// Line 1432:         state: _DataState = _DataState.NOMINAL",
                "// Line 1433:         while self.transport is not None:           # pragma: nobranch",
                "// Line 1434:             # Since eof_received cancels this coroutine,",
                "// Line 1435:             # readuntil() can never raise asyncio.IncompleteReadError.",
                "// Line 1436:             try:",
                "// vulnerable line: 1437: line: bytes = await self._reader.readuntil()",
                "// Line 1438:                 log.debug('DATA readline: %s', line)",
                "// Line 1439:                 assert line.endswith(b'",
                "// Line 1440: ')",
                "// Line 1441:             except asyncio.CancelledError:",
                "// Line 1442:                 # The connection got reset during the DATA command.",
                "// Line 1443:                 log.info('Connection lost during DATA')",
                "// Line 1444:                 self._writer.close()",
                "// Line 1445:                 raise",
                "// Line 1446:             except asyncio.LimitOverrunError as e:",
                "// Line 1447:                 # The line exceeds StreamReader's \"stream limit\"."
            ]
        }
    ]
}