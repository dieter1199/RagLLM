{
    "cve_id": "CVE-2024-24806",
    "cve_description": "libuv is a multi-platform support library with a focus on asynchronous I/O. The `uv_getaddrinfo` function in `src/unix/getaddrinfo.c` (and its windows counterpart `src/win/getaddrinfo.c`), truncates hostnames to 256 characters before calling `getaddrinfo`. This behavior can be exploited to create addresses like `0x00007f000001`, which are considered valid by `getaddrinfo` and could allow an attacker to craft payloads that resolve to unintended IP addresses, bypassing developer checks. The vulnerability arises due to how the `hostname_ascii` variable (with a length of 256 bytes) is handled in `uv_getaddrinfo` and subsequently in `uv__idna_toascii`. When the hostname exceeds 256 characters, it gets truncated without a terminating null byte. As a result attackers may be able to access internal APIs or for websites (similar to MySpace) that allows users to have `username.example.com` pages. Internal services that crawl or cache these user pages can be exposed to SSRF attacks if a malicious user chooses a long vulnerable username. This issue has been addressed in release version 1.48.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-02-07T22:15Z",
    "cwe_id": "CWE-918",
    "cwe_name": "Server-Side Request Forgery (SSRF)",
    "cwe_description": "The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",
    "commit_message": "test: empty strings are not valid IDNA\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "test-idna.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 126: ",
                "// Line 127: #define F(input, err)                                                           do {                                                                            char d[256] = {0};                                                            static const char s[] = \"\" input \"\";                                          ASSERT_EQ(err, uv__idna_toascii(s, s + sizeof(s) - 1, d, d + sizeof(d)));   } while (0)",
                "// Line 128: ",
                "// Line 129: #define T(input, expected)                                                      do {                                                                            long n;                                                                       char d1[256] = {0};                                                           char d2[256] = {0};                                                           static const char s[] = \"\" input \"\";                                          n = uv__idna_toascii(s, s + sizeof(s) - 1, d1, d1 + sizeof(d1));              ASSERT_EQ(n, sizeof(expected));                                               ASSERT_OK(memcmp(d1, expected, n));                                           /* Sanity check: encoding twice should not change the output. */              n = uv__idna_toascii(d1, d1 + strlen(d1), d2, d2 + sizeof(d2));               ASSERT_EQ(n, sizeof(expected));                                               ASSERT_OK(memcmp(d2, expected, n));                                           ASSERT_OK(memcmp(d1, d2, sizeof(d2)));                                      } while (0)",
                "// Line 130: ",
                "// Line 131: TEST_IMPL(idna_toascii) {",
                "// Line 132:   /* Illegal inputs. */",
                "// Line 133:   F(\"ÀÁ\", UV_EINVAL);  /* Overlong UTF-8 sequence. */",
                "// Line 134:   F(\"ÀÁ.com\", UV_EINVAL);  /* Overlong UTF-8 sequence. */",
                "// Line 135:   /* No conversion. */",
                "// vulnerable line: 136: T(\"\", \"\");",
                "// Line 137:   T(\".\", \".\");",
                "// Line 138:   T(\".com\", \".com\");",
                "// Line 139:   T(\"example\", \"example\");",
                "// Line 140:   T(\"example-\", \"example-\");",
                "// Line 141:   T(\"straße.de\", \"xn--strae-oqa.de\");",
                "// Line 142:   /* Test cases adapted from punycode.js. Most are from RFC 3492. */",
                "// Line 143:   T(\"foo.bar\", \"foo.bar\");",
                "// Line 144:   T(\"mañana.com\", \"xn--maana-pta.com\");",
                "// Line 145:   T(\"example.com.\", \"example.com.\");",
                "// Line 146:   T(\"bücher.com\", \"xn--bcher-kva.com\");"
            ]
        }
    ]
}