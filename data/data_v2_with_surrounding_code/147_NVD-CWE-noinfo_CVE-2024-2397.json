{
    "cve_id": "CVE-2024-2397",
    "cve_description": "Due to a bug in packet data buffers management, the PPP printer in tcpdump can enter an infinite loop when reading a crafted DLT_PPP_SERIAL .pcap savefile.  This problem does not affect any tcpdump release, but it affected the git master branch from 2023-06-05 to 2024-03-21.",
    "cve_publish_date": "2024-04-12T14:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "ppp: use the buffer stack for the de-escaping buffer.\n\nThis both saves the buffer for freeing later and saves the packet\npointer and snapend to be restored when packet processing is complete,\neven if an exception is thrown with longjmp.\n\nThis means that the hex/ASCII printing in pretty_print_packet()\nprocesses the packet data as captured or read from the savefile, rather\nthan as modified by the PPP printer, so that the bounds checking is\ncorrect.\n\nThat fixes CVE-2024-2397, which was caused by an exception being thrown\nby the hex/ASCII printer (which should only happen if those routines are\ncalled by a packet printer, not if they're called for the -X/-x/-A\nflag), which jumps back to the setjmp() that surrounds the packet\nprinter.  Hilarity^Winfinite looping ensues.\n\nAlso, restore ndo->ndo_packetp before calling the hex/ASCII printing\nroutine, in case nd_pop_all_packet_info() didn't restore it.",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "print-ppp.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "17",
            "number_of_lines_deleted_vulnerable_to_cve": "14",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 426:     tptr++;",
                "// Line 427: ",
                "// Line 428:     ND_PRINT(\"%s (0x%02x), id %u, length %u\",",
                "// Line 429:               tok2str(cpcodes, \"Unknown Opcode\",code),",
                "// Line 430:               code,",
                "// Line 431:               GET_U_1(tptr), /* ID */",
                "// Line 432:               length + 2);",
                "// Line 433:     tptr++;",
                "// Line 434: ",
                "// Line 435:     if (!ndo->ndo_vflag)",
                "// vulnerable line: 436: return;",
                "// Line 437: ",
                "// Line 438:     len = GET_BE_U_2(tptr);",
                "// Line 439:     tptr += 2;",
                "// Line 440: ",
                "// Line 441:     if (len < 4) {",
                "// Line 442:         ND_PRINT(\"",
                "// Line 443:     encoded length %u (< 4))\", len);",
                "// vulnerable line: 444: return;",
                "// Line 445:     }",
                "// Line 446: ",
                "// Line 447:     if (len > length) {",
                "// Line 448:         ND_PRINT(\"",
                "// Line 449:     encoded length %u (> packet length %u))\", len, length);",
                "// vulnerable line: 450: return;",
                "// Line 451:     }",
                "// Line 452:     length = len;",
                "// Line 453: ",
                "// Line 454:     ND_PRINT(\"",
                "// Line 455:     encoded length %u (=Option(s) length %u)\", len, len - 4);",
                "// Line 456: ",
                "// Line 457:     if (length == 4)",
                "// Line 458:         return;    /* there may be a NULL confreq etc. */",
                "// Line 459: ",
                "// Line 460:     if (ndo->ndo_vflag > 1)",
                "// Line 583:         break;",
                "// Line 584:     default:",
                "// Line 585:         /* XXX this is dirty but we do not get the",
                "// Line 586:          * original pointer passed to the begin",
                "// Line 587:          * the PPP packet */",
                "// Line 588:         if (ndo->ndo_vflag <= 1)",
                "// Line 589:             print_unknown_data(ndo, pptr - 2, \"",
                "// Line 590:       \", length + 2);",
                "// Line 591:         break;",
                "// Line 592:     }",
                "// vulnerable line: 593: return;",
                "// Line 594: ",
                "// Line 595: trunc:",
                "// Line 596:     ND_PRINT(\"[|%s]\", typestr);",
                "// Line 597: }",
                "// Line 598: ",
                "// Line 599: /* LCP config options */",
                "// Line 600: static u_int",
                "// Line 601: print_lcp_config_options(netdissect_options *ndo,",
                "// Line 602:                          const u_char *p, u_int length)",
                "// Line 603: {",
                "// Line 820: ",
                "// Line 821: static void",
                "// Line 822: handle_mlppp(netdissect_options *ndo,",
                "// Line 823:              const u_char *p, u_int length)",
                "// Line 824: {",
                "// Line 825:     if (!ndo->ndo_eflag)",
                "// Line 826:         ND_PRINT(\"MLPPP, \");",
                "// Line 827: ",
                "// Line 828:     if (length < 2) {",
                "// Line 829:         ND_PRINT(\"[|mlppp]\");",
                "// vulnerable line: 830: return;",
                "// Line 831:     }",
                "// Line 832:     if (!ND_TTEST_2(p)) {",
                "// Line 833:         ND_PRINT(\"[|mlppp]\");",
                "// vulnerable line: 834: return;",
                "// Line 835:     }",
                "// Line 836: ",
                "// Line 837:     ND_PRINT(\"seq 0x%03x, Flags [%s], length %u\",",
                "// Line 838:            (GET_BE_U_2(p))&0x0fff,",
                "// Line 839:            /* only support 12-Bit sequence space for now */",
                "// Line 840:            bittok2str(ppp_ml_flag_values, \"none\", GET_U_1(p) & 0xc0),",
                "// Line 841:            length);",
                "// Line 842: }",
                "// Line 843: ",
                "// Line 844: /* CHAP */",
                "// Line 847:             const u_char *p, u_int length)",
                "// Line 848: {",
                "// Line 849:     u_int code, len;",
                "// Line 850:     u_int val_size, name_size, msg_size;",
                "// Line 851:     const u_char *p0;",
                "// Line 852:     u_int i;",
                "// Line 853: ",
                "// Line 854:     p0 = p;",
                "// Line 855:     if (length < 1) {",
                "// Line 856:         ND_PRINT(\"[|chap]\");",
                "// vulnerable line: 857: return;",
                "// Line 858:     } else if (length < 4) {",
                "// Line 859:         ND_PRINT(\"[|chap 0x%02x]\", GET_U_1(p));",
                "// vulnerable line: 860: return;",
                "// Line 861:     }",
                "// Line 862: ",
                "// Line 863:     code = GET_U_1(p);",
                "// Line 864:     ND_PRINT(\"CHAP, %s (0x%02x)\",",
                "// Line 865:                tok2str(chapcode_values,\"unknown\",code),",
                "// Line 866:                code);",
                "// Line 867:     p++;",
                "// Line 868: ",
                "// Line 869:     ND_PRINT(\", id %u\", GET_U_1(p));    /* ID */",
                "// Line 870:     p++;",
                "// Line 876:      * Note that this is a generic CHAP decoding routine. Since we",
                "// Line 877:      * don't know which flavor of CHAP (i.e. CHAP-MD5, MS-CHAPv1,",
                "// Line 878:      * MS-CHAPv2) is used at this point, we can't decode packet",
                "// Line 879:      * specifically to each algorithms. Instead, we simply decode",
                "// Line 880:      * the GCD (Greatest Common Denominator) for all algorithms.",
                "// Line 881:      */",
                "// Line 882:     switch (code) {",
                "// Line 883:     case CHAP_CHAL:",
                "// Line 884:     case CHAP_RESP:",
                "// Line 885:         if (length - (p - p0) < 1)",
                "// vulnerable line: 886: return;",
                "// Line 887:         val_size = GET_U_1(p);    /* value size */",
                "// Line 888:         p++;",
                "// Line 889:         if (length - (p - p0) < val_size)",
                "// vulnerable line: 890: return;",
                "// Line 891:         ND_PRINT(\", Value \");",
                "// Line 892:         for (i = 0; i < val_size; i++) {",
                "// Line 893:             ND_PRINT(\"%02x\", GET_U_1(p));",
                "// Line 894:             p++;",
                "// Line 895:         }",
                "// Line 896:         name_size = len - (u_int)(p - p0);",
                "// Line 897:         ND_PRINT(\", Name \");",
                "// Line 898:         for (i = 0; i < name_size; i++) {",
                "// Line 899:             fn_print_char(ndo, GET_U_1(p));",
                "// Line 900:             p++;",
                "// Line 918:            const u_char *p, u_int length)",
                "// Line 919: {",
                "// Line 920:     u_int code, len;",
                "// Line 921:     u_int peerid_len, passwd_len, msg_len;",
                "// Line 922:     const u_char *p0;",
                "// Line 923:     u_int i;",
                "// Line 924: ",
                "// Line 925:     p0 = p;",
                "// Line 926:     if (length < 1) {",
                "// Line 927:         ND_PRINT(\"[|pap]\");",
                "// vulnerable line: 928: return;",
                "// Line 929:     } else if (length < 4) {",
                "// Line 930:         ND_PRINT(\"[|pap 0x%02x]\", GET_U_1(p));",
                "// vulnerable line: 931: return;",
                "// Line 932:     }",
                "// Line 933: ",
                "// Line 934:     code = GET_U_1(p);",
                "// Line 935:     ND_PRINT(\"PAP, %s (0x%02x)\",",
                "// Line 936:               tok2str(papcode_values, \"unknown\", code),",
                "// Line 937:               code);",
                "// Line 938:     p++;",
                "// Line 939: ",
                "// Line 940:     ND_PRINT(\", id %u\", GET_U_1(p));    /* ID */",
                "// Line 941:     p++;",
                "// Line 942: ",
                "// Line 943:     len = GET_BE_U_2(p);",
                "// Line 944:     p += 2;",
                "// Line 945: ",
                "// Line 946:     if (len > length) {",
                "// Line 947:         ND_PRINT(\", length %u > packet size\", len);",
                "// vulnerable line: 948: return;",
                "// Line 949:     }",
                "// Line 950:     length = len;",
                "// Line 951:     if (length < (size_t)(p - p0)) {",
                "// Line 952:         ND_PRINT(\", length %u < PAP header length\", length);",
                "// vulnerable line: 953: return;",
                "// Line 954:     }",
                "// Line 955: ",
                "// Line 956:     switch (code) {",
                "// Line 957:     case PAP_AREQ:",
                "// Line 958:         /* A valid Authenticate-Request is 6 or more octets long. */",
                "// Line 959:         if (len < 6)",
                "// Line 960:             goto trunc;",
                "// Line 961:         if (length - (p - p0) < 1)",
                "// vulnerable line: 962: return;",
                "// Line 963:         peerid_len = GET_U_1(p);    /* Peer-ID Length */",
                "// Line 964:         p++;",
                "// Line 965:         if (length - (p - p0) < peerid_len)",
                "// vulnerable line: 966: return;",
                "// Line 967:         ND_PRINT(\", Peer \");",
                "// Line 968:         for (i = 0; i < peerid_len; i++) {",
                "// Line 969:             fn_print_char(ndo, GET_U_1(p));",
                "// Line 970:             p++;",
                "// Line 971:         }",
                "// Line 972: ",
                "// Line 973:         if (length - (p - p0) < 1)",
                "// vulnerable line: 974: return;",
                "// Line 975:         passwd_len = GET_U_1(p);    /* Password Length */",
                "// Line 976:         p++;",
                "// Line 977:         if (length - (p - p0) < passwd_len)",
                "// vulnerable line: 978: return;",
                "// Line 979:         ND_PRINT(\", Name \");",
                "// Line 980:         for (i = 0; i < passwd_len; i++) {",
                "// Line 981:             fn_print_char(ndo, GET_U_1(p));",
                "// Line 982:             p++;",
                "// Line 983:         }",
                "// Line 984:         break;",
                "// Line 985:     case PAP_AACK:",
                "// Line 986:     case PAP_ANAK:",
                "// Line 987:         /* Although some implementations ignore truncation at",
                "// Line 988:          * this point and at least one generates a truncated",
                "// Line 989:          * packet, RFC 1334 section 2.2.2 clearly states that",
                "// Line 990:          * both AACK and ANAK are at least 5 bytes long.",
                "// Line 991:          */",
                "// Line 992:         if (len < 5)",
                "// Line 993:             goto trunc;",
                "// Line 994:         if (length - (p - p0) < 1)",
                "// vulnerable line: 995: return;",
                "// Line 996:         msg_len = GET_U_1(p);    /* Msg-Length */",
                "// Line 997:         p++;",
                "// Line 998:         if (length - (p - p0) < msg_len)",
                "// vulnerable line: 999: return;",
                "// Line 1000:         ND_PRINT(\", Msg \");",
                "// Line 1001:         for (i = 0; i< msg_len; i++) {",
                "// Line 1002:             fn_print_char(ndo, GET_U_1(p));",
                "// Line 1003:             p++;",
                "// Line 1004:         }",
                "// Line 1005:         break;",
                "// Line 1006:     }",
                "// vulnerable line: 1007: return;",
                "// Line 1008: ",
                "// Line 1009: trunc:",
                "// Line 1010:     ND_PRINT(\"[|pap]\");",
                "// Line 1011: }",
                "// Line 1012: ",
                "// Line 1013: /* BAP */",
                "// Line 1014: static void",
                "// Line 1015: handle_bap(netdissect_options *ndo _U_,",
                "// Line 1016:            const u_char *p _U_, u_int length _U_)",
                "// Line 1017: {",
                "// Line 1393:  * length; we can only un-escape the captured part.",
                "// Line 1394:  */",
                "// Line 1395: static void",
                "// Line 1396: ppp_hdlc(netdissect_options *ndo,",
                "// Line 1397:          const u_char *p, u_int length)",
                "// Line 1398: {",
                "// Line 1399:     u_int caplen = ND_BYTES_AVAILABLE_AFTER(p);",
                "// Line 1400:     u_char *b, *t, c;",
                "// Line 1401:     const u_char *s;",
                "// Line 1402:     u_int i, proto;",
                "// vulnerable line: 1403: const void *sb, *se;",
                "// Line 1404: ",
                "// Line 1405:     if (caplen == 0)",
                "// vulnerable line: 1406: return;",
                "// Line 1407: ",
                "// Line 1408:         if (length == 0)",
                "// vulnerable line: 1409: return;",
                "// Line 1410: ",
                "// vulnerable line: 1411: b = (u_char *)nd_malloc(ndo, caplen);",
                "// vulnerable line: 1412: if (b == NULL)",
                "// vulnerable line: 1413: return;",
                "// Line 1414: ",
                "// Line 1415:     /*",
                "// Line 1416:      * Unescape all the data into a temporary, private, buffer.",
                "// Line 1417:      * Do this so that we don't overwrite the original packet",
                "// Line 1418:      * contents.",
                "// Line 1419:      */",
                "// Line 1420:     for (s = p, t = b, i = caplen; i != 0; i--) {",
                "// Line 1421:         c = GET_U_1(s);",
                "// Line 1422:         s++;",
                "// Line 1423:         if (c == 0x7d) {",
                "// Line 1424:             if (i <= 1)",
                "// Line 1425:                 break;",
                "// Line 1426:             i--;",
                "// Line 1427:             c = GET_U_1(s) ^ 0x20;",
                "// Line 1428:             s++;",
                "// Line 1429:         }",
                "// Line 1430:         *t++ = c;",
                "// Line 1431:     }",
                "// Line 1432: ",
                "// Line 1433:     /*",
                "// vulnerable line: 1434: * Change the end pointer, so bounds checks work.",
                "// vulnerable line: 1435: * Change the pointer to packet data to help debugging.",
                "// Line 1436:      */",
                "// vulnerable line: 1437: sb = ndo->ndo_packetp;",
                "// vulnerable line: 1438: se = ndo->ndo_snapend;",
                "// vulnerable line: 1439: ndo->ndo_packetp = b;",
                "// vulnerable line: 1440: ndo->ndo_snapend = t;",
                "// Line 1441:     length = ND_BYTES_AVAILABLE_AFTER(b);",
                "// Line 1442: ",
                "// Line 1443:         /* now lets guess about the payload codepoint format */",
                "// Line 1444:         if (length < 1)",
                "// Line 1445:                 goto trunc;",
                "// Line 1446:         proto = GET_U_1(b); /* start with a one-octet codepoint guess */",
                "// Line 1447: ",
                "// Line 1448:         switch (proto) {",
                "// Line 1449:         case PPP_IP:",
                "// Line 1450:         ip_print(ndo, b + 1, length - 1);",
                "// Line 1472:             break;",
                "// Line 1473:         default: /* last guess - proto must be a PPP proto-id */",
                "// Line 1474:             if ((proto & 0xff00) == 0x7e00)",
                "// Line 1475:                 ND_PRINT(\"(protocol 0x%04x invalid)\", proto);",
                "// Line 1476:             else",
                "// Line 1477:                 handle_ppp(ndo, proto, b + 2, length - 2);",
                "// Line 1478:             break;",
                "// Line 1479:         }",
                "// Line 1480: ",
                "// Line 1481: cleanup:",
                "// vulnerable line: 1482: ndo->ndo_packetp = sb;",
                "// vulnerable line: 1483: ndo->ndo_snapend = se;",
                "// vulnerable line: 1484: return;",
                "// Line 1485: ",
                "// Line 1486: trunc:",
                "// vulnerable line: 1487: ndo->ndo_packetp = sb;",
                "// vulnerable line: 1488: ndo->ndo_snapend = se;",
                "// Line 1489:     nd_print_trunc(ndo);",
                "// Line 1490: }",
                "// Line 1491: ",
                "// Line 1492: ",
                "// Line 1493: /* PPP */",
                "// Line 1494: static void",
                "// Line 1495: handle_ppp(netdissect_options *ndo,",
                "// Line 1496:            u_int proto, const u_char *p, u_int length)",
                "// Line 1497: {",
                "// Line 1498:     if ((proto & 0xff00) == 0x7e00) { /* is this an escape code ? */",
                "// Line 1499:         ppp_hdlc(ndo, p - 1, length);",
                "// vulnerable line: 1500: return;",
                "// Line 1501:     }",
                "// Line 1502: ",
                "// Line 1503:     switch (proto) {",
                "// Line 1504:     case PPP_LCP: /* fall through */",
                "// Line 1505:     case PPP_IPCP:",
                "// Line 1506:     case PPP_OSICP:",
                "// Line 1507:     case PPP_MPLSCP:",
                "// Line 1508:     case PPP_IPV6CP:",
                "// Line 1509:     case PPP_CCP:",
                "// Line 1510:     case PPP_BACP:",
                "// Line 1634: ppp_if_print(netdissect_options *ndo,",
                "// Line 1635:              const struct pcap_pkthdr *h, const u_char *p)",
                "// Line 1636: {",
                "// Line 1637:     u_int length = h->len;",
                "// Line 1638:     u_int caplen = h->caplen;",
                "// Line 1639: ",
                "// Line 1640:     ndo->ndo_protocol = \"ppp\";",
                "// Line 1641:     if (caplen < PPP_HDRLEN) {",
                "// Line 1642:         nd_print_trunc(ndo);",
                "// Line 1643:         ndo->ndo_ll_hdr_len += caplen;",
                "// vulnerable line: 1644: return;",
                "// Line 1645:     }",
                "// Line 1646:     ndo->ndo_ll_hdr_len += PPP_HDRLEN;",
                "// Line 1647: ",
                "// Line 1648: #if 0",
                "// Line 1649:     /*",
                "// Line 1650:      * XXX: seems to assume that there are 2 octets prepended to an",
                "// Line 1651:      * actual PPP frame. The 1st octet looks like Input/Output flag",
                "// Line 1652:      * while 2nd octet is unknown, at least to me",
                "// Line 1653:      * (mshindo@mshindo.net).",
                "// Line 1654:      *",
                "// Line 1705: {",
                "// Line 1706:     u_int length = h->len;",
                "// Line 1707:     u_int caplen = h->caplen;",
                "// Line 1708:     u_int proto;",
                "// Line 1709:     u_int hdrlen = 0;",
                "// Line 1710: ",
                "// Line 1711:     ndo->ndo_protocol = \"ppp_hdlc\";",
                "// Line 1712:     if (caplen < 2) {",
                "// Line 1713:         nd_print_trunc(ndo);",
                "// Line 1714:         ndo->ndo_ll_hdr_len += caplen;",
                "// vulnerable line: 1715: return;",
                "// Line 1716:     }",
                "// Line 1717: ",
                "// Line 1718:     switch (GET_U_1(p)) {",
                "// Line 1719: ",
                "// Line 1720:     case PPP_ADDRESS:",
                "// Line 1721:         if (caplen < 4) {",
                "// Line 1722:             nd_print_trunc(ndo);",
                "// Line 1723:             ndo->ndo_ll_hdr_len += caplen;",
                "// vulnerable line: 1724: return;",
                "// Line 1725:         }",
                "// Line 1726: ",
                "// Line 1727:         if (ndo->ndo_eflag)",
                "// Line 1728:             ND_PRINT(\"%02x %02x %u \", GET_U_1(p),",
                "// Line 1729:                  GET_U_1(p + 1), length);",
                "// Line 1730:         p += 2;",
                "// Line 1731:         length -= 2;",
                "// Line 1732:         hdrlen += 2;",
                "// Line 1733: ",
                "// Line 1734:         proto = GET_BE_U_2(p);",
                "// Line 1736:         length -= 2;",
                "// Line 1737:         hdrlen += 2;",
                "// Line 1738:         ND_PRINT(\"%s: \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto));",
                "// Line 1739: ",
                "// Line 1740:         handle_ppp(ndo, proto, p, length);",
                "// Line 1741:         break;",
                "// Line 1742: ",
                "// Line 1743:     case CHDLC_UNICAST:",
                "// Line 1744:     case CHDLC_BCAST:",
                "// Line 1745:         chdlc_if_print(ndo, h, p);",
                "// vulnerable line: 1746: return;",
                "// Line 1747: ",
                "// Line 1748:     default:",
                "// Line 1749:         if (caplen < 4) {",
                "// Line 1750:             nd_print_trunc(ndo);",
                "// Line 1751:             ndo->ndo_ll_hdr_len += caplen;",
                "// vulnerable line: 1752: return;",
                "// Line 1753:         }",
                "// Line 1754: ",
                "// Line 1755:         if (ndo->ndo_eflag)",
                "// Line 1756:             ND_PRINT(\"%02x %02x %u \", GET_U_1(p),",
                "// Line 1757:                  GET_U_1(p + 1), length);",
                "// Line 1758:         p += 2;",
                "// Line 1759:         hdrlen += 2;",
                "// Line 1760: ",
                "// Line 1761:         /*",
                "// Line 1762:          * XXX - NetBSD's \"ppp_netbsd_serial_if_print()\" treats"
            ]
        },
        {
            "filename_of_changes": "print.c",
            "code_language": "C",
            "number_of_lines_added_for_mitigation": "6",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 425: ",
                "// Line 426:     /*",
                "// Line 427:      * Empty the stack of packet information, freeing all pushed buffers;",
                "// Line 428:      * if we got here by a printer quitting, we need to release anything",
                "// Line 429:      * that didn't get released because we longjmped out of the code",
                "// Line 430:      * before it popped the packet information.",
                "// Line 431:      */",
                "// Line 432:     nd_pop_all_packet_info(ndo);",
                "// Line 433: ",
                "// Line 434:     /*",
                "// vulnerable line: 435: * Restore the original snapend, as a printer might have",
                "// vulnerable line: 436: * changed it.",
                "// Line 437:      */",
                "// Line 438:     ndo->ndo_snapend = sp + h->caplen;",
                "// Line 439:     if (ndo->ndo_Xflag) {",
                "// Line 440:         /*",
                "// Line 441:          * Print the raw packet data in hex and ASCII.",
                "// Line 442:          */",
                "// Line 443:         if (ndo->ndo_Xflag > 1) {",
                "// Line 444:             /*",
                "// Line 445:              * Include the link-layer header.",
                "// Line 446:              */"
            ]
        }
    ]
}