{
    "cve_id": "CVE-2024-1728",
    "cve_description": "gradio-app/gradio is vulnerable to a local file inclusion vulnerability due to improper validation of user-supplied input in the UploadButton component. Attackers can exploit this vulnerability to read arbitrary files on the filesystem, such as private SSH keys, by manipulating the file path in the request to the `/queue/join` endpoint. This issue could potentially lead to remote code execution. The vulnerability is present in the handling of file upload paths, allowing attackers to redirect file uploads to unintended locations on the server.",
    "cve_publish_date": "2024-04-10T17:15Z",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "Prevent components from working with non-uploaded files (#7465)\n\n* changes\r\n\r\n* chanegs\r\n\r\n* add changeset\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* add changeset\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n---------\r\n\r\nCo-authored-by: Ali Abid <aliabid94@gmail.com>\r\nCo-authored-by: gradio-pr-bot <gradio-pr-bot@users.noreply.github.com>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "blocks.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "30",
            "number_of_lines_deleted_vulnerable_to_cve": "12",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 2: ",
                "// Line 3: import copy",
                "// Line 4: import hashlib",
                "// Line 5: import inspect",
                "// Line 6: import json",
                "// Line 7: import os",
                "// Line 8: import random",
                "// Line 9: import secrets",
                "// Line 10: import string",
                "// Line 11: import sys",
                "// vulnerable line: 12: import tempfile",
                "// Line 13: import threading",
                "// Line 14: import time",
                "// Line 15: import warnings",
                "// Line 16: import webbrowser",
                "// Line 17: from collections import defaultdict",
                "// Line 18: from pathlib import Path",
                "// Line 19: from types import ModuleType",
                "// Line 20: from typing import TYPE_CHECKING, Any, AsyncIterator, Callable, Literal, Sequence, cast",
                "// Line 21: from urllib.parse import urlparse, urlunparse",
                "// Line 22: ",
                "// Line 30:     analytics,",
                "// Line 31:     components,",
                "// Line 32:     networking,",
                "// Line 33:     processing_utils,",
                "// Line 34:     queueing,",
                "// Line 35:     routes,",
                "// Line 36:     strings,",
                "// Line 37:     themes,",
                "// Line 38:     utils,",
                "// Line 39:     wasm_utils,",
                "// vulnerable line: 40: )",
                "// Line 41: from gradio.blocks_events import BlocksEvents, BlocksMeta",
                "// Line 42: from gradio.context import Context",
                "// Line 43: from gradio.data_classes import FileData, GradioModel, GradioRootModel",
                "// Line 44: from gradio.events import (",
                "// Line 45:     EventData,",
                "// Line 46:     EventListener,",
                "// Line 47:     EventListenerMethod,",
                "// vulnerable line: 48: )",
                "// Line 49: from gradio.exceptions import (",
                "// Line 50:     DuplicateBlockError,",
                "// Line 51:     InvalidApiNameError,",
                "// Line 52:     InvalidBlockError,",
                "// Line 53:     InvalidComponentError,",
                "// vulnerable line: 54: )",
                "// Line 55: from gradio.helpers import create_tracker, skip, special_args",
                "// Line 56: from gradio.state_holder import SessionState",
                "// Line 57: from gradio.themes import Default as DefaultTheme",
                "// Line 58: from gradio.themes import ThemeClass as Theme",
                "// Line 59: from gradio.tunneling import (",
                "// Line 60:     BINARY_FILENAME,",
                "// Line 61:     BINARY_FOLDER,",
                "// Line 62:     BINARY_PATH,",
                "// Line 63:     BINARY_URL,",
                "// Line 64:     CURRENT_TUNNELS,",
                "// vulnerable line: 65: )",
                "// Line 66: from gradio.utils import (",
                "// Line 67:     TupleNoPrint,",
                "// Line 68:     check_function_inputs_match,",
                "// Line 69:     component_or_layout_class,",
                "// Line 70:     get_cancel_function,",
                "// Line 71:     get_continuous_fn,",
                "// Line 72:     get_package_version,",
                "// vulnerable line: 73: )",
                "// Line 74: ",
                "// Line 75: try:",
                "// Line 76:     import spaces  # type: ignore",
                "// Line 77: except Exception:",
                "// Line 78:     spaces = None",
                "// Line 79: ",
                "// Line 80: ",
                "// Line 81: if TYPE_CHECKING:  # Only import for type checking (is False at runtime).",
                "// Line 82:     from fastapi.applications import FastAPI",
                "// Line 83: ",
                "// Line 104:         render: bool = True,",
                "// Line 105:         visible: bool = True,",
                "// Line 106:         proxy_url: str | None = None,",
                "// Line 107:     ):",
                "// Line 108:         self._id = Context.id",
                "// Line 109:         Context.id += 1",
                "// Line 110:         self.visible = visible",
                "// Line 111:         self.elem_id = elem_id",
                "// Line 112:         self.elem_classes = (",
                "// Line 113:             [elem_classes] if isinstance(elem_classes, str) else elem_classes",
                "// vulnerable line: 114: )",
                "// Line 115:         self.proxy_url = proxy_url",
                "// Line 116:         self.share_token = secrets.token_urlsafe(32)",
                "// Line 117:         self.parent: BlockContext | None = None",
                "// Line 118:         self.is_rendered: bool = False",
                "// Line 119:         self._constructor_args: list[dict]",
                "// Line 120:         self.state_session_capacity = 10000",
                "// Line 121:         self.temp_files: set[str] = set()",
                "// vulnerable line: 122: self.GRADIO_CACHE = str(",
                "// vulnerable line: 123: Path(",
                "// vulnerable line: 124: os.environ.get(\"GRADIO_TEMP_DIR\")",
                "// vulnerable line: 125: or str(Path(tempfile.gettempdir()) / \"gradio\")",
                "// vulnerable line: 126: ).resolve()",
                "// vulnerable line: 127: )",
                "// Line 128: ",
                "// Line 129:         if render:",
                "// Line 130:             self.render()",
                "// Line 131: ",
                "// Line 132:     @property",
                "// Line 133:     def skip_api(self):",
                "// Line 134:         return False",
                "// Line 135: ",
                "// Line 136:     @property",
                "// Line 137:     def constructor_args(self) -> dict[str, Any]:",
                "// Line 149:     ) -> list[EventListener]:",
                "// Line 150:         return getattr(self, \"EVENTS\", [])",
                "// Line 151: ",
                "// Line 152:     def render(self):",
                "// Line 153:         \"\"\"",
                "// Line 154:         Adds self into appropriate BlockContext",
                "// Line 155:         \"\"\"",
                "// Line 156:         if Context.root_block is not None and self._id in Context.root_block.blocks:",
                "// Line 157:             raise DuplicateBlockError(",
                "// Line 158:                 f\"A block with id: {self._id} has already been rendered in the current Blocks.\"",
                "// vulnerable line: 159: )",
                "// Line 160:         if Context.block is not None:",
                "// Line 161:             Context.block.add(self)",
                "// Line 162:         if Context.root_block is not None:",
                "// Line 163:             Context.root_block.blocks[self._id] = self",
                "// Line 164:             self.is_rendered = True",
                "// Line 165:             if isinstance(self, components.Component):",
                "// Line 166:                 Context.root_block.temp_file_sets.append(self.temp_files)",
                "// Line 167:         return self",
                "// Line 168: ",
                "// Line 169:     def unrender(self):",
                "// Line 189:         Gets block's class name.",
                "// Line 190: ",
                "// Line 191:         If it is template component it gets the parent's class name.",
                "// Line 192: ",
                "// Line 193:         @return: class name",
                "// Line 194:         \"\"\"",
                "// Line 195:         return (",
                "// Line 196:             self.__class__.__base__.__name__.lower()",
                "// Line 197:             if hasattr(self, \"is_template\")",
                "// Line 198:             else self.__class__.__name__.lower()",
                "// vulnerable line: 199: )",
                "// Line 200: ",
                "// Line 201:     def get_expected_parent(self) -> type[BlockContext] | None:",
                "// Line 202:         return None",
                "// Line 203: ",
                "// Line 204:     def get_config(self):",
                "// Line 205:         config = {}",
                "// Line 206:         signature = inspect.signature(self.__class__.__init__)",
                "// Line 207:         for parameter in signature.parameters.values():",
                "// Line 208:             if hasattr(self, parameter.name):",
                "// Line 209:                 value = getattr(self, parameter.name)",
                "// Line 241:         ensures that the file is accessible to the Block and can be served to users.",
                "// Line 242:         \"\"\"",
                "// Line 243:         if url_or_file_path is None:",
                "// Line 244:             return None",
                "// Line 245:         if isinstance(url_or_file_path, Path):",
                "// Line 246:             url_or_file_path = str(url_or_file_path)",
                "// Line 247: ",
                "// Line 248:         if client_utils.is_http_url_like(url_or_file_path):",
                "// Line 249:             temp_file_path = processing_utils.save_url_to_cache(",
                "// Line 250:                 url_or_file_path, cache_dir=self.GRADIO_CACHE",
                "// vulnerable line: 251: )",
                "// Line 252: ",
                "// Line 253:             self.temp_files.add(temp_file_path)",
                "// Line 254:         else:",
                "// Line 255:             url_or_file_path = str(utils.abspath(url_or_file_path))",
                "// Line 256:             if not utils.is_in_or_equal(url_or_file_path, self.GRADIO_CACHE):",
                "// Line 257:                 temp_file_path = processing_utils.save_file_to_cache(",
                "// Line 258:                     url_or_file_path, cache_dir=self.GRADIO_CACHE",
                "// vulnerable line: 259: )",
                "// Line 260:             else:",
                "// Line 261:                 temp_file_path = url_or_file_path",
                "// Line 262:             self.temp_files.add(temp_file_path)",
                "// Line 263: ",
                "// Line 264:         return temp_file_path",
                "// Line 265: ",
                "// Line 266: ",
                "// Line 267: class BlockContext(Block):",
                "// Line 268:     def __init__(",
                "// Line 269:         self,",
                "// Line 279:             visible: If False, this will be hidden but included in the Blocks config file (its visibility can later be updated).",
                "// Line 280:             render: If False, this will not be included in the Blocks config file at all.",
                "// Line 281:         \"\"\"",
                "// Line 282:         self.children: list[Block] = []",
                "// Line 283:         Block.__init__(",
                "// Line 284:             self,",
                "// Line 285:             elem_id=elem_id,",
                "// Line 286:             elem_classes=elem_classes,",
                "// Line 287:             visible=visible,",
                "// Line 288:             render=render,",
                "// vulnerable line: 289: )",
                "// Line 290: ",
                "// Line 291:     TEMPLATE_DIR = \"./templates/\"",
                "// Line 292:     FRONTEND_DIR = \"../../frontend/\"",
                "// Line 293: ",
                "// Line 294:     @property",
                "// Line 295:     def skip_api(self):",
                "// Line 296:         return True",
                "// Line 297: ",
                "// Line 298:     @classmethod",
                "// Line 299:     def get_component_class_id(cls) -> str:",
                "// Line 393:             return",
                "// Line 394:         self.fn = spaces.gradio_auto_wrap(self.fn)",
                "// Line 395: ",
                "// Line 396:     def __str__(self):",
                "// Line 397:         return str(",
                "// Line 398:             {",
                "// Line 399:                 \"fn\": self.name,",
                "// Line 400:                 \"preprocess\": self.preprocess,",
                "// Line 401:                 \"postprocess\": self.postprocess,",
                "// Line 402:             }",
                "// vulnerable line: 403: )",
                "// Line 404: ",
                "// Line 405:     def __repr__(self):",
                "// Line 406:         return str(self)",
                "// Line 407: ",
                "// Line 408: ",
                "// Line 409: def postprocess_update_dict(",
                "// Line 410:     block: Component | BlockContext, update_dict: dict, postprocess: bool = True",
                "// Line 411: ):",
                "// Line 412:     \"\"\"",
                "// Line 413:     Converts a dictionary of updates into a format that can be sent to the frontend to update the component.",
                "// Line 440:     E.g. {\"textbox\": \"hello\", \"number\": {\"__type__\": \"generic_update\", \"value\": \"2\"}}",
                "// Line 441:     Into -> [\"hello\", {\"__type__\": \"generic_update\"}, {\"__type__\": \"generic_update\", \"value\": \"2\"}]",
                "// Line 442:     \"\"\"",
                "// Line 443:     keys_are_blocks = [isinstance(key, Block) for key in predictions]",
                "// Line 444:     if all(keys_are_blocks):",
                "// Line 445:         reordered_predictions = [skip() for _ in outputs_ids]",
                "// Line 446:         for component, value in predictions.items():",
                "// Line 447:             if component._id not in outputs_ids:",
                "// Line 448:                 raise ValueError(",
                "// Line 449:                     f\"Returned component {component} not specified as output of function.\"",
                "// vulnerable line: 450: )",
                "// Line 451:             output_index = outputs_ids.index(component._id)",
                "// Line 452:             reordered_predictions[output_index] = value",
                "// Line 453:         predictions = utils.resolve_singleton(reordered_predictions)",
                "// Line 454:     elif any(keys_are_blocks):",
                "// Line 455:         raise ValueError(",
                "// Line 456:             \"Returned dictionary included some keys as Components. Either all keys must be Components to assign Component values, or return a List of values to assign output values in order.\"",
                "// vulnerable line: 457: )",
                "// Line 458:     return predictions",
                "// Line 459: ",
                "// Line 460: ",
                "// Line 461: @document(\"launch\", \"queue\", \"integrate\", \"load\")",
                "// Line 462: class Blocks(BlockContext, BlocksEvents, metaclass=BlocksMeta):",
                "// Line 463:     \"\"\"",
                "// Line 464:     Blocks is Gradio's low-level API that allows you to create more custom web",
                "// Line 465:     applications and demos than Interfaces (yet still entirely in Python).",
                "// Line 466: ",
                "// Line 467: ",
                "// Line 554:                 self.js = js_file.read()",
                "// Line 555:         else:",
                "// Line 556:             self.js = js",
                "// Line 557: ",
                "// Line 558:         # For analytics_enabled and allow_flagging: (1) first check for",
                "// Line 559:         # parameter, (2) check for env variable, (3) default to True/\"manual\"",
                "// Line 560:         self.analytics_enabled = (",
                "// Line 561:             analytics_enabled",
                "// Line 562:             if analytics_enabled is not None",
                "// Line 563:             else analytics.analytics_enabled()",
                "// vulnerable line: 564: )",
                "// Line 565:         if self.analytics_enabled:",
                "// Line 566:             if not wasm_utils.IS_WASM:",
                "// Line 567:                 t = threading.Thread(target=analytics.version_check)",
                "// Line 568:                 t.start()",
                "// Line 569:         else:",
                "// Line 570:             os.environ[\"HF_HUB_DISABLE_TELEMETRY\"] = \"True\"",
                "// Line 571:         super().__init__(render=False, **kwargs)",
                "// Line 572:         self.blocks: dict[int, Component | Block] = {}",
                "// Line 573:         self.fns: list[BlockFunction] = []",
                "// Line 574:         self.dependencies = []",
                "// Line 602: ",
                "// Line 603:         self.allowed_paths = []",
                "// Line 604:         self.blocked_paths = []",
                "// Line 605:         self.root_path = os.environ.get(\"GRADIO_ROOT_PATH\", \"\")",
                "// Line 606:         self.proxy_urls = set()",
                "// Line 607: ",
                "// Line 608:         if self.analytics_enabled:",
                "// Line 609:             is_custom_theme = not any(",
                "// Line 610:                 self.theme.to_dict() == built_in_theme.to_dict()",
                "// Line 611:                 for built_in_theme in BUILT_IN_THEMES.values()",
                "// vulnerable line: 612: )",
                "// Line 613:             data = {",
                "// Line 614:                 \"mode\": self.mode,",
                "// Line 615:                 \"custom_css\": self.css is not None,",
                "// Line 616:                 \"theme\": self.theme.name,",
                "// Line 617:                 \"is_custom_theme\": is_custom_theme,",
                "// Line 618:                 \"version\": get_package_version(),",
                "// Line 619:             }",
                "// Line 620:             analytics.initiated_analytics(data)",
                "// Line 621: ",
                "// Line 622:         self.queue()",
                "// Line 690:                 id = child_config[\"id\"]",
                "// Line 691:                 block = get_block_instance(id)",
                "// Line 692: ",
                "// Line 693:                 original_mapping[id] = block",
                "// Line 694: ",
                "// Line 695:                 children = child_config.get(\"children\")",
                "// Line 696:                 if children is not None:",
                "// Line 697:                     if not isinstance(block, BlockContext):",
                "// Line 698:                         raise ValueError(",
                "// Line 699:                             f\"Invalid config, Block with id {id} has children but is not a BlockContext.\"",
                "// vulnerable line: 700: )",
                "// Line 701:                     with block:",
                "// Line 702:                         iterate_over_children(children)",
                "// Line 703: ",
                "// Line 704:         derived_fields = [\"types\"]",
                "// Line 705: ",
                "// Line 706:         with Blocks(theme=theme) as blocks:",
                "// Line 707:             # ID 0 should be the root Blocks component",
                "// Line 708:             original_mapping[0] = Context.root_block or blocks",
                "// Line 709: ",
                "// Line 710:             iterate_over_children(config[\"layout\"][\"children\"])",
                "// Line 726:                 # older versions had a separate trigger field, but now it is part of the",
                "// Line 727:                 # targets field",
                "// Line 728:                 _targets = dependency.pop(\"targets\")",
                "// Line 729:                 trigger = dependency.pop(\"trigger\", None)",
                "// Line 730:                 targets = [",
                "// Line 731:                     getattr(",
                "// Line 732:                         original_mapping[",
                "// Line 733:                             target if isinstance(target, int) else target[0]",
                "// Line 734:                         ],",
                "// Line 735:                         trigger if isinstance(target, int) else target[1],",
                "// vulnerable line: 736: )",
                "// Line 737:                     for target in _targets",
                "// Line 738:                 ]",
                "// Line 739:                 dependency.pop(\"backend_fn\")",
                "// Line 740:                 dependency.pop(\"documentation\", None)",
                "// Line 741:                 dependency[\"inputs\"] = [",
                "// Line 742:                     original_mapping[i] for i in dependency[\"inputs\"]",
                "// Line 743:                 ]",
                "// Line 744:                 dependency[\"outputs\"] = [",
                "// Line 745:                     original_mapping[o] for o in dependency[\"outputs\"]",
                "// Line 746:                 ]",
                "// Line 747:                 dependency.pop(\"status_tracker\", None)",
                "// Line 748:                 dependency[\"preprocess\"] = False",
                "// Line 749:                 dependency[\"postprocess\"] = False",
                "// Line 750:                 targets = [",
                "// Line 751:                     EventListenerMethod(",
                "// Line 752:                         t.__self__ if t.has_trigger else None, t.event_name",
                "// vulnerable line: 753: )",
                "// Line 754:                     for t in targets",
                "// Line 755:                 ]",
                "// Line 756:                 dependency = blocks.set_event_trigger(",
                "// Line 757:                     targets=targets, fn=fn, **dependency",
                "// Line 758:                 )[0]",
                "// Line 759:                 if first_dependency is None:",
                "// Line 760:                     first_dependency = dependency",
                "// Line 761: ",
                "// Line 762:             # Allows some use of Interface-specific methods with loaded Spaces",
                "// Line 763:             if first_dependency and Context.root_block:",
                "// Line 798:                     repr += f\"",
                "// Line 799:  |-{block}\"",
                "// Line 800:         return repr",
                "// Line 801: ",
                "// Line 802:     @property",
                "// Line 803:     def expects_oauth(self):",
                "// Line 804:         \"\"\"Return whether the app expects user to authenticate via OAuth.\"\"\"",
                "// Line 805:         return any(",
                "// Line 806:             isinstance(block, (components.LoginButton, components.LogoutButton))",
                "// Line 807:             for block in self.blocks.values()",
                "// vulnerable line: 808: )",
                "// Line 809: ",
                "// Line 810:     def set_event_trigger(",
                "// Line 811:         self,",
                "// Line 812:         targets: Sequence[EventListenerMethod],",
                "// Line 813:         fn: Callable | None,",
                "// Line 814:         inputs: Component | list[Component] | set[Component] | None,",
                "// Line 815:         outputs: Component | list[Component] | None,",
                "// Line 816:         preprocess: bool = True,",
                "// Line 817:         postprocess: bool = True,",
                "// Line 818:         scroll_to_output: bool = False,",
                "// Line 859:             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to \"default\" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `queue()`, which itself is 1 by default).",
                "// Line 860:             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.",
                "// Line 861:             show_api: whether to show this event in the \"view API\" page of the Gradio app, or in the \".view_api()\" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.",
                "// Line 862:         Returns: dependency information, dependency index",
                "// Line 863:         \"\"\"",
                "// Line 864:         # Support for singular parameter",
                "// Line 865:         _targets = [",
                "// Line 866:             (",
                "// Line 867:                 target.block._id if target.block and not no_target else None,",
                "// Line 868:                 target.event_name,",
                "// vulnerable line: 869: )",
                "// Line 870:             for target in targets",
                "// Line 871:         ]",
                "// Line 872:         if isinstance(inputs, set):",
                "// Line 873:             inputs_as_dict = True",
                "// Line 874:             inputs = sorted(inputs, key=lambda x: x._id)",
                "// Line 875:         else:",
                "// Line 876:             inputs_as_dict = False",
                "// Line 877:             if inputs is None:",
                "// Line 878:                 inputs = []",
                "// Line 879:             elif not isinstance(inputs, list):",
                "// Line 887:             outputs = [outputs]",
                "// Line 888: ",
                "// Line 889:         if fn is not None and not cancels:",
                "// Line 890:             check_function_inputs_match(fn, inputs, inputs_as_dict)",
                "// Line 891:         if every is not None and every <= 0:",
                "// Line 892:             raise ValueError(\"Parameter every must be positive or None\")",
                "// Line 893:         if every and batch:",
                "// Line 894:             raise ValueError(",
                "// Line 895:                 f\"Cannot run event in a batch and every {every} seconds. \"",
                "// Line 896:                 \"Either batch is True or every is non-zero but not both.\"",
                "// vulnerable line: 897: )",
                "// Line 898: ",
                "// Line 899:         if every and fn:",
                "// Line 900:             fn = get_continuous_fn(fn, every)",
                "// Line 901:         elif every:",
                "// Line 902:             raise ValueError(\"Cannot set a value for `every` without a `fn`.\")",
                "// Line 903:         if every and concurrency_limit is not None:",
                "// Line 904:             if concurrency_limit == \"default\":",
                "// Line 905:                 concurrency_limit = None",
                "// Line 906:             else:",
                "// Line 907:                 raise ValueError(",
                "// Line 908:                     \"Cannot set a value for `concurrency_limit` with `every`.\"",
                "// vulnerable line: 909: )",
                "// Line 910: ",
                "// Line 911:         if _targets[0][1] in [\"change\", \"key_up\"] and trigger_mode is None:",
                "// Line 912:             trigger_mode = \"always_last\"",
                "// Line 913:         elif trigger_mode is None:",
                "// Line 914:             trigger_mode = \"once\"",
                "// Line 915:         elif trigger_mode not in [\"once\", \"multiple\", \"always_last\"]:",
                "// Line 916:             raise ValueError(",
                "// Line 917:                 f\"Invalid value for parameter `trigger_mode`: {trigger_mode}. Please choose from: {['once', 'multiple', 'always_last']}\"",
                "// vulnerable line: 918: )",
                "// Line 919: ",
                "// Line 920:         _, progress_index, event_data_index = (",
                "// Line 921:             special_args(fn) if fn else (None, None, None)",
                "// vulnerable line: 922: )",
                "// Line 923:         self.fns.append(",
                "// Line 924:             BlockFunction(",
                "// Line 925:                 fn,",
                "// Line 926:                 inputs,",
                "// Line 927:                 outputs,",
                "// Line 928:                 preprocess,",
                "// Line 929:                 postprocess,",
                "// Line 930:                 inputs_as_dict=inputs_as_dict,",
                "// Line 931:                 concurrency_limit=concurrency_limit,",
                "// Line 932:                 concurrency_id=concurrency_id,",
                "// Line 933:                 batch=batch,",
                "// Line 934:                 max_batch_size=max_batch_size,",
                "// Line 935:                 tracks_progress=progress_index is not None,",
                "// vulnerable line: 936: )",
                "// vulnerable line: 937: )",
                "// Line 938: ",
                "// Line 939:         # If api_name is None or empty string, use the function name",
                "// Line 940:         if api_name is None or isinstance(api_name, str) and api_name.strip() == \"\":",
                "// Line 941:             if fn is not None:",
                "// Line 942:                 if not hasattr(fn, \"__name__\"):",
                "// Line 943:                     if hasattr(fn, \"__class__\") and hasattr(fn.__class__, \"__name__\"):",
                "// Line 944:                         name = fn.__class__.__name__",
                "// Line 945:                     else:",
                "// Line 946:                         name = \"unnamed\"",
                "// Line 947:                 else:",
                "// Line 948:                     name = fn.__name__",
                "// Line 949:                 api_name = \"\".join(",
                "// Line 950:                     [s for s in name if s not in set(string.punctuation) - {\"-\", \"_\"}]",
                "// vulnerable line: 951: )",
                "// Line 952:             elif js is not None:",
                "// Line 953:                 api_name = \"js_fn\"",
                "// Line 954:                 show_api = False",
                "// Line 955:             else:",
                "// Line 956:                 api_name = \"unnamed\"",
                "// Line 957:                 show_api = False",
                "// Line 958: ",
                "// Line 959:         if api_name is not False:",
                "// Line 960:             api_name = utils.append_unique_suffix(",
                "// Line 961:                 api_name, [dep[\"api_name\"] for dep in self.dependencies]",
                "// vulnerable line: 962: )",
                "// Line 963:         else:",
                "// Line 964:             show_api = False",
                "// Line 965: ",
                "// Line 966:         # The `show_api` parameter is False if: (1) the user explicitly sets it (2) the user sets `api_name` to False",
                "// Line 967:         # or (3) the user sets `fn` to None (there's no backend function)",
                "// Line 968: ",
                "// Line 969:         if collects_event_data is None:",
                "// Line 970:             collects_event_data = event_data_index is not None",
                "// Line 971: ",
                "// Line 972:         dependency = {",
                "// Line 996:             \"show_api\": show_api,",
                "// Line 997:         }",
                "// Line 998:         self.dependencies.append(dependency)",
                "// Line 999:         return dependency, len(self.dependencies) - 1",
                "// Line 1000: ",
                "// Line 1001:     def render(self):",
                "// Line 1002:         if Context.root_block is not None:",
                "// Line 1003:             if self._id in Context.root_block.blocks:",
                "// Line 1004:                 raise DuplicateBlockError(",
                "// Line 1005:                     f\"A block with id: {self._id} has already been rendered in the current Blocks.\"",
                "// vulnerable line: 1006: )",
                "// Line 1007:             overlapping_ids = set(Context.root_block.blocks).intersection(self.blocks)",
                "// Line 1008:             for id in overlapping_ids:",
                "// Line 1009:                 # State components are allowed to be reused between Blocks",
                "// Line 1010:                 if not isinstance(self.blocks[id], components.State):",
                "// Line 1011:                     raise DuplicateBlockError(",
                "// Line 1012:                         \"At least one block in this Blocks has already been rendered.\"",
                "// vulnerable line: 1013: )",
                "// Line 1014: ",
                "// Line 1015:             Context.root_block.blocks.update(self.blocks)",
                "// Line 1016:             Context.root_block.fns.extend(self.fns)",
                "// Line 1017:             dependency_offset = len(Context.root_block.dependencies)",
                "// Line 1018:             for i, dependency in enumerate(self.dependencies):",
                "// Line 1019:                 api_name = dependency[\"api_name\"]",
                "// Line 1020:                 if api_name is not None and api_name is not False:",
                "// Line 1021:                     api_name_ = utils.append_unique_suffix(",
                "// Line 1022:                         api_name,",
                "// Line 1023:                         [dep[\"api_name\"] for dep in Context.root_block.dependencies],",
                "// vulnerable line: 1024: )",
                "// Line 1025:                     if api_name != api_name_:",
                "// Line 1026:                         dependency[\"api_name\"] = api_name_",
                "// Line 1027:                 dependency[\"cancels\"] = [",
                "// Line 1028:                     c + dependency_offset for c in dependency[\"cancels\"]",
                "// Line 1029:                 ]",
                "// Line 1030:                 if dependency.get(\"trigger_after\") is not None:",
                "// Line 1031:                     dependency[\"trigger_after\"] += dependency_offset",
                "// Line 1032:                 # Recreate the cancel function so that it has the latest",
                "// Line 1033:                 # dependency fn indices. This is necessary to properly cancel",
                "// Line 1034:                 # events in the backend",
                "// Line 1037:                         Context.root_block.dependencies[i]",
                "// Line 1038:                         for i in dependency[\"cancels\"]",
                "// Line 1039:                     ]",
                "// Line 1040:                     new_fn = BlockFunction(",
                "// Line 1041:                         get_cancel_function(updated_cancels)[0],",
                "// Line 1042:                         [],",
                "// Line 1043:                         [],",
                "// Line 1044:                         False,",
                "// Line 1045:                         True,",
                "// Line 1046:                         False,",
                "// vulnerable line: 1047: )",
                "// Line 1048:                     Context.root_block.fns[dependency_offset + i] = new_fn",
                "// Line 1049:                 Context.root_block.dependencies.append(dependency)",
                "// Line 1050:             Context.root_block.temp_file_sets.extend(self.temp_file_sets)",
                "// Line 1051:             Context.root_block.proxy_urls.update(self.proxy_urls)",
                "// Line 1052: ",
                "// Line 1053:         if Context.block is not None:",
                "// Line 1054:             Context.block.children.extend(self.children)",
                "// Line 1055:         return self",
                "// Line 1056: ",
                "// Line 1057:     def is_callable(self, fn_index: int = 0) -> bool:",
                "// Line 1086:         api_name: The api_name of the dependency to call. Will take precedence over fn_index.",
                "// Line 1087:         \"\"\"",
                "// Line 1088:         if api_name is not None:",
                "// Line 1089:             inferred_fn_index = next(",
                "// Line 1090:                 (",
                "// Line 1091:                     i",
                "// Line 1092:                     for i, d in enumerate(self.dependencies)",
                "// Line 1093:                     if d.get(\"api_name\") == api_name",
                "// Line 1094:                 ),",
                "// Line 1095:                 None,",
                "// vulnerable line: 1096: )",
                "// Line 1097:             if inferred_fn_index is None:",
                "// Line 1098:                 raise InvalidApiNameError(",
                "// Line 1099:                     f\"Cannot find a function with api_name {api_name}\"",
                "// vulnerable line: 1100: )",
                "// Line 1101:             fn_index = inferred_fn_index",
                "// Line 1102:         if not (self.is_callable(fn_index)):",
                "// Line 1103:             raise ValueError(",
                "// Line 1104:                 \"This function is not callable because it is either stateful or is a generator. Please use the .launch() method instead to create an interactive user interface.\"",
                "// vulnerable line: 1105: )",
                "// Line 1106: ",
                "// Line 1107:         inputs = list(inputs)",
                "// Line 1108:         processed_inputs = self.serialize_data(fn_index, inputs)",
                "// Line 1109:         batch = self.dependencies[fn_index][\"batch\"]",
                "// Line 1110:         if batch:",
                "// Line 1111:             processed_inputs = [[inp] for inp in processed_inputs]",
                "// Line 1112: ",
                "// Line 1113:         outputs = client_utils.synchronize_async(",
                "// Line 1114:             self.process_api,",
                "// Line 1115:             fn_index=fn_index,",
                "// Line 1116:             inputs=processed_inputs,",
                "// Line 1117:             request=None,",
                "// Line 1118:             state={},",
                "// vulnerable line: 1119: )",
                "// Line 1120:         outputs = outputs[\"data\"]",
                "// Line 1121: ",
                "// Line 1122:         if batch:",
                "// Line 1123:             outputs = [out[0] for out in outputs]",
                "// Line 1124: ",
                "// Line 1125:         outputs = self.deserialize_data(fn_index, outputs)",
                "// Line 1126:         processed_outputs = utils.resolve_singleton(outputs)",
                "// Line 1127: ",
                "// Line 1128:         return processed_outputs",
                "// Line 1129: ",
                "// Line 1153:         is_generating = False",
                "// Line 1154:         request = requests[0] if isinstance(requests, list) else requests",
                "// Line 1155:         start = time.time()",
                "// Line 1156: ",
                "// Line 1157:         fn = utils.get_function_with_locals(",
                "// Line 1158:             fn=block_fn.fn,",
                "// Line 1159:             blocks=self,",
                "// Line 1160:             event_id=event_id,",
                "// Line 1161:             in_event_listener=in_event_listener,",
                "// Line 1162:             request=request,",
                "// vulnerable line: 1163: )",
                "// Line 1164: ",
                "// Line 1165:         if iterator is None:  # If not a generator function that has already run",
                "// Line 1166:             if block_fn.inputs_as_dict:",
                "// Line 1167:                 processed_input = [dict(zip(block_fn.inputs, processed_input))]",
                "// Line 1168: ",
                "// Line 1169:             processed_input, progress_index, _ = special_args(",
                "// Line 1170:                 block_fn.fn, processed_input, request, event_data",
                "// vulnerable line: 1171: )",
                "// Line 1172:             progress_tracker = (",
                "// Line 1173:                 processed_input[progress_index] if progress_index is not None else None",
                "// vulnerable line: 1174: )",
                "// Line 1175: ",
                "// Line 1176:             if progress_tracker is not None and progress_index is not None:",
                "// Line 1177:                 progress_tracker, fn = create_tracker(fn, progress_tracker.track_tqdm)",
                "// Line 1178:                 processed_input[progress_index] = progress_tracker",
                "// Line 1179: ",
                "// Line 1180:             if inspect.iscoroutinefunction(fn):",
                "// Line 1181:                 prediction = await fn(*processed_input)",
                "// Line 1182:             else:",
                "// Line 1183:                 prediction = await anyio.to_thread.run_sync(",
                "// Line 1184:                     fn, *processed_input, limiter=self.limiter",
                "// vulnerable line: 1185: )",
                "// Line 1186:         else:",
                "// Line 1187:             prediction = None",
                "// Line 1188: ",
                "// Line 1189:         if inspect.isgeneratorfunction(fn) or inspect.isasyncgenfunction(fn):",
                "// Line 1190:             try:",
                "// Line 1191:                 if iterator is None:",
                "// Line 1192:                     iterator = cast(AsyncIterator[Any], prediction)",
                "// Line 1193:                 if inspect.isgenerator(iterator):",
                "// Line 1194:                     iterator = utils.SyncToAsyncIterator(iterator, self.limiter)",
                "// Line 1195:                 prediction = await utils.async_iteration(iterator)",
                "// Line 1196:                 is_generating = True",
                "// Line 1197:             except StopAsyncIteration:",
                "// Line 1198:                 n_outputs = len(self.dependencies[fn_index].get(\"outputs\"))",
                "// Line 1199:                 prediction = (",
                "// Line 1200:                     components._Keywords.FINISHED_ITERATING",
                "// Line 1201:                     if n_outputs == 1",
                "// Line 1202:                     else (components._Keywords.FINISHED_ITERATING,) * n_outputs",
                "// vulnerable line: 1203: )",
                "// Line 1204:                 iterator = None",
                "// Line 1205: ",
                "// Line 1206:         duration = time.time() - start",
                "// Line 1207: ",
                "// Line 1208:         return {",
                "// Line 1209:             \"prediction\": prediction,",
                "// Line 1210:             \"duration\": duration,",
                "// Line 1211:             \"is_generating\": is_generating,",
                "// Line 1212:             \"iterator\": iterator,",
                "// Line 1213:         }",
                "// Line 1222:         for i, input_id in enumerate(dependency[\"inputs\"]):",
                "// Line 1223:             try:",
                "// Line 1224:                 block = self.blocks[input_id]",
                "// Line 1225:             except KeyError as e:",
                "// Line 1226:                 raise InvalidBlockError(",
                "// Line 1227:                     f\"Input component with id {input_id} used in {dependency['trigger']}() event is not defined in this gr.Blocks context. You are allowed to nest gr.Blocks contexts, but there must be a gr.Blocks context that contains all components and events.\"",
                "// Line 1228:                 ) from e",
                "// Line 1229:             if not isinstance(block, components.Component):",
                "// Line 1230:                 raise InvalidComponentError(",
                "// Line 1231:                     f\"{block.__class__} Component with id {input_id} not a valid input component.\"",
                "// vulnerable line: 1232: )",
                "// Line 1233:             api_info = block.api_info()",
                "// Line 1234:             if client_utils.value_is_file(api_info):",
                "// Line 1235:                 serialized_input = client_utils.traverse(",
                "// Line 1236:                     inputs[i],",
                "// Line 1237:                     format_file,",
                "// Line 1238:                     lambda s: client_utils.is_filepath(s) or client_utils.is_url(s),",
                "// vulnerable line: 1239: )",
                "// Line 1240:             else:",
                "// Line 1241:                 serialized_input = inputs[i]",
                "// Line 1242:             processed_input.append(serialized_input)",
                "// Line 1243: ",
                "// Line 1244:         return processed_input",
                "// Line 1245: ",
                "// Line 1246:     def deserialize_data(self, fn_index: int, outputs: list[Any]) -> list[Any]:",
                "// Line 1247:         dependency = self.dependencies[fn_index]",
                "// Line 1248:         predictions = []",
                "// Line 1249: ",
                "// Line 1250:         for o, output_id in enumerate(dependency[\"outputs\"]):",
                "// Line 1251:             try:",
                "// Line 1252:                 block = self.blocks[output_id]",
                "// Line 1253:             except KeyError as e:",
                "// Line 1254:                 raise InvalidBlockError(",
                "// Line 1255:                     f\"Output component with id {output_id} used in {dependency['trigger']}() event not found in this gr.Blocks context. You are allowed to nest gr.Blocks contexts, but there must be a gr.Blocks context that contains all components and events.\"",
                "// Line 1256:                 ) from e",
                "// Line 1257:             if not isinstance(block, components.Component):",
                "// Line 1258:                 raise InvalidComponentError(",
                "// Line 1259:                     f\"{block.__class__} Component with id {output_id} not a valid output component.\"",
                "// vulnerable line: 1260: )",
                "// Line 1261: ",
                "// Line 1262:             deserialized = client_utils.traverse(",
                "// Line 1263:                 outputs[o], lambda s: s[\"path\"], client_utils.is_file_obj",
                "// vulnerable line: 1264: )",
                "// Line 1265:             predictions.append(deserialized)",
                "// Line 1266: ",
                "// Line 1267:         return predictions",
                "// Line 1268: ",
                "// Line 1269:     def validate_inputs(self, fn_index: int, inputs: list[Any]):",
                "// Line 1270:         block_fn = self.fns[fn_index]",
                "// Line 1271:         dependency = self.dependencies[fn_index]",
                "// Line 1272: ",
                "// Line 1273:         dep_inputs = dependency[\"inputs\"]",
                "// Line 1274: ",
                "// Line 1275:         # This handles incorrect inputs when args are changed by a JS function",
                "// Line 1276:         # Only check not enough args case, ignore extra arguments (for now)",
                "// Line 1277:         # TODO: make this stricter?",
                "// Line 1278:         if len(inputs) < len(dep_inputs):",
                "// Line 1279:             name = (",
                "// Line 1280:                 f\" ({block_fn.name})\"",
                "// Line 1281:                 if block_fn.name and block_fn.name != \"<lambda>\"",
                "// Line 1282:                 else \"\"",
                "// vulnerable line: 1283: )",
                "// Line 1284: ",
                "// Line 1285:             wanted_args = []",
                "// Line 1286:             received_args = []",
                "// Line 1287:             for input_id in dep_inputs:",
                "// Line 1288:                 block = self.blocks[input_id]",
                "// Line 1289:                 wanted_args.append(str(block))",
                "// Line 1290:             for inp in inputs:",
                "// Line 1291:                 v = f'\"{inp}\"' if isinstance(inp, str) else str(inp)",
                "// Line 1292:                 received_args.append(v)",
                "// Line 1293: ",
                "// Line 1295:             received = \", \".join(received_args)",
                "// Line 1296: ",
                "// Line 1297:             # JS func didn't pass enough arguments",
                "// Line 1298:             raise ValueError(",
                "// Line 1299:                 f\"\"\"An event handler{name} didn't receive enough input values (needed: {len(dep_inputs)}, got: {len(inputs)}).",
                "// Line 1300: Check if the event handler calls a Javascript function, and make sure its return value is correct.",
                "// Line 1301: Wanted inputs:",
                "// Line 1302:     [{wanted}]",
                "// Line 1303: Received inputs:",
                "// Line 1304:     [{received}]\"\"\"",
                "// vulnerable line: 1305: )",
                "// Line 1306: ",
                "// Line 1307:     def preprocess_data(",
                "// vulnerable line: 1308: self, fn_index: int, inputs: list[Any], state: SessionState | None",
                "// Line 1309:     ):",
                "// Line 1310:         state = state or SessionState(self)",
                "// Line 1311:         block_fn = self.fns[fn_index]",
                "// Line 1312:         dependency = self.dependencies[fn_index]",
                "// Line 1313: ",
                "// Line 1314:         self.validate_inputs(fn_index, inputs)",
                "// Line 1315: ",
                "// Line 1316:         if block_fn.preprocess:",
                "// Line 1317:             processed_input = []",
                "// Line 1318:             for i, input_id in enumerate(dependency[\"inputs\"]):",
                "// Line 1319:                 try:",
                "// Line 1320:                     block = self.blocks[input_id]",
                "// Line 1321:                 except KeyError as e:",
                "// Line 1322:                     raise InvalidBlockError(",
                "// Line 1323:                         f\"Input component with id {input_id} used in {dependency['trigger']}() event not found in this gr.Blocks context. You are allowed to nest gr.Blocks contexts, but there must be a gr.Blocks context that contains all components and events.\"",
                "// Line 1324:                     ) from e",
                "// Line 1325:                 if not isinstance(block, components.Component):",
                "// Line 1326:                     raise InvalidComponentError(",
                "// Line 1327:                         f\"{block.__class__} Component with id {input_id} not a valid input component.\"",
                "// vulnerable line: 1328: )",
                "// Line 1329:                 if getattr(block, \"stateful\", False):",
                "// Line 1330:                     processed_input.append(state[input_id])",
                "// Line 1331:                 else:",
                "// Line 1332:                     if input_id in state:",
                "// Line 1333:                         block = state[input_id]",
                "// Line 1334:                     inputs_cached = processing_utils.move_files_to_cache(",
                "// vulnerable line: 1335: inputs[i], block, add_urls=True",
                "// vulnerable line: 1336: )",
                "// Line 1337:                     if getattr(block, \"data_model\", None) and inputs_cached is not None:",
                "// Line 1338:                         if issubclass(block.data_model, GradioModel):  # type: ignore",
                "// Line 1339:                             inputs_cached = block.data_model(**inputs_cached)  # type: ignore",
                "// Line 1340:                         elif issubclass(block.data_model, GradioRootModel):  # type: ignore",
                "// Line 1341:                             inputs_cached = block.data_model(root=inputs_cached)  # type: ignore",
                "// Line 1342:                     processed_input.append(block.preprocess(inputs_cached))",
                "// Line 1343:         else:",
                "// Line 1344:             processed_input = inputs",
                "// Line 1345:         return processed_input",
                "// Line 1346: ",
                "// Line 1351:         dep_outputs = dependency[\"outputs\"]",
                "// Line 1352: ",
                "// Line 1353:         if not isinstance(predictions, (list, tuple)):",
                "// Line 1354:             predictions = [predictions]",
                "// Line 1355: ",
                "// Line 1356:         if len(predictions) < len(dep_outputs):",
                "// Line 1357:             name = (",
                "// Line 1358:                 f\" ({block_fn.name})\"",
                "// Line 1359:                 if block_fn.name and block_fn.name != \"<lambda>\"",
                "// Line 1360:                 else \"\"",
                "// vulnerable line: 1361: )",
                "// Line 1362: ",
                "// Line 1363:             wanted_args = []",
                "// Line 1364:             received_args = []",
                "// Line 1365:             for output_id in dep_outputs:",
                "// Line 1366:                 block = self.blocks[output_id]",
                "// Line 1367:                 wanted_args.append(str(block))",
                "// Line 1368:             for pred in predictions:",
                "// Line 1369:                 v = f'\"{pred}\"' if isinstance(pred, str) else str(pred)",
                "// Line 1370:                 received_args.append(v)",
                "// Line 1371: ",
                "// Line 1372:             wanted = \", \".join(wanted_args)",
                "// Line 1373:             received = \", \".join(received_args)",
                "// Line 1374: ",
                "// Line 1375:             raise ValueError(",
                "// Line 1376:                 f\"\"\"An event handler{name} didn't receive enough output values (needed: {len(dep_outputs)}, received: {len(predictions)}).",
                "// Line 1377: Wanted outputs:",
                "// Line 1378:     [{wanted}]",
                "// Line 1379: Received outputs:",
                "// Line 1380:     [{received}]\"\"\"",
                "// vulnerable line: 1381: )",
                "// Line 1382: ",
                "// Line 1383:     def postprocess_data(",
                "// Line 1384:         self, fn_index: int, predictions: list | dict, state: SessionState | None",
                "// Line 1385:     ):",
                "// Line 1386:         state = state or SessionState(self)",
                "// Line 1387:         block_fn = self.fns[fn_index]",
                "// Line 1388:         dependency = self.dependencies[fn_index]",
                "// Line 1389:         batch = dependency[\"batch\"]",
                "// Line 1390: ",
                "// Line 1391:         if isinstance(predictions, dict) and len(predictions) > 0:",
                "// Line 1392:             predictions = convert_component_dict_to_list(",
                "// Line 1393:                 dependency[\"outputs\"], predictions",
                "// vulnerable line: 1394: )",
                "// Line 1395: ",
                "// Line 1396:         if len(dependency[\"outputs\"]) == 1 and not (batch):",
                "// Line 1397:             predictions = [",
                "// Line 1398:                 predictions,",
                "// Line 1399:             ]",
                "// Line 1400: ",
                "// Line 1401:         self.validate_outputs(fn_index, predictions)  # type: ignore",
                "// Line 1402: ",
                "// Line 1403:         output = []",
                "// Line 1404:         for i, output_id in enumerate(dependency[\"outputs\"]):",
                "// Line 1423:                 if not utils.is_update(predictions[i]):",
                "// Line 1424:                     state[output_id] = predictions[i]",
                "// Line 1425:                 output.append(None)",
                "// Line 1426:             else:",
                "// Line 1427:                 prediction_value = predictions[i]",
                "// Line 1428:                 if utils.is_update(",
                "// Line 1429:                     prediction_value",
                "// Line 1430:                 ):  # if update is passed directly (deprecated), remove Nones",
                "// Line 1431:                     prediction_value = utils.delete_none(",
                "// Line 1432:                         prediction_value, skip_value=True",
                "// vulnerable line: 1433: )",
                "// Line 1434: ",
                "// Line 1435:                 if isinstance(prediction_value, Block):",
                "// Line 1436:                     prediction_value = prediction_value.constructor_args.copy()",
                "// Line 1437:                     prediction_value[\"__type__\"] = \"update\"",
                "// Line 1438:                 if utils.is_update(prediction_value):",
                "// Line 1439:                     if output_id in state:",
                "// Line 1440:                         kwargs = state[output_id].constructor_args.copy()",
                "// Line 1441:                     else:",
                "// Line 1442:                         kwargs = self.blocks[output_id].constructor_args.copy()",
                "// Line 1443:                     kwargs.update(prediction_value)",
                "// Line 1444:                     kwargs.pop(\"value\", None)",
                "// Line 1445:                     kwargs.pop(\"__type__\")",
                "// Line 1446:                     kwargs[\"render\"] = False",
                "// Line 1447:                     state[output_id] = self.blocks[output_id].__class__(**kwargs)",
                "// Line 1448: ",
                "// Line 1449:                     prediction_value = postprocess_update_dict(",
                "// Line 1450:                         block=state[output_id],",
                "// Line 1451:                         update_dict=prediction_value,",
                "// Line 1452:                         postprocess=block_fn.postprocess,",
                "// vulnerable line: 1453: )",
                "// Line 1454:                 elif block_fn.postprocess:",
                "// Line 1455:                     if not isinstance(block, components.Component):",
                "// Line 1456:                         raise InvalidComponentError(",
                "// Line 1457:                             f\"{block.__class__} Component with id {output_id} not a valid output component.\"",
                "// vulnerable line: 1458: )",
                "// Line 1459:                     if output_id in state:",
                "// Line 1460:                         block = state[output_id]",
                "// Line 1461:                     prediction_value = block.postprocess(prediction_value)",
                "// Line 1462: ",
                "// Line 1463:                 outputs_cached = processing_utils.move_files_to_cache(",
                "// Line 1464:                     prediction_value,",
                "// Line 1465:                     block,  # type: ignore",
                "// Line 1466:                     postprocess=True,",
                "// Line 1467:                     add_urls=True,",
                "// vulnerable line: 1468: )",
                "// Line 1469:                 output.append(outputs_cached)",
                "// Line 1470: ",
                "// Line 1471:         return output",
                "// Line 1472: ",
                "// Line 1473:     def handle_streaming_outputs(",
                "// Line 1474:         self,",
                "// Line 1475:         fn_index: int,",
                "// Line 1476:         data: list,",
                "// Line 1477:         session_hash: str | None,",
                "// Line 1478:         run: int | None,",
                "// Line 1482:         if run not in self.pending_streams[session_hash]:",
                "// Line 1483:             self.pending_streams[session_hash][run] = {}",
                "// Line 1484:         stream_run = self.pending_streams[session_hash][run]",
                "// Line 1485: ",
                "// Line 1486:         for i, output_id in enumerate(self.dependencies[fn_index][\"outputs\"]):",
                "// Line 1487:             block = self.blocks[output_id]",
                "// Line 1488:             if isinstance(block, components.StreamingOutput) and block.streaming:",
                "// Line 1489:                 first_chunk = output_id not in stream_run",
                "// Line 1490:                 binary_data, output_data = block.stream_output(",
                "// Line 1491:                     data[i], f\"{session_hash}/{run}/{output_id}\", first_chunk",
                "// vulnerable line: 1492: )",
                "// Line 1493:                 if first_chunk:",
                "// Line 1494:                     stream_run[output_id] = []",
                "// Line 1495:                 self.pending_streams[session_hash][run][output_id].append(binary_data)",
                "// Line 1496:                 data[i] = output_data",
                "// Line 1497:         return data",
                "// Line 1498: ",
                "// Line 1499:     def handle_streaming_diffs(",
                "// Line 1500:         self,",
                "// Line 1501:         fn_index: int,",
                "// Line 1502:         data: list,",
                "// Line 1521:             else:",
                "// Line 1522:                 prev_chunk = last_diffs[i]",
                "// Line 1523:                 last_diffs[i] = data[i]",
                "// Line 1524:                 data[i] = utils.diff(prev_chunk, data[i])",
                "// Line 1525: ",
                "// Line 1526:         if final:",
                "// Line 1527:             del self.pending_diff_streams[session_hash][run]",
                "// Line 1528: ",
                "// Line 1529:         return data",
                "// Line 1530: ",
                "// vulnerable line: 1531: def run_fn_batch(self, fn, batch, fn_index, state):",
                "// vulnerable line: 1532: return [fn(fn_index, list(i), state) for i in zip(*batch)]",
                "// Line 1533: ",
                "// Line 1534:     async def process_api(",
                "// Line 1535:         self,",
                "// Line 1536:         fn_index: int,",
                "// Line 1537:         inputs: list[Any],",
                "// Line 1538:         state: SessionState | None = None,",
                "// Line 1539:         request: routes.Request | list[routes.Request] | None = None,",
                "// Line 1540:         iterator: AsyncIterator | None = None,",
                "// Line 1541:         session_hash: str | None = None,",
                "// Line 1542:         event_id: str | None = None,",
                "// Line 1563:             max_batch_size = self.dependencies[fn_index][\"max_batch_size\"]",
                "// Line 1564:             batch_sizes = [len(inp) for inp in inputs]",
                "// Line 1565:             batch_size = batch_sizes[0]",
                "// Line 1566:             if inspect.isasyncgenfunction(block_fn.fn) or inspect.isgeneratorfunction(",
                "// Line 1567:                 block_fn.fn",
                "// Line 1568:             ):",
                "// Line 1569:                 raise ValueError(\"Gradio does not support generators in batch mode.\")",
                "// Line 1570:             if not all(x == batch_size for x in batch_sizes):",
                "// Line 1571:                 raise ValueError(",
                "// Line 1572:                     f\"All inputs to a batch function must have the same length but instead have sizes: {batch_sizes}.\"",
                "// vulnerable line: 1573: )",
                "// Line 1574:             if batch_size > max_batch_size:",
                "// Line 1575:                 raise ValueError(",
                "// Line 1576:                     f\"Batch size ({batch_size}) exceeds the max_batch_size for this function ({max_batch_size})\"",
                "// vulnerable line: 1577: )",
                "// Line 1578:             inputs = await anyio.to_thread.run_sync(",
                "// Line 1579:                 self.run_fn_batch,",
                "// Line 1580:                 self.preprocess_data,",
                "// Line 1581:                 inputs,",
                "// Line 1582:                 fn_index,",
                "// Line 1583:                 state,",
                "// Line 1584:                 limiter=self.limiter,",
                "// vulnerable line: 1585: )",
                "// Line 1586:             result = await self.call_function(",
                "// Line 1587:                 fn_index,",
                "// Line 1588:                 list(zip(*inputs)),",
                "// Line 1589:                 None,",
                "// Line 1590:                 request,",
                "// Line 1591:                 event_id,",
                "// Line 1592:                 event_data,",
                "// Line 1593:                 in_event_listener,",
                "// vulnerable line: 1594: )",
                "// Line 1595:             preds = result[\"prediction\"]",
                "// Line 1596:             data = await anyio.to_thread.run_sync(",
                "// Line 1597:                 self.run_fn_batch,",
                "// Line 1598:                 self.postprocess_data,",
                "// Line 1599:                 preds,",
                "// Line 1600:                 fn_index,",
                "// Line 1601:                 state,",
                "// Line 1602:                 limiter=self.limiter,",
                "// vulnerable line: 1603: )",
                "// Line 1604:             data = list(zip(*data))",
                "// Line 1605:             is_generating, iterator = None, None",
                "// Line 1606:         else:",
                "// Line 1607:             old_iterator = iterator",
                "// Line 1608:             if old_iterator:",
                "// Line 1609:                 inputs = []",
                "// Line 1610:             else:",
                "// Line 1611:                 inputs = await anyio.to_thread.run_sync(",
                "// vulnerable line: 1612: self.preprocess_data, fn_index, inputs, state, limiter=self.limiter",
                "// vulnerable line: 1613: )",
                "// Line 1614:             was_generating = old_iterator is not None",
                "// Line 1615:             result = await self.call_function(",
                "// Line 1616:                 fn_index,",
                "// Line 1617:                 inputs,",
                "// Line 1618:                 old_iterator,",
                "// Line 1619:                 request,",
                "// Line 1620:                 event_id,",
                "// Line 1621:                 event_data,",
                "// Line 1622:                 in_event_listener,",
                "// vulnerable line: 1623: )",
                "// Line 1624:             data = await anyio.to_thread.run_sync(",
                "// Line 1625:                 self.postprocess_data,",
                "// Line 1626:                 fn_index,  # type: ignore",
                "// Line 1627:                 result[\"prediction\"],",
                "// Line 1628:                 state,",
                "// Line 1629:                 limiter=self.limiter,",
                "// vulnerable line: 1630: )",
                "// Line 1631:             is_generating, iterator = result[\"is_generating\"], result[\"iterator\"]",
                "// Line 1632:             if is_generating or was_generating:",
                "// Line 1633:                 run = id(old_iterator) if was_generating else id(iterator)",
                "// Line 1634:                 data = self.handle_streaming_outputs(",
                "// Line 1635:                     fn_index,",
                "// Line 1636:                     data,",
                "// Line 1637:                     session_hash=session_hash,",
                "// Line 1638:                     run=run,",
                "// vulnerable line: 1639: )",
                "// Line 1640:                 data = self.handle_streaming_diffs(",
                "// Line 1641:                     fn_index,",
                "// Line 1642:                     data,",
                "// Line 1643:                     session_hash=session_hash,",
                "// Line 1644:                     run=run,",
                "// Line 1645:                     final=not is_generating,",
                "// vulnerable line: 1646: )",
                "// Line 1647: ",
                "// Line 1648:         block_fn.total_runtime += result[\"duration\"]",
                "// Line 1649:         block_fn.total_runs += 1",
                "// Line 1650:         return {",
                "// Line 1651:             \"data\": data,",
                "// Line 1652:             \"is_generating\": is_generating,",
                "// Line 1653:             \"iterator\": iterator,",
                "// Line 1654:             \"duration\": result[\"duration\"],",
                "// Line 1655:             \"average_duration\": block_fn.total_runtime / block_fn.total_runs,",
                "// Line 1656:         }",
                "// Line 1657: ",
                "// Line 1658:     def create_limiter(self):",
                "// Line 1659:         self.limiter = (",
                "// Line 1660:             None",
                "// Line 1661:             if self.max_threads == 40",
                "// Line 1662:             else CapacityLimiter(total_tokens=self.max_threads)",
                "// vulnerable line: 1663: )",
                "// Line 1664: ",
                "// Line 1665:     def get_config(self):",
                "// Line 1666:         return {\"type\": \"column\"}",
                "// Line 1667: ",
                "// Line 1668:     def get_config_file(self):",
                "// Line 1669:         config = {",
                "// Line 1670:             \"version\": routes.VERSION,",
                "// Line 1671:             \"mode\": self.mode,",
                "// Line 1672:             \"app_id\": self.app_id,",
                "// Line 1673:             \"dev_mode\": self.dev_mode,",
                "// Line 1713:         for _id, block in self.blocks.items():",
                "// Line 1714:             props = block.get_config() if hasattr(block, \"get_config\") else {}",
                "// Line 1715:             block_config = {",
                "// Line 1716:                 \"id\": _id,",
                "// Line 1717:                 \"type\": block.get_block_name(),",
                "// Line 1718:                 \"props\": utils.delete_none(props),",
                "// Line 1719:             }",
                "// Line 1720:             block_config[\"skip_api\"] = block.skip_api",
                "// Line 1721:             block_config[\"component_class_id\"] = getattr(",
                "// Line 1722:                 block, \"component_class_id\", None",
                "// vulnerable line: 1723: )",
                "// Line 1724: ",
                "// Line 1725:             if not block.skip_api:",
                "// Line 1726:                 block_config[\"api_info\"] = block.api_info()  # type: ignore",
                "// Line 1727:                 block_config[\"example_inputs\"] = block.example_inputs()  # type: ignore",
                "// Line 1728:             config[\"components\"].append(block_config)",
                "// Line 1729:         config[\"dependencies\"] = self.dependencies",
                "// Line 1730:         return config",
                "// Line 1731: ",
                "// Line 1732:     def __enter__(self):",
                "// Line 1733:         if Context.block is None:",
                "// Line 1788:             demo.queue(max_size=10)",
                "// Line 1789:             demo.launch()",
                "// Line 1790:         Example: (Interface)",
                "// Line 1791:             demo = gr.Interface(image_generator, gr.Textbox(), gr.Image())",
                "// Line 1792:             demo.queue(max_size=20)",
                "// Line 1793:             demo.launch()",
                "// Line 1794:         \"\"\"",
                "// Line 1795:         if concurrency_count:",
                "// Line 1796:             raise DeprecationWarning(",
                "// Line 1797:                 \"concurrency_count has been deprecated. Set the concurrency_limit directly on event listeners e.g. btn.click(fn, ..., concurrency_limit=10) or gr.Interface(concurrency_limit=10). If necessary, the total number of workers can be configured via `max_threads` in launch().\"",
                "// vulnerable line: 1798: )",
                "// Line 1799:         if api_open is not None:",
                "// Line 1800:             self.api_open = api_open",
                "// Line 1801:         if utils.is_zero_gpu_space():",
                "// Line 1802:             max_size = 1 if max_size is None else max_size",
                "// Line 1803:         self._queue = queueing.Queue(",
                "// Line 1804:             live_updates=status_update_rate == \"auto\",",
                "// Line 1805:             concurrency_count=self.max_threads,",
                "// Line 1806:             update_intervals=status_update_rate if status_update_rate != \"auto\" else 1,",
                "// Line 1807:             max_size=max_size,",
                "// Line 1808:             block_fns=self.fns,",
                "// Line 1809:             default_concurrency_limit=default_concurrency_limit,",
                "// vulnerable line: 1810: )",
                "// Line 1811:         self.config = self.get_config_file()",
                "// Line 1812:         self.app = routes.App.create_app(self)",
                "// Line 1813:         return self",
                "// Line 1814: ",
                "// Line 1815:     def validate_queue_settings(self):",
                "// Line 1816:         for dep in self.dependencies:",
                "// Line 1817:             for i in dep[\"cancels\"]:",
                "// Line 1818:                 if not self.queue_enabled_for_fn(i):",
                "// Line 1819:                     raise ValueError(",
                "// Line 1820:                         \"Queue needs to be enabled! \"",
                "// Line 1821:                         \"You may get this error by either 1) passing a function that uses the yield keyword \"",
                "// Line 1822:                         \"into an interface without enabling the queue or 2) defining an event that cancels \"",
                "// Line 1823:                         \"another event without enabling the queue. Both can be solved by calling .queue() \"",
                "// Line 1824:                         \"before .launch()\"",
                "// vulnerable line: 1825: )",
                "// Line 1826:             if dep[\"batch\"] and dep[\"queue\"] is False:",
                "// Line 1827:                 raise ValueError(\"In order to use batching, the queue must be enabled.\")",
                "// Line 1828: ",
                "// Line 1829:     def launch(",
                "// Line 1830:         self,",
                "// Line 1831:         inline: bool | None = None,",
                "// Line 1832:         inbrowser: bool = False,",
                "// Line 1833:         share: bool | None = None,",
                "// Line 1834:         debug: bool = False,",
                "// Line 1835:         max_threads: int = 40,",
                "// Line 1953:         self.max_threads = max_threads",
                "// Line 1954:         self._queue.max_thread_count = max_threads",
                "// Line 1955: ",
                "// Line 1956:         if self.is_running:",
                "// Line 1957:             if not isinstance(self.local_url, str):",
                "// Line 1958:                 raise ValueError(f\"Invalid local_url: {self.local_url}\")",
                "// Line 1959:             if not (quiet):",
                "// Line 1960:                 print(",
                "// Line 1961:                     \"Rerunning server... use `close()` to stop if you need to change `launch()` parameters.",
                "// Line 1962: ----\"",
                "// vulnerable line: 1963: )",
                "// Line 1964:         else:",
                "// Line 1965:             if wasm_utils.IS_WASM:",
                "// Line 1966:                 server_name = \"xxx\"",
                "// Line 1967:                 server_port = 99999",
                "// Line 1968:                 local_url = \"\"",
                "// Line 1969:                 server = None",
                "// Line 1970: ",
                "// Line 1971:                 # In the Wasm environment, we only need the app object",
                "// Line 1972:                 # which the frontend app will directly communicate with through the Worker API,",
                "// Line 1973:                 # and we don't need to start a server.",
                "// Line 1985:                     app,",
                "// Line 1986:                     server,",
                "// Line 1987:                 ) = networking.start_server(",
                "// Line 1988:                     self,",
                "// Line 1989:                     server_name,",
                "// Line 1990:                     server_port,",
                "// Line 1991:                     ssl_keyfile,",
                "// Line 1992:                     ssl_certfile,",
                "// Line 1993:                     ssl_keyfile_password,",
                "// Line 1994:                     app_kwargs=app_kwargs,",
                "// vulnerable line: 1995: )",
                "// Line 1996:             self.server_name = server_name",
                "// Line 1997:             self.local_url = local_url",
                "// Line 1998:             self.server_port = server_port",
                "// Line 1999:             self.server_app = (",
                "// Line 2000:                 self.app",
                "// Line 2001:             ) = app  # server_app is included for backwards compatibility",
                "// Line 2002:             self.server = server",
                "// Line 2003:             self.is_running = True",
                "// Line 2004:             self.is_colab = utils.colab_check()",
                "// Line 2005:             self.is_kaggle = utils.kaggle_check()",
                "// Line 2006:             self.share_server_address = share_server_address",
                "// Line 2007:             self.share_server_protocol = share_server_protocol or (",
                "// Line 2008:                 \"http\" if share_server_address is not None else \"https\"",
                "// vulnerable line: 2009: )",
                "// Line 2010: ",
                "// Line 2011:             self.protocol = (",
                "// Line 2012:                 \"https\"",
                "// Line 2013:                 if self.local_url.startswith(\"https\") or self.is_colab",
                "// Line 2014:                 else \"http\"",
                "// vulnerable line: 2015: )",
                "// Line 2016:             if not wasm_utils.IS_WASM and not self.is_colab:",
                "// Line 2017:                 print(",
                "// Line 2018:                     strings.en[\"RUNNING_LOCALLY_SEPARATED\"].format(",
                "// Line 2019:                         self.protocol, self.server_name, self.server_port",
                "// vulnerable line: 2020: )",
                "// vulnerable line: 2021: )",
                "// Line 2022: ",
                "// Line 2023:             self._queue.set_server_app(self.server_app)",
                "// Line 2024: ",
                "// Line 2025:             if not wasm_utils.IS_WASM:",
                "// Line 2026:                 # Cannot run async functions in background other than app's scope.",
                "// Line 2027:                 # Workaround by triggering the app endpoint",
                "// Line 2028:                 httpx.get(f\"{self.local_url}startup-events\", verify=ssl_verify)",
                "// Line 2029:             else:",
                "// Line 2030:                 # NOTE: One benefit of the code above dispatching `startup_events()` via a self HTTP request is",
                "// Line 2031:                 # that `self._queue.start()` is called in another thread which is managed by the HTTP server, `uvicorn`",
                "// Line 2036:                 self.startup_events()",
                "// Line 2037: ",
                "// Line 2038:         utils.launch_counter()",
                "// Line 2039:         self.is_sagemaker = utils.sagemaker_check()",
                "// Line 2040:         if share is None:",
                "// Line 2041:             if self.is_colab:",
                "// Line 2042:                 if not quiet:",
                "// Line 2043:                     print(",
                "// Line 2044:                         \"Setting queue=True in a Colab notebook requires sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).",
                "// Line 2045: \"",
                "// vulnerable line: 2046: )",
                "// Line 2047:                 self.share = True",
                "// Line 2048:             elif self.is_kaggle:",
                "// Line 2049:                 if not quiet:",
                "// Line 2050:                     print(",
                "// Line 2051:                         \"Kaggle notebooks require sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).",
                "// Line 2052: \"",
                "// vulnerable line: 2053: )",
                "// Line 2054:                 self.share = True",
                "// Line 2055:             elif self.is_sagemaker:",
                "// Line 2056:                 if not quiet:",
                "// Line 2057:                     print(",
                "// Line 2058:                         \"Sagemaker notebooks may require sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).",
                "// Line 2059: \"",
                "// vulnerable line: 2060: )",
                "// Line 2061:                 self.share = True",
                "// Line 2062:             else:",
                "// Line 2063:                 self.share = False",
                "// Line 2064:         else:",
                "// Line 2065:             self.share = share",
                "// Line 2066: ",
                "// Line 2067:         # If running in a colab or not able to access localhost,",
                "// Line 2068:         # a shareable link must be created.",
                "// Line 2069:         if (",
                "// Line 2070:             _frontend",
                "// Line 2071:             and not wasm_utils.IS_WASM",
                "// Line 2072:             and not networking.url_ok(self.local_url)",
                "// Line 2073:             and not self.share",
                "// Line 2074:         ):",
                "// Line 2075:             raise ValueError(",
                "// Line 2076:                 \"When localhost is not accessible, a shareable link must be created. Please set share=True or check your proxy settings to allow access to localhost.\"",
                "// vulnerable line: 2077: )",
                "// Line 2078: ",
                "// Line 2079:         if self.is_colab and not quiet:",
                "// Line 2080:             if debug:",
                "// Line 2081:                 print(strings.en[\"COLAB_DEBUG_TRUE\"])",
                "// Line 2082:             else:",
                "// Line 2083:                 print(strings.en[\"COLAB_DEBUG_FALSE\"])",
                "// Line 2084:             if not self.share:",
                "// Line 2085:                 print(strings.en[\"COLAB_WARNING\"].format(self.server_port))",
                "// Line 2086: ",
                "// Line 2087:         if self.share:",
                "// Line 2088:             if self.space_id:",
                "// Line 2089:                 warnings.warn(",
                "// Line 2090:                     \"Setting share=True is not supported on Hugging Face Spaces\"",
                "// vulnerable line: 2091: )",
                "// Line 2092:                 self.share = False",
                "// Line 2093:             if wasm_utils.IS_WASM:",
                "// Line 2094:                 warnings.warn(",
                "// Line 2095:                     \"Setting share=True is not supported in the Wasm environment\"",
                "// vulnerable line: 2096: )",
                "// Line 2097:                 self.share = False",
                "// Line 2098: ",
                "// Line 2099:         if self.share:",
                "// Line 2100:             try:",
                "// Line 2101:                 if self.share_url is None:",
                "// Line 2102:                     share_url = networking.setup_tunnel(",
                "// Line 2103:                         local_host=self.server_name,",
                "// Line 2104:                         local_port=self.server_port,",
                "// Line 2105:                         share_token=self.share_token,",
                "// Line 2106:                         share_server_address=self.share_server_address,",
                "// vulnerable line: 2107: )",
                "// Line 2108:                     parsed_url = urlparse(share_url)",
                "// Line 2109:                     self.share_url = urlunparse(",
                "// Line 2110:                         (self.share_server_protocol,) + parsed_url[1:]",
                "// vulnerable line: 2111: )",
                "// Line 2112:                 print(strings.en[\"SHARE_LINK_DISPLAY\"].format(self.share_url))",
                "// Line 2113:                 if not (quiet):",
                "// Line 2114:                     print(strings.en[\"SHARE_LINK_MESSAGE\"])",
                "// Line 2115:             except (RuntimeError, httpx.ConnectError):",
                "// Line 2116:                 if self.analytics_enabled:",
                "// Line 2117:                     analytics.error_analytics(\"Not able to set up tunnel\")",
                "// Line 2118:                 self.share_url = None",
                "// Line 2119:                 self.share = False",
                "// Line 2120:                 if Path(BINARY_PATH).exists():",
                "// Line 2121:                     print(strings.en[\"COULD_NOT_GET_SHARE_LINK\"])",
                "// Line 2122:                 else:",
                "// Line 2123:                     print(",
                "// Line 2124:                         strings.en[\"COULD_NOT_GET_SHARE_LINK_MISSING_FILE\"].format(",
                "// Line 2125:                             BINARY_PATH,",
                "// Line 2126:                             BINARY_URL,",
                "// Line 2127:                             BINARY_FILENAME,",
                "// Line 2128:                             BINARY_FOLDER,",
                "// vulnerable line: 2129: )",
                "// vulnerable line: 2130: )",
                "// Line 2131:         else:",
                "// Line 2132:             if not quiet and not wasm_utils.IS_WASM:",
                "// Line 2133:                 print(strings.en[\"PUBLIC_SHARE_TRUE\"])",
                "// Line 2134:             self.share_url = None",
                "// Line 2135: ",
                "// Line 2136:         if inbrowser and not wasm_utils.IS_WASM:",
                "// Line 2137:             link = self.share_url if self.share and self.share_url else self.local_url",
                "// Line 2138:             webbrowser.open(link)",
                "// Line 2139: ",
                "// Line 2140:         # Check if running in a Python notebook in which case, display inline",
                "// Line 2142:             inline = utils.ipython_check()",
                "// Line 2143:         if inline:",
                "// Line 2144:             try:",
                "// Line 2145:                 from IPython.display import HTML, Javascript, display  # type: ignore",
                "// Line 2146: ",
                "// Line 2147:                 if self.share and self.share_url:",
                "// Line 2148:                     while not networking.url_ok(self.share_url):",
                "// Line 2149:                         time.sleep(0.25)",
                "// Line 2150:                     artifact = HTML(",
                "// Line 2151:                         f'<div><iframe src=\"{self.share_url}\" width=\"{self.width}\" height=\"{self.height}\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>'",
                "// vulnerable line: 2152: )",
                "// Line 2153: ",
                "// Line 2154:                 elif self.is_colab:",
                "// Line 2155:                     # modified from /usr/local/lib/python3.7/dist-packages/google/colab/output/_util.py within Colab environment",
                "// Line 2156:                     code = \"\"\"(async (port, path, width, height, cache, element) => {",
                "// Line 2157:                         if (!google.colab.kernel.accessAllowed && !cache) {",
                "// Line 2158:                             return;",
                "// Line 2159:                         }",
                "// Line 2160:                         element.appendChild(document.createTextNode(''));",
                "// Line 2161:                         const url = await google.colab.kernel.proxyPort(port, {cache});",
                "// Line 2162: ",
                "// Line 2176:                         iframe.allow = \"autoplay; camera; microphone; clipboard-read; clipboard-write;\"",
                "// Line 2177:                         iframe.width = width;",
                "// Line 2178:                         iframe.style.border = 0;",
                "// Line 2179:                         element.appendChild(iframe);",
                "// Line 2180:                     })\"\"\" + \"({port}, {path}, {width}, {height}, {cache}, window.element)\".format(",
                "// Line 2181:                         port=json.dumps(self.server_port),",
                "// Line 2182:                         path=json.dumps(\"/\"),",
                "// Line 2183:                         width=json.dumps(self.width),",
                "// Line 2184:                         height=json.dumps(self.height),",
                "// Line 2185:                         cache=json.dumps(False),",
                "// vulnerable line: 2186: )",
                "// Line 2187: ",
                "// Line 2188:                     artifact = Javascript(code)",
                "// Line 2189:                 else:",
                "// Line 2190:                     artifact = HTML(",
                "// Line 2191:                         f'<div><iframe src=\"{self.local_url}\" width=\"{self.width}\" height=\"{self.height}\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>'",
                "// vulnerable line: 2192: )",
                "// Line 2193:                 self.artifact = artifact",
                "// Line 2194:                 display(artifact)",
                "// Line 2195:             except ImportError:",
                "// Line 2196:                 pass",
                "// Line 2197: ",
                "// Line 2198:         if getattr(self, \"analytics_enabled\", False):",
                "// Line 2199:             data = {",
                "// Line 2200:                 \"launch_method\": \"browser\" if inbrowser else \"inline\",",
                "// Line 2201:                 \"is_google_colab\": self.is_colab,",
                "// Line 2202:                 \"is_sharing_on\": self.share,",
                "// Line 2257:                 wandb.log(",
                "// Line 2258:                     {",
                "// Line 2259:                         \"Gradio panel\": wandb.Html(",
                "// Line 2260:                             '<iframe src=\"'",
                "// Line 2261:                             + self.share_url",
                "// Line 2262:                             + '\" width=\"'",
                "// Line 2263:                             + str(self.width)",
                "// Line 2264:                             + '\" height=\"'",
                "// Line 2265:                             + str(self.height)",
                "// Line 2266:                             + '\" frameBorder=\"0\"></iframe>'",
                "// vulnerable line: 2267: )",
                "// Line 2268:                     }",
                "// vulnerable line: 2269: )",
                "// Line 2270:             else:",
                "// Line 2271:                 print(",
                "// Line 2272:                     \"The WandB integration requires you to \"",
                "// Line 2273:                     \"`launch(share=True)` first.\"",
                "// vulnerable line: 2274: )",
                "// Line 2275:         if mlflow is not None:",
                "// Line 2276:             analytics_integration = \"MLFlow\"",
                "// Line 2277:             if self.share_url is not None:",
                "// Line 2278:                 mlflow.log_param(\"Gradio Interface Share Link\", self.share_url)",
                "// Line 2279:             else:",
                "// Line 2280:                 mlflow.log_param(\"Gradio Interface Local Link\", self.local_url)",
                "// Line 2281:         if self.analytics_enabled and analytics_integration:",
                "// Line 2282:             data = {\"integration\": analytics_integration}",
                "// Line 2283:             analytics.integration_analytics(data)",
                "// Line 2284: ",
                "// Line 2399:                     {",
                "// Line 2400:                         \"label\": label,",
                "// Line 2401:                         \"type\": info,",
                "// Line 2402:                         \"python_type\": {",
                "// Line 2403:                             \"type\": python_type,",
                "// Line 2404:                             \"description\": info.get(\"description\", \"\"),",
                "// Line 2405:                         },",
                "// Line 2406:                         \"component\": type.capitalize(),",
                "// Line 2407:                         \"example_input\": example,",
                "// Line 2408:                     }",
                "// vulnerable line: 2409: )",
                "// Line 2410: ",
                "// Line 2411:             outputs = dependency[\"outputs\"]",
                "// Line 2412:             for o in outputs:",
                "// Line 2413:                 for component in config[\"components\"]:",
                "// Line 2414:                     if component[\"id\"] == o:",
                "// Line 2415:                         break",
                "// Line 2416:                 else:",
                "// Line 2417:                     skip_endpoint = True  # if component not found, skip endpoint",
                "// Line 2418:                     break",
                "// Line 2419:                 type = component[\"type\"]",
                "// Line 2429:                 dependency_info[\"returns\"].append(",
                "// Line 2430:                     {",
                "// Line 2431:                         \"label\": label,",
                "// Line 2432:                         \"type\": info,",
                "// Line 2433:                         \"python_type\": {",
                "// Line 2434:                             \"type\": python_type,",
                "// Line 2435:                             \"description\": info.get(\"description\", \"\"),",
                "// Line 2436:                         },",
                "// Line 2437:                         \"component\": type.capitalize(),",
                "// Line 2438:                     }",
                "// vulnerable line: 2439: )",
                "// Line 2440: ",
                "// Line 2441:             if not skip_endpoint:",
                "// Line 2442:                 api_info[\"named_endpoints\"][",
                "// Line 2443:                     f\"/{dependency['api_name']}\"",
                "// Line 2444:                 ] = dependency_info",
                "// Line 2445: ",
                "// Line 2446:         return api_info"
            ]
        },
        {
            "filename_of_changes": "processing_utils.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "12",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 13: from pathlib import Path",
                "// Line 14: from typing import TYPE_CHECKING, Any, Literal",
                "// Line 15: ",
                "// Line 16: import httpx",
                "// Line 17: import numpy as np",
                "// Line 18: from gradio_client import utils as client_utils",
                "// Line 19: from PIL import Image, ImageOps, PngImagePlugin",
                "// Line 20: ",
                "// Line 21: from gradio import wasm_utils",
                "// Line 22: from gradio.data_classes import FileData, GradioModel, GradioRootModel",
                "// vulnerable line: 23: from gradio.utils import abspath",
                "// Line 24: ",
                "// Line 25: with warnings.catch_warnings():",
                "// Line 26:     warnings.simplefilter(\"ignore\")  # Ignore pydub warning if ffmpeg is not installed",
                "// Line 27:     from pydub import AudioSegment",
                "// Line 28: ",
                "// Line 29: log = logging.getLogger(__name__)",
                "// Line 30: ",
                "// Line 31: if TYPE_CHECKING:",
                "// Line 32:     from gradio.components.base import Component",
                "// Line 33: "
            ]
        },
        {
            "filename_of_changes": "routes.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "7",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 10: if sys.version_info >= (3, 9):",
                "// Line 11:     from importlib.resources import files",
                "// Line 12: else:",
                "// Line 13:     from importlib_resources import files",
                "// Line 14: import inspect",
                "// Line 15: import json",
                "// Line 16: import mimetypes",
                "// Line 17: import os",
                "// Line 18: import posixpath",
                "// Line 19: import secrets",
                "// vulnerable line: 20: import tempfile",
                "// Line 21: import threading",
                "// Line 22: import time",
                "// Line 23: import traceback",
                "// Line 24: from pathlib import Path",
                "// Line 25: from queue import Empty as EmptyQueue",
                "// Line 26: from typing import TYPE_CHECKING, Any, AsyncIterator, Dict, List, Optional, Type",
                "// Line 27: ",
                "// Line 28: import fastapi",
                "// Line 29: import httpx",
                "// Line 30: import markupsafe",
                "// Line 31: import orjson",
                "// Line 32: from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, status",
                "// Line 33: from fastapi.middleware.cors import CORSMiddleware",
                "// Line 34: from fastapi.responses import (",
                "// Line 35:     FileResponse,",
                "// Line 36:     HTMLResponse,",
                "// Line 37:     JSONResponse,",
                "// Line 38:     PlainTextResponse,",
                "// vulnerable line: 39: )",
                "// Line 40: from fastapi.security import OAuth2PasswordRequestForm",
                "// Line 41: from fastapi.templating import Jinja2Templates",
                "// Line 42: from gradio_client import utils as client_utils",
                "// Line 43: from gradio_client.documentation import document",
                "// Line 44: from gradio_client.utils import ServerMessage",
                "// Line 45: from jinja2.exceptions import TemplateNotFound",
                "// Line 46: from multipart.multipart import parse_options_header",
                "// Line 47: from starlette.background import BackgroundTask",
                "// Line 48: from starlette.responses import RedirectResponse, StreamingResponse",
                "// Line 49: ",
                "// Line 58: from gradio.route_utils import (  # noqa: F401",
                "// Line 59:     FileUploadProgress,",
                "// Line 60:     FileUploadProgressNotQueuedError,",
                "// Line 61:     FileUploadProgressNotTrackedError,",
                "// Line 62:     GradioMultiPartParser,",
                "// Line 63:     GradioUploadFile,",
                "// Line 64:     MultiPartException,",
                "// Line 65:     Request,",
                "// Line 66:     compare_passwords_securely,",
                "// Line 67:     move_uploaded_files_to_cache,",
                "// vulnerable line: 68: )",
                "// Line 69: from gradio.state_holder import StateHolder",
                "// vulnerable line: 70: from gradio.utils import (",
                "// vulnerable line: 71: get_package_version,",
                "// vulnerable line: 72: )",
                "// Line 73: ",
                "// Line 74: if TYPE_CHECKING:",
                "// Line 75:     from gradio.blocks import Block",
                "// Line 76: ",
                "// Line 77: ",
                "// Line 78: mimetypes.init()",
                "// Line 79: ",
                "// Line 80: STATIC_TEMPLATE_LIB = files(\"gradio\").joinpath(\"templates\").as_posix()  # type: ignore",
                "// Line 81: STATIC_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix()  # type: ignore",
                "// Line 82: BUILD_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix()  # type: ignore",
                "// Line 85: ",
                "// Line 86: class ORJSONResponse(JSONResponse):",
                "// Line 87:     media_type = \"application/json\"",
                "// Line 88: ",
                "// Line 89:     @staticmethod",
                "// Line 90:     def _render(content: Any) -> bytes:",
                "// Line 91:         return orjson.dumps(",
                "// Line 92:             content,",
                "// Line 93:             option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
                "// Line 94:             default=str,",
                "// vulnerable line: 95: )",
                "// Line 96: ",
                "// Line 97:     def render(self, content: Any) -> bytes:",
                "// Line 98:         return ORJSONResponse._render(content)",
                "// Line 99: ",
                "// Line 100:     @staticmethod",
                "// Line 101:     def _render_str(content: Any) -> str:",
                "// Line 102:         return ORJSONResponse._render(content).decode(\"utf-8\")",
                "// Line 103: ",
                "// Line 104: ",
                "// Line 105: def toorjson(value):",
                "// Line 106:     return markupsafe.Markup(",
                "// Line 107:         ORJSONResponse._render_str(value)",
                "// Line 108:         .replace(\"<\", \"<\")",
                "// Line 109:         .replace(\">\", \">\")",
                "// Line 110:         .replace(\"&\", \"&\")",
                "// Line 111:         .replace(\"'\", \"'\")",
                "// vulnerable line: 112: )",
                "// Line 113: ",
                "// Line 114: ",
                "// Line 115: templates = Jinja2Templates(directory=STATIC_TEMPLATE_LIB)",
                "// Line 116: templates.env.filters[\"toorjson\"] = toorjson",
                "// Line 117: ",
                "// Line 118: client = httpx.AsyncClient()",
                "// Line 119: ",
                "// Line 120: file_upload_statuses = FileUploadProgress()",
                "// Line 121: ",
                "// Line 122: ",
                "// Line 129:         self.tokens = {}",
                "// Line 130:         self.auth = None",
                "// Line 131:         self.blocks: gradio.Blocks | None = None",
                "// Line 132:         self.state_holder = StateHolder()",
                "// Line 133:         self.iterators: dict[str, AsyncIterator] = {}",
                "// Line 134:         self.iterators_to_reset: set[str] = set()",
                "// Line 135:         self.lock = utils.safe_get_lock()",
                "// Line 136:         self.cookie_id = secrets.token_urlsafe(32)",
                "// Line 137:         self.queue_token = secrets.token_urlsafe(32)",
                "// Line 138:         self.startup_events_triggered = False",
                "// vulnerable line: 139: self.uploaded_file_dir = os.environ.get(\"GRADIO_TEMP_DIR\") or str(",
                "// vulnerable line: 140: (Path(tempfile.gettempdir()) / \"gradio\").resolve()",
                "// vulnerable line: 141: )",
                "// Line 142:         self.change_event: None | threading.Event = None",
                "// Line 143:         self._asyncio_tasks: list[asyncio.Task] = []",
                "// Line 144:         # Allow user to manually set `docs_url` and `redoc_url`",
                "// Line 145:         # when instantiating an App; when they're not set, disable docs and redoc.",
                "// Line 146:         kwargs.setdefault(\"docs_url\", None)",
                "// Line 147:         kwargs.setdefault(\"redoc_url\", None)",
                "// Line 148:         super().__init__(**kwargs)",
                "// Line 149: ",
                "// Line 150:     def configure_app(self, blocks: gradio.Blocks) -> None:",
                "// Line 151:         auth = blocks.auth",
                "// Line 169:             raise ValueError(\"No Blocks has been configured for this app.\")",
                "// Line 170:         return self.blocks",
                "// Line 171: ",
                "// Line 172:     def build_proxy_request(self, url_path):",
                "// Line 173:         url = httpx.URL(url_path)",
                "// Line 174:         assert self.blocks  # noqa: S101",
                "// Line 175:         # Don't proxy a URL unless it's a URL specifically loaded by the user using",
                "// Line 176:         # gr.load() to prevent SSRF or harvesting of HF tokens by malicious Spaces.",
                "// Line 177:         is_safe_url = any(",
                "// Line 178:             url.host == httpx.URL(root).host for root in self.blocks.proxy_urls",
                "// vulnerable line: 179: )",
                "// Line 180:         if not is_safe_url:",
                "// Line 181:             raise PermissionError(\"This URL cannot be proxied.\")",
                "// Line 182:         is_hf_url = url.host.endswith(\".hf.space\")",
                "// Line 183:         headers = {}",
                "// Line 184:         if Context.hf_token is not None and is_hf_url:",
                "// Line 185:             headers[\"Authorization\"] = f\"Bearer {Context.hf_token}\"",
                "// Line 186:         rp_req = client.build_request(\"GET\", url, headers=headers)",
                "// Line 187:         return rp_req",
                "// Line 188: ",
                "// Line 189:     def _cancel_asyncio_tasks(self):",
                "// Line 199:         app_kwargs.setdefault(\"default_response_class\", ORJSONResponse)",
                "// Line 200:         app = App(**app_kwargs)",
                "// Line 201:         app.configure_app(blocks)",
                "// Line 202: ",
                "// Line 203:         if not wasm_utils.IS_WASM:",
                "// Line 204:             app.add_middleware(",
                "// Line 205:                 CORSMiddleware,",
                "// Line 206:                 allow_origins=[\"*\"],",
                "// Line 207:                 allow_methods=[\"*\"],",
                "// Line 208:                 allow_headers=[\"*\"],",
                "// vulnerable line: 209: )",
                "// Line 210: ",
                "// Line 211:         @app.get(\"/user\")",
                "// Line 212:         @app.get(\"/user/\")",
                "// Line 213:         def get_current_user(request: fastapi.Request) -> Optional[str]:",
                "// Line 214:             token = request.cookies.get(",
                "// Line 215:                 f\"access-token-{app.cookie_id}\"",
                "// Line 216:             ) or request.cookies.get(f\"access-token-unsecure-{app.cookie_id}\")",
                "// Line 217:             return app.tokens.get(token)",
                "// Line 218: ",
                "// Line 219:         @app.get(\"/login_check\")",
                "// Line 220:         @app.get(\"/login_check/\")",
                "// Line 221:         def login_check(user: str = Depends(get_current_user)):",
                "// Line 222:             if app.auth is None or user is not None:",
                "// Line 223:                 return",
                "// Line 224:             raise HTTPException(",
                "// Line 225:                 status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
                "// vulnerable line: 226: )",
                "// Line 227: ",
                "// Line 228:         @app.get(\"/token\")",
                "// Line 229:         @app.get(\"/token/\")",
                "// Line 230:         def get_token(request: fastapi.Request) -> dict:",
                "// Line 231:             token = request.cookies.get(f\"access-token-{app.cookie_id}\")",
                "// Line 232:             return {\"token\": token, \"user\": app.tokens.get(token)}",
                "// Line 233: ",
                "// Line 234:         @app.get(\"/app_id\")",
                "// Line 235:         @app.get(\"/app_id/\")",
                "// Line 236:         def app_id(request: fastapi.Request) -> dict:  # noqa: ARG001",
                "// Line 258:                     await asyncio.sleep(check_rate)",
                "// Line 259:                     if time.perf_counter() - last_heartbeat > heartbeat_rate:",
                "// Line 260:                         yield \"\"\"data: HEARTBEAT",
                "// Line 261: ",
                "// Line 262: \"\"\"",
                "// Line 263:                         last_heartbeat = time.time()",
                "// Line 264: ",
                "// Line 265:             return StreamingResponse(",
                "// Line 266:                 reload_checker(request),",
                "// Line 267:                 media_type=\"text/event-stream\",",
                "// vulnerable line: 268: )",
                "// Line 269: ",
                "// Line 270:         @app.post(\"/login\")",
                "// Line 271:         @app.post(\"/login/\")",
                "// Line 272:         def login(form_data: OAuth2PasswordRequestForm = Depends()):",
                "// Line 273:             username, password = form_data.username.strip(), form_data.password",
                "// Line 274:             if app.auth is None:",
                "// Line 275:                 return RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
                "// Line 276:             if (",
                "// Line 277:                 not callable(app.auth)",
                "// Line 278:                 and username in app.auth",
                "// Line 280:             ) or (callable(app.auth) and app.auth.__call__(username, password)):",
                "// Line 281:                 token = secrets.token_urlsafe(16)",
                "// Line 282:                 app.tokens[token] = username",
                "// Line 283:                 response = JSONResponse(content={\"success\": True})",
                "// Line 284:                 response.set_cookie(",
                "// Line 285:                     key=f\"access-token-{app.cookie_id}\",",
                "// Line 286:                     value=token,",
                "// Line 287:                     httponly=True,",
                "// Line 288:                     samesite=\"none\",",
                "// Line 289:                     secure=True,",
                "// vulnerable line: 290: )",
                "// Line 291:                 response.set_cookie(",
                "// Line 292:                     key=f\"access-token-unsecure-{app.cookie_id}\",",
                "// Line 293:                     value=token,",
                "// Line 294:                     httponly=True,",
                "// vulnerable line: 295: )",
                "// Line 296:                 return response",
                "// Line 297:             else:",
                "// Line 298:                 raise HTTPException(status_code=400, detail=\"Incorrect credentials.\")",
                "// Line 299: ",
                "// Line 300:         ###############",
                "// Line 301:         # OAuth Routes",
                "// Line 302:         ###############",
                "// Line 303: ",
                "// Line 304:         # Define OAuth routes if the app expects it (i.e. a LoginButton is defined).",
                "// Line 305:         # It allows users to \"Sign in with HuggingFace\".",
                "// Line 310:         # Main Routes",
                "// Line 311:         ###############",
                "// Line 312: ",
                "// Line 313:         @app.head(\"/\", response_class=HTMLResponse)",
                "// Line 314:         @app.get(\"/\", response_class=HTMLResponse)",
                "// Line 315:         def main(request: fastapi.Request, user: str = Depends(get_current_user)):",
                "// Line 316:             mimetypes.add_type(\"application/javascript\", \".js\")",
                "// Line 317:             blocks = app.get_blocks()",
                "// Line 318:             root = route_utils.get_root_url(",
                "// Line 319:                 request=request, route_path=\"/\", root_path=app.root_path",
                "// vulnerable line: 320: )",
                "// Line 321:             if app.auth is None or user is not None:",
                "// Line 322:                 config = app.get_blocks().config",
                "// Line 323:                 config = route_utils.update_root_in_config(config, root)",
                "// Line 324:             else:",
                "// Line 325:                 config = {",
                "// Line 326:                     \"auth_required\": True,",
                "// Line 327:                     \"auth_message\": blocks.auth_message,",
                "// Line 328:                     \"space_id\": app.get_blocks().space_id,",
                "// Line 329:                     \"root\": root,",
                "// Line 330:                 }",
                "// Line 331: ",
                "// Line 332:             try:",
                "// Line 333:                 template = (",
                "// Line 334:                     \"frontend/share.html\" if blocks.share else \"frontend/index.html\"",
                "// vulnerable line: 335: )",
                "// Line 336:                 return templates.TemplateResponse(",
                "// Line 337:                     template,",
                "// Line 338:                     {\"request\": request, \"config\": config},",
                "// vulnerable line: 339: )",
                "// Line 340:             except TemplateNotFound as err:",
                "// Line 341:                 if blocks.share:",
                "// Line 342:                     raise ValueError(",
                "// Line 343:                         \"Did you install Gradio from source files? Share mode only \"",
                "// Line 344:                         \"works when Gradio is installed through the pip package.\"",
                "// Line 345:                     ) from err",
                "// Line 346:                 else:",
                "// Line 347:                     raise ValueError(",
                "// Line 348:                         \"Did you install Gradio from source files? You need to build \"",
                "// Line 349:                         \"the frontend by running /scripts/build_frontend.sh\"",
                "// Line 353:         @app.get(\"/info\", dependencies=[Depends(login_check)])",
                "// Line 354:         def api_info():",
                "// Line 355:             return app.get_blocks().get_api_info()  # type: ignore",
                "// Line 356: ",
                "// Line 357:         @app.get(\"/config/\", dependencies=[Depends(login_check)])",
                "// Line 358:         @app.get(\"/config\", dependencies=[Depends(login_check)])",
                "// Line 359:         def get_config(request: fastapi.Request):",
                "// Line 360:             config = app.get_blocks().config",
                "// Line 361:             root = route_utils.get_root_url(",
                "// Line 362:                 request=request, route_path=\"/config\", root_path=app.root_path",
                "// vulnerable line: 363: )",
                "// Line 364:             config = route_utils.update_root_in_config(config, root)",
                "// Line 365:             return ORJSONResponse(content=config)",
                "// Line 366: ",
                "// Line 367:         @app.get(\"/static/{path:path}\")",
                "// Line 368:         def static_resource(path: str):",
                "// Line 369:             static_file = safe_join(STATIC_PATH_LIB, path)",
                "// Line 370:             return FileResponse(static_file)",
                "// Line 371: ",
                "// Line 372:         @app.get(\"/custom_component/{id}/{type}/{file_name}\")",
                "// Line 373:         def custom_component_path(id: str, type: str, file_name: str):",
                "// Line 374:             config = app.get_blocks().config",
                "// Line 375:             components = config[\"components\"]",
                "// Line 376:             location = next(",
                "// Line 377:                 (item for item in components if item[\"component_class_id\"] == id), None",
                "// vulnerable line: 378: )",
                "// Line 379: ",
                "// Line 380:             if location is None:",
                "// Line 381:                 raise HTTPException(status_code=404, detail=\"Component not found.\")",
                "// Line 382: ",
                "// Line 383:             component_instance = app.get_blocks().get_component(location[\"id\"])",
                "// Line 384: ",
                "// Line 385:             module_name = component_instance.__class__.__module__",
                "// Line 386:             module_path = sys.modules[module_name].__file__",
                "// Line 387: ",
                "// Line 388:             if module_path is None or component_instance is None:",
                "// Line 389:                 raise HTTPException(status_code=404, detail=\"Component not found.\")",
                "// Line 390: ",
                "// Line 391:             return FileResponse(",
                "// Line 392:                 safe_join(",
                "// Line 393:                     str(Path(module_path).parent),",
                "// Line 394:                     f\"{component_instance.__class__.TEMPLATE_DIR}/{type}/{file_name}\",",
                "// vulnerable line: 395: )",
                "// vulnerable line: 396: )",
                "// Line 397: ",
                "// Line 398:         @app.get(\"/assets/{path:path}\")",
                "// Line 399:         def build_resource(path: str):",
                "// Line 400:             build_file = safe_join(BUILD_PATH_LIB, path)",
                "// Line 401:             return FileResponse(build_file)",
                "// Line 402: ",
                "// Line 403:         @app.get(\"/favicon.ico\")",
                "// Line 404:         async def favicon():",
                "// Line 405:             blocks = app.get_blocks()",
                "// Line 406:             if blocks.favicon_path is None:",
                "// Line 415:             try:",
                "// Line 416:                 rp_req = app.build_proxy_request(url_path)",
                "// Line 417:             except PermissionError as err:",
                "// Line 418:                 raise HTTPException(status_code=400, detail=str(err)) from err",
                "// Line 419:             rp_resp = await client.send(rp_req, stream=True)",
                "// Line 420:             return StreamingResponse(",
                "// Line 421:                 rp_resp.aiter_raw(),",
                "// Line 422:                 status_code=rp_resp.status_code,",
                "// Line 423:                 headers=rp_resp.headers,  # type: ignore",
                "// Line 424:                 background=BackgroundTask(rp_resp.aclose),",
                "// vulnerable line: 425: )",
                "// Line 426: ",
                "// Line 427:         @app.head(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
                "// Line 428:         @app.get(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
                "// Line 429:         async def file(path_or_url: str, request: fastapi.Request):",
                "// Line 430:             blocks = app.get_blocks()",
                "// Line 431:             if client_utils.is_http_url_like(path_or_url):",
                "// Line 432:                 return RedirectResponse(",
                "// Line 433:                     url=path_or_url, status_code=status.HTTP_302_FOUND",
                "// vulnerable line: 434: )",
                "// Line 435: ",
                "// Line 436:             if route_utils.starts_with_protocol(path_or_url):",
                "// Line 437:                 raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
                "// Line 438: ",
                "// Line 439:             abs_path = utils.abspath(path_or_url)",
                "// Line 440: ",
                "// Line 441:             in_blocklist = any(",
                "// Line 442:                 utils.is_in_or_equal(abs_path, blocked_path)",
                "// Line 443:                 for blocked_path in blocks.blocked_paths",
                "// vulnerable line: 444: )",
                "// Line 445: ",
                "// Line 446:             is_dir = abs_path.is_dir()",
                "// Line 447: ",
                "// Line 448:             if in_blocklist or is_dir:",
                "// Line 449:                 raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
                "// Line 450: ",
                "// Line 451:             created_by_app = False",
                "// Line 452:             for temp_file_set in blocks.temp_file_sets:",
                "// Line 453:                 if abs_path in temp_file_set:",
                "// Line 454:                     created_by_app = True",
                "// Line 455:                     break",
                "// Line 456:             in_allowlist = any(",
                "// Line 457:                 utils.is_in_or_equal(abs_path, allowed_path)",
                "// Line 458:                 for allowed_path in blocks.allowed_paths",
                "// vulnerable line: 459: )",
                "// Line 460:             was_uploaded = utils.is_in_or_equal(abs_path, app.uploaded_file_dir)",
                "// Line 461:             is_cached_example = utils.is_in_or_equal(",
                "// Line 462:                 abs_path, utils.abspath(utils.get_cache_folder())",
                "// vulnerable line: 463: )",
                "// Line 464: ",
                "// Line 465:             if not (",
                "// Line 466:                 created_by_app or in_allowlist or was_uploaded or is_cached_example",
                "// Line 467:             ):",
                "// Line 468:                 raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
                "// Line 469: ",
                "// Line 470:             if not abs_path.exists():",
                "// Line 471:                 raise HTTPException(404, f\"File not found: {path_or_url}.\")",
                "// Line 472: ",
                "// Line 473:             range_val = request.headers.get(\"Range\", \"\").strip()",
                "// Line 475:                 range_val = range_val[6:]",
                "// Line 476:                 start, end = range_val.split(\"-\")",
                "// Line 477:                 if start.isnumeric() and end.isnumeric():",
                "// Line 478:                     start = int(start)",
                "// Line 479:                     end = int(end)",
                "// Line 480:                     response = ranged_response.RangedFileResponse(",
                "// Line 481:                         abs_path,",
                "// Line 482:                         ranged_response.OpenRange(start, end),",
                "// Line 483:                         dict(request.headers),",
                "// Line 484:                         stat_result=os.stat(abs_path),",
                "// vulnerable line: 485: )",
                "// Line 486:                     return response",
                "// Line 487: ",
                "// Line 488:             return FileResponse(abs_path, headers={\"Accept-Ranges\": \"bytes\"})",
                "// Line 489: ",
                "// Line 490:         @app.get(",
                "// Line 491:             \"/stream/{session_hash}/{run}/{component_id}\",",
                "// Line 492:             dependencies=[Depends(login_check)],",
                "// vulnerable line: 493: )",
                "// Line 494:         async def stream(",
                "// Line 495:             session_hash: str,",
                "// Line 496:             run: int,",
                "// Line 497:             component_id: int,",
                "// Line 498:             request: fastapi.Request,  # noqa: ARG001",
                "// Line 499:         ):",
                "// Line 500:             stream: list = (",
                "// Line 501:                 app.get_blocks()",
                "// Line 502:                 .pending_streams[session_hash]",
                "// Line 503:                 .get(run, {})",
                "// Line 504:                 .get(component_id, None)",
                "// vulnerable line: 505: )",
                "// Line 506:             if stream is None:",
                "// Line 507:                 raise HTTPException(404, \"Stream not found.\")",
                "// Line 508: ",
                "// Line 509:             def stream_wrapper():",
                "// Line 510:                 check_stream_rate = 0.01",
                "// Line 511:                 max_wait_time = 120  # maximum wait between yields - assume generator thread has crashed otherwise.",
                "// Line 512:                 wait_time = 0",
                "// Line 513:                 while True:",
                "// Line 514:                     if len(stream) == 0:",
                "// Line 515:                         if wait_time > max_wait_time:",
                "// Line 546:         @app.post(\"/api/{api_name}\", dependencies=[Depends(login_check)])",
                "// Line 547:         @app.post(\"/api/{api_name}/\", dependencies=[Depends(login_check)])",
                "// Line 548:         async def predict(",
                "// Line 549:             api_name: str,",
                "// Line 550:             body: PredictBody,",
                "// Line 551:             request: fastapi.Request,",
                "// Line 552:             username: str = Depends(get_current_user),",
                "// Line 553:         ):",
                "// Line 554:             fn_index_inferred = route_utils.infer_fn_index(",
                "// Line 555:                 app=app, api_name=api_name, body=body",
                "// vulnerable line: 556: )",
                "// Line 557: ",
                "// Line 558:             if not app.get_blocks().api_open and app.get_blocks().queue_enabled_for_fn(",
                "// Line 559:                 fn_index_inferred",
                "// Line 560:             ):",
                "// Line 561:                 raise HTTPException(",
                "// Line 562:                     detail=\"This API endpoint does not accept direct HTTP POST requests. Please join the queue to use this API.\",",
                "// Line 563:                     status_code=status.HTTP_404_NOT_FOUND,",
                "// vulnerable line: 564: )",
                "// Line 565: ",
                "// Line 566:             gr_request = route_utils.compile_gr_request(",
                "// Line 567:                 app,",
                "// Line 568:                 body,",
                "// Line 569:                 fn_index_inferred=fn_index_inferred,",
                "// Line 570:                 username=username,",
                "// Line 571:                 request=request,",
                "// vulnerable line: 572: )",
                "// Line 573: ",
                "// Line 574:             try:",
                "// Line 575:                 output = await route_utils.call_process_api(",
                "// Line 576:                     app=app,",
                "// Line 577:                     body=body,",
                "// Line 578:                     gr_request=gr_request,",
                "// Line 579:                     fn_index_inferred=fn_index_inferred,",
                "// vulnerable line: 580: )",
                "// Line 581:             except BaseException as error:",
                "// Line 582:                 show_error = app.get_blocks().show_error or isinstance(error, Error)",
                "// Line 583:                 traceback.print_exc()",
                "// Line 584:                 return JSONResponse(",
                "// Line 585:                     content={\"error\": str(error) if show_error else None},",
                "// Line 586:                     status_code=500,",
                "// vulnerable line: 587: )",
                "// Line 588:             root_path = route_utils.get_root_url(",
                "// Line 589:                 request=request, route_path=f\"/api/{api_name}\", root_path=app.root_path",
                "// vulnerable line: 590: )",
                "// Line 591:             output = add_root_url(output, root_path, None)",
                "// Line 592:             return output",
                "// Line 593: ",
                "// Line 594:         @app.get(\"/queue/data\", dependencies=[Depends(login_check)])",
                "// Line 595:         async def queue_data(",
                "// Line 596:             request: fastapi.Request,",
                "// Line 597:             session_hash: str,",
                "// Line 598:         ):",
                "// Line 599:             blocks = app.get_blocks()",
                "// Line 600:             root_path = route_utils.get_root_url(",
                "// Line 601:                 request=request, route_path=\"/queue/data\", root_path=app.root_path",
                "// vulnerable line: 602: )",
                "// Line 603: ",
                "// Line 604:             async def sse_stream(request: fastapi.Request):",
                "// Line 605:                 try:",
                "// Line 606:                     last_heartbeat = time.perf_counter()",
                "// Line 607:                     while True:",
                "// Line 608:                         if await request.is_disconnected():",
                "// Line 609:                             await blocks._queue.clean_events(session_hash=session_hash)",
                "// Line 610:                             return",
                "// Line 611: ",
                "// Line 612:                         if (",
                "// Line 613:                             session_hash",
                "// Line 614:                             not in blocks._queue.pending_messages_per_session",
                "// Line 615:                         ):",
                "// Line 616:                             raise HTTPException(",
                "// Line 617:                                 status_code=status.HTTP_404_NOT_FOUND,",
                "// Line 618:                                 detail=\"Session not found.\",",
                "// vulnerable line: 619: )",
                "// Line 620: ",
                "// Line 621:                         heartbeat_rate = 15",
                "// Line 622:                         check_rate = 0.05",
                "// Line 623:                         message = None",
                "// Line 624:                         try:",
                "// Line 625:                             messages = blocks._queue.pending_messages_per_session[",
                "// Line 626:                                 session_hash",
                "// Line 627:                             ]",
                "// Line 628:                             message = messages.get_nowait()",
                "// Line 629:                         except EmptyQueue:",
                "// Line 653:                                 blocks._queue.pending_event_ids_session[",
                "// Line 654:                                     session_hash",
                "// Line 655:                                 ].remove(message[\"event_id\"])",
                "// Line 656:                                 if message[\"msg\"] == ServerMessage.server_stopped or (",
                "// Line 657:                                     message[\"msg\"] == ServerMessage.process_completed",
                "// Line 658:                                     and (",
                "// Line 659:                                         len(",
                "// Line 660:                                             blocks._queue.pending_event_ids_session[",
                "// Line 661:                                                 session_hash",
                "// Line 662:                                             ]",
                "// vulnerable line: 663: )",
                "// Line 664:                                         == 0",
                "// vulnerable line: 665: )",
                "// Line 666:                                 ):",
                "// Line 667:                                     return",
                "// Line 668:                 except BaseException as e:",
                "// Line 669:                     message = {",
                "// Line 670:                         \"msg\": \"unexpected_error\",",
                "// Line 671:                         \"success\": False,",
                "// Line 672:                         \"message\": str(e),",
                "// Line 673:                     }",
                "// Line 674:                     yield f\"data: {json.dumps(message)}",
                "// Line 675: ",
                "// Line 676: \"",
                "// Line 677:                     if isinstance(e, asyncio.CancelledError):",
                "// Line 678:                         del blocks._queue.pending_messages_per_session[session_hash]",
                "// Line 679:                         await blocks._queue.clean_events(session_hash=session_hash)",
                "// Line 680:                     raise e",
                "// Line 681: ",
                "// Line 682:             return StreamingResponse(",
                "// Line 683:                 sse_stream(request),",
                "// Line 684:                 media_type=\"text/event-stream\",",
                "// vulnerable line: 685: )",
                "// Line 686: ",
                "// Line 687:         @app.post(\"/queue/join\", dependencies=[Depends(login_check)])",
                "// Line 688:         async def queue_join(",
                "// Line 689:             body: PredictBody,",
                "// Line 690:             request: fastapi.Request,",
                "// Line 691:             username: str = Depends(get_current_user),",
                "// Line 692:         ):",
                "// Line 693:             blocks = app.get_blocks()",
                "// Line 694: ",
                "// Line 695:             if blocks._queue.server_app is None:",
                "// Line 696:                 blocks._queue.set_server_app(app)",
                "// Line 697: ",
                "// Line 698:             if blocks._queue.stopped:",
                "// Line 699:                 raise HTTPException(",
                "// Line 700:                     status_code=status.HTTP_503_SERVICE_UNAVAILABLE,",
                "// Line 701:                     detail=\"Queue is stopped.\",",
                "// vulnerable line: 702: )",
                "// Line 703: ",
                "// Line 704:             success, event_id = await blocks._queue.push(body, request, username)",
                "// Line 705:             if not success:",
                "// Line 706:                 status_code = (",
                "// Line 707:                     status.HTTP_503_SERVICE_UNAVAILABLE",
                "// Line 708:                     if \"Queue is full.\" in event_id",
                "// Line 709:                     else status.HTTP_400_BAD_REQUEST",
                "// vulnerable line: 710: )",
                "// Line 711:                 raise HTTPException(status_code=status_code, detail=event_id)",
                "// Line 712:             return {\"event_id\": event_id}",
                "// Line 713: ",
                "// Line 714:         @app.post(\"/component_server\", dependencies=[Depends(login_check)])",
                "// Line 715:         @app.post(\"/component_server/\", dependencies=[Depends(login_check)])",
                "// Line 716:         def component_server(body: ComponentServerBody):",
                "// Line 717:             state = app.state_holder[body.session_hash]",
                "// Line 718:             component_id = body.component_id",
                "// Line 719:             block: Block",
                "// Line 720:             if component_id in state:",
                "// Line 721:                 block = state[component_id]",
                "// Line 722:             else:",
                "// Line 723:                 block = app.get_blocks().blocks[component_id]",
                "// Line 724:             fn = getattr(block, body.fn_name, None)",
                "// Line 725:             if fn is None or not getattr(fn, \"_is_server_fn\", False):",
                "// Line 726:                 raise HTTPException(",
                "// Line 727:                     status_code=status.HTTP_404_NOT_FOUND,",
                "// Line 728:                     detail=\"Function not found.\",",
                "// vulnerable line: 729: )",
                "// Line 730:             return fn(body.data)",
                "// Line 731: ",
                "// Line 732:         @app.get(",
                "// Line 733:             \"/queue/status\",",
                "// Line 734:             dependencies=[Depends(login_check)],",
                "// Line 735:             response_model=Estimation,",
                "// vulnerable line: 736: )",
                "// Line 737:         async def get_queue_status():",
                "// Line 738:             return app.get_blocks()._queue.get_status()",
                "// Line 739: ",
                "// Line 740:         @app.get(\"/upload_progress\")",
                "// Line 741:         def get_upload_progress(upload_id: str, request: fastapi.Request):",
                "// Line 742:             async def sse_stream(request: fastapi.Request):",
                "// Line 743:                 last_heartbeat = time.perf_counter()",
                "// Line 744:                 is_done = False",
                "// Line 745:                 while True:",
                "// Line 746:                     if await request.is_disconnected():",
                "// Line 773:                         if time.perf_counter() - last_heartbeat > heartbeat_rate:",
                "// Line 774:                             message = {\"msg\": \"heartbeat\"}",
                "// Line 775:                             yield f\"data: {json.dumps(message)}",
                "// Line 776: ",
                "// Line 777: \"",
                "// Line 778:                             last_heartbeat = time.perf_counter()",
                "// Line 779: ",
                "// Line 780:             return StreamingResponse(",
                "// Line 781:                 sse_stream(request),",
                "// Line 782:                 media_type=\"text/event-stream\",",
                "// vulnerable line: 783: )",
                "// Line 784: ",
                "// Line 785:         @app.post(\"/upload\", dependencies=[Depends(login_check)])",
                "// Line 786:         async def upload_file(",
                "// Line 787:             request: fastapi.Request,",
                "// Line 788:             bg_tasks: BackgroundTasks,",
                "// Line 789:             upload_id: Optional[str] = None,",
                "// Line 790:         ):",
                "// Line 791:             content_type_header = request.headers.get(\"Content-Type\")",
                "// Line 792:             content_type: bytes",
                "// Line 793:             content_type, _ = parse_options_header(content_type_header or \"\")",
                "// Line 797:             try:",
                "// Line 798:                 if upload_id:",
                "// Line 799:                     file_upload_statuses.track(upload_id)",
                "// Line 800:                 multipart_parser = GradioMultiPartParser(",
                "// Line 801:                     request.headers,",
                "// Line 802:                     request.stream(),",
                "// Line 803:                     max_files=1000,",
                "// Line 804:                     max_fields=1000,",
                "// Line 805:                     upload_id=upload_id if upload_id else None,",
                "// Line 806:                     upload_progress=file_upload_statuses if upload_id else None,",
                "// vulnerable line: 807: )",
                "// Line 808:                 form = await multipart_parser.parse()",
                "// Line 809:             except MultiPartException as exc:",
                "// Line 810:                 raise HTTPException(status_code=400, detail=exc.message) from exc",
                "// Line 811: ",
                "// Line 812:             output_files = []",
                "// Line 813:             files_to_copy = []",
                "// Line 814:             locations: list[str] = []",
                "// Line 815:             for temp_file in form.getlist(\"files\"):",
                "// Line 816:                 if not isinstance(temp_file, GradioUploadFile):",
                "// Line 817:                     raise TypeError(\"File is not an instance of GradioUploadFile\")",
                "// Line 831:                 # if that fails, we move in the background.",
                "// Line 832:                 try:",
                "// Line 833:                     os.rename(temp_file.file.name, dest)",
                "// Line 834:                 except OSError:",
                "// Line 835:                     files_to_copy.append(temp_file.file.name)",
                "// Line 836:                     locations.append(str(dest))",
                "// Line 837:                 output_files.append(dest)",
                "// Line 838:             if files_to_copy:",
                "// Line 839:                 bg_tasks.add_task(",
                "// Line 840:                     move_uploaded_files_to_cache, files_to_copy, locations",
                "// vulnerable line: 841: )",
                "// Line 842:             return output_files",
                "// Line 843: ",
                "// Line 844:         @app.on_event(\"startup\")",
                "// Line 845:         @app.get(\"/startup-events\")",
                "// Line 846:         async def startup_events():",
                "// Line 847:             if not app.startup_events_triggered:",
                "// Line 848:                 app.get_blocks().startup_events()",
                "// Line 849:                 app.startup_events_triggered = True",
                "// Line 850:                 return True",
                "// Line 851:             return False"
            ]
        },
        {
            "filename_of_changes": "utils.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "7",
            "number_of_lines_deleted_vulnerable_to_cve": "0",
            "Code_with_highlighted_vulnerability_lines": []
        }
    ]
}