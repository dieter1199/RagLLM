{
    "cve_id": "CVE-2024-5642",
    "cve_description": "CPython 3.9 and earlier doesn't disallow configuring an empty list (\"[]\") for SSLContext.set_npn_protocols() which is an invalid value for the underlying OpenSSL API. This results in a buffer over-read when NPN is used (see CVE-2024-5535 for OpenSSL). This vulnerability is of low severity due to NPN being not widely used and specifying an empty list likely being uncommon in-practice (typically a protocol name would be configured).",
    "cve_publish_date": "2024-06-27T21:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "bpo-43669: PEP 644: Require OpenSSL 1.1.1 or newer (GH-23014)\n\n- Remove HAVE_X509_VERIFY_PARAM_SET1_HOST check\r\n- Update hashopenssl to require OpenSSL 1.1.1\r\n- multissltests only OpenSSL > 1.1.0\r\n- ALPN is always supported\r\n- SNI is always supported\r\n- Remove deprecated NPN code. Python wrappers are no-op.\r\n- ECDH is always supported\r\n- Remove OPENSSL_VERSION_1_1 macro\r\n- Remove locking callbacks\r\n- Drop PY_OPENSSL_1_1_API macro\r\n- Drop HAVE_SSL_CTX_CLEAR_OPTIONS macro\r\n- SSL_CTRL_GET_MAX_PROTO_VERSION is always defined now\r\n- security level is always available now\r\n- get_num_tickets is available with TLS 1.3\r\n- X509_V_ERR MISMATCH is always available now\r\n- Always set SSL_MODE_RELEASE_BUFFERS\r\n- X509_V_FLAG_TRUSTED_FIRST is always available\r\n- get_ciphers is always supported\r\n- SSL_CTX_set_keylog_callback is always available\r\n- Update Modules/Setup with static link example\r\n- Mention PEP in whatsnew\r\n- Drop 1.0.2 and 1.1.0 from GHA tests",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "multissltests.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 36: import shutil",
                "// Line 37: import string",
                "// Line 38: import subprocess",
                "// Line 39: import sys",
                "// Line 40: import tarfile",
                "// Line 41: ",
                "// Line 42: ",
                "// Line 43: log = logging.getLogger(\"multissl\")",
                "// Line 44: ",
                "// Line 45: OPENSSL_OLD_VERSIONS = [",
                "// vulnerable line: 46: \"1.0.2u\",",
                "// vulnerable line: 47: \"1.1.0l\",",
                "// Line 48: ]",
                "// Line 49: ",
                "// Line 50: OPENSSL_RECENT_VERSIONS = [",
                "// Line 51:     \"1.1.1k\",",
                "// vulnerable line: 52: # \"3.0.0-alpha14\"",
                "// Line 53: ]",
                "// Line 54: ",
                "// Line 55: LIBRESSL_OLD_VERSIONS = [",
                "// vulnerable line: 56: \"2.9.2\",",
                "// Line 57: ]",
                "// Line 58: ",
                "// Line 59: LIBRESSL_RECENT_VERSIONS = [",
                "// vulnerable line: 60: \"3.2.4\",",
                "// Line 61: ]",
                "// Line 62: ",
                "// Line 63: # store files in ../multissl",
                "// Line 64: HERE = os.path.dirname(os.path.abspath(__file__))",
                "// Line 65: PYTHONROOT = os.path.abspath(os.path.join(HERE, '..', '..'))",
                "// Line 66: MULTISSL_DIR = os.path.abspath(os.path.join(PYTHONROOT, '..', 'multissl'))",
                "// Line 67: ",
                "// Line 68: ",
                "// Line 69: parser = argparse.ArgumentParser(",
                "// Line 70:     prog='multissl',"
            ]
        },
        {
            "filename_of_changes": "setup.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "14",
            "number_of_lines_deleted_vulnerable_to_cve": "27",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 180: ",
                "// Line 181:     # If already called, return cached result.",
                "// Line 182:     if MACOS_SDK_ROOT:",
                "// Line 183:         return MACOS_SDK_ROOT",
                "// Line 184: ",
                "// Line 185:     cflags = sysconfig.get_config_var('CFLAGS')",
                "// Line 186:     m = re.search(r'-isysroot\\s*(\\S+)', cflags)",
                "// Line 187:     if m is not None:",
                "// Line 188:         MACOS_SDK_ROOT = m.group(1)",
                "// Line 189:         MACOS_SDK_SPECIFIED = MACOS_SDK_ROOT != '/'",
                "// vulnerable line: 190: else:",
                "// Line 191:         MACOS_SDK_ROOT = _osx_support._default_sysroot(",
                "// Line 192:             sysconfig.get_config_var('CC'))",
                "// Line 193:         MACOS_SDK_SPECIFIED = False",
                "// Line 194: ",
                "// Line 195:     return MACOS_SDK_ROOT",
                "// Line 196: ",
                "// Line 197: ",
                "// Line 198: def macosx_sdk_specified():",
                "// Line 199:     \"\"\"Returns true if an SDK was explicitly configured.",
                "// Line 200: ",
                "// Line 315:     for p in paths:",
                "// Line 316:         # Ensure path doesn't end with path separator",
                "// Line 317:         p = p.rstrip(os.sep)",
                "// Line 318: ",
                "// Line 319:         if MACOS and is_macosx_sdk_path(p):",
                "// Line 320:             if os.path.join(sysroot, p[1:]) == dirname:",
                "// Line 321:                 return [ p ]",
                "// Line 322: ",
                "// Line 323:         if p == dirname:",
                "// Line 324:             return [p]",
                "// vulnerable line: 325: else:",
                "// Line 326:         assert False, \"Internal error: Path not found in std_dirs or paths\"",
                "// Line 327: ",
                "// Line 328: def validate_tzpath():",
                "// Line 329:     base_tzpath = sysconfig.get_config_var('TZPATH')",
                "// Line 330:     if not base_tzpath:",
                "// Line 331:         return",
                "// Line 332: ",
                "// Line 333:     tzpaths = base_tzpath.split(os.pathsep)",
                "// Line 334:     bad_paths = [tzpath for tzpath in tzpaths if not os.path.isabs(tzpath)]",
                "// Line 335:     if bad_paths:",
                "// Line 399:         # Python header files",
                "// Line 400:         headers = [sysconfig.get_config_h_filename()]",
                "// Line 401:         headers += glob(os.path.join(escape(sysconfig.get_path('include')), \"*.h\"))",
                "// Line 402: ",
                "// Line 403:         for ext in self.extensions:",
                "// Line 404:             ext.sources = [ find_module_file(filename, moddirlist)",
                "// Line 405:                             for filename in ext.sources ]",
                "// Line 406:             if ext.depends is not None:",
                "// Line 407:                 ext.depends = [find_module_file(filename, moddirlist)",
                "// Line 408:                                for filename in ext.depends]",
                "// vulnerable line: 409: else:",
                "// Line 410:                 ext.depends = []",
                "// Line 411:             # re-compile extensions if a header file has been changed",
                "// Line 412:             ext.depends.extend(headers)",
                "// Line 413: ",
                "// Line 414:     def remove_configured_extensions(self):",
                "// Line 415:         # The sysconfig variables built by makesetup that list the already",
                "// Line 416:         # built modules and the disabled modules as configured by the Setup",
                "// Line 417:         # files.",
                "// Line 418:         sysconf_built = sysconfig.get_config_var('MODBUILT_NAMES').split()",
                "// Line 419:         sysconf_dis = sysconfig.get_config_var('MODDISABLED_NAMES').split()",
                "// Line 547:             print()",
                "// Line 548:             print(\"Following modules built successfully\"",
                "// Line 549:                   \" but were removed because they could not be imported:\")",
                "// Line 550:             print_three_column(failed)",
                "// Line 551:             print()",
                "// Line 552: ",
                "// Line 553:         if any('_ssl' in l",
                "// Line 554:                for l in (self.missing, self.failed, self.failed_on_import)):",
                "// Line 555:             print()",
                "// Line 556:             print(\"Could not build the ssl module!\")",
                "// vulnerable line: 557: print(\"Python requires an OpenSSL 1.0.2 or 1.1 compatible \"",
                "// vulnerable line: 558: \"libssl with X509_VERIFY_PARAM_set1_host().\")",
                "// vulnerable line: 559: print(\"LibreSSL 2.6.4 and earlier do not provide the necessary \"",
                "// vulnerable line: 560: \"APIs, https://github.com/libressl-portable/portable/issues/381\")",
                "// Line 561:             if sysconfig.get_config_var(\"OPENSSL_LDFLAGS\"):",
                "// Line 562:                 print(\"Custom linker flags may require --with-openssl-rpath=auto\")",
                "// Line 563:             print()",
                "// Line 564: ",
                "// Line 565:     def build_extension(self, ext):",
                "// Line 566: ",
                "// Line 567:         if ext.name == '_ctypes':",
                "// Line 568:             if not self.configure_ctypes(ext):",
                "// Line 569:                 self.failed.append(ext.name)",
                "// Line 570:                 return",
                "// Line 825:                             sysconfig.get_config_var(\"INCLUDEDIR\"))",
                "// Line 826: ",
                "// Line 827:         system_lib_dirs = ['/lib64', '/usr/lib64', '/lib', '/usr/lib']",
                "// Line 828:         system_include_dirs = ['/usr/include']",
                "// Line 829:         # lib_dirs and inc_dirs are used to search for files;",
                "// Line 830:         # if a file is found in one of those directories, it can",
                "// Line 831:         # be assumed that no additional -I,-L directives are needed.",
                "// Line 832:         if not CROSS_COMPILING:",
                "// Line 833:             self.lib_dirs = self.compiler.library_dirs + system_lib_dirs",
                "// Line 834:             self.inc_dirs = self.compiler.include_dirs + system_include_dirs",
                "// vulnerable line: 835: else:",
                "// Line 836:             # Add the sysroot paths. 'sysroot' is a compiler option used to",
                "// Line 837:             # set the logical path of the standard system headers and",
                "// Line 838:             # libraries.",
                "// Line 839:             self.lib_dirs = (self.compiler.library_dirs +",
                "// Line 840:                              sysroot_paths(('LDFLAGS', 'CC'), system_lib_dirs))",
                "// Line 841:             self.inc_dirs = (self.compiler.include_dirs +",
                "// Line 842:                              sysroot_paths(('CPPFLAGS', 'CFLAGS', 'CC'),",
                "// Line 843:                                            system_include_dirs))",
                "// Line 844: ",
                "// Line 845:         config_h = sysconfig.get_config_h_filename()",
                "// Line 1040:         readline_termcap_library = \"\"",
                "// Line 1041:         curses_library = \"\"",
                "// Line 1042:         # Cannot use os.popen here in py3k.",
                "// Line 1043:         tmpfile = os.path.join(self.build_temp, 'readline_termcap_lib')",
                "// Line 1044:         if not os.path.exists(self.build_temp):",
                "// Line 1045:             os.makedirs(self.build_temp)",
                "// Line 1046:         # Determine if readline is already linked against curses or tinfo.",
                "// Line 1047:         if sysconfig.get_config_var('HAVE_LIBREADLINE'):",
                "// Line 1048:             if sysconfig.get_config_var('WITH_EDITLINE'):",
                "// Line 1049:                 readline_lib = 'edit'",
                "// vulnerable line: 1050: else:",
                "// Line 1051:                 readline_lib = 'readline'",
                "// Line 1052:             do_readline = self.compiler.find_library_file(self.lib_dirs,",
                "// Line 1053:                 readline_lib)",
                "// Line 1054:             if CROSS_COMPILING:",
                "// Line 1055:                 ret = run_command(\"%s -d %s | grep '(NEEDED)' > %s\"",
                "// Line 1056:                                 % (sysconfig.get_config_var('READELF'),",
                "// Line 1057:                                    do_readline, tmpfile))",
                "// Line 1058:             elif find_executable('ldd'):",
                "// Line 1059:                 ret = run_command(\"ldd %s > %s\" % (do_readline, tmpfile))",
                "// vulnerable line: 1060: else:",
                "// Line 1061:                 ret = 1",
                "// Line 1062:             if ret == 0:",
                "// Line 1063:                 with open(tmpfile) as fp:",
                "// Line 1064:                     for ln in fp:",
                "// Line 1065:                         if 'curses' in ln:",
                "// Line 1066:                             readline_termcap_library = re.sub(",
                "// Line 1067:                                 r'.*lib(n?cursesw?)\\.so.*', r'\u0001', ln",
                "// Line 1068:                             ).rstrip()",
                "// Line 1069:                             break",
                "// Line 1070:                         # termcap interface split out from ncurses",
                "// Line 1071:                         if 'tinfo' in ln:",
                "// Line 1072:                             readline_termcap_library = 'tinfo'",
                "// Line 1073:                             break",
                "// Line 1074:             if os.path.exists(tmpfile):",
                "// Line 1075:                 os.unlink(tmpfile)",
                "// vulnerable line: 1076: else:",
                "// Line 1077:             do_readline = False",
                "// Line 1078:         # Issue 7384: If readline is already linked against curses,",
                "// Line 1079:         # use the same library for the readline and curses modules.",
                "// Line 1080:         if 'curses' in readline_termcap_library:",
                "// Line 1081:             curses_library = readline_termcap_library",
                "// Line 1082:         elif self.compiler.find_library_file(self.lib_dirs, 'ncursesw'):",
                "// Line 1083:             curses_library = 'ncursesw'",
                "// Line 1084:         # Issue 36210: OSS provided ncurses does not link on AIX",
                "// Line 1085:         # Use IBM supplied 'curses' for successful build of _curses",
                "// Line 1086:         elif AIX and self.compiler.find_library_file(self.lib_dirs, 'curses'):",
                "// Line 1104:                 if find_file('readline/rlconf.h', self.inc_dirs, []) is None:",
                "// Line 1105:                     do_readline = False",
                "// Line 1106:         if do_readline:",
                "// Line 1107:             if MACOS and os_release < 9:",
                "// Line 1108:                 # In every directory on the search path search for a dynamic",
                "// Line 1109:                 # library and then a static library, instead of first looking",
                "// Line 1110:                 # for dynamic libraries on the entire path.",
                "// Line 1111:                 # This way a statically linked custom readline gets picked up",
                "// Line 1112:                 # before the (possibly broken) dynamic library in /usr/lib.",
                "// Line 1113:                 readline_extra_link_args = ('-Wl,-search_paths_first',)",
                "// vulnerable line: 1114: else:",
                "// Line 1115:                 readline_extra_link_args = ()",
                "// Line 1116: ",
                "// Line 1117:             readline_libs = [readline_lib]",
                "// Line 1118:             if readline_termcap_library:",
                "// Line 1119:                 pass # Issue 7384: Already linked against curses or tinfo.",
                "// Line 1120:             elif curses_library:",
                "// Line 1121:                 readline_libs.append(curses_library)",
                "// Line 1122:             elif self.compiler.find_library_file(self.lib_dirs +",
                "// Line 1123:                                                      ['/usr/lib/termcap'],",
                "// Line 1124:                                                      'termcap'):",
                "// Line 1125:                 readline_libs.append('termcap')",
                "// Line 1126:             self.add(Extension('readline', ['readline.c'],",
                "// Line 1127:                                library_dirs=['/usr/lib/termcap'],",
                "// Line 1128:                                extra_link_args=readline_extra_link_args,",
                "// Line 1129:                                libraries=readline_libs))",
                "// vulnerable line: 1130: else:",
                "// Line 1131:             self.missing.append('readline')",
                "// Line 1132: ",
                "// Line 1133:         # Curses support, requiring the System V version of curses, often",
                "// Line 1134:         # provided by the ncurses library.",
                "// Line 1135:         curses_defines = []",
                "// Line 1136:         curses_includes = []",
                "// Line 1137:         panel_library = 'panel'",
                "// Line 1138:         if curses_library == 'ncursesw':",
                "// Line 1139:             curses_defines.append(('HAVE_NCURSESW', '1'))",
                "// Line 1140:             if not CROSS_COMPILING:",
                "// Line 1163:                                include_dirs=curses_includes,",
                "// Line 1164:                                define_macros=curses_defines,",
                "// Line 1165:                                libraries=curses_libs))",
                "// Line 1166:         elif curses_library == 'curses' and not MACOS:",
                "// Line 1167:                 # OSX has an old Berkeley curses, not good enough for",
                "// Line 1168:                 # the _curses module.",
                "// Line 1169:             if (self.compiler.find_library_file(self.lib_dirs, 'terminfo')):",
                "// Line 1170:                 curses_libs = ['curses', 'terminfo']",
                "// Line 1171:             elif (self.compiler.find_library_file(self.lib_dirs, 'termcap')):",
                "// Line 1172:                 curses_libs = ['curses', 'termcap']",
                "// vulnerable line: 1173: else:",
                "// Line 1174:                 curses_libs = ['curses']",
                "// Line 1175: ",
                "// Line 1176:             self.add(Extension('_curses', ['_cursesmodule.c'],",
                "// Line 1177:                                extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
                "// Line 1178:                                define_macros=curses_defines,",
                "// Line 1179:                                libraries=curses_libs))",
                "// vulnerable line: 1180: else:",
                "// Line 1181:             curses_enabled = False",
                "// Line 1182:             self.missing.append('_curses')",
                "// Line 1183: ",
                "// Line 1184:         # If the curses module is enabled, check for the panel module",
                "// Line 1185:         # _curses_panel needs some form of ncurses",
                "// Line 1186:         skip_curses_panel = True if AIX else False",
                "// Line 1187:         if (curses_enabled and not skip_curses_panel and",
                "// Line 1188:                 self.compiler.find_library_file(self.lib_dirs, panel_library)):",
                "// Line 1189:             self.add(Extension('_curses_panel', ['_curses_panel.c'],",
                "// Line 1190:                            include_dirs=curses_includes,",
                "// Line 1197:         # crypt module.",
                "// Line 1198:         if VXWORKS:",
                "// Line 1199:             # bpo-31904: crypt() function is not provided by VxWorks.",
                "// Line 1200:             # DES_crypt() OpenSSL provides is too weak to implement",
                "// Line 1201:             # the encryption.",
                "// Line 1202:             self.missing.append('_crypt')",
                "// Line 1203:             return",
                "// Line 1204: ",
                "// Line 1205:         if self.compiler.find_library_file(self.lib_dirs, 'crypt'):",
                "// Line 1206:             libs = ['crypt']",
                "// vulnerable line: 1207: else:",
                "// Line 1208:             libs = []",
                "// Line 1209: ",
                "// Line 1210:         self.add(Extension('_crypt', ['_cryptmodule.c'], libraries=libs))",
                "// Line 1211: ",
                "// Line 1212:     def detect_socket(self):",
                "// Line 1213:         # socket(2)",
                "// Line 1214:         kwargs = {'depends': ['socketmodule.h']}",
                "// Line 1215:         if MACOS:",
                "// Line 1216:             # Issue #35569: Expose RFC 3542 socket options.",
                "// Line 1217:             kwargs['extra_compile_args'] = ['-D__APPLE_USE_RFC_3542']",
                "// Line 1250: ",
                "// Line 1251:         def gen_db_minor_ver_nums(major):",
                "// Line 1252:             if major == 4:",
                "// Line 1253:                 for x in range(max_db_ver[1]+1):",
                "// Line 1254:                     if allow_db_ver((4, x)):",
                "// Line 1255:                         yield x",
                "// Line 1256:             elif major == 3:",
                "// Line 1257:                 for x in (3,):",
                "// Line 1258:                     if allow_db_ver((3, x)):",
                "// Line 1259:                         yield x",
                "// vulnerable line: 1260: else:",
                "// Line 1261:                 raise ValueError(\"unknown major BerkeleyDB version\", major)",
                "// Line 1262: ",
                "// Line 1263:         # construct a list of paths to look for the header file in on",
                "// Line 1264:         # top of the normal inc_dirs.",
                "// Line 1265:         db_inc_paths = [",
                "// Line 1266:             '/usr/include/db4',",
                "// Line 1267:             '/usr/local/include/db4',",
                "// Line 1268:             '/opt/sfw/include/db4',",
                "// Line 1269:             '/usr/include/db3',",
                "// Line 1270:             '/usr/local/include/db3',",
                "// Line 1346:                                       \"being ignored (4.6.x must be >= 4.6.21)\")",
                "// Line 1347:                                 continue",
                "// Line 1348: ",
                "// Line 1349:                         if ( (db_ver not in db_ver_inc_map) and",
                "// Line 1350:                             allow_db_ver(db_ver) ):",
                "// Line 1351:                             # save the include directory with the db.h version",
                "// Line 1352:                             # (first occurrence only)",
                "// Line 1353:                             db_ver_inc_map[db_ver] = d",
                "// Line 1354:                             if db_setup_debug:",
                "// Line 1355:                                 print(\"db.h: found\", db_ver, \"in\", d)",
                "// vulnerable line: 1356: else:",
                "// Line 1357:                             # we already found a header for this library version",
                "// Line 1358:                             if db_setup_debug: print(\"db.h: ignoring\", d)",
                "// vulnerable line: 1359: else:",
                "// Line 1360:                         # ignore this header, it didn't contain a version number",
                "// Line 1361:                         if db_setup_debug:",
                "// Line 1362:                             print(\"db.h: no version number version in\", d)",
                "// Line 1363: ",
                "// Line 1364:             db_found_vers = list(db_ver_inc_map.keys())",
                "// Line 1365:             db_found_vers.sort()",
                "// Line 1366: ",
                "// Line 1367:             while db_found_vers:",
                "// Line 1368:                 db_ver = db_found_vers.pop()",
                "// Line 1369:                 db_incdir = db_ver_inc_map[db_ver]",
                "// Line 1370: ",
                "// Line 1371:                 # check lib directories parallel to the location of the header",
                "// Line 1372:                 db_dirs_to_check = [",
                "// Line 1373:                     db_incdir.replace(\"include\", 'lib64'),",
                "// Line 1374:                     db_incdir.replace(\"include\", 'lib'),",
                "// Line 1375:                 ]",
                "// Line 1376: ",
                "// Line 1377:                 if not MACOS:",
                "// Line 1378:                     db_dirs_to_check = list(filter(os.path.isdir, db_dirs_to_check))",
                "// Line 1379: ",
                "// vulnerable line: 1380: else:",
                "// Line 1381:                     # Same as other branch, but takes OSX SDK into account",
                "// Line 1382:                     tmp = []",
                "// Line 1383:                     for dn in db_dirs_to_check:",
                "// Line 1384:                         if is_macosx_sdk_path(dn):",
                "// Line 1385:                             if os.path.isdir(os.path.join(sysroot, dn[1:])):",
                "// Line 1386:                                 tmp.append(dn)",
                "// vulnerable line: 1387: else:",
                "// Line 1388:                             if os.path.isdir(dn):",
                "// Line 1389:                                 tmp.append(dn)",
                "// Line 1390:                     db_dirs_to_check = tmp",
                "// Line 1391: ",
                "// Line 1392:                     db_dirs_to_check = tmp",
                "// Line 1393: ",
                "// Line 1394:                 # Look for a version specific db-X.Y before an ambiguous dbX",
                "// Line 1395:                 # XXX should we -ever- look for a dbX name?  Do any",
                "// Line 1396:                 # systems really not name their library by version and",
                "// Line 1397:                 # symlink to more general names?",
                "// Line 1398:                 for dblib in (('db-%d.%d' % db_ver),",
                "// Line 1399:                               ('db%d%d' % db_ver),",
                "// Line 1400:                               ('db%d' % db_ver[0])):",
                "// Line 1401:                     dblib_file = self.compiler.find_library_file(",
                "// Line 1402:                                     db_dirs_to_check + self.lib_dirs, dblib )",
                "// Line 1403:                     if dblib_file:",
                "// Line 1404:                         dblib_dir = [ os.path.abspath(os.path.dirname(dblib_file)) ]",
                "// Line 1405:                         raise db_found",
                "// vulnerable line: 1406: else:",
                "// Line 1407:                         if db_setup_debug: print(\"db lib: \", dblib, \"not found\")",
                "// Line 1408: ",
                "// Line 1409:         except db_found:",
                "// Line 1410:             if db_setup_debug:",
                "// Line 1411:                 print(\"bsddb using BerkeleyDB lib:\", db_ver, dblib)",
                "// Line 1412:                 print(\"bsddb lib dir:\", dblib_dir, \" inc dir:\", db_incdir)",
                "// Line 1413:             dblibs = [dblib]",
                "// Line 1414:             # Only add the found library and include directories if they aren't",
                "// Line 1415:             # already being searched. This avoids an explicit runtime library",
                "// Line 1416:             # dependency.",
                "// Line 1417:             if db_incdir in self.inc_dirs:",
                "// Line 1418:                 db_incs = None",
                "// vulnerable line: 1419: else:",
                "// Line 1420:                 db_incs = [db_incdir]",
                "// Line 1421:             if dblib_dir[0] in self.lib_dirs:",
                "// Line 1422:                 dblib_dir = None",
                "// vulnerable line: 1423: else:",
                "// Line 1424:             if db_setup_debug: print(\"db: no appropriate library found\")",
                "// Line 1425:             db_incs = None",
                "// Line 1426:             dblibs = []",
                "// Line 1427:             dblib_dir = None",
                "// Line 1428: ",
                "// Line 1429:         dbm_setup_debug = False   # verbose debug prints from this script?",
                "// Line 1430:         dbm_order = ['gdbm']",
                "// Line 1431:         # The standard Unix dbm module:",
                "// Line 1432:         if not CYGWIN:",
                "// Line 1433:             config_args = [arg.strip(\"'\")",
                "// Line 1434:                            for arg in sysconfig.get_config_var(\"CONFIG_ARGS\").split()]",
                "// Line 1435:             dbm_args = [arg for arg in config_args",
                "// Line 1436:                         if arg.startswith('--with-dbmliborder=')]",
                "// Line 1437:             if dbm_args:",
                "// Line 1438:                 dbm_order = [arg.split('=')[-1] for arg in dbm_args][-1].split(\":\")",
                "// vulnerable line: 1439: else:",
                "// Line 1440:                 dbm_order = \"ndbm:gdbm:bdb\".split(\":\")",
                "// Line 1441:             dbmext = None",
                "// Line 1442:             for cand in dbm_order:",
                "// Line 1443:                 if cand == \"ndbm\":",
                "// Line 1444:                     if find_file(\"ndbm.h\", self.inc_dirs, []) is not None:",
                "// Line 1445:                         # Some systems have -lndbm, others have -lgdbm_compat,",
                "// Line 1446:                         # others don't have either",
                "// Line 1447:                         if self.compiler.find_library_file(self.lib_dirs,",
                "// Line 1448:                                                                'ndbm'):",
                "// Line 1449:                             ndbm_libs = ['ndbm']",
                "// Line 1450:                         elif self.compiler.find_library_file(self.lib_dirs,",
                "// Line 1451:                                                              'gdbm_compat'):",
                "// Line 1452:                             ndbm_libs = ['gdbm_compat']",
                "// vulnerable line: 1453: else:",
                "// Line 1454:                             ndbm_libs = []",
                "// Line 1455:                         if dbm_setup_debug: print(\"building dbm using ndbm\")",
                "// Line 1456:                         dbmext = Extension('_dbm', ['_dbmmodule.c'],",
                "// Line 1457:                                            define_macros=[",
                "// Line 1458:                                                ('HAVE_NDBM_H',None),",
                "// vulnerable line: 1459: ],",
                "// Line 1460:                                            libraries=ndbm_libs)",
                "// Line 1461:                         break",
                "// Line 1462: ",
                "// Line 1463:                 elif cand == \"gdbm\":",
                "// Line 1464:                     if self.compiler.find_library_file(self.lib_dirs, 'gdbm'):",
                "// Line 1465:                         gdbm_libs = ['gdbm']",
                "// Line 1466:                         if self.compiler.find_library_file(self.lib_dirs,",
                "// Line 1467:                                                                'gdbm_compat'):",
                "// Line 1468:                             gdbm_libs.append('gdbm_compat')",
                "// Line 1469:                         if find_file(\"gdbm/ndbm.h\", self.inc_dirs, []) is not None:",
                "// Line 1470:                             if dbm_setup_debug: print(\"building dbm using gdbm\")",
                "// Line 1471:                             dbmext = Extension(",
                "// Line 1472:                                 '_dbm', ['_dbmmodule.c'],",
                "// Line 1473:                                 define_macros=[",
                "// Line 1474:                                     ('HAVE_GDBM_NDBM_H', None),",
                "// vulnerable line: 1475: ],",
                "// Line 1476:                                 libraries = gdbm_libs)",
                "// Line 1477:                             break",
                "// Line 1478:                         if find_file(\"gdbm-ndbm.h\", self.inc_dirs, []) is not None:",
                "// Line 1479:                             if dbm_setup_debug: print(\"building dbm using gdbm\")",
                "// Line 1480:                             dbmext = Extension(",
                "// Line 1481:                                 '_dbm', ['_dbmmodule.c'],",
                "// Line 1482:                                 define_macros=[",
                "// Line 1483:                                     ('HAVE_GDBM_DASH_NDBM_H', None),",
                "// vulnerable line: 1484: ],",
                "// Line 1485:                                 libraries = gdbm_libs)",
                "// Line 1486:                             break",
                "// Line 1487:                 elif cand == \"bdb\":",
                "// Line 1488:                     if dblibs:",
                "// Line 1489:                         if dbm_setup_debug: print(\"building dbm using bdb\")",
                "// Line 1490:                         dbmext = Extension('_dbm', ['_dbmmodule.c'],",
                "// Line 1491:                                            library_dirs=dblib_dir,",
                "// Line 1492:                                            runtime_library_dirs=dblib_dir,",
                "// Line 1493:                                            include_dirs=db_incs,",
                "// Line 1494:                                            define_macros=[",
                "// Line 1495:                                                ('HAVE_BERKDB_H', None),",
                "// Line 1496:                                                ('DB_DBM_HSEARCH', None),",
                "// vulnerable line: 1497: ],",
                "// Line 1498:                                            libraries=dblibs)",
                "// Line 1499:                         break",
                "// Line 1500:             if dbmext is not None:",
                "// Line 1501:                 self.add(dbmext)",
                "// vulnerable line: 1502: else:",
                "// Line 1503:                 self.missing.append('_dbm')",
                "// Line 1504: ",
                "// Line 1505:         # Anthony Baxter's gdbm module.  GNU dbm(3) will require -lgdbm:",
                "// Line 1506:         if ('gdbm' in dbm_order and",
                "// Line 1507:             self.compiler.find_library_file(self.lib_dirs, 'gdbm')):",
                "// Line 1508:             self.add(Extension('_gdbm', ['_gdbmmodule.c'],",
                "// Line 1509:                                libraries=['gdbm']))",
                "// vulnerable line: 1510: else:",
                "// Line 1511:             self.missing.append('_gdbm')",
                "// Line 1512: ",
                "// Line 1513:     def detect_sqlite(self):",
                "// Line 1514:         # The sqlite interface",
                "// Line 1515:         sqlite_setup_debug = False   # verbose debug prints from this script?",
                "// Line 1516: ",
                "// Line 1517:         # We hunt for #define SQLITE_VERSION \"n.n.n\"",
                "// Line 1518:         sqlite_incdir = sqlite_libdir = None",
                "// Line 1519:         sqlite_inc_paths = [ '/usr/include',",
                "// Line 1520:                              '/usr/include/sqlite',",
                "// Line 1550:                 if m:",
                "// Line 1551:                     sqlite_version = m.group(1)",
                "// Line 1552:                     sqlite_version_tuple = tuple([int(x)",
                "// Line 1553:                                         for x in sqlite_version.split(\".\")])",
                "// Line 1554:                     if sqlite_version_tuple >= MIN_SQLITE_VERSION_NUMBER:",
                "// Line 1555:                         # we win!",
                "// Line 1556:                         if sqlite_setup_debug:",
                "// Line 1557:                             print(\"%s/sqlite3.h: version %s\"%(d, sqlite_version))",
                "// Line 1558:                         sqlite_incdir = d",
                "// Line 1559:                         break",
                "// vulnerable line: 1560: else:",
                "// Line 1561:                         if sqlite_setup_debug:",
                "// Line 1562:                             print(\"%s: version %s is too old, need >= %s\"%(d,",
                "// Line 1563:                                         sqlite_version, MIN_SQLITE_VERSION))",
                "// Line 1564:                 elif sqlite_setup_debug:",
                "// Line 1565:                     print(\"sqlite: %s had no SQLITE_VERSION\"%(f,))",
                "// Line 1566: ",
                "// Line 1567:         if sqlite_incdir:",
                "// Line 1568:             sqlite_dirs_to_check = [",
                "// Line 1569:                 os.path.join(sqlite_incdir, '..', 'lib64'),",
                "// Line 1570:                 os.path.join(sqlite_incdir, '..', 'lib'),",
                "// Line 1593:             if '--enable-loadable-sqlite-extensions' not in sysconfig.get_config_var(\"CONFIG_ARGS\"):",
                "// Line 1594:                 sqlite_defines.append((\"SQLITE_OMIT_LOAD_EXTENSION\", \"1\"))",
                "// Line 1595: ",
                "// Line 1596:             if MACOS:",
                "// Line 1597:                 # In every directory on the search path search for a dynamic",
                "// Line 1598:                 # library and then a static library, instead of first looking",
                "// Line 1599:                 # for dynamic libraries on the entire path.",
                "// Line 1600:                 # This way a statically linked custom sqlite gets picked up",
                "// Line 1601:                 # before the dynamic library in /usr/lib.",
                "// Line 1602:                 sqlite_extra_link_args = ('-Wl,-search_paths_first',)",
                "// vulnerable line: 1603: else:",
                "// Line 1604:                 sqlite_extra_link_args = ()",
                "// Line 1605: ",
                "// Line 1606:             include_dirs = [\"Modules/_sqlite\"]",
                "// Line 1607:             # Only include the directory where sqlite was found if it does",
                "// Line 1608:             # not already exist in set include directories, otherwise you",
                "// Line 1609:             # can end up with a bad search path order.",
                "// Line 1610:             if sqlite_incdir not in self.compiler.include_dirs:",
                "// Line 1611:                 include_dirs.append(sqlite_incdir)",
                "// Line 1612:             # avoid a runtime library path for a system library dir",
                "// Line 1613:             if sqlite_libdir and sqlite_libdir[0] in self.lib_dirs:",
                "// Line 1614:                 sqlite_libdir = None",
                "// Line 1615:             self.add(Extension('_sqlite3', sqlite_srcs,",
                "// Line 1616:                                define_macros=sqlite_defines,",
                "// Line 1617:                                include_dirs=include_dirs,",
                "// Line 1618:                                library_dirs=sqlite_libdir,",
                "// Line 1619:                                extra_link_args=sqlite_extra_link_args,",
                "// Line 1620:                                libraries=[\"sqlite3\",]))",
                "// vulnerable line: 1621: else:",
                "// Line 1622:             self.missing.append('_sqlite3')",
                "// Line 1623: ",
                "// Line 1624:     def detect_platform_specific_exts(self):",
                "// Line 1625:         # Unix-only modules",
                "// Line 1626:         if not MS_WINDOWS:",
                "// Line 1627:             if not VXWORKS:",
                "// Line 1628:                 # Steen Lumholt's termios module",
                "// Line 1629:                 self.add(Extension('termios', ['termios.c']))",
                "// Line 1630:                 # Jeremy Hylton's rlimit interface",
                "// Line 1631:             self.add(Extension('resource', ['resource.c']))",
                "// vulnerable line: 1632: else:",
                "// Line 1633:             self.missing.extend(['resource', 'termios'])",
                "// Line 1634: ",
                "// Line 1635:         # Platform-specific libraries",
                "// Line 1636:         if HOST_PLATFORM.startswith(('linux', 'freebsd', 'gnukfreebsd')):",
                "// Line 1637:             self.add(Extension('ossaudiodev', ['ossaudiodev.c']))",
                "// Line 1638:         elif not AIX:",
                "// Line 1639:             self.missing.append('ossaudiodev')",
                "// Line 1640: ",
                "// Line 1641:         if MACOS:",
                "// Line 1642:             self.add(Extension('_scproxy', ['_scproxy.c'],",
                "// Line 1670:                     line = fp.readline()",
                "// Line 1671:                     if not line:",
                "// Line 1672:                         break",
                "// Line 1673:                     if line.startswith('#define ZLIB_VERSION'):",
                "// Line 1674:                         version = line.split()[2]",
                "// Line 1675:                         break",
                "// Line 1676:             if version >= version_req:",
                "// Line 1677:                 if (self.compiler.find_library_file(self.lib_dirs, 'z')):",
                "// Line 1678:                     if MACOS:",
                "// Line 1679:                         zlib_extra_link_args = ('-Wl,-search_paths_first',)",
                "// vulnerable line: 1680: else:",
                "// Line 1681:                         zlib_extra_link_args = ()",
                "// Line 1682:                     self.add(Extension('zlib', ['zlibmodule.c'],",
                "// Line 1683:                                        libraries=['z'],",
                "// Line 1684:                                        extra_link_args=zlib_extra_link_args))",
                "// Line 1685:                     have_zlib = True",
                "// vulnerable line: 1686: else:",
                "// Line 1687:                     self.missing.append('zlib')",
                "// vulnerable line: 1688: else:",
                "// Line 1689:                 self.missing.append('zlib')",
                "// vulnerable line: 1690: else:",
                "// Line 1691:             self.missing.append('zlib')",
                "// Line 1692: ",
                "// Line 1693:         # Helper module for various ascii-encoders.  Uses zlib for an optimized",
                "// Line 1694:         # crc32 if we have it.  Otherwise binascii uses its own.",
                "// Line 1695:         if have_zlib:",
                "// Line 1696:             extra_compile_args = ['-DUSE_ZLIB_CRC32']",
                "// Line 1697:             libraries = ['z']",
                "// Line 1698:             extra_link_args = zlib_extra_link_args",
                "// vulnerable line: 1699: else:",
                "// Line 1700:             extra_compile_args = []",
                "// Line 1701:             libraries = []",
                "// Line 1702:             extra_link_args = []",
                "// Line 1703:         self.add(Extension('binascii', ['binascii.c'],",
                "// Line 1704:                            extra_compile_args=extra_compile_args,",
                "// Line 1705:                            libraries=libraries,",
                "// Line 1706:                            extra_link_args=extra_link_args))",
                "// Line 1707: ",
                "// Line 1708:         # Gustavo Niemeyer's bz2 module.",
                "// Line 1709:         if (self.compiler.find_library_file(self.lib_dirs, 'bz2')):",
                "// Line 1710:             if MACOS:",
                "// Line 1711:                 bz2_extra_link_args = ('-Wl,-search_paths_first',)",
                "// vulnerable line: 1712: else:",
                "// Line 1713:                 bz2_extra_link_args = ()",
                "// Line 1714:             self.add(Extension('_bz2', ['_bz2module.c'],",
                "// Line 1715:                                libraries=['bz2'],",
                "// Line 1716:                                extra_link_args=bz2_extra_link_args))",
                "// vulnerable line: 1717: else:",
                "// Line 1718:             self.missing.append('_bz2')",
                "// Line 1719: ",
                "// Line 1720:         # LZMA compression support.",
                "// Line 1721:         if self.compiler.find_library_file(self.lib_dirs, 'lzma'):",
                "// Line 1722:             self.add(Extension('_lzma', ['_lzmamodule.c'],",
                "// Line 1723:                                libraries=['lzma']))",
                "// vulnerable line: 1724: else:",
                "// Line 1725:             self.missing.append('_lzma')",
                "// Line 1726: ",
                "// Line 1727:     def detect_expat_elementtree(self):",
                "// Line 1728:         # Interface to the Expat XML parser",
                "// Line 1729:         #",
                "// Line 1730:         # Expat was written by James Clark and is now maintained by a group of",
                "// Line 1731:         # developers on SourceForge; see www.libexpat.org for more information.",
                "// Line 1732:         # The pyexpat module was written by Paul Prescod after a prototype by",
                "// Line 1733:         # Jack Jansen.  The Expat source is included in Modules/expat/.  Usage",
                "// Line 1734:         # of a system shared libexpat.so is possible with --with-system-expat",
                "// Line 1736:         #",
                "// Line 1737:         # More information on Expat can be found at www.libexpat.org.",
                "// Line 1738:         #",
                "// Line 1739:         if '--with-system-expat' in sysconfig.get_config_var(\"CONFIG_ARGS\"):",
                "// Line 1740:             expat_inc = []",
                "// Line 1741:             define_macros = []",
                "// Line 1742:             extra_compile_args = []",
                "// Line 1743:             expat_lib = ['expat']",
                "// Line 1744:             expat_sources = []",
                "// Line 1745:             expat_depends = []",
                "// vulnerable line: 1746: else:",
                "// Line 1747:             expat_inc = [os.path.join(self.srcdir, 'Modules', 'expat')]",
                "// Line 1748:             define_macros = [",
                "// Line 1749:                 ('HAVE_EXPAT_CONFIG_H', '1'),",
                "// Line 1750:                 # bpo-30947: Python uses best available entropy sources to",
                "// Line 1751:                 # call XML_SetHashSalt(), expat entropy sources are not needed",
                "// Line 1752:                 ('XML_POOR_ENTROPY', '1'),",
                "// Line 1753:             ]",
                "// Line 1754:             extra_compile_args = []",
                "// Line 1755:             expat_lib = []",
                "// Line 1756:             expat_sources = ['expat/xmlparse.c',",
                "// Line 1788: ",
                "// Line 1789:         if os.path.isfile(os.path.join(self.srcdir, 'Modules', '_elementtree.c')):",
                "// Line 1790:             define_macros.append(('USE_PYEXPAT_CAPI', None))",
                "// Line 1791:             self.add(Extension('_elementtree',",
                "// Line 1792:                                define_macros=define_macros,",
                "// Line 1793:                                include_dirs=expat_inc,",
                "// Line 1794:                                libraries=expat_lib,",
                "// Line 1795:                                sources=['_elementtree.c'],",
                "// Line 1796:                                depends=['pyexpat.c', *expat_sources,",
                "// Line 1797:                                         *expat_depends]))",
                "// vulnerable line: 1798: else:",
                "// Line 1799:             self.missing.append('_elementtree')",
                "// Line 1800: ",
                "// Line 1801:     def detect_multibytecodecs(self):",
                "// Line 1802:         # Hye-Shik Chang's CJKCodecs modules.",
                "// Line 1803:         self.add(Extension('_multibytecodec',",
                "// Line 1804:                            ['cjkcodecs/multibytecodec.c']))",
                "// Line 1805:         for loc in ('kr', 'jp', 'cn', 'tw', 'hk', 'iso2022'):",
                "// Line 1806:             self.add(Extension('_codecs_%s' % loc,",
                "// Line 1807:                                ['cjkcodecs/_codecs_%s.c' % loc]))",
                "// Line 1808: ",
                "// Line 1809:     def detect_multiprocessing(self):",
                "// Line 1810:         # Richard Oudkerk's multiprocessing module",
                "// Line 1811:         if MS_WINDOWS:",
                "// Line 1812:             multiprocessing_srcs = ['_multiprocessing/multiprocessing.c',",
                "// Line 1813:                                     '_multiprocessing/semaphore.c']",
                "// vulnerable line: 1814: else:",
                "// Line 1815:             multiprocessing_srcs = ['_multiprocessing/multiprocessing.c']",
                "// Line 1816:             if (sysconfig.get_config_var('HAVE_SEM_OPEN') and not",
                "// Line 1817:                 sysconfig.get_config_var('POSIX_SEMAPHORES_NOT_ENABLED')):",
                "// Line 1818:                 multiprocessing_srcs.append('_multiprocessing/semaphore.c')",
                "// Line 1819:         self.add(Extension('_multiprocessing', multiprocessing_srcs,",
                "// Line 1820:                            include_dirs=[\"Modules/_multiprocessing\"]))",
                "// Line 1821: ",
                "// Line 1822:         if (not MS_WINDOWS and",
                "// Line 1823:            sysconfig.get_config_var('HAVE_SHM_OPEN') and",
                "// Line 1824:            sysconfig.get_config_var('HAVE_SHM_UNLINK')):",
                "// Line 1825:             posixshmem_srcs = ['_multiprocessing/posixshmem.c']",
                "// Line 1826:             libs = []",
                "// Line 1827:             if sysconfig.get_config_var('SHM_NEEDS_LIBRT'):",
                "// Line 1828:                 # need to link with librt to get shm_open()",
                "// Line 1829:                 libs.append('rt')",
                "// Line 1830:             self.add(Extension('_posixshmem', posixshmem_srcs,",
                "// Line 1831:                                define_macros={},",
                "// Line 1832:                                libraries=libs,",
                "// Line 1833:                                include_dirs=[\"Modules/_multiprocessing\"]))",
                "// vulnerable line: 1834: else:",
                "// Line 1835:             self.missing.append('_posixshmem')",
                "// Line 1836: ",
                "// Line 1837:     def detect_uuid(self):",
                "// Line 1838:         # Build the _uuid module if possible",
                "// Line 1839:         uuid_incs = find_file(\"uuid.h\", self.inc_dirs, [\"/usr/include/uuid\"])",
                "// Line 1840:         if uuid_incs is not None:",
                "// Line 1841:             if self.compiler.find_library_file(self.lib_dirs, 'uuid'):",
                "// Line 1842:                 uuid_libs = ['uuid']",
                "// vulnerable line: 1843: else:",
                "// Line 1844:                 uuid_libs = []",
                "// Line 1845:             self.add(Extension('_uuid', ['_uuidmodule.c'],",
                "// Line 1846:                                libraries=uuid_libs,",
                "// Line 1847:                                include_dirs=uuid_incs))",
                "// vulnerable line: 1848: else:",
                "// Line 1849:             self.missing.append('_uuid')",
                "// Line 1850: ",
                "// Line 1851:     def detect_modules(self):",
                "// Line 1852:         self.configure_compiler()",
                "// Line 1853:         self.init_inc_lib_dirs()",
                "// Line 1854: ",
                "// Line 1855:         self.detect_simple_extensions()",
                "// Line 1856:         if TEST_EXTENSIONS:",
                "// Line 1857:             self.detect_test_extensions()",
                "// Line 1858:         self.detect_readline_curses()",
                "// Line 1976: ",
                "// Line 1977:         sysroot = macosx_sdk_root() # path to the SDK or '/'",
                "// Line 1978: ",
                "// Line 1979:         if macosx_sdk_specified():",
                "// Line 1980:             # Use case #2: an SDK other than '/' was specified.",
                "// Line 1981:             # Only search there.",
                "// Line 1982:             framework_dirs = [",
                "// Line 1983:                 join(sysroot, 'Library', 'Frameworks'),",
                "// Line 1984:                 join(sysroot, 'System', 'Library', 'Frameworks'),",
                "// Line 1985:             ]",
                "// vulnerable line: 1986: else:",
                "// Line 1987:             # Use case #1: no explicit SDK selected.",
                "// Line 1988:             # Search the local system-wide /Library/Frameworks,",
                "// Line 1989:             # not the one in the default SDK, otherwise fall back to",
                "// Line 1990:             # /System/Library/Frameworks whose header files may be in",
                "// Line 1991:             # the default SDK or, on older systems, actually installed.",
                "// Line 1992:             framework_dirs = [",
                "// Line 1993:                 join('/', 'Library', 'Frameworks'),",
                "// Line 1994:                 join(sysroot, 'System', 'Library', 'Frameworks'),",
                "// Line 1995:             ]",
                "// Line 1996: ",
                "// Line 1997:         # Find the directory that contains the Tcl.framework and",
                "// Line 1998:         # Tk.framework bundles.",
                "// Line 1999:         for F in framework_dirs:",
                "// Line 2000:             # both Tcl.framework and Tk.framework should be present",
                "// Line 2001:             for fw in 'Tcl', 'Tk':",
                "// Line 2002:                 if not exists(join(F, fw + '.framework')):",
                "// Line 2003:                     break",
                "// vulnerable line: 2004: else:",
                "// Line 2005:                 # ok, F is now directory with both frameworks. Continue",
                "// Line 2006:                 # building",
                "// Line 2007:                 break",
                "// vulnerable line: 2008: else:",
                "// Line 2009:             # Tk and Tcl frameworks not found. Normal \"unix\" tkinter search",
                "// Line 2010:             # will now resume.",
                "// Line 2011:             return False",
                "// Line 2012: ",
                "// Line 2013:         include_dirs = [",
                "// Line 2014:             join(F, fw + '.framework', H)",
                "// Line 2015:             for fw in ('Tcl', 'Tk')",
                "// Line 2016:             for H in ('Headers',)",
                "// Line 2017:         ]",
                "// Line 2018: ",
                "// Line 2022:         # Do not build tkinter for archs that this Tk was not built with.",
                "// Line 2023:         cflags = sysconfig.get_config_vars('CFLAGS')[0]",
                "// Line 2024:         archs = re.findall(r'-arch\\s+(\\w+)', cflags)",
                "// Line 2025: ",
                "// Line 2026:         tmpfile = os.path.join(self.build_temp, 'tk.arch')",
                "// Line 2027:         if not os.path.exists(self.build_temp):",
                "// Line 2028:             os.makedirs(self.build_temp)",
                "// Line 2029: ",
                "// Line 2030:         run_command(",
                "// Line 2031:             \"file {}/Tk.framework/Tk | grep 'for architecture' > {}\".format(F, tmpfile)",
                "// vulnerable line: 2032: )",
                "// Line 2033:         with open(tmpfile) as fp:",
                "// Line 2034:             detected_archs = []",
                "// Line 2035:             for ln in fp:",
                "// Line 2036:                 a = ln.split()[-1]",
                "// Line 2037:                 if a in archs:",
                "// Line 2038:                     detected_archs.append(ln.split()[-1])",
                "// Line 2039:         os.unlink(tmpfile)",
                "// Line 2040: ",
                "// Line 2041:         arch_args = []",
                "// Line 2042:         for a in detected_archs:",
                "// Line 2132:         if HOST_PLATFORM == 'sunos5':",
                "// Line 2133:             include_dirs.append('/usr/openwin/include')",
                "// Line 2134:             added_lib_dirs.append('/usr/openwin/lib')",
                "// Line 2135:         elif os.path.exists('/usr/X11R6/include'):",
                "// Line 2136:             include_dirs.append('/usr/X11R6/include')",
                "// Line 2137:             added_lib_dirs.append('/usr/X11R6/lib64')",
                "// Line 2138:             added_lib_dirs.append('/usr/X11R6/lib')",
                "// Line 2139:         elif os.path.exists('/usr/X11R5/include'):",
                "// Line 2140:             include_dirs.append('/usr/X11R5/include')",
                "// Line 2141:             added_lib_dirs.append('/usr/X11R5/lib')",
                "// vulnerable line: 2142: else:",
                "// Line 2143:             # Assume default location for X11",
                "// Line 2144:             include_dirs.append('/usr/X11/include')",
                "// Line 2145:             added_lib_dirs.append('/usr/X11/lib')",
                "// Line 2146: ",
                "// Line 2147:         # If Cygwin, then verify that X is installed before proceeding",
                "// Line 2148:         if CYGWIN:",
                "// Line 2149:             x11_inc = find_file('X11/Xlib.h', [], include_dirs)",
                "// Line 2150:             if x11_inc is None:",
                "// Line 2151:                 return False",
                "// Line 2152: ",
                "// Line 2181:         return True",
                "// Line 2182: ",
                "// Line 2183:     def configure_ctypes(self, ext):",
                "// Line 2184:         return True",
                "// Line 2185: ",
                "// Line 2186:     def detect_ctypes(self):",
                "// Line 2187:         # Thomas Heller's _ctypes module",
                "// Line 2188: ",
                "// Line 2189:         if (not sysconfig.get_config_var(\"LIBFFI_INCLUDEDIR\") and MACOS):",
                "// Line 2190:             self.use_system_libffi = True",
                "// vulnerable line: 2191: else:",
                "// Line 2192:             self.use_system_libffi = '--with-system-ffi' in sysconfig.get_config_var(\"CONFIG_ARGS\")",
                "// Line 2193: ",
                "// Line 2194:         include_dirs = []",
                "// Line 2195:         extra_compile_args = ['-DPy_BUILD_CORE_MODULE']",
                "// Line 2196:         extra_link_args = []",
                "// Line 2197:         sources = ['_ctypes/_ctypes.c',",
                "// Line 2198:                    '_ctypes/callbacks.c',",
                "// Line 2199:                    '_ctypes/callproc.c',",
                "// Line 2200:                    '_ctypes/stgdict.c',",
                "// Line 2201:                    '_ctypes/cfield.c']",
                "// Line 2240: ",
                "// Line 2241:         ffi_inc_dirs = self.inc_dirs.copy()",
                "// Line 2242:         if MACOS:",
                "// Line 2243:             ffi_in_sdk = os.path.join(macosx_sdk_root(), \"usr/include/ffi\")",
                "// Line 2244: ",
                "// Line 2245:             if not ffi_inc:",
                "// Line 2246:                 if os.path.exists(ffi_in_sdk):",
                "// Line 2247:                     ext.extra_compile_args.append(\"-DUSING_APPLE_OS_LIBFFI=1\")",
                "// Line 2248:                     ffi_inc = ffi_in_sdk",
                "// Line 2249:                     ffi_lib = 'ffi'",
                "// vulnerable line: 2250: else:",
                "// Line 2251:                     # OS X 10.5 comes with libffi.dylib; the include files are",
                "// Line 2252:                     # in /usr/include/ffi",
                "// Line 2253:                     ffi_inc_dirs.append('/usr/include/ffi')",
                "// Line 2254: ",
                "// Line 2255:         if not ffi_inc:",
                "// Line 2256:             found = find_file('ffi.h', [], ffi_inc_dirs)",
                "// Line 2257:             if found:",
                "// Line 2258:                 ffi_inc = found[0]",
                "// Line 2259:         if ffi_inc:",
                "// Line 2260:             ffi_h = ffi_inc + '/ffi.h'",
                "// Line 2286: ",
                "// Line 2287:     def detect_decimal(self):",
                "// Line 2288:         # Stefan Krah's _decimal module",
                "// Line 2289:         extra_compile_args = []",
                "// Line 2290:         undef_macros = []",
                "// Line 2291:         if '--with-system-libmpdec' in sysconfig.get_config_var(\"CONFIG_ARGS\"):",
                "// Line 2292:             include_dirs = []",
                "// Line 2293:             libraries = ['mpdec']",
                "// Line 2294:             sources = ['_decimal/_decimal.c']",
                "// Line 2295:             depends = ['_decimal/docstrings.h']",
                "// vulnerable line: 2296: else:",
                "// Line 2297:             include_dirs = [os.path.abspath(os.path.join(self.srcdir,",
                "// Line 2298:                                                          'Modules',",
                "// Line 2299:                                                          '_decimal',",
                "// Line 2300:                                                          'libmpdec'))]",
                "// Line 2301:             libraries = ['m']",
                "// Line 2302:             sources = [",
                "// Line 2303:               '_decimal/_decimal.c',",
                "// Line 2304:               '_decimal/libmpdec/basearith.c',",
                "// Line 2305:               '_decimal/libmpdec/constants.c',",
                "// Line 2306:               '_decimal/libmpdec/context.c',",
                "// Line 2356:             define_macros = config[machine]",
                "// Line 2357:         elif MACOS:",
                "// Line 2358:             # Universal here means: build with the same options Python",
                "// Line 2359:             # was built with.",
                "// Line 2360:             define_macros = config['universal']",
                "// Line 2361:         elif sizeof_size_t == 8:",
                "// Line 2362:             if sysconfig.get_config_var('HAVE_GCC_ASM_FOR_X64'):",
                "// Line 2363:                 define_macros = config['x64']",
                "// Line 2364:             elif sysconfig.get_config_var('HAVE_GCC_UINT128_T'):",
                "// Line 2365:                 define_macros = config['uint128']",
                "// vulnerable line: 2366: else:",
                "// Line 2367:                 define_macros = config['ansi64']",
                "// Line 2368:         elif sizeof_size_t == 4:",
                "// Line 2369:             ppro = sysconfig.get_config_var('HAVE_GCC_ASM_FOR_X87')",
                "// Line 2370:             if ppro and ('gcc' in cc or 'clang' in cc) and                not 'sunos' in HOST_PLATFORM:",
                "// Line 2371:                 # solaris: problems with register allocation.",
                "// Line 2372:                 # icc >= 11.0 works as well.",
                "// Line 2373:                 define_macros = config['ppro']",
                "// Line 2374:                 extra_compile_args.append('-Wno-unknown-pragmas')",
                "// vulnerable line: 2375: else:",
                "// Line 2376:                 define_macros = config['ansi32']",
                "// vulnerable line: 2377: else:",
                "// Line 2378:             raise DistutilsError(\"_decimal: unsupported architecture\")",
                "// Line 2379: ",
                "// Line 2380:         # Workarounds for toolchain bugs:",
                "// Line 2381:         if sysconfig.get_config_var('HAVE_IPA_PURE_CONST_BUG'):",
                "// Line 2382:             # Some versions of gcc miscompile inline asm:",
                "// Line 2383:             # http://gcc.gnu.org/bugzilla/show_bug.cgi?id=46491",
                "// Line 2384:             # http://gcc.gnu.org/ml/gcc/2010-11/msg00366.html",
                "// Line 2385:             extra_compile_args.append('-fno-ipa-pure-const')",
                "// Line 2386:         if sysconfig.get_config_var('HAVE_GLIBC_MEMMOVE_BUG'):",
                "// Line 2387:             # _FORTIFY_SOURCE wrappers for memmove and bcopy are incorrect:",
                "// Line 2419:         openssl_libs = split_var('OPENSSL_LIBS', '-l')",
                "// Line 2420:         openssl_rpath = config_vars.get('OPENSSL_RPATH')",
                "// Line 2421:         if not openssl_libs:",
                "// Line 2422:             # libssl and libcrypto not found",
                "// Line 2423:             self.missing.extend(['_ssl', '_hashlib'])",
                "// Line 2424:             return None, None",
                "// Line 2425: ",
                "// Line 2426:         # Find OpenSSL includes",
                "// Line 2427:         ssl_incs = find_file(",
                "// Line 2428:             'openssl/ssl.h', self.inc_dirs, openssl_includes",
                "// vulnerable line: 2429: )",
                "// Line 2430:         if ssl_incs is None:",
                "// Line 2431:             self.missing.extend(['_ssl', '_hashlib'])",
                "// Line 2432:             return None, None",
                "// Line 2433: ",
                "// vulnerable line: 2434: # OpenSSL 1.0.2 uses Kerberos for KRB5 ciphers",
                "// vulnerable line: 2435: krb5_h = find_file(",
                "// vulnerable line: 2436: 'krb5.h', self.inc_dirs,",
                "// vulnerable line: 2437: ['/usr/kerberos/include']",
                "// vulnerable line: 2438: )",
                "// vulnerable line: 2439: if krb5_h:",
                "// vulnerable line: 2440: ssl_incs.extend(krb5_h)",
                "// Line 2441: ",
                "// Line 2442:         if openssl_rpath == 'auto':",
                "// Line 2443:             runtime_library_dirs = openssl_libdirs[:]",
                "// Line 2444:         elif not openssl_rpath:",
                "// Line 2445:             runtime_library_dirs = []",
                "// vulnerable line: 2446: else:",
                "// Line 2447:             runtime_library_dirs = [openssl_rpath]",
                "// Line 2448: ",
                "// Line 2449:         openssl_extension_kwargs = dict(",
                "// Line 2450:             include_dirs=openssl_includes,",
                "// Line 2451:             library_dirs=openssl_libdirs,",
                "// Line 2452:             libraries=openssl_libs,",
                "// Line 2453:             runtime_library_dirs=runtime_library_dirs,",
                "// vulnerable line: 2454: )",
                "// Line 2455: ",
                "// Line 2456:         # This static linking is NOT OFFICIALLY SUPPORTED.",
                "// Line 2457:         # Requires static OpenSSL build with position-independent code. Some",
                "// Line 2458:         # features like DSO engines or external OSSL providers don't work.",
                "// Line 2459:         # Only tested on GCC and clang on X86_64.",
                "// Line 2460:         if os.environ.get(\"PY_UNSUPPORTED_OPENSSL_BUILD\") == \"static\":",
                "// Line 2461:             extra_linker_args = []",
                "// Line 2462:             for lib in openssl_extension_kwargs[\"libraries\"]:",
                "// Line 2463:                 # link statically",
                "// Line 2464:                 extra_linker_args.append(f\"-l:lib{lib}.a\")",
                "// Line 2465:                 # don't export symbols",
                "// Line 2466:                 extra_linker_args.append(f\"-Wl,--exclude-libs,lib{lib}.a\")",
                "// Line 2467:             openssl_extension_kwargs[\"extra_link_args\"] = extra_linker_args",
                "// Line 2468:             # don't link OpenSSL shared libraries.",
                "// Line 2469:             openssl_extension_kwargs[\"libraries\"] = []",
                "// Line 2470: ",
                "// vulnerable line: 2471: if config_vars.get(\"HAVE_X509_VERIFY_PARAM_SET1_HOST\"):",
                "// vulnerable line: 2472: self.add(",
                "// vulnerable line: 2473: Extension(",
                "// vulnerable line: 2474: '_ssl',",
                "// vulnerable line: 2475: ['_ssl.c'],",
                "// vulnerable line: 2476: depends=[",
                "// vulnerable line: 2477: 'socketmodule.h',",
                "// vulnerable line: 2478: '_ssl/debughelpers.c',",
                "// vulnerable line: 2479: '_ssl_data.h',",
                "// vulnerable line: 2480: '_ssl_data_111.h',",
                "// vulnerable line: 2481: '_ssl_data_300.h',",
                "// vulnerable line: 2482: ],",
                "// vulnerable line: 2483: **openssl_extension_kwargs",
                "// vulnerable line: 2484: )",
                "// vulnerable line: 2485: )",
                "// vulnerable line: 2486: else:",
                "// vulnerable line: 2487: self.missing.append('_ssl')",
                "// Line 2488: ",
                "// vulnerable line: 2489: self.add(",
                "// vulnerable line: 2490: Extension(",
                "// Line 2491:                 '_hashlib',",
                "// Line 2492:                 ['_hashopenssl.c'],",
                "// Line 2493:                 depends=['hashlib.h'],",
                "// Line 2494:                 **openssl_extension_kwargs,",
                "// vulnerable line: 2495: )",
                "// vulnerable line: 2496: )",
                "// Line 2497: ",
                "// Line 2498:     def detect_hash_builtins(self):",
                "// Line 2499:         # By default we always compile these even when OpenSSL is available",
                "// Line 2500:         # (issue #14693). It's harmless and the object code is tiny",
                "// Line 2501:         # (40-50 KiB per module, only loaded when actually used).  Modules can",
                "// Line 2502:         # be disabled via the --with-builtin-hashlib-hashes configure flag.",
                "// Line 2503:         supported = {\"md5\", \"sha1\", \"sha256\", \"sha512\", \"sha3\", \"blake2\"}",
                "// Line 2504: ",
                "// Line 2505:         configured = sysconfig.get_config_var(\"PY_BUILTIN_HASHLIB_HASHES\")",
                "// Line 2506:         configured = configured.strip('\"').lower()",
                "// Line 2507:         configured = {",
                "// Line 2508:             m.strip() for m in configured.split(\",\")",
                "// Line 2509:         }",
                "// Line 2510: ",
                "// Line 2511:         self.disabled_configure.extend(",
                "// Line 2512:             sorted(supported.difference(configured))",
                "// vulnerable line: 2513: )",
                "// Line 2514: ",
                "// Line 2515:         if \"sha256\" in configured:",
                "// Line 2516:             self.add(Extension(",
                "// Line 2517:                 '_sha256', ['sha256module.c'],",
                "// Line 2518:                 extra_compile_args=['-DPy_BUILD_CORE_MODULE'],",
                "// Line 2519:                 depends=['hashlib.h']",
                "// Line 2520:             ))",
                "// Line 2521: ",
                "// Line 2522:         if \"sha512\" in configured:",
                "// Line 2523:             self.add(Extension(",
                "// Line 2534: ",
                "// Line 2535:         if \"sha1\" in configured:",
                "// Line 2536:             self.add(Extension(",
                "// Line 2537:                 '_sha1', ['sha1module.c'],",
                "// Line 2538:                 depends=['hashlib.h']",
                "// Line 2539:             ))",
                "// Line 2540: ",
                "// Line 2541:         if \"blake2\" in configured:",
                "// Line 2542:             blake2_deps = glob(",
                "// Line 2543:                 os.path.join(escape(self.srcdir), 'Modules/_blake2/impl/*')",
                "// vulnerable line: 2544: )",
                "// Line 2545:             blake2_deps.append('hashlib.h')",
                "// Line 2546:             self.add(Extension(",
                "// Line 2547:                 '_blake2',",
                "// Line 2548:                 [",
                "// Line 2549:                     '_blake2/blake2module.c',",
                "// Line 2550:                     '_blake2/blake2b_impl.c',",
                "// Line 2551:                     '_blake2/blake2s_impl.c'",
                "// vulnerable line: 2552: ],",
                "// Line 2553:                 depends=blake2_deps",
                "// Line 2554:             ))",
                "// Line 2555: ",
                "// Line 2556:         if \"sha3\" in configured:",
                "// Line 2557:             sha3_deps = glob(",
                "// Line 2558:                 os.path.join(escape(self.srcdir), 'Modules/_sha3/kcp/*')",
                "// vulnerable line: 2559: )",
                "// Line 2560:             sha3_deps.append('hashlib.h')",
                "// Line 2561:             self.add(Extension(",
                "// Line 2562:                 '_sha3',",
                "// Line 2563:                 ['_sha3/sha3module.c'],",
                "// Line 2564:                 depends=sha3_deps",
                "// Line 2565:             ))",
                "// Line 2566: ",
                "// Line 2567:     def detect_nis(self):",
                "// Line 2568:         if MS_WINDOWS or CYGWIN or HOST_PLATFORM == 'qnx6':",
                "// Line 2569:             self.missing.append('nis')",
                "// Line 2572:         libs = []",
                "// Line 2573:         library_dirs = []",
                "// Line 2574:         includes_dirs = []",
                "// Line 2575: ",
                "// Line 2576:         # bpo-32521: glibc has deprecated Sun RPC for some time. Fedora 28",
                "// Line 2577:         # moved headers and libraries to libtirpc and libnsl. The headers",
                "// Line 2578:         # are in tircp and nsl sub directories.",
                "// Line 2579:         rpcsvc_inc = find_file(",
                "// Line 2580:             'rpcsvc/yp_prot.h', self.inc_dirs,",
                "// Line 2581:             [os.path.join(inc_dir, 'nsl') for inc_dir in self.inc_dirs]",
                "// vulnerable line: 2582: )",
                "// Line 2583:         rpc_inc = find_file(",
                "// Line 2584:             'rpc/rpc.h', self.inc_dirs,",
                "// Line 2585:             [os.path.join(inc_dir, 'tirpc') for inc_dir in self.inc_dirs]",
                "// vulnerable line: 2586: )",
                "// Line 2587:         if rpcsvc_inc is None or rpc_inc is None:",
                "// Line 2588:             # not found",
                "// Line 2589:             self.missing.append('nis')",
                "// Line 2590:             return",
                "// Line 2591:         includes_dirs.extend(rpcsvc_inc)",
                "// Line 2592:         includes_dirs.extend(rpc_inc)",
                "// Line 2593: ",
                "// Line 2594:         if self.compiler.find_library_file(self.lib_dirs, 'nsl'):",
                "// Line 2595:             libs.append('nsl')",
                "// vulnerable line: 2596: else:",
                "// Line 2597:             # libnsl-devel: check for libnsl in nsl/ subdirectory",
                "// Line 2598:             nsl_dirs = [os.path.join(lib_dir, 'nsl') for lib_dir in self.lib_dirs]",
                "// Line 2599:             libnsl = self.compiler.find_library_file(nsl_dirs, 'nsl')",
                "// Line 2600:             if libnsl is not None:",
                "// Line 2601:                 library_dirs.append(os.path.dirname(libnsl))",
                "// Line 2602:                 libs.append('nsl')",
                "// Line 2603: ",
                "// Line 2604:         if self.compiler.find_library_file(self.lib_dirs, 'tirpc'):",
                "// Line 2605:             libs.append('tirpc')",
                "// Line 2606: ",
                "// Line 2661: class PyBuildScripts(build_scripts):",
                "// Line 2662:     def copy_scripts(self):",
                "// Line 2663:         outfiles, updated_files = build_scripts.copy_scripts(self)",
                "// Line 2664:         fullversion = '-{0[0]}.{0[1]}'.format(sys.version_info)",
                "// Line 2665:         minoronly = '.{0[1]}'.format(sys.version_info)",
                "// Line 2666:         newoutfiles = []",
                "// Line 2667:         newupdated_files = []",
                "// Line 2668:         for filename in outfiles:",
                "// Line 2669:             if filename.endswith('2to3'):",
                "// Line 2670:                 newfilename = filename + fullversion",
                "// vulnerable line: 2671: else:",
                "// Line 2672:                 newfilename = filename + minoronly",
                "// Line 2673:             log.info('renaming %s to %s', filename, newfilename)",
                "// Line 2674:             os.rename(filename, newfilename)",
                "// Line 2675:             newoutfiles.append(newfilename)",
                "// Line 2676:             if filename in updated_files:",
                "// Line 2677:                 newupdated_files.append(newfilename)",
                "// Line 2678:         return newoutfiles, newupdated_files",
                "// Line 2679: ",
                "// Line 2680: ",
                "// Line 2681: def main():",
                "// Line 2718:                       'install_lib': PyBuildInstallLib},",
                "// Line 2719:           # The struct module is defined here, because build_ext won't be",
                "// Line 2720:           # called unless there's at least one extension module defined.",
                "// Line 2721:           ext_modules=[Extension('_struct', ['_struct.c'])],",
                "// Line 2722: ",
                "// Line 2723:           # If you change the scripts installed here, you also need to",
                "// Line 2724:           # check the PyBuildScripts command above, and change the links",
                "// Line 2725:           # created by the bininstall target in Makefile.pre.in",
                "// Line 2726:           scripts = [\"Tools/scripts/pydoc3\", \"Tools/scripts/idle3\",",
                "// Line 2727:                      \"Tools/scripts/2to3\"]",
                "// vulnerable line: 2728: )",
                "// Line 2729: ",
                "// Line 2730: # --install-platlib",
                "// Line 2731: if __name__ == '__main__':",
                "// Line 2732:     main()"
            ]
        },
        {
            "filename_of_changes": "ssl.py",
            "code_language": "Python",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "8",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 327:     Supports IPv4 addresses on all platforms and IPv6 on platforms with IPv6",
                "// Line 328:     support.",
                "// Line 329:     \"\"\"",
                "// Line 330:     # inet_aton() also accepts strings like '1', '127.1', some also trailing",
                "// Line 331:     # data like '127.0.0.1 whatever'.",
                "// Line 332:     try:",
                "// Line 333:         addr = _socket.inet_aton(ipname)",
                "// Line 334:     except OSError:",
                "// Line 335:         # not an IPv4 address",
                "// Line 336:         pass",
                "// vulnerable line: 337: else:",
                "// Line 338:         if _socket.inet_ntoa(addr) == ipname:",
                "// Line 339:             # only accept injective ipnames",
                "// Line 340:             return addr",
                "// vulnerable line: 341: else:",
                "// Line 342:             # refuse for short IPv4 notation and additional trailing data",
                "// Line 343:             raise ValueError(",
                "// Line 344:                 \"{!r} is not a quad-dotted IPv4 address.\".format(ipname)",
                "// Line 345:             )",
                "// Line 346: ",
                "// Line 347:     try:",
                "// Line 348:         return _socket.inet_pton(_socket.AF_INET6, ipname)",
                "// Line 349:     except OSError:",
                "// Line 350:         raise ValueError(\"{!r} is neither an IPv4 nor an IP6 \"",
                "// Line 351:                          \"address.\".format(ipname))",
                "// Line 414:                         return",
                "// Line 415:                     dnsnames.append(value)",
                "// Line 416:     if len(dnsnames) > 1:",
                "// Line 417:         raise CertificateError(\"hostname %r \"",
                "// Line 418:             \"doesn't match either of %s\"",
                "// Line 419:             % (hostname, ', '.join(map(repr, dnsnames))))",
                "// Line 420:     elif len(dnsnames) == 1:",
                "// Line 421:         raise CertificateError(\"hostname %r \"",
                "// Line 422:             \"doesn't match %r\"",
                "// Line 423:             % (hostname, dnsnames[0]))",
                "// vulnerable line: 424: else:",
                "// Line 425:         raise CertificateError(\"no appropriate commonName or \"",
                "// Line 426:             \"subjectAltName fields were found\")",
                "// Line 427: ",
                "// Line 428: ",
                "// Line 429: DefaultVerifyPaths = namedtuple(\"DefaultVerifyPaths\",",
                "// Line 430:     \"cafile capath openssl_cafile_env openssl_cafile openssl_capath_env \"",
                "// Line 431:     \"openssl_capath\")",
                "// Line 432: ",
                "// Line 433: def get_default_verify_paths():",
                "// Line 434:     \"\"\"Return paths to default cafile and capath.",
                "// Line 479: ",
                "// Line 480:     sslsocket_class = None  # SSLSocket is assigned later.",
                "// Line 481:     sslobject_class = None  # SSLObject is assigned later.",
                "// Line 482: ",
                "// Line 483:     def __new__(cls, protocol=PROTOCOL_TLS, *args, **kwargs):",
                "// Line 484:         self = _SSLContext.__new__(cls, protocol)",
                "// Line 485:         return self",
                "// Line 486: ",
                "// Line 487:     def _encode_hostname(self, hostname):",
                "// Line 488:         if hostname is None:",
                "// vulnerable line: 489: return None",
                "// Line 490:         elif isinstance(hostname, str):",
                "// Line 491:             return hostname.encode('idna').decode('ascii')",
                "// vulnerable line: 492: else:",
                "// Line 493:             return hostname.decode('ascii')",
                "// Line 494: ",
                "// Line 495:     def wrap_socket(self, sock, server_side=False,",
                "// Line 496:                     do_handshake_on_connect=True,",
                "// Line 497:                     suppress_ragged_eofs=True,",
                "// Line 498:                     server_hostname=None, session=None):",
                "// Line 499:         # SSLSocket class handles server_hostname encoding before it calls",
                "// Line 500:         # ctx._wrap_socket()",
                "// Line 501:         return self.sslsocket_class._create(",
                "// Line 502:             sock=sock,",
                "// Line 525:             if len(b) == 0 or len(b) > 255:",
                "// Line 526:                 raise SSLError('NPN protocols must be 1 to 255 in length')",
                "// Line 527:             protos.append(len(b))",
                "// Line 528:             protos.extend(b)",
                "// Line 529: ",
                "// Line 530:         self._set_npn_protocols(protos)",
                "// Line 531: ",
                "// Line 532:     def set_servername_callback(self, server_name_callback):",
                "// Line 533:         if server_name_callback is None:",
                "// Line 534:             self.sni_callback = None",
                "// vulnerable line: 535: else:",
                "// Line 536:             if not callable(server_name_callback):",
                "// Line 537:                 raise TypeError(\"not a callable object\")",
                "// Line 538: ",
                "// Line 539:             def shim_cb(sslobj, servername, sslctx):",
                "// Line 540:                 servername = self._encode_hostname(servername)",
                "// Line 541:                 return server_name_callback(sslobj, servername, sslctx)",
                "// Line 542: ",
                "// Line 543:             self.sni_callback = shim_cb",
                "// Line 544: ",
                "// Line 545:     def set_alpn_protocols(self, alpn_protocols):",
                "// Line 605:     if hasattr(_ssl, 'HOSTFLAG_NEVER_CHECK_SUBJECT'):",
                "// Line 606:         @property",
                "// Line 607:         def hostname_checks_common_name(self):",
                "// Line 608:             ncs = self._host_flags & _ssl.HOSTFLAG_NEVER_CHECK_SUBJECT",
                "// Line 609:             return ncs != _ssl.HOSTFLAG_NEVER_CHECK_SUBJECT",
                "// Line 610: ",
                "// Line 611:         @hostname_checks_common_name.setter",
                "// Line 612:         def hostname_checks_common_name(self, value):",
                "// Line 613:             if value:",
                "// Line 614:                 self._host_flags &= ~_ssl.HOSTFLAG_NEVER_CHECK_SUBJECT",
                "// vulnerable line: 615: else:",
                "// Line 616:                 self._host_flags |= _ssl.HOSTFLAG_NEVER_CHECK_SUBJECT",
                "// vulnerable line: 617: else:",
                "// Line 618:         @property",
                "// Line 619:         def hostname_checks_common_name(self):",
                "// Line 620:             return True",
                "// Line 621: ",
                "// Line 622:     @property",
                "// Line 623:     def _msg_callback(self):",
                "// Line 624:         \"\"\"TLS message callback",
                "// Line 625: ",
                "// Line 626:         The message callback provides a debugging hook to analyze TLS",
                "// Line 627:         connections. The callback is called for any TLS protocol message",
                "// Line 648:             Either a :class:`_TLSContentType` enum number for a header",
                "// Line 649:             message, a :class:`_TLSAlertType` enum member for an alert",
                "// Line 650:             message, a :class:`_TLSMessageType` enum member for other",
                "// Line 651:             messages, or int for unsupported message types.",
                "// Line 652:         data",
                "// Line 653:             Raw, decrypted message content as bytes",
                "// Line 654:         \"\"\"",
                "// Line 655:         inner = super()._msg_callback",
                "// Line 656:         if inner is not None:",
                "// Line 657:             return inner.user_function",
                "// vulnerable line: 658: else:",
                "// vulnerable line: 659: return None",
                "// Line 660: ",
                "// Line 661:     @_msg_callback.setter",
                "// Line 662:     def _msg_callback(self, callback):",
                "// Line 663:         if callback is None:",
                "// Line 664:             super(SSLContext, SSLContext)._msg_callback.__set__(self, None)",
                "// Line 665:             return",
                "// Line 666: ",
                "// Line 667:         if not hasattr(callback, '__call__'):",
                "// Line 668:             raise TypeError(f\"{callback} is not callable.\")",
                "// Line 669: ",
                "// Line 675: ",
                "// Line 676:             try:",
                "// Line 677:                 content_type = _TLSContentType(content_type)",
                "// Line 678:             except ValueError:",
                "// Line 679:                 pass",
                "// Line 680: ",
                "// Line 681:             if content_type == _TLSContentType.HEADER:",
                "// Line 682:                 msg_enum = _TLSContentType",
                "// Line 683:             elif content_type == _TLSContentType.ALERT:",
                "// Line 684:                 msg_enum = _TLSAlertType",
                "// vulnerable line: 685: else:",
                "// Line 686:                 msg_enum = _TLSMessageType",
                "// Line 687:             try:",
                "// Line 688:                 msg_type = msg_enum(msg_type)",
                "// Line 689:             except ValueError:",
                "// Line 690:                 pass",
                "// Line 691: ",
                "// Line 692:             return callback(conn, direction, version,",
                "// Line 693:                             content_type, msg_type, data)",
                "// Line 694: ",
                "// Line 695:         inner.user_function = callback",
                "// Line 878:         return self._sslobj.server_hostname",
                "// Line 879: ",
                "// Line 880:     def read(self, len=1024, buffer=None):",
                "// Line 881:         \"\"\"Read up to 'len' bytes from the SSL object and return them.",
                "// Line 882: ",
                "// Line 883:         If 'buffer' is provided, read into this buffer and return the number of",
                "// Line 884:         bytes read.",
                "// Line 885:         \"\"\"",
                "// Line 886:         if buffer is not None:",
                "// Line 887:             v = self._sslobj.read(len, buffer)",
                "// vulnerable line: 888: else:",
                "// Line 889:             v = self._sslobj.read(len)",
                "// Line 890:         return v",
                "// Line 891: ",
                "// Line 892:     def write(self, data):",
                "// Line 893:         \"\"\"Write 'data' to the SSL object and return the number of bytes",
                "// Line 894:         written.",
                "// Line 895: ",
                "// Line 896:         The 'data' argument must support the buffer interface.",
                "// Line 897:         \"\"\"",
                "// Line 898:         return self._sslobj.write(data)",
                "// Line 903: ",
                "// Line 904:         Return None if no certificate was provided, {} if a certificate was",
                "// Line 905:         provided, but not validated.",
                "// Line 906:         \"\"\"",
                "// Line 907:         return self._sslobj.getpeercert(binary_form)",
                "// Line 908: ",
                "// Line 909:     def selected_npn_protocol(self):",
                "// Line 910:         \"\"\"Return the currently selected NPN protocol as a string, or ``None``",
                "// Line 911:         if a next protocol was not negotiated or if NPN is not supported by one",
                "// Line 912:         of the peers.\"\"\"",
                "// vulnerable line: 913: if _ssl.HAS_NPN:",
                "// vulnerable line: 914: return self._sslobj.selected_npn_protocol()",
                "// Line 915: ",
                "// Line 916:     def selected_alpn_protocol(self):",
                "// Line 917:         \"\"\"Return the currently selected ALPN protocol as a string, or ``None``",
                "// Line 918:         if a next protocol was not negotiated or if ALPN is not supported by one",
                "// Line 919:         of the peers.\"\"\"",
                "// vulnerable line: 920: if _ssl.HAS_ALPN:",
                "// vulnerable line: 921: return self._sslobj.selected_alpn_protocol()",
                "// Line 922: ",
                "// Line 923:     def cipher(self):",
                "// Line 924:         \"\"\"Return the currently selected cipher as a 3-tuple ``(name,",
                "// Line 925:         ssl_version, secret_bits)``.\"\"\"",
                "// Line 926:         return self._sslobj.cipher()",
                "// Line 927: ",
                "// Line 928:     def shared_ciphers(self):",
                "// Line 929:         \"\"\"Return a list of ciphers shared by the client during the handshake or",
                "// Line 930:         None if this is not a valid server connection.",
                "// Line 931:         \"\"\"",
                "// Line 1015:         self.do_handshake_on_connect = do_handshake_on_connect",
                "// Line 1016:         self.suppress_ragged_eofs = suppress_ragged_eofs",
                "// Line 1017: ",
                "// Line 1018:         # See if we are connected",
                "// Line 1019:         try:",
                "// Line 1020:             self.getpeername()",
                "// Line 1021:         except OSError as e:",
                "// Line 1022:             if e.errno != errno.ENOTCONN:",
                "// Line 1023:                 raise",
                "// Line 1024:             connected = False",
                "// vulnerable line: 1025: else:",
                "// Line 1026:             connected = True",
                "// Line 1027: ",
                "// Line 1028:         self._connected = connected",
                "// Line 1029:         if connected:",
                "// Line 1030:             # create the SSL object",
                "// Line 1031:             try:",
                "// Line 1032:                 self._sslobj = self._context._wrap_socket(",
                "// Line 1033:                     self, server_side, self.server_hostname,",
                "// Line 1034:                     owner=self, session=self._session,",
                "// Line 1035:                 )",
                "// Line 1091:     def read(self, len=1024, buffer=None):",
                "// Line 1092:         \"\"\"Read up to LEN bytes and return them.",
                "// Line 1093:         Return zero-length string on EOF.\"\"\"",
                "// Line 1094: ",
                "// Line 1095:         self._checkClosed()",
                "// Line 1096:         if self._sslobj is None:",
                "// Line 1097:             raise ValueError(\"Read on closed or unwrapped SSL socket.\")",
                "// Line 1098:         try:",
                "// Line 1099:             if buffer is not None:",
                "// Line 1100:                 return self._sslobj.read(len, buffer)",
                "// vulnerable line: 1101: else:",
                "// Line 1102:                 return self._sslobj.read(len)",
                "// Line 1103:         except SSLError as x:",
                "// Line 1104:             if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:",
                "// Line 1105:                 if buffer is not None:",
                "// Line 1106:                     return 0",
                "// vulnerable line: 1107: else:",
                "// Line 1108:                     return b''",
                "// vulnerable line: 1109: else:",
                "// Line 1110:                 raise",
                "// Line 1111: ",
                "// Line 1112:     def write(self, data):",
                "// Line 1113:         \"\"\"Write DATA to the underlying SSL channel.  Returns",
                "// Line 1114:         number of bytes of DATA actually transmitted.\"\"\"",
                "// Line 1115: ",
                "// Line 1116:         self._checkClosed()",
                "// Line 1117:         if self._sslobj is None:",
                "// Line 1118:             raise ValueError(\"Write on closed or unwrapped SSL socket.\")",
                "// Line 1119:         return self._sslobj.write(data)",
                "// Line 1120: ",
                "// Line 1121:     @_sslcopydoc",
                "// Line 1122:     def getpeercert(self, binary_form=False):",
                "// Line 1123:         self._checkClosed()",
                "// Line 1124:         self._check_connected()",
                "// Line 1125:         return self._sslobj.getpeercert(binary_form)",
                "// Line 1126: ",
                "// Line 1127:     @_sslcopydoc",
                "// Line 1128:     def selected_npn_protocol(self):",
                "// Line 1129:         self._checkClosed()",
                "// vulnerable line: 1130: if self._sslobj is None or not _ssl.HAS_NPN:",
                "// vulnerable line: 1131: return None",
                "// vulnerable line: 1132: else:",
                "// vulnerable line: 1133: return self._sslobj.selected_npn_protocol()",
                "// Line 1134: ",
                "// Line 1135:     @_sslcopydoc",
                "// Line 1136:     def selected_alpn_protocol(self):",
                "// Line 1137:         self._checkClosed()",
                "// Line 1138:         if self._sslobj is None or not _ssl.HAS_ALPN:",
                "// vulnerable line: 1139: return None",
                "// vulnerable line: 1140: else:",
                "// vulnerable line: 1141: return self._sslobj.selected_alpn_protocol()",
                "// Line 1142: ",
                "// Line 1143:     @_sslcopydoc",
                "// Line 1144:     def cipher(self):",
                "// Line 1145:         self._checkClosed()",
                "// Line 1146:         if self._sslobj is None:",
                "// vulnerable line: 1147: return None",
                "// vulnerable line: 1148: else:",
                "// Line 1149:             return self._sslobj.cipher()",
                "// Line 1150: ",
                "// Line 1151:     @_sslcopydoc",
                "// Line 1152:     def shared_ciphers(self):",
                "// Line 1153:         self._checkClosed()",
                "// Line 1154:         if self._sslobj is None:",
                "// vulnerable line: 1155: return None",
                "// vulnerable line: 1156: else:",
                "// Line 1157:             return self._sslobj.shared_ciphers()",
                "// Line 1158: ",
                "// Line 1159:     @_sslcopydoc",
                "// Line 1160:     def compression(self):",
                "// Line 1161:         self._checkClosed()",
                "// Line 1162:         if self._sslobj is None:",
                "// vulnerable line: 1163: return None",
                "// vulnerable line: 1164: else:",
                "// Line 1165:             return self._sslobj.compression()",
                "// Line 1166: ",
                "// Line 1167:     def send(self, data, flags=0):",
                "// Line 1168:         self._checkClosed()",
                "// Line 1169:         if self._sslobj is not None:",
                "// Line 1170:             if flags != 0:",
                "// Line 1171:                 raise ValueError(",
                "// Line 1172:                     \"non-zero flags not allowed in calls to send() on %s\" %",
                "// Line 1173:                     self.__class__)",
                "// Line 1174:             return self._sslobj.write(data)",
                "// vulnerable line: 1175: else:",
                "// Line 1176:             return super().send(data, flags)",
                "// Line 1177: ",
                "// Line 1178:     def sendto(self, data, flags_or_addr, addr=None):",
                "// Line 1179:         self._checkClosed()",
                "// Line 1180:         if self._sslobj is not None:",
                "// Line 1181:             raise ValueError(\"sendto not allowed on instances of %s\" %",
                "// Line 1182:                              self.__class__)",
                "// Line 1183:         elif addr is None:",
                "// Line 1184:             return super().sendto(data, flags_or_addr)",
                "// vulnerable line: 1185: else:",
                "// Line 1186:             return super().sendto(data, flags_or_addr, addr)",
                "// Line 1187: ",
                "// Line 1188:     def sendmsg(self, *args, **kwargs):",
                "// Line 1189:         # Ensure programs don't send data unencrypted if they try to",
                "// Line 1190:         # use this method.",
                "// Line 1191:         raise NotImplementedError(\"sendmsg not allowed on instances of %s\" %",
                "// Line 1192:                                   self.__class__)",
                "// Line 1193: ",
                "// Line 1194:     def sendall(self, data, flags=0):",
                "// Line 1195:         self._checkClosed()",
                "// Line 1197:             if flags != 0:",
                "// Line 1198:                 raise ValueError(",
                "// Line 1199:                     \"non-zero flags not allowed in calls to sendall() on %s\" %",
                "// Line 1200:                     self.__class__)",
                "// Line 1201:             count = 0",
                "// Line 1202:             with memoryview(data) as view, view.cast(\"B\") as byte_view:",
                "// Line 1203:                 amount = len(byte_view)",
                "// Line 1204:                 while count < amount:",
                "// Line 1205:                     v = self.send(byte_view[count:])",
                "// Line 1206:                     count += v",
                "// vulnerable line: 1207: else:",
                "// Line 1208:             return super().sendall(data, flags)",
                "// Line 1209: ",
                "// Line 1210:     def sendfile(self, file, offset=0, count=None):",
                "// Line 1211:         \"\"\"Send a file, possibly by using os.sendfile() if this is a",
                "// Line 1212:         clear-text socket.  Return the total number of bytes sent.",
                "// Line 1213:         \"\"\"",
                "// Line 1214:         if self._sslobj is not None:",
                "// Line 1215:             return self._sendfile_use_send(file, offset, count)",
                "// vulnerable line: 1216: else:",
                "// Line 1217:             # os.sendfile() works with plain sockets only",
                "// Line 1218:             return super().sendfile(file, offset, count)",
                "// Line 1219: ",
                "// Line 1220:     def recv(self, buflen=1024, flags=0):",
                "// Line 1221:         self._checkClosed()",
                "// Line 1222:         if self._sslobj is not None:",
                "// Line 1223:             if flags != 0:",
                "// Line 1224:                 raise ValueError(",
                "// Line 1225:                     \"non-zero flags not allowed in calls to recv() on %s\" %",
                "// Line 1226:                     self.__class__)",
                "// Line 1227:             return self.read(buflen)",
                "// vulnerable line: 1228: else:",
                "// Line 1229:             return super().recv(buflen, flags)",
                "// Line 1230: ",
                "// Line 1231:     def recv_into(self, buffer, nbytes=None, flags=0):",
                "// Line 1232:         self._checkClosed()",
                "// Line 1233:         if buffer and (nbytes is None):",
                "// Line 1234:             nbytes = len(buffer)",
                "// Line 1235:         elif nbytes is None:",
                "// Line 1236:             nbytes = 1024",
                "// Line 1237:         if self._sslobj is not None:",
                "// Line 1238:             if flags != 0:",
                "// Line 1239:                 raise ValueError(",
                "// Line 1240:                   \"non-zero flags not allowed in calls to recv_into() on %s\" %",
                "// Line 1241:                   self.__class__)",
                "// Line 1242:             return self.read(nbytes, buffer)",
                "// vulnerable line: 1243: else:",
                "// Line 1244:             return super().recv_into(buffer, nbytes, flags)",
                "// Line 1245: ",
                "// Line 1246:     def recvfrom(self, buflen=1024, flags=0):",
                "// Line 1247:         self._checkClosed()",
                "// Line 1248:         if self._sslobj is not None:",
                "// Line 1249:             raise ValueError(\"recvfrom not allowed on instances of %s\" %",
                "// Line 1250:                              self.__class__)",
                "// vulnerable line: 1251: else:",
                "// Line 1252:             return super().recvfrom(buflen, flags)",
                "// Line 1253: ",
                "// Line 1254:     def recvfrom_into(self, buffer, nbytes=None, flags=0):",
                "// Line 1255:         self._checkClosed()",
                "// Line 1256:         if self._sslobj is not None:",
                "// Line 1257:             raise ValueError(\"recvfrom_into not allowed on instances of %s\" %",
                "// Line 1258:                              self.__class__)",
                "// vulnerable line: 1259: else:",
                "// Line 1260:             return super().recvfrom_into(buffer, nbytes, flags)",
                "// Line 1261: ",
                "// Line 1262:     def recvmsg(self, *args, **kwargs):",
                "// Line 1263:         raise NotImplementedError(\"recvmsg not allowed on instances of %s\" %",
                "// Line 1264:                                   self.__class__)",
                "// Line 1265: ",
                "// Line 1266:     def recvmsg_into(self, *args, **kwargs):",
                "// Line 1267:         raise NotImplementedError(\"recvmsg_into not allowed on instances of \"",
                "// Line 1268:                                   \"%s\" % self.__class__)",
                "// Line 1269: ",
                "// Line 1270:     @_sslcopydoc",
                "// Line 1271:     def pending(self):",
                "// Line 1272:         self._checkClosed()",
                "// Line 1273:         if self._sslobj is not None:",
                "// Line 1274:             return self._sslobj.pending()",
                "// vulnerable line: 1275: else:",
                "// Line 1276:             return 0",
                "// Line 1277: ",
                "// Line 1278:     def shutdown(self, how):",
                "// Line 1279:         self._checkClosed()",
                "// Line 1280:         self._sslobj = None",
                "// Line 1281:         super().shutdown(how)",
                "// Line 1282: ",
                "// Line 1283:     @_sslcopydoc",
                "// Line 1284:     def unwrap(self):",
                "// Line 1285:         if self._sslobj:",
                "// Line 1286:             s = self._sslobj.shutdown()",
                "// Line 1287:             self._sslobj = None",
                "// Line 1288:             return s",
                "// vulnerable line: 1289: else:",
                "// Line 1290:             raise ValueError(\"No SSL wrapper around \" + str(self))",
                "// Line 1291: ",
                "// Line 1292:     @_sslcopydoc",
                "// Line 1293:     def verify_client_post_handshake(self):",
                "// Line 1294:         if self._sslobj:",
                "// Line 1295:             return self._sslobj.verify_client_post_handshake()",
                "// vulnerable line: 1296: else:",
                "// Line 1297:             raise ValueError(\"No SSL wrapper around \" + str(self))",
                "// Line 1298: ",
                "// Line 1299:     def _real_close(self):",
                "// Line 1300:         self._sslobj = None",
                "// Line 1301:         super()._real_close()",
                "// Line 1302: ",
                "// Line 1303:     @_sslcopydoc",
                "// Line 1304:     def do_handshake(self, block=False):",
                "// Line 1305:         self._check_connected()",
                "// Line 1306:         timeout = self.gettimeout()",
                "// Line 1318:         # connected at the time of the call.  We connect it, then wrap it.",
                "// Line 1319:         if self._connected or self._sslobj is not None:",
                "// Line 1320:             raise ValueError(\"attempt to connect already-connected SSLSocket!\")",
                "// Line 1321:         self._sslobj = self.context._wrap_socket(",
                "// Line 1322:             self, False, self.server_hostname,",
                "// Line 1323:             owner=self, session=self._session",
                "// Line 1324:         )",
                "// Line 1325:         try:",
                "// Line 1326:             if connect_ex:",
                "// Line 1327:                 rc = super().connect_ex(addr)",
                "// vulnerable line: 1328: else:",
                "// Line 1329:                 rc = None",
                "// Line 1330:                 super().connect(addr)",
                "// Line 1331:             if not rc:",
                "// Line 1332:                 self._connected = True",
                "// Line 1333:                 if self.do_handshake_on_connect:",
                "// Line 1334:                     self.do_handshake()",
                "// Line 1335:             return rc",
                "// Line 1336:         except (OSError, ValueError):",
                "// Line 1337:             self._sslobj = None",
                "// Line 1338:             raise",
                "// Line 1356:         newsock = self.context.wrap_socket(newsock,",
                "// Line 1357:                     do_handshake_on_connect=self.do_handshake_on_connect,",
                "// Line 1358:                     suppress_ragged_eofs=self.suppress_ragged_eofs,",
                "// Line 1359:                     server_side=True)",
                "// Line 1360:         return newsock, addr",
                "// Line 1361: ",
                "// Line 1362:     @_sslcopydoc",
                "// Line 1363:     def get_channel_binding(self, cb_type=\"tls-unique\"):",
                "// Line 1364:         if self._sslobj is not None:",
                "// Line 1365:             return self._sslobj.get_channel_binding(cb_type)",
                "// vulnerable line: 1366: else:",
                "// Line 1367:             if cb_type not in CHANNEL_BINDING_TYPES:",
                "// Line 1368:                 raise ValueError(",
                "// Line 1369:                     \"{0} channel binding type not implemented\".format(cb_type)",
                "// Line 1370:                 )",
                "// vulnerable line: 1371: return None",
                "// Line 1372: ",
                "// Line 1373:     @_sslcopydoc",
                "// Line 1374:     def version(self):",
                "// Line 1375:         if self._sslobj is not None:",
                "// Line 1376:             return self._sslobj.version()",
                "// vulnerable line: 1377: else:",
                "// vulnerable line: 1378: return None",
                "// Line 1379: ",
                "// Line 1380: ",
                "// Line 1381: # Python does not support forward declaration of types.",
                "// Line 1382: SSLContext.sslsocket_class = SSLSocket",
                "// Line 1383: SSLContext.sslobject_class = SSLObject",
                "// Line 1384: ",
                "// Line 1385: ",
                "// Line 1386: def wrap_socket(sock, keyfile=None, certfile=None,",
                "// Line 1387:                 server_side=False, cert_reqs=CERT_NONE,",
                "// Line 1388:                 ssl_version=PROTOCOL_TLS, ca_certs=None,",
                "// Line 1427:     months = (",
                "// Line 1428:         \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",",
                "// Line 1429:         \"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"",
                "// Line 1430:     )",
                "// Line 1431:     time_format = ' %d %H:%M:%S %Y GMT' # NOTE: no month, fixed GMT",
                "// Line 1432:     try:",
                "// Line 1433:         month_number = months.index(cert_time[:3].title()) + 1",
                "// Line 1434:     except ValueError:",
                "// Line 1435:         raise ValueError('time data %r does not match '",
                "// Line 1436:                          'format \"%%b%s\"' % (cert_time, time_format))",
                "// vulnerable line: 1437: else:",
                "// Line 1438:         # found valid month",
                "// Line 1439:         tt = strptime(cert_time[3:], time_format)",
                "// Line 1440:         # return an integer, the previous mktime()-based implementation",
                "// Line 1441:         # returned a float (fractional seconds are always zero here).",
                "// Line 1442:         return timegm((tt[0], month_number) + tt[2:6])",
                "// Line 1443: ",
                "// Line 1444: PEM_HEADER = \"-----BEGIN CERTIFICATE-----\"",
                "// Line 1445: PEM_FOOTER = \"-----END CERTIFICATE-----\"",
                "// Line 1446: ",
                "// Line 1447: def DER_cert_to_PEM_cert(der_cert_bytes):",
                "// Line 1471: ",
                "// Line 1472: def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):",
                "// Line 1473:     \"\"\"Retrieve the certificate from the server at the specified address,",
                "// Line 1474:     and return it as a PEM-encoded string.",
                "// Line 1475:     If 'ca_certs' is specified, validate the server cert against it.",
                "// Line 1476:     If 'ssl_version' is specified, use it in the connection attempt.\"\"\"",
                "// Line 1477: ",
                "// Line 1478:     host, port = addr",
                "// Line 1479:     if ca_certs is not None:",
                "// Line 1480:         cert_reqs = CERT_REQUIRED",
                "// vulnerable line: 1481: else:",
                "// Line 1482:         cert_reqs = CERT_NONE",
                "// Line 1483:     context = _create_stdlib_context(ssl_version,",
                "// Line 1484:                                      cert_reqs=cert_reqs,",
                "// Line 1485:                                      cafile=ca_certs)",
                "// Line 1486:     with  create_connection(addr) as sock:",
                "// Line 1487:         with context.wrap_socket(sock) as sslsock:",
                "// Line 1488:             dercert = sslsock.getpeercert(True)",
                "// Line 1489:     return DER_cert_to_PEM_cert(dercert)",
                "// Line 1490: ",
                "// Line 1491: def get_protocol_name(protocol_code):"
            ]
        }
    ]
}