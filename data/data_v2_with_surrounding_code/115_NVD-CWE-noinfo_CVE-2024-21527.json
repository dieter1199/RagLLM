{
    "cve_id": "CVE-2024-21527",
    "cve_description": "Versions of the package github.com/gotenberg/gotenberg/v8/pkg/gotenberg before 8.1.0; versions of the package github.com/gotenberg/gotenberg/v8/pkg/modules/chromium before 8.1.0; versions of the package github.com/gotenberg/gotenberg/v8/pkg/modules/webhook before 8.1.0 are vulnerable to Server-side Request Forgery (SSRF) via the /convert/html endpoint when a request is made to a file via localhost, such as <iframe src=\"\\\\localhost/etc/passwd\">. By exploiting this vulnerability, an attacker can achieve local file inclusion, allowing of sensitive files read on the host system.\r\r Workaround\rAn alternative is using either or both --chromium-deny-list and --chromium-allow-list flags.",
    "cve_publish_date": "2024-07-19T05:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix(chromium): better default deny list regexp",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "browser.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "10",
            "number_of_lines_deleted_vulnerable_to_cve": "13",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package chromium",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"context\"",
                "// Line 5:     \"errors\"",
                "// Line 6:     \"fmt\"",
                "// Line 7:     \"os\"",
                "// vulnerable line: 8: \"regexp\"",
                "// Line 9:     \"strings\"",
                "// Line 10:     \"sync\"",
                "// Line 11:     \"sync/atomic\"",
                "// Line 12:     \"time\"",
                "// Line 13: ",
                "// Line 14:     \"github.com/chromedp/cdproto/fetch\"",
                "// Line 15:     \"github.com/chromedp/cdproto/network\"",
                "// Line 16:     \"github.com/chromedp/cdproto/runtime\"",
                "// Line 17:     \"github.com/chromedp/chromedp\"",
                "// Line 18:     \"go.uber.org/zap\"",
                "// Line 19: ",
                "// Line 20:     \"github.com/gotenberg/gotenberg/v8/pkg/gotenberg\"",
                "// Line 21: )",
                "// Line 22: ",
                "// Line 23: type browser interface {",
                "// Line 24:     gotenberg.Process",
                "// Line 25:     pdf(ctx context.Context, logger *zap.Logger, url, outputPath string, options PdfOptions) error",
                "// Line 26:     screenshot(ctx context.Context, logger *zap.Logger, url, outputPath string, options ScreenshotOptions) error",
                "// vulnerable line: 27: }",
                "// Line 28: ",
                "// Line 29: type browserArguments struct {",
                "// Line 30:     // Executor args.",
                "// Line 31:     binPath                  string",
                "// Line 32:     incognito                bool",
                "// Line 33:     allowInsecureLocalhost   bool",
                "// Line 34:     ignoreCertificateErrors  bool",
                "// Line 35:     disableWebSecurity       bool",
                "// Line 36:     allowFileAccessFromFiles bool",
                "// Line 37:     hostResolverRules        string",
                "// Line 38:     proxyServer              string",
                "// Line 39:     wsUrlReadTimeout         time.Duration",
                "// Line 40: ",
                "// Line 41:     // Tasks specific.",
                "// vulnerable line: 42: allowList         *regexp.Regexp",
                "// vulnerable line: 43: denyList          *regexp.Regexp",
                "// Line 44:     clearCache        bool",
                "// Line 45:     clearCookies      bool",
                "// Line 46:     disableJavaScript bool",
                "// vulnerable line: 47: }",
                "// Line 48: ",
                "// Line 49: type chromiumBrowser struct {",
                "// Line 50:     initialCtx         context.Context",
                "// Line 51:     ctx                context.Context",
                "// Line 52:     cancelFunc         context.CancelFunc",
                "// Line 53:     userProfileDirPath string",
                "// Line 54:     ctxMu              sync.RWMutex",
                "// Line 55:     isStarted          atomic.Bool",
                "// Line 56: ",
                "// Line 57:     arguments browserArguments",
                "// Line 58:     fs        *gotenberg.FileSystem",
                "// vulnerable line: 59: }",
                "// Line 60: ",
                "// Line 61: func newChromiumBrowser(arguments browserArguments) browser {",
                "// Line 62:     b := &chromiumBrowser{",
                "// Line 63:         initialCtx: context.Background(),",
                "// Line 64:         arguments:  arguments,",
                "// Line 65:         fs:         gotenberg.NewFileSystem(),",
                "// vulnerable line: 66: }",
                "// Line 67:     b.isStarted.Store(false)",
                "// Line 68: ",
                "// Line 69:     return b",
                "// vulnerable line: 70: }",
                "// Line 71: ",
                "// Line 72: func (b *chromiumBrowser) Start(logger *zap.Logger) error {",
                "// Line 73:     if b.isStarted.Load() {",
                "// Line 74:         return errors.New(\"browser is already started\")",
                "// vulnerable line: 75: }",
                "// Line 76: ",
                "// Line 77:     debug := &debugLogger{logger: logger}",
                "// Line 78:     b.userProfileDirPath = b.fs.NewDirPath()",
                "// Line 79: ",
                "// Line 80:     opts := append(chromedp.DefaultExecAllocatorOptions[:],",
                "// Line 81:         chromedp.CombinedOutput(debug),",
                "// Line 82:         chromedp.ExecPath(b.arguments.binPath),",
                "// Line 83:         chromedp.NoSandbox,",
                "// Line 84:         // See:",
                "// Line 85:         // https://github.com/gotenberg/gotenberg/issues/327",
                "// Line 87:         chromedp.DisableGPU,",
                "// Line 88:         // See:",
                "// Line 89:         // https://github.com/puppeteer/puppeteer/issues/661",
                "// Line 90:         // https://github.com/puppeteer/puppeteer/issues/2410",
                "// Line 91:         chromedp.Flag(\"font-render-hinting\", \"none\"),",
                "// Line 92:         chromedp.UserDataDir(b.userProfileDirPath),",
                "// Line 93:     )",
                "// Line 94: ",
                "// Line 95:     if b.arguments.incognito {",
                "// Line 96:         opts = append(opts, chromedp.Flag(\"incognito\", b.arguments.incognito))",
                "// vulnerable line: 97: }",
                "// Line 98: ",
                "// Line 99:     if b.arguments.allowInsecureLocalhost {",
                "// Line 100:         // See https://github.com/gotenberg/gotenberg/issues/488.",
                "// Line 101:         opts = append(opts, chromedp.Flag(\"allow-insecure-localhost\", true))",
                "// vulnerable line: 102: }",
                "// Line 103: ",
                "// Line 104:     if b.arguments.ignoreCertificateErrors {",
                "// Line 105:         opts = append(opts, chromedp.IgnoreCertErrors)",
                "// vulnerable line: 106: }",
                "// Line 107: ",
                "// Line 108:     if b.arguments.disableWebSecurity {",
                "// Line 109:         opts = append(opts, chromedp.Flag(\"disable-web-security\", true))",
                "// vulnerable line: 110: }",
                "// Line 111: ",
                "// Line 112:     if b.arguments.allowFileAccessFromFiles {",
                "// Line 113:         // See https://github.com/gotenberg/gotenberg/issues/356.",
                "// Line 114:         opts = append(opts, chromedp.Flag(\"allow-file-access-from-files\", true))",
                "// vulnerable line: 115: }",
                "// Line 116: ",
                "// Line 117:     if b.arguments.hostResolverRules != \"\" {",
                "// Line 118:         // See https://github.com/gotenberg/gotenberg/issues/488.",
                "// Line 119:         opts = append(opts, chromedp.Flag(\"host-resolver-rules\", b.arguments.hostResolverRules))",
                "// vulnerable line: 120: }",
                "// Line 121: ",
                "// Line 122:     if b.arguments.proxyServer != \"\" {",
                "// Line 123:         // See https://github.com/gotenberg/gotenberg/issues/376.",
                "// Line 124:         opts = append(opts, chromedp.ProxyServer(b.arguments.proxyServer))",
                "// vulnerable line: 125: }",
                "// Line 126: ",
                "// Line 127:     // See https://github.com/gotenberg/gotenberg/issues/524.",
                "// Line 128:     opts = append(opts, chromedp.WSURLReadTimeout(b.arguments.wsUrlReadTimeout))",
                "// Line 129: ",
                "// Line 130:     allocatorCtx, allocatorCancel := chromedp.NewExecAllocator(b.initialCtx, opts...)",
                "// Line 131:     ctx, cancel := chromedp.NewContext(allocatorCtx, chromedp.WithDebugf(debug.Printf))",
                "// Line 132: ",
                "// Line 133:     err := chromedp.Run(ctx)",
                "// Line 134:     if err != nil {",
                "// Line 135:         cancel()",
                "// Line 136:         allocatorCancel()",
                "// Line 137:         return fmt.Errorf(\"run exec allocator: %w\", err)",
                "// vulnerable line: 138: }",
                "// Line 139: ",
                "// Line 140:     b.ctxMu.Lock()",
                "// Line 141:     defer b.ctxMu.Unlock()",
                "// Line 142: ",
                "// Line 143:     // We have to keep the context around, as we need it to create new tabs",
                "// Line 144:     // later.",
                "// Line 145:     b.ctx = ctx",
                "// Line 146:     b.cancelFunc = func() {",
                "// Line 147:         cancel()",
                "// Line 148:         allocatorCancel()",
                "// vulnerable line: 149: }",
                "// Line 150:     b.isStarted.Store(true)",
                "// Line 151: ",
                "// Line 152:     return nil",
                "// vulnerable line: 153: }",
                "// Line 154: ",
                "// Line 155: func (b *chromiumBrowser) Stop(logger *zap.Logger) error {",
                "// Line 156:     if !b.isStarted.Load() {",
                "// Line 157:         // No big deal? Like calling cancel twice.",
                "// Line 158:         return nil",
                "// vulnerable line: 159: }",
                "// Line 160: ",
                "// Line 161:     // Always remove the user profile directory created by Chromium.",
                "// Line 162:     copyUserProfileDirPath := b.userProfileDirPath",
                "// Line 163:     defer func(userProfileDirPath string) {",
                "// Line 164:         go func() {",
                "// Line 165:             // FIXME: Chromium seems to recreate the user profile directory",
                "// Line 166:             //  right after its deletion if we do not wait a certain amount",
                "// Line 167:             //  of time before re-deleting it.",
                "// Line 168:             <-time.After(10 * time.Second)",
                "// Line 169: ",
                "// Line 170:             err := os.RemoveAll(userProfileDirPath)",
                "// Line 171:             if err != nil {",
                "// Line 172:                 logger.Error(fmt.Sprintf(\"remove Chromium's user profile directory: %s\", err))",
                "// vulnerable line: 173: }",
                "// Line 174: ",
                "// Line 175:             logger.Debug(fmt.Sprintf(\"'%s' Chromium's user profile directory removed\", userProfileDirPath))",
                "// Line 176:         }()",
                "// Line 177:     }(copyUserProfileDirPath)",
                "// Line 178: ",
                "// Line 179:     b.ctxMu.Lock()",
                "// Line 180:     defer b.ctxMu.Unlock()",
                "// Line 181: ",
                "// Line 182:     b.cancelFunc()",
                "// Line 183:     b.ctx = nil",
                "// Line 184:     b.userProfileDirPath = \"\"",
                "// Line 185:     b.isStarted.Store(false)",
                "// Line 186: ",
                "// Line 187:     return nil",
                "// vulnerable line: 188: }",
                "// Line 189: ",
                "// Line 190: func (b *chromiumBrowser) Healthy(logger *zap.Logger) bool {",
                "// Line 191:     // Good to know: the supervisor does not call this method if no first start",
                "// Line 192:     // or if the process is restarting.",
                "// Line 193: ",
                "// Line 194:     if !b.isStarted.Load() {",
                "// Line 195:         // Non-started browser but not restarting?",
                "// Line 196:         return false",
                "// vulnerable line: 197: }",
                "// Line 198: ",
                "// Line 199:     b.ctxMu.RLock()",
                "// Line 200:     defer b.ctxMu.RUnlock()",
                "// Line 201: ",
                "// Line 202:     timeoutCtx, timeoutCancel := context.WithTimeout(b.ctx, time.Duration(10)*time.Second)",
                "// Line 203:     defer timeoutCancel()",
                "// Line 204: ",
                "// Line 205:     taskCtx, taskCancel := chromedp.NewContext(timeoutCtx)",
                "// Line 206:     defer taskCancel()",
                "// Line 207: ",
                "// Line 208:     err := chromedp.Run(taskCtx, chromedp.Navigate(\"about:blank\"))",
                "// Line 209:     if err != nil {",
                "// Line 210:         logger.Error(fmt.Sprintf(\"browser health check failed: %s\", err))",
                "// Line 211:         return false",
                "// vulnerable line: 212: }",
                "// Line 213: ",
                "// Line 214:     return true",
                "// vulnerable line: 215: }",
                "// Line 216: ",
                "// Line 217: func (b *chromiumBrowser) pdf(ctx context.Context, logger *zap.Logger, url, outputPath string, options PdfOptions) error {",
                "// Line 218:     // Note: no error wrapping because it leaks on errors we want to display to",
                "// Line 219:     // the end user.",
                "// Line 220:     return b.do(ctx, logger, url, options.Options, chromedp.Tasks{",
                "// Line 221:         network.Enable(),",
                "// Line 222:         fetch.Enable(),",
                "// Line 223:         runtime.Enable(),",
                "// Line 224:         clearCacheActionFunc(logger, b.arguments.clearCache),",
                "// Line 225:         clearCookiesActionFunc(logger, b.arguments.clearCookies),",
                "// Line 227:         extraHttpHeadersActionFunc(logger, options.ExtraHttpHeaders),",
                "// Line 228:         navigateActionFunc(logger, url, options.SkipNetworkIdleEvent),",
                "// Line 229:         hideDefaultWhiteBackgroundActionFunc(logger, options.OmitBackground, options.PrintBackground),",
                "// Line 230:         forceExactColorsActionFunc(),",
                "// Line 231:         emulateMediaTypeActionFunc(logger, options.EmulatedMediaType),",
                "// Line 232:         waitDelayBeforePrintActionFunc(logger, b.arguments.disableJavaScript, options.WaitDelay),",
                "// Line 233:         waitForExpressionBeforePrintActionFunc(logger, b.arguments.disableJavaScript, options.WaitForExpression),",
                "// Line 234:         // PDF specific.",
                "// Line 235:         printToPdfActionFunc(logger, outputPath, options),",
                "// Line 236:     })",
                "// vulnerable line: 237: }",
                "// Line 238: ",
                "// Line 239: func (b *chromiumBrowser) screenshot(ctx context.Context, logger *zap.Logger, url, outputPath string, options ScreenshotOptions) error {",
                "// Line 240:     // Note: no error wrapping because it leaks on errors we want to display to",
                "// Line 241:     // the end user.",
                "// Line 242:     return b.do(ctx, logger, url, options.Options, chromedp.Tasks{",
                "// Line 243:         network.Enable(),",
                "// Line 244:         fetch.Enable(),",
                "// Line 245:         runtime.Enable(),",
                "// Line 246:         clearCacheActionFunc(logger, b.arguments.clearCache),",
                "// Line 247:         clearCookiesActionFunc(logger, b.arguments.clearCookies),",
                "// Line 249:         extraHttpHeadersActionFunc(logger, options.ExtraHttpHeaders),",
                "// Line 250:         navigateActionFunc(logger, url, options.SkipNetworkIdleEvent),",
                "// Line 251:         hideDefaultWhiteBackgroundActionFunc(logger, options.OmitBackground, true),",
                "// Line 252:         forceExactColorsActionFunc(),",
                "// Line 253:         emulateMediaTypeActionFunc(logger, options.EmulatedMediaType),",
                "// Line 254:         waitDelayBeforePrintActionFunc(logger, b.arguments.disableJavaScript, options.WaitDelay),",
                "// Line 255:         waitForExpressionBeforePrintActionFunc(logger, b.arguments.disableJavaScript, options.WaitForExpression),",
                "// Line 256:         // Screenshot specific.",
                "// Line 257:         captureScreenshotActionFunc(logger, outputPath, options),",
                "// Line 258:     })",
                "// vulnerable line: 259: }",
                "// Line 260: ",
                "// Line 261: func (b *chromiumBrowser) do(ctx context.Context, logger *zap.Logger, url string, options Options, tasks chromedp.Tasks) error {",
                "// Line 262:     if !b.isStarted.Load() {",
                "// Line 263:         return errors.New(\"browser not started, cannot handle tasks\")",
                "// vulnerable line: 264: }",
                "// Line 265: ",
                "// vulnerable line: 266: // We validate the \"main\" URL against our allow / deny lists.",
                "// vulnerable line: 267: if !b.arguments.allowList.MatchString(url) {",
                "// vulnerable line: 268: return fmt.Errorf(\"'%s' does not match the expression from the allowed list: %w\", url, ErrUrlNotAuthorized)",
                "// vulnerable line: 269: }",
                "// Line 270: ",
                "// vulnerable line: 271: if b.arguments.denyList.String() != \"\" && b.arguments.denyList.MatchString(url) {",
                "// vulnerable line: 272: return fmt.Errorf(\"'%s' matches the expression from the denied list: %w\", url, ErrUrlNotAuthorized)",
                "// vulnerable line: 273: }",
                "// Line 274: ",
                "// Line 275:     deadline, ok := ctx.Deadline()",
                "// Line 276:     if !ok {",
                "// Line 277:         return errors.New(\"context has no deadline\")",
                "// vulnerable line: 278: }",
                "// Line 279: ",
                "// Line 280:     b.ctxMu.RLock()",
                "// Line 281:     defer b.ctxMu.RUnlock()",
                "// Line 282: ",
                "// Line 283:     timeoutCtx, timeoutCancel := context.WithTimeout(b.ctx, time.Until(deadline))",
                "// Line 284:     defer timeoutCancel()",
                "// Line 285: ",
                "// Line 286:     taskCtx, taskCancel := chromedp.NewContext(timeoutCtx)",
                "// Line 287:     defer taskCancel()",
                "// Line 288: ",
                "// Line 291:     listenForEventRequestPaused(taskCtx, logger, b.arguments.allowList, b.arguments.denyList)",
                "// Line 292: ",
                "// Line 293:     var (",
                "// Line 294:         invalidHttpStatusCode   error",
                "// Line 295:         invalidHttpStatusCodeMu sync.RWMutex",
                "// Line 296:     )",
                "// Line 297: ",
                "// Line 298:     // See https://github.com/gotenberg/gotenberg/issues/613.",
                "// Line 299:     if len(options.FailOnHttpStatusCodes) != 0 {",
                "// Line 300:         listenForEventResponseReceived(taskCtx, logger, url, options.FailOnHttpStatusCodes, &invalidHttpStatusCode, &invalidHttpStatusCodeMu)",
                "// vulnerable line: 301: }",
                "// Line 302: ",
                "// Line 303:     var (",
                "// Line 304:         consoleExceptions   error",
                "// Line 305:         consoleExceptionsMu sync.RWMutex",
                "// Line 306:     )",
                "// Line 307: ",
                "// Line 308:     // See https://github.com/gotenberg/gotenberg/issues/262.",
                "// Line 309:     if options.FailOnConsoleExceptions && !b.arguments.disableJavaScript {",
                "// Line 310:         listenForEventExceptionThrown(taskCtx, logger, &consoleExceptions, &consoleExceptionsMu)",
                "// vulnerable line: 311: }",
                "// Line 312: ",
                "// vulnerable line: 313: err := chromedp.Run(taskCtx, tasks...)",
                "// Line 314:     if err != nil {",
                "// Line 315:         errMessage := err.Error()",
                "// Line 316: ",
                "// Line 317:         if strings.Contains(errMessage, \"Show invalid printer settings error (-32000)\") || strings.Contains(errMessage, \"content area is empty (-32602)\") {",
                "// Line 318:             return ErrInvalidPrinterSettings",
                "// vulnerable line: 319: }",
                "// Line 320: ",
                "// Line 321:         if strings.Contains(errMessage, \"Page range syntax error\") {",
                "// Line 322:             return ErrPageRangesSyntaxError",
                "// vulnerable line: 323: }",
                "// Line 324: ",
                "// Line 325:         if strings.Contains(errMessage, \"rpcc: message too large\") {",
                "// Line 326:             return ErrRpccMessageTooLarge",
                "// vulnerable line: 327: }",
                "// Line 328: ",
                "// Line 329:         return fmt.Errorf(\"handle tasks: %w\", err)",
                "// vulnerable line: 330: }",
                "// Line 331: ",
                "// Line 332:     // See https://github.com/gotenberg/gotenberg/issues/613.",
                "// Line 333:     invalidHttpStatusCodeMu.RLock()",
                "// Line 334:     defer invalidHttpStatusCodeMu.RUnlock()",
                "// Line 335: ",
                "// Line 336:     if invalidHttpStatusCode != nil {",
                "// Line 337:         return fmt.Errorf(\"%v: %w\", invalidHttpStatusCode, ErrInvalidHttpStatusCode)",
                "// vulnerable line: 338: }",
                "// Line 339: ",
                "// Line 340:     // See https://github.com/gotenberg/gotenberg/issues/262.",
                "// Line 341:     consoleExceptionsMu.RLock()",
                "// Line 342:     defer consoleExceptionsMu.RUnlock()",
                "// Line 343: ",
                "// Line 344:     if consoleExceptions != nil {",
                "// Line 345:         return fmt.Errorf(\"%v: %w\", consoleExceptions, ErrConsoleExceptions)",
                "// vulnerable line: 346: }",
                "// Line 347: ",
                "// Line 348:     return nil",
                "// vulnerable line: 349: }",
                "// Line 350: ",
                "// Line 351: // Interface guards.",
                "// Line 352: var (",
                "// Line 353:     _ gotenberg.Process = (*chromiumBrowser)(nil)",
                "// Line 354:     _ browser           = (*chromiumBrowser)(nil)",
                "// Line 355: )"
            ]
        },
        {
            "filename_of_changes": "chromium.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 13: ",
                "// Line 14:     \"github.com/gotenberg/gotenberg/v8/pkg/gotenberg\"",
                "// Line 15:     \"github.com/gotenberg/gotenberg/v8/pkg/modules/api\"",
                "// Line 16: )",
                "// Line 17: ",
                "// Line 18: func init() {",
                "// Line 19:     gotenberg.MustRegisterModule(new(Chromium))",
                "// Line 20: }",
                "// Line 21: ",
                "// Line 22: var (",
                "// vulnerable line: 23: // ErrUrlNotAuthorized happens if a URL is not acceptable according to the",
                "// vulnerable line: 24: // allowed/denied lists.",
                "// vulnerable line: 25: ErrUrlNotAuthorized = errors.New(\"URL not authorized\")",
                "// Line 26: ",
                "// Line 27:     // ErrInvalidEmulatedMediaType happens if the emulated media type is not",
                "// Line 28:     // \"screen\" nor \"print\". Empty value are allowed though.",
                "// Line 29:     ErrInvalidEmulatedMediaType = errors.New(\"invalid emulated media type\")",
                "// Line 30: ",
                "// Line 31:     // ErrInvalidEvaluationExpression happens if an evaluation expression",
                "// Line 32:     // returns an exception or undefined.",
                "// Line 33:     ErrInvalidEvaluationExpression = errors.New(\"invalid evaluation expression\")",
                "// Line 34: ",
                "// Line 35:     // ErrRpccMessageTooLarge happens when the messages received by",
                "// Line 284:             fs.Bool(\"chromium-auto-start\", false, \"Automatically launch Chromium upon initialization if set to true; otherwise, Chromium will start at the time of the first conversion\")",
                "// Line 285:             fs.Duration(\"chromium-start-timeout\", time.Duration(20)*time.Second, \"Maximum duration to wait for Chromium to start or restart\")",
                "// Line 286:             fs.Bool(\"chromium-incognito\", false, \"Start Chromium with incognito mode\")",
                "// Line 287:             fs.Bool(\"chromium-allow-insecure-localhost\", false, \"Ignore TLS/SSL errors on localhost\")",
                "// Line 288:             fs.Bool(\"chromium-ignore-certificate-errors\", false, \"Ignore the certificate errors\")",
                "// Line 289:             fs.Bool(\"chromium-disable-web-security\", false, \"Don't enforce the same-origin policy\")",
                "// Line 290:             fs.Bool(\"chromium-allow-file-access-from-files\", false, \"Allow file:// URIs to read other file:// URIs\")",
                "// Line 291:             fs.String(\"chromium-host-resolver-rules\", \"\", \"Set custom mappings to the host resolver\")",
                "// Line 292:             fs.String(\"chromium-proxy-server\", \"\", \"Set the outbound proxy server; this switch only affects HTTP and HTTPS requests\")",
                "// Line 293:             fs.String(\"chromium-allow-list\", \"\", \"Set the allowed URLs for Chromium using a regular expression\")",
                "// vulnerable line: 294: fs.String(\"chromium-deny-list\", \"^file:///[^tmp].*\", \"Set the denied URLs for Chromium using a regular expression\")",
                "// Line 295:             fs.Bool(\"chromium-clear-cache\", false, \"Clear Chromium cache between each conversion\")",
                "// Line 296:             fs.Bool(\"chromium-clear-cookies\", false, \"Clear Chromium cookies between each conversion\")",
                "// Line 297:             fs.Bool(\"chromium-disable-javascript\", false, \"Disable JavaScript\")",
                "// Line 298:             fs.Bool(\"chromium-disable-routes\", false, \"Disable the routes\")",
                "// Line 299: ",
                "// Line 300:             return fs",
                "// Line 301:         }(),",
                "// Line 302:         New: func() gotenberg.Module { return new(Chromium) },",
                "// Line 303:     }",
                "// Line 304: }"
            ]
        },
        {
            "filename_of_changes": "events.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "13",
            "number_of_lines_deleted_vulnerable_to_cve": "10",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package chromium",
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"context\"",
                "// Line 5:     \"fmt\"",
                "// vulnerable line: 6: \"regexp\"",
                "// Line 7:     \"slices\"",
                "// Line 8:     \"sync\"",
                "// Line 9: ",
                "// Line 10:     \"github.com/chromedp/cdproto/cdp\"",
                "// Line 11:     \"github.com/chromedp/cdproto/fetch\"",
                "// Line 12:     \"github.com/chromedp/cdproto/network\"",
                "// Line 13:     \"github.com/chromedp/cdproto/page\"",
                "// Line 14:     \"github.com/chromedp/cdproto/runtime\"",
                "// Line 15:     \"github.com/chromedp/chromedp\"",
                "// Line 16:     \"go.uber.org/multierr\"",
                "// Line 17:     \"go.uber.org/zap\"",
                "// Line 18:     \"golang.org/x/sync/errgroup\"",
                "// Line 19: )",
                "// Line 20: ",
                "// Line 21: // listenForEventRequestPaused listens for requests to check if they are",
                "// Line 22: // allowed or not.",
                "// vulnerable line: 23: func listenForEventRequestPaused(ctx context.Context, logger *zap.Logger, allowList *regexp.Regexp, denyList *regexp.Regexp) {",
                "// Line 24:     chromedp.ListenTarget(ctx, func(ev interface{}) {",
                "// Line 25:         switch e := ev.(type) {",
                "// Line 26:         case *fetch.EventRequestPaused:",
                "// Line 27:             go func() {",
                "// Line 28:                 logger.Debug(fmt.Sprintf(\"event EventRequestPaused fired for '%s'\", e.Request.URL))",
                "// Line 29:                 allow := true",
                "// Line 30: ",
                "// vulnerable line: 31: if !allowList.MatchString(e.Request.URL) {",
                "// vulnerable line: 32: logger.Warn(fmt.Sprintf(\"'%s' does not match the expression from the allowed list\", e.Request.URL))",
                "// vulnerable line: 33: allow = false",
                "// Line 34:                 }",
                "// Line 35: ",
                "// vulnerable line: 36: if denyList.String() != \"\" && denyList.MatchString(e.Request.URL) {",
                "// vulnerable line: 37: logger.Warn(fmt.Sprintf(\"'%s' matches the expression from the denied list\", e.Request.URL))",
                "// vulnerable line: 38: allow = false",
                "// Line 39:                 }",
                "// Line 40: ",
                "// Line 41:                 cctx := chromedp.FromContext(ctx)",
                "// Line 42:                 executorCtx := cdp.WithExecutor(ctx, cctx.Target)",
                "// Line 43: ",
                "// Line 44:                 if allow {",
                "// Line 45:                     req := fetch.ContinueRequest(e.RequestID)",
                "// vulnerable line: 46: err := req.Do(executorCtx)",
                "// Line 47:                     if err != nil {",
                "// Line 48:                         logger.Error(fmt.Sprintf(\"continue request: %s\", err))",
                "// Line 49:                     }",
                "// Line 50: ",
                "// Line 51:                     return",
                "// Line 52:                 }",
                "// Line 53: ",
                "// Line 54:                 req := fetch.FailRequest(e.RequestID, network.ErrorReasonAccessDenied)",
                "// vulnerable line: 55: err := req.Do(executorCtx)",
                "// Line 56:                 if err != nil {",
                "// Line 57:                     logger.Error(fmt.Sprintf(\"fail request: %s\", err))",
                "// Line 58:                 }",
                "// Line 59:             }()",
                "// Line 60:         }",
                "// Line 61:     })",
                "// Line 62: }",
                "// Line 63: ",
                "// Line 64: // listenForEventResponseReceived listens for an invalid HTTP status code is",
                "// Line 65: // returned by the main page."
            ]
        },
        {
            "filename_of_changes": "flags.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package gotenberg",
                "// Line 2: ",
                "// Line 3: import (",
                "// vulnerable line: 4: \"regexp\"",
                "// Line 5:     \"time\"",
                "// Line 6: ",
                "// Line 7:     \"github.com/labstack/gommon/bytes\"",
                "// Line 8:     flag \"github.com/spf13/pflag\"",
                "// Line 9: )",
                "// Line 10: ",
                "// Line 11: // ParsedFlags wraps a [flag.FlagSet] so that retrieving the typed values is",
                "// Line 12: // easier.",
                "// Line 13: type ParsedFlags struct {",
                "// Line 14:     *flag.FlagSet",
                "// Line 192: func (f *ParsedFlags) MustDeprecatedHumanReadableBytesString(deprecated string, newName string) string {",
                "// Line 193:     if f.Changed(deprecated) {",
                "// Line 194:         return f.MustHumanReadableBytesString(deprecated)",
                "// Line 195:     }",
                "// Line 196: ",
                "// Line 197:     return f.MustHumanReadableBytesString(newName)",
                "// Line 198: }",
                "// Line 199: ",
                "// Line 200: // MustRegexp returns the regular expression of a flag given by name.",
                "// Line 201: // It panics if an error occurs.",
                "// vulnerable line: 202: func (f *ParsedFlags) MustRegexp(name string) *regexp.Regexp {",
                "// Line 203:     val, err := f.GetString(name)",
                "// Line 204:     if err != nil {",
                "// Line 205:         panic(err)",
                "// Line 206:     }",
                "// Line 207: ",
                "// vulnerable line: 208: return regexp.MustCompile(val)",
                "// Line 209: }",
                "// Line 210: ",
                "// Line 211: // MustDeprecatedRegexp returns the regular expression of a deprecated flag if",
                "// Line 212: // it was explicitly set or the regular expression of the new flag.",
                "// Line 213: // It panics if an error occurs.",
                "// vulnerable line: 214: func (f *ParsedFlags) MustDeprecatedRegexp(deprecated string, newName string) *regexp.Regexp {",
                "// Line 215:     if f.Changed(deprecated) {",
                "// Line 216:         return f.MustRegexp(deprecated)",
                "// Line 217:     }",
                "// Line 218: ",
                "// Line 219:     return f.MustRegexp(newName)",
                "// Line 220: }"
            ]
        },
        {
            "filename_of_changes": "middleware.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "17",
            "number_of_lines_deleted_vulnerable_to_cve": "16",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 2: ",
                "// Line 3: import (",
                "// Line 4:     \"bufio\"",
                "// Line 5:     \"bytes\"",
                "// Line 6:     \"context\"",
                "// Line 7:     \"encoding/json\"",
                "// Line 8:     \"errors\"",
                "// Line 9:     \"fmt\"",
                "// Line 10:     \"net/http\"",
                "// Line 11:     \"os\"",
                "// vulnerable line: 12: \"regexp\"",
                "// Line 13:     \"strconv\"",
                "// Line 14:     \"strings\"",
                "// Line 15:     \"time\"",
                "// Line 16: ",
                "// Line 17:     \"github.com/hashicorp/go-retryablehttp\"",
                "// Line 18:     \"github.com/labstack/echo/v4\"",
                "// Line 19: ",
                "// Line 20:     \"github.com/gotenberg/gotenberg/v8/pkg/modules/api\"",
                "// vulnerable line: 21: )",
                "// Line 22: ",
                "// Line 23: func webhookMiddleware(w *Webhook) api.Middleware {",
                "// Line 24:     return api.Middleware{",
                "// Line 25:         Stack: api.MultipartStack,",
                "// Line 26:         Handler: func() echo.MiddlewareFunc {",
                "// Line 27:             return func(next echo.HandlerFunc) echo.HandlerFunc {",
                "// Line 28:                 return func(c echo.Context) error {",
                "// Line 29:                     webhookUrl := c.Request().Header.Get(\"Gotenberg-Webhook-Url\")",
                "// Line 30:                     if webhookUrl == \"\" {",
                "// Line 31:                         // No webhook URL, call the next middleware in the chain.",
                "// Line 32:                         return next(c)",
                "// Line 33:                     }",
                "// Line 34: ",
                "// Line 35:                     ctx := c.Get(\"context\").(*api.Context)",
                "// Line 36:                     cancel := c.Get(\"cancel\").(context.CancelFunc)",
                "// Line 37: ",
                "// Line 38:                     // Do we have a webhook error URL in case of... error?",
                "// Line 39:                     webhookErrorUrl := c.Request().Header.Get(\"Gotenberg-Webhook-Error-Url\")",
                "// Line 40:                     if webhookErrorUrl == \"\" {",
                "// vulnerable line: 41: return api.WrapError(",
                "// Line 42:                             errors.New(\"empty webhook error URL\"),",
                "// Line 43:                             api.NewSentinelHttpError(http.StatusBadRequest, \"Invalid 'Gotenberg-Webhook-Error-Url' header: empty value or header not provided\"),",
                "// vulnerable line: 44: )",
                "// Line 45:                     }",
                "// Line 46: ",
                "// Line 47:                     // Let's check if the webhook URLs are acceptable according to our",
                "// Line 48:                     // allowed/denied lists.",
                "// vulnerable line: 49: filter := func(URL, header string, allowList, denyList *regexp.Regexp) error {",
                "// vulnerable line: 50: if !allowList.MatchString(URL) {",
                "// vulnerable line: 51: return api.WrapError(",
                "// vulnerable line: 52: fmt.Errorf(\"'%s' does not match the expression from the allowed list\", URL),",
                "// vulnerable line: 53: api.NewSentinelHttpError(",
                "// vulnerable line: 54: http.StatusForbidden,",
                "// vulnerable line: 55: fmt.Sprintf(\"Invalid '%s' header value: '%s' does not match the authorized URLs\", header, URL),",
                "// vulnerable line: 56: ),",
                "// vulnerable line: 57: )",
                "// Line 58:                         }",
                "// Line 59: ",
                "// vulnerable line: 60: if denyList.String() != \"\" && denyList.MatchString(URL) {",
                "// vulnerable line: 61: return api.WrapError(",
                "// vulnerable line: 62: fmt.Errorf(\"'%s' matches the expression from the denied list\", URL),",
                "// vulnerable line: 63: api.NewSentinelHttpError(",
                "// vulnerable line: 64: http.StatusForbidden,",
                "// vulnerable line: 65: fmt.Sprintf(\"Invalid '%s' header value: '%s' does not match the authorized URLs\", header, URL),",
                "// vulnerable line: 66: ),",
                "// vulnerable line: 67: )",
                "// Line 68:                         }",
                "// Line 69: ",
                "// vulnerable line: 70: return nil",
                "// Line 71:                     }",
                "// Line 72: ",
                "// vulnerable line: 73: err := filter(webhookUrl, \"Gotenberg-Webhook-Url\", w.allowList, w.denyList)",
                "// Line 74:                     if err != nil {",
                "// Line 75:                         return fmt.Errorf(\"filter webhook URL: %w\", err)",
                "// Line 76:                     }",
                "// Line 77: ",
                "// vulnerable line: 78: err = filter(webhookErrorUrl, \"Gotenberg-Webhook-Error-Url\", w.errorAllowList, w.errorDenyList)",
                "// Line 79:                     if err != nil {",
                "// Line 80:                         return fmt.Errorf(\"filter webhook error URL: %w\", err)",
                "// Line 81:                     }",
                "// Line 82: ",
                "// Line 83:                     // Let's check the HTTP methods for calling the webhook URLs.",
                "// Line 84:                     methodFromHeader := func(header string) (string, error) {",
                "// Line 85:                         method := c.Request().Header.Get(header)",
                "// Line 86: ",
                "// Line 87:                         if method == \"\" {",
                "// Line 88:                             return http.MethodPost, nil",
                "// Line 94:                         case http.MethodPost:",
                "// Line 95:                             return method, nil",
                "// Line 96:                         case http.MethodPatch:",
                "// Line 97:                             return method, nil",
                "// Line 98:                         case http.MethodPut:",
                "// Line 99:                             return method, nil",
                "// Line 100:                         }",
                "// Line 101: ",
                "// Line 102:                         return \"\", api.WrapError(",
                "// Line 103:                             fmt.Errorf(\"webhook method '%s' is not '%s', '%s' or '%s'\", method, http.MethodPost, http.MethodPatch, http.MethodPut),",
                "// vulnerable line: 104: api.NewSentinelHttpError(",
                "// Line 105:                                 http.StatusBadRequest,",
                "// Line 106:                                 fmt.Sprintf(\"Invalid '%s' header value: expected '%s', '%s' or '%s', but got '%s'\", header, http.MethodPost, http.MethodPatch, http.MethodPut, method),",
                "// vulnerable line: 107: ),",
                "// vulnerable line: 108: )",
                "// Line 109:                     }",
                "// Line 110: ",
                "// Line 111:                     webhookMethod, err := methodFromHeader(\"Gotenberg-Webhook-Method\")",
                "// Line 112:                     if err != nil {",
                "// Line 113:                         return fmt.Errorf(\"get method to use for webhook: %w\", err)",
                "// Line 114:                     }",
                "// Line 115: ",
                "// Line 116:                     webhookErrorMethod, err := methodFromHeader(\"Gotenberg-Webhook-Error-Method\")",
                "// Line 117:                     if err != nil {",
                "// Line 118:                         return fmt.Errorf(\"get method to use for webhook error: %w\", err)",
                "// Line 119:                     }",
                "// Line 120: ",
                "// Line 121:                     // What about extra HTTP headers?",
                "// Line 122:                     var extraHTTPHeaders map[string]string",
                "// Line 123: ",
                "// Line 124:                     extraHTTPHeadersJSON := c.Request().Header.Get(\"Gotenberg-Webhook-Extra-Http-Headers\")",
                "// Line 125:                     if extraHTTPHeadersJSON != \"\" {",
                "// Line 126:                         err = json.Unmarshal([]byte(extraHTTPHeadersJSON), &extraHTTPHeaders)",
                "// Line 127:                         if err != nil {",
                "// vulnerable line: 128: return api.WrapError(",
                "// Line 129:                                 fmt.Errorf(\"unmarshal webhook extra HTTP headers: %w\", err),",
                "// Line 130:                                 api.NewSentinelHttpError(http.StatusBadRequest, fmt.Sprintf(\"Invalid 'Gotenberg-Webhook-Extra-Http-Headers' header value: %s\", err.Error())),",
                "// vulnerable line: 131: )",
                "// Line 132:                         }",
                "// Line 133:                     }",
                "// Line 134: ",
                "// Line 135:                     client := &client{",
                "// Line 136:                         url:              webhookUrl,",
                "// Line 137:                         method:           webhookMethod,",
                "// Line 138:                         errorUrl:         webhookErrorUrl,",
                "// Line 139:                         errorMethod:      webhookErrorMethod,",
                "// Line 140:                         extraHttpHeaders: extraHTTPHeaders,",
                "// Line 141:                         startTime:        c.Get(\"startTime\").(time.Time),"
            ]
        },
        {
            "filename_of_changes": "routes.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "1",
            "number_of_lines_deleted_vulnerable_to_cve": "1",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 614:     if errors.Is(err, gotenberg.ErrMaximumQueueSizeExceeded) {",
                "// Line 615:         return api.WrapError(",
                "// Line 616:             err,",
                "// Line 617:             api.NewSentinelHttpError(",
                "// Line 618:                 http.StatusTooManyRequests,",
                "// Line 619:                 \"The maximum queue size has been reached\",",
                "// Line 620:             ),",
                "// Line 621:         )",
                "// Line 622:     }",
                "// Line 623: ",
                "// vulnerable line: 624: if errors.Is(err, ErrUrlNotAuthorized) {",
                "// Line 625:         return api.WrapError(",
                "// Line 626:             err,",
                "// Line 627:             api.NewSentinelHttpError(",
                "// Line 628:                 http.StatusForbidden,",
                "// Line 629:                 fmt.Sprintf(\"'%s' does not match the authorized URLs\", url),",
                "// Line 630:             ),",
                "// Line 631:         )",
                "// Line 632:     }",
                "// Line 633: ",
                "// Line 634:     if errors.Is(err, ErrInvalidEvaluationExpression) {"
            ]
        },
        {
            "filename_of_changes": "routes_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "4",
            "number_of_lines_deleted_vulnerable_to_cve": "4",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1236:             api: &ApiMock{PdfMock: func(ctx context.Context, logger *zap.Logger, url, outputPath string, options PdfOptions) error {",
                "// Line 1237:                 return gotenberg.ErrMaximumQueueSizeExceeded",
                "// Line 1238:             }},",
                "// Line 1239:             options:                DefaultPdfOptions(),",
                "// Line 1240:             expectError:            true,",
                "// Line 1241:             expectHttpError:        true,",
                "// Line 1242:             expectHttpStatus:       http.StatusTooManyRequests,",
                "// Line 1243:             expectOutputPathsCount: 0,",
                "// Line 1244:         },",
                "// Line 1245:         {",
                "// vulnerable line: 1246: scenario: \"ErrUrlNotAuthorized\",",
                "// Line 1247:             ctx:      &api.ContextMock{Context: new(api.Context)},",
                "// Line 1248:             api: &ApiMock{PdfMock: func(ctx context.Context, logger *zap.Logger, url, outputPath string, options PdfOptions) error {",
                "// vulnerable line: 1249: return ErrUrlNotAuthorized",
                "// Line 1250:             }},",
                "// Line 1251:             options:                DefaultPdfOptions(),",
                "// Line 1252:             expectError:            true,",
                "// Line 1253:             expectHttpError:        true,",
                "// Line 1254:             expectHttpStatus:       http.StatusForbidden,",
                "// Line 1255:             expectOutputPathsCount: 0,",
                "// Line 1256:         },",
                "// Line 1257:         {",
                "// Line 1258:             scenario: \"ErrOmitBackgroundWithoutPrintBackground\",",
                "// Line 1259:             ctx:      &api.ContextMock{Context: new(api.Context)},",
                "// Line 1496:             api: &ApiMock{ScreenshotMock: func(ctx context.Context, logger *zap.Logger, url, outputPath string, options ScreenshotOptions) error {",
                "// Line 1497:                 return gotenberg.ErrMaximumQueueSizeExceeded",
                "// Line 1498:             }},",
                "// Line 1499:             options:                DefaultScreenshotOptions(),",
                "// Line 1500:             expectError:            true,",
                "// Line 1501:             expectHttpError:        true,",
                "// Line 1502:             expectHttpStatus:       http.StatusTooManyRequests,",
                "// Line 1503:             expectOutputPathsCount: 0,",
                "// Line 1504:         },",
                "// Line 1505:         {",
                "// vulnerable line: 1506: scenario: \"ErrUrlNotAuthorized\",",
                "// Line 1507:             ctx:      &api.ContextMock{Context: new(api.Context)},",
                "// Line 1508:             api: &ApiMock{ScreenshotMock: func(ctx context.Context, logger *zap.Logger, url, outputPath string, options ScreenshotOptions) error {",
                "// vulnerable line: 1509: return ErrUrlNotAuthorized",
                "// Line 1510:             }},",
                "// Line 1511:             options:                DefaultScreenshotOptions(),",
                "// Line 1512:             expectError:            true,",
                "// Line 1513:             expectHttpError:        true,",
                "// Line 1514:             expectHttpStatus:       http.StatusForbidden,",
                "// Line 1515:             expectOutputPathsCount: 0,",
                "// Line 1516:         },",
                "// Line 1517:         {",
                "// Line 1518:             scenario: \"ErrInvalidEvaluationExpression (without waitForExpression form field)\",",
                "// Line 1519:             ctx:      &api.ContextMock{Context: new(api.Context)},"
            ]
        },
        {
            "filename_of_changes": "supervisor_test.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "2",
            "number_of_lines_deleted_vulnerable_to_cve": "2",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 411:             }",
                "// Line 412:             if tc.currentQueueSize > 0 {",
                "// Line 413:                 ps.reqQueueSize.Store(tc.currentQueueSize)",
                "// Line 414:             }",
                "// Line 415: ",
                "// Line 416:             task := func() error {",
                "// Line 417:                 return tc.taskError",
                "// Line 418:             }",
                "// Line 419: ",
                "// Line 420:             ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)",
                "// vulnerable line: 421: defer cancel()",
                "// Line 422: ",
                "// Line 423:             var wg sync.WaitGroup",
                "// Line 424:             errorChan := make(chan error, tc.tasksToRun)",
                "// Line 425: ",
                "// Line 426:             for i := 0; i < tc.tasksToRun; i++ {",
                "// Line 427:                 wg.Add(1)",
                "// Line 428:                 go func() {",
                "// Line 429:                     defer wg.Done()",
                "// Line 430:                     err := ps.Run(ctx, logger, task)",
                "// Line 431:                     if err != nil {",
                "// Line 480:         {",
                "// Line 481:             scenario:    \"context expired\",",
                "// Line 482:             ctxDone:     true,",
                "// Line 483:             expectError: true,",
                "// Line 484:         },",
                "// Line 485:     } {",
                "// Line 486:         t.Run(tc.scenario, func(t *testing.T) {",
                "// Line 487:             ps := NewProcessSupervisor(zap.NewNop(), new(ProcessMock), 0, 0).(*processSupervisor)",
                "// Line 488: ",
                "// Line 489:             ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)",
                "// vulnerable line: 490: defer cancel()",
                "// Line 491: ",
                "// Line 492:             if tc.ctxDone {",
                "// Line 493:                 cancel()",
                "// Line 494:             }",
                "// Line 495: ",
                "// Line 496:             err := ps.runWithDeadline(ctx, func() error {",
                "// Line 497:                 return nil",
                "// Line 498:             })",
                "// Line 499: ",
                "// Line 500:             if tc.expectError && err == nil {",
                "// Line 521:     ps := NewProcessSupervisor(logger, process, 0, 0).(*processSupervisor)",
                "// Line 522: ",
                "// Line 523:     // Simulating a lock.",
                "// Line 524:     ps.mutexChan <- struct{}{}",
                "// Line 525: ",
                "// Line 526:     if ps.ReqQueueSize() != 0 {",
                "// Line 527:         t.Fatalf(\"expected queue size to be 0 but got %d\", ps.ReqQueueSize())",
                "// Line 528:     }",
                "// Line 529: ",
                "// Line 530:     ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)",
                "// vulnerable line: 531: defer cancel()",
                "// Line 532: ",
                "// Line 533:     var wg sync.WaitGroup",
                "// Line 534:     errorChan := make(chan error, 10)",
                "// Line 535: ",
                "// Line 536:     for i := 0; i < 10; i++ {",
                "// Line 537:         wg.Add(1)",
                "// Line 538:         go func() {",
                "// Line 539:             defer wg.Done()",
                "// Line 540:             err := ps.Run(ctx, logger, func() error {",
                "// Line 541:                 return nil"
            ]
        },
        {
            "filename_of_changes": "webhook.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "5",
            "number_of_lines_deleted_vulnerable_to_cve": "5",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 1: package webhook",
                "// Line 2: ",
                "// Line 3: import (",
                "// vulnerable line: 4: \"regexp\"",
                "// Line 5:     \"time\"",
                "// Line 6: ",
                "// Line 7:     flag \"github.com/spf13/pflag\"",
                "// Line 8: ",
                "// Line 9:     \"github.com/gotenberg/gotenberg/v8/pkg/gotenberg\"",
                "// Line 10:     \"github.com/gotenberg/gotenberg/v8/pkg/modules/api\"",
                "// Line 11: )",
                "// Line 12: ",
                "// Line 13: func init() {",
                "// Line 14:     gotenberg.MustRegisterModule(new(Webhook))",
                "// Line 15: }",
                "// Line 16: ",
                "// Line 17: // Webhook is a module which provides a middleware for uploading output files",
                "// Line 18: // to any destinations in an asynchronous fashion.",
                "// Line 19: type Webhook struct {",
                "// vulnerable line: 20: allowList      *regexp.Regexp",
                "// vulnerable line: 21: denyList       *regexp.Regexp",
                "// vulnerable line: 22: errorAllowList *regexp.Regexp",
                "// vulnerable line: 23: errorDenyList  *regexp.Regexp",
                "// Line 24:     maxRetry       int",
                "// Line 25:     retryMinWait   time.Duration",
                "// Line 26:     retryMaxWait   time.Duration",
                "// Line 27:     clientTimeout  time.Duration",
                "// Line 28:     disable        bool",
                "// Line 29: }",
                "// Line 30: ",
                "// Line 31: // Descriptor returns an [Webhook]'s module descriptor.",
                "// Line 32: func (w *Webhook) Descriptor() gotenberg.ModuleDescriptor {",
                "// Line 33:     return gotenberg.ModuleDescriptor{"
            ]
        }
    ]
}