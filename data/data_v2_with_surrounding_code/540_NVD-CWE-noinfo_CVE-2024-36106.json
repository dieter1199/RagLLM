{
    "cve_id": "CVE-2024-36106",
    "cve_description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. It’s possible for authenticated users to enumerate clusters by name by inspecting error messages. It’s also possible to enumerate the names of projects with project-scoped clusters if you know the names of the clusters. This vulnerability is fixed in 2.11.3, 2.10.12, and 2.9.17.",
    "cve_publish_date": "2024-06-06T15:15Z",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-3cqf-953p-h5cp\n\n* fix: prevent enumerating by cluster name, return exact error for case when cluster exists and not\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix: prevent cluster enumeration by name\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix: prevent cluster enumeration by name\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter and add unit test\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter and add unit test\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter and add unit test\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter and add unit test\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n* fix linter and add unit test\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>\n\n---------\n\nSigned-off-by: pashakostohrys <pavel@codefresh.io>",
    "type_of_change": "Modification",
    "changes": [
        {
            "filename_of_changes": "cluster.go",
            "code_language": "Go",
            "number_of_lines_added_for_mitigation": "30",
            "number_of_lines_deleted_vulnerable_to_cve": "21",
            "Code_with_highlighted_vulnerability_lines": [
                "// Line 23:     \"github.com/argoproj/argo-cd/v2/util/db\"",
                "// Line 24:     \"github.com/argoproj/argo-cd/v2/util/rbac\"",
                "// Line 25: )",
                "// Line 26: ",
                "// Line 27: // Server provides a Cluster service",
                "// Line 28: type Server struct {",
                "// Line 29:     db      db.ArgoDB",
                "// Line 30:     enf     *rbac.Enforcer",
                "// Line 31:     cache   *servercache.Cache",
                "// Line 32:     kubectl kube.Kubectl",
                "// vulnerable line: 33: }",
                "// Line 34: ",
                "// Line 35: // NewServer returns a new instance of the Cluster service",
                "// Line 36: func NewServer(db db.ArgoDB, enf *rbac.Enforcer, cache *servercache.Cache, kubectl kube.Kubectl) *Server {",
                "// Line 37:     return &Server{",
                "// Line 38:         db:      db,",
                "// Line 39:         enf:     enf,",
                "// Line 40:         cache:   cache,",
                "// Line 41:         kubectl: kubectl,",
                "// vulnerable line: 42: }",
                "// vulnerable line: 43: }",
                "// Line 44: ",
                "// Line 45: func CreateClusterRBACObject(project string, server string) string {",
                "// Line 46:     if project != \"\" {",
                "// Line 47:         return project + \"/\" + server",
                "// vulnerable line: 48: }",
                "// Line 49:     return server",
                "// vulnerable line: 50: }",
                "// Line 51: ",
                "// Line 52: // List returns list of clusters",
                "// Line 53: func (s *Server) List(ctx context.Context, q *cluster.ClusterQuery) (*appv1.ClusterList, error) {",
                "// Line 54:     clusterList, err := s.db.ListClusters(ctx)",
                "// Line 55:     if err != nil {",
                "// vulnerable line: 56: return nil, err",
                "// vulnerable line: 57: }",
                "// Line 58: ",
                "// Line 59:     filteredItems := clusterList.Items",
                "// Line 60: ",
                "// Line 61:     // Filter clusters by id",
                "// Line 62:     if filteredItems, err = filterClustersById(filteredItems, q.Id); err != nil {",
                "// vulnerable line: 63: return nil, err",
                "// vulnerable line: 64: }",
                "// Line 65: ",
                "// Line 66:     // Filter clusters by name",
                "// Line 67:     filteredItems = filterClustersByName(filteredItems, q.Name)",
                "// Line 68: ",
                "// Line 69:     // Filter clusters by server",
                "// Line 70:     filteredItems = filterClustersByServer(filteredItems, q.Server)",
                "// Line 71: ",
                "// Line 72:     items := make([]appv1.Cluster, 0)",
                "// Line 73:     for _, clust := range filteredItems {",
                "// Line 74:         if s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionGet, CreateClusterRBACObject(clust.Project, clust.Server)) {",
                "// Line 75:             items = append(items, clust)",
                "// vulnerable line: 76: }",
                "// vulnerable line: 77: }",
                "// Line 78:     err = kube.RunAllAsync(len(items), func(i int) error {",
                "// Line 79:         items[i] = *s.toAPIResponse(&items[i])",
                "// Line 80:         return nil",
                "// vulnerable line: 81: })",
                "// Line 82:     if err != nil {",
                "// vulnerable line: 83: return nil, err",
                "// vulnerable line: 84: }",
                "// Line 85: ",
                "// Line 86:     cl := *clusterList",
                "// Line 87:     cl.Items = items",
                "// Line 88: ",
                "// Line 89:     return &cl, nil",
                "// vulnerable line: 90: }",
                "// Line 91: ",
                "// Line 92: func filterClustersById(clusters []appv1.Cluster, id *cluster.ClusterID) ([]appv1.Cluster, error) {",
                "// Line 93:     if id == nil {",
                "// Line 94:         return clusters, nil",
                "// vulnerable line: 95: }",
                "// Line 96: ",
                "// Line 97:     var items []appv1.Cluster",
                "// Line 98: ",
                "// Line 99:     switch id.Type {",
                "// Line 100:     case \"name\":",
                "// Line 101:         items = filterClustersByName(clusters, id.Value)",
                "// Line 102:     case \"name_escaped\":",
                "// Line 103:         nameUnescaped, err := url.QueryUnescape(id.Value)",
                "// Line 104:         if err != nil {",
                "// vulnerable line: 105: return nil, err",
                "// vulnerable line: 106: }",
                "// Line 107:         items = filterClustersByName(clusters, nameUnescaped)",
                "// Line 108:     default:",
                "// Line 109:         items = filterClustersByServer(clusters, id.Value)",
                "// vulnerable line: 110: }",
                "// Line 111: ",
                "// Line 112:     return items, nil",
                "// vulnerable line: 113: }",
                "// Line 114: ",
                "// Line 115: func filterClustersByName(clusters []appv1.Cluster, name string) []appv1.Cluster {",
                "// Line 116:     if name == \"\" {",
                "// Line 117:         return clusters",
                "// vulnerable line: 118: }",
                "// Line 119:     items := make([]appv1.Cluster, 0)",
                "// Line 120:     for i := 0; i < len(clusters); i++ {",
                "// Line 121:         if clusters[i].Name == name {",
                "// Line 122:             items = append(items, clusters[i])",
                "// Line 123:             return items",
                "// vulnerable line: 124: }",
                "// vulnerable line: 125: }",
                "// Line 126:     return items",
                "// vulnerable line: 127: }",
                "// Line 128: ",
                "// Line 129: func filterClustersByServer(clusters []appv1.Cluster, server string) []appv1.Cluster {",
                "// Line 130:     if server == \"\" {",
                "// Line 131:         return clusters",
                "// vulnerable line: 132: }",
                "// Line 133:     items := make([]appv1.Cluster, 0)",
                "// Line 134:     for i := 0; i < len(clusters); i++ {",
                "// Line 135:         if clusters[i].Server == server {",
                "// Line 136:             items = append(items, clusters[i])",
                "// Line 137:             return items",
                "// vulnerable line: 138: }",
                "// vulnerable line: 139: }",
                "// Line 140:     return items",
                "// vulnerable line: 141: }",
                "// Line 142: ",
                "// Line 143: // Create creates a cluster",
                "// Line 144: func (s *Server) Create(ctx context.Context, q *cluster.ClusterCreateRequest) (*appv1.Cluster, error) {",
                "// Line 145:     if err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionCreate, CreateClusterRBACObject(q.Cluster.Project, q.Cluster.Server)); err != nil {",
                "// vulnerable line: 146: return nil, err",
                "// vulnerable line: 147: }",
                "// Line 148:     c := q.Cluster",
                "// Line 149:     serverVersion, err := s.kubectl.GetServerVersion(c.RESTConfig())",
                "// Line 150:     if err != nil {",
                "// vulnerable line: 151: return nil, err",
                "// vulnerable line: 152: }",
                "// Line 153: ",
                "// Line 154:     clust, err := s.db.CreateCluster(ctx, c)",
                "// Line 155:     if err != nil {",
                "// Line 156:         if status.Convert(err).Code() == codes.AlreadyExists {",
                "// Line 157:             // act idempotent if existing spec matches new spec",
                "// Line 158:             existing, getErr := s.db.GetCluster(ctx, c.Server)",
                "// Line 159:             if getErr != nil {",
                "// Line 160:                 return nil, status.Errorf(codes.Internal, \"unable to check existing cluster details: %v\", getErr)",
                "// vulnerable line: 161: }",
                "// Line 162: ",
                "// Line 163:             if existing.Equals(c) {",
                "// Line 164:                 clust = existing",
                "// Line 165:             } else if q.Upsert {",
                "// Line 166:                 return s.Update(ctx, &cluster.ClusterUpdateRequest{Cluster: c})",
                "// Line 167:             } else {",
                "// Line 168:                 return nil, status.Errorf(codes.InvalidArgument, argo.GenerateSpecIsDifferentErrorMessage(\"cluster\", existing, c))",
                "// vulnerable line: 169: }",
                "// Line 170:         } else {",
                "// vulnerable line: 171: return nil, err",
                "// vulnerable line: 172: }",
                "// vulnerable line: 173: }",
                "// Line 174: ",
                "// Line 175:     err = s.cache.SetClusterInfo(c.Server, &appv1.ClusterInfo{",
                "// Line 176:         ServerVersion: serverVersion,",
                "// Line 177:         ConnectionState: appv1.ConnectionState{",
                "// Line 178:             Status:     appv1.ConnectionStatusSuccessful,",
                "// Line 179:             ModifiedAt: &v1.Time{Time: time.Now()},",
                "// Line 180:         },",
                "// vulnerable line: 181: })",
                "// Line 182:     if err != nil {",
                "// vulnerable line: 183: return nil, err",
                "// vulnerable line: 184: }",
                "// Line 185:     return s.toAPIResponse(clust), err",
                "// vulnerable line: 186: }",
                "// Line 187: ",
                "// Line 188: // Get returns a cluster from a query",
                "// Line 189: func (s *Server) Get(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {",
                "// vulnerable line: 190: c, err := s.getClusterWith403IfNotExist(ctx, q)",
                "// Line 191:     if err != nil {",
                "// vulnerable line: 192: return nil, err",
                "// vulnerable line: 193: }",
                "// Line 194: ",
                "// vulnerable line: 195: if err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionGet, CreateClusterRBACObject(c.Project, q.Server)); err != nil {",
                "// vulnerable line: 196: return nil, err",
                "// vulnerable line: 197: }",
                "// Line 198: ",
                "// Line 199:     return s.toAPIResponse(c), nil",
                "// vulnerable line: 200: }",
                "// Line 201: ",
                "// Line 202: func (s *Server) getClusterWith403IfNotExist(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {",
                "// Line 203:     repo, err := s.getCluster(ctx, q)",
                "// Line 204:     if err != nil || repo == nil {",
                "// vulnerable line: 205: return nil, common.PermissionDeniedAPIError",
                "// vulnerable line: 206: }",
                "// Line 207:     return repo, nil",
                "// vulnerable line: 208: }",
                "// Line 209: ",
                "// Line 210: func (s *Server) getCluster(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {",
                "// Line 211:     if q.Id != nil {",
                "// Line 212:         q.Server = \"\"",
                "// Line 213:         q.Name = \"\"",
                "// Line 214:         if q.Id.Type == \"name\" {",
                "// Line 215:             q.Name = q.Id.Value",
                "// Line 216:         } else if q.Id.Type == \"name_escaped\" {",
                "// Line 217:             nameUnescaped, err := url.QueryUnescape(q.Id.Value)",
                "// Line 218:             if err != nil {",
                "// vulnerable line: 219: return nil, err",
                "// vulnerable line: 220: }",
                "// Line 221:             q.Name = nameUnescaped",
                "// Line 222:         } else {",
                "// Line 223:             q.Server = q.Id.Value",
                "// vulnerable line: 224: }",
                "// vulnerable line: 225: }",
                "// Line 226: ",
                "// Line 227:     if q.Server != \"\" {",
                "// Line 228:         c, err := s.db.GetCluster(ctx, q.Server)",
                "// Line 229:         if err != nil {",
                "// vulnerable line: 230: return nil, err",
                "// vulnerable line: 231: }",
                "// Line 232:         return c, nil",
                "// vulnerable line: 233: }",
                "// Line 234: ",
                "// Line 235:     //we only get the name when we specify Name in ApplicationDestination and next",
                "// Line 236:     //we want to find the server in order to populate ApplicationDestination.Server",
                "// Line 237:     if q.Name != \"\" {",
                "// Line 238:         clusterList, err := s.db.ListClusters(ctx)",
                "// Line 239:         if err != nil {",
                "// vulnerable line: 240: return nil, err",
                "// vulnerable line: 241: }",
                "// Line 242:         for _, c := range clusterList.Items {",
                "// Line 243:             if c.Name == q.Name {",
                "// Line 244:                 return &c, nil",
                "// vulnerable line: 245: }",
                "// vulnerable line: 246: }",
                "// vulnerable line: 247: }",
                "// Line 248: ",
                "// Line 249:     return nil, nil",
                "// vulnerable line: 250: }",
                "// Line 251: ",
                "// Line 252: var clusterFieldsByPath = map[string]func(updated *appv1.Cluster, existing *appv1.Cluster){",
                "// Line 253:     \"name\": func(updated *appv1.Cluster, existing *appv1.Cluster) {",
                "// Line 254:         updated.Name = existing.Name",
                "// Line 255:     },",
                "// Line 256:     \"namespaces\": func(updated *appv1.Cluster, existing *appv1.Cluster) {",
                "// Line 257:         updated.Namespaces = existing.Namespaces",
                "// Line 258:     },",
                "// Line 259:     \"config\": func(updated *appv1.Cluster, existing *appv1.Cluster) {",
                "// Line 260:         updated.Config = existing.Config",
                "// Line 267:     },",
                "// Line 268:     \"labels\": func(updated *appv1.Cluster, existing *appv1.Cluster) {",
                "// Line 269:         updated.Labels = existing.Labels",
                "// Line 270:     },",
                "// Line 271:     \"annotations\": func(updated *appv1.Cluster, existing *appv1.Cluster) {",
                "// Line 272:         updated.Annotations = existing.Annotations",
                "// Line 273:     },",
                "// Line 274:     \"project\": func(updated *appv1.Cluster, existing *appv1.Cluster) {",
                "// Line 275:         updated.Project = existing.Project",
                "// Line 276:     },",
                "// vulnerable line: 277: }",
                "// Line 278: ",
                "// Line 279: // Update updates a cluster",
                "// Line 280: func (s *Server) Update(ctx context.Context, q *cluster.ClusterUpdateRequest) (*appv1.Cluster, error) {",
                "// vulnerable line: 281: c, err := s.getClusterWith403IfNotExist(ctx, &cluster.ClusterQuery{",
                "// Line 282:         Server: q.Cluster.Server,",
                "// Line 283:         Name:   q.Cluster.Name,",
                "// Line 284:         Id:     q.Id,",
                "// vulnerable line: 285: })",
                "// Line 286:     if err != nil {",
                "// vulnerable line: 287: return nil, err",
                "// vulnerable line: 288: }",
                "// Line 289: ",
                "// vulnerable line: 290: // verify that user can do update inside project where cluster is located",
                "// vulnerable line: 291: if !s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(c.Project, c.Server)) {",
                "// vulnerable line: 292: return nil, common.PermissionDeniedAPIError",
                "// vulnerable line: 293: }",
                "// Line 294: ",
                "// Line 295:     if len(q.UpdatedFields) == 0 || sets.NewString(q.UpdatedFields...).Has(\"project\") {",
                "// Line 296:         // verify that user can do update inside project where cluster will be located",
                "// Line 297:         if !s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(q.Cluster.Project, c.Server)) {",
                "// vulnerable line: 298: return nil, common.PermissionDeniedAPIError",
                "// vulnerable line: 299: }",
                "// vulnerable line: 300: }",
                "// Line 301: ",
                "// Line 302:     if len(q.UpdatedFields) != 0 {",
                "// Line 303:         for _, path := range q.UpdatedFields {",
                "// Line 304:             if updater, ok := clusterFieldsByPath[path]; ok {",
                "// Line 305:                 updater(c, q.Cluster)",
                "// vulnerable line: 306: }",
                "// vulnerable line: 307: }",
                "// Line 308:         q.Cluster = c",
                "// vulnerable line: 309: }",
                "// Line 310: ",
                "// Line 311:     // Test the token we just created before persisting it",
                "// Line 312:     serverVersion, err := s.kubectl.GetServerVersion(q.Cluster.RESTConfig())",
                "// Line 313:     if err != nil {",
                "// vulnerable line: 314: return nil, err",
                "// vulnerable line: 315: }",
                "// Line 316: ",
                "// Line 317:     clust, err := s.db.UpdateCluster(ctx, q.Cluster)",
                "// Line 318:     if err != nil {",
                "// vulnerable line: 319: return nil, err",
                "// vulnerable line: 320: }",
                "// Line 321:     err = s.cache.SetClusterInfo(clust.Server, &appv1.ClusterInfo{",
                "// Line 322:         ServerVersion: serverVersion,",
                "// Line 323:         ConnectionState: appv1.ConnectionState{",
                "// Line 324:             Status:     appv1.ConnectionStatusSuccessful,",
                "// Line 325:             ModifiedAt: &v1.Time{Time: time.Now()},",
                "// Line 326:         },",
                "// vulnerable line: 327: })",
                "// Line 328:     if err != nil {",
                "// vulnerable line: 329: return nil, err",
                "// vulnerable line: 330: }",
                "// Line 331:     return s.toAPIResponse(clust), nil",
                "// vulnerable line: 332: }",
                "// Line 333: ",
                "// Line 334: // Delete deletes a cluster by server/name",
                "// Line 335: func (s *Server) Delete(ctx context.Context, q *cluster.ClusterQuery) (*cluster.ClusterResponse, error) {",
                "// vulnerable line: 336: c, err := s.getClusterWith403IfNotExist(ctx, q)",
                "// Line 337:     if err != nil {",
                "// vulnerable line: 338: return nil, err",
                "// vulnerable line: 339: }",
                "// Line 340: ",
                "// Line 341:     if q.Name != \"\" {",
                "// Line 342:         servers, err := s.db.GetClusterServersByName(ctx, q.Name)",
                "// Line 343:         if err != nil {",
                "// vulnerable line: 344: return nil, err",
                "// vulnerable line: 345: }",
                "// Line 346:         for _, server := range servers {",
                "// Line 347:             if err := enforceAndDelete(s, ctx, server, c.Project); err != nil {",
                "// vulnerable line: 348: return nil, err",
                "// vulnerable line: 349: }",
                "// vulnerable line: 350: }",
                "// Line 351:     } else {",
                "// Line 352:         if err := enforceAndDelete(s, ctx, q.Server, c.Project); err != nil {",
                "// vulnerable line: 353: return nil, err",
                "// vulnerable line: 354: }",
                "// vulnerable line: 355: }",
                "// Line 356: ",
                "// Line 357:     return &cluster.ClusterResponse{}, nil",
                "// vulnerable line: 358: }",
                "// Line 359: ",
                "// Line 360: func enforceAndDelete(s *Server, ctx context.Context, server, project string) error {",
                "// Line 361:     if err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionDelete, CreateClusterRBACObject(project, server)); err != nil {",
                "// vulnerable line: 362: return err",
                "// vulnerable line: 363: }",
                "// Line 364:     if err := s.db.DeleteCluster(ctx, server); err != nil {",
                "// vulnerable line: 365: return err",
                "// vulnerable line: 366: }",
                "// Line 367:     return nil",
                "// vulnerable line: 368: }",
                "// Line 369: ",
                "// Line 370: // RotateAuth rotates the bearer token used for a cluster",
                "// Line 371: func (s *Server) RotateAuth(ctx context.Context, q *cluster.ClusterQuery) (*cluster.ClusterResponse, error) {",
                "// Line 372:     clust, err := s.getClusterWith403IfNotExist(ctx, q)",
                "// Line 373:     if err != nil {",
                "// vulnerable line: 374: return nil, err",
                "// vulnerable line: 375: }",
                "// Line 376: ",
                "// Line 377:     var servers []string",
                "// Line 378:     if q.Name != \"\" {",
                "// Line 379:         servers, err = s.db.GetClusterServersByName(ctx, q.Name)",
                "// Line 380:         if err != nil {",
                "// vulnerable line: 381: return nil, status.Errorf(codes.NotFound, \"failed to get cluster servers by name: %v\", err)",
                "// vulnerable line: 382: }",
                "// Line 383:         for _, server := range servers {",
                "// Line 384:             if err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(clust.Project, server)); err != nil {",
                "// vulnerable line: 385: return nil, status.Errorf(codes.PermissionDenied, \"encountered permissions issue while processing request: %v\", err)",
                "// vulnerable line: 386: }",
                "// vulnerable line: 387: }",
                "// Line 388:     } else {",
                "// Line 389:         if err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(clust.Project, q.Server)); err != nil {",
                "// vulnerable line: 390: return nil, status.Errorf(codes.PermissionDenied, \"encountered permissions issue while processing request: %v\", err)",
                "// vulnerable line: 391: }",
                "// Line 392:         servers = append(servers, q.Server)",
                "// vulnerable line: 393: }",
                "// Line 394: ",
                "// Line 395:     for _, server := range servers {",
                "// Line 396:         logCtx := log.WithField(\"cluster\", server)",
                "// Line 397:         logCtx.Info(\"Rotating auth\")",
                "// Line 398:         restCfg := clust.RESTConfig()",
                "// Line 399:         if restCfg.BearerToken == \"\" {",
                "// Line 400:             return nil, status.Errorf(codes.InvalidArgument, \"Cluster '%s' does not use bearer token authentication\", server)",
                "// vulnerable line: 401: }",
                "// Line 402: ",
                "// Line 403:         claims, err := clusterauth.ParseServiceAccountToken(restCfg.BearerToken)",
                "// Line 404:         if err != nil {",
                "// vulnerable line: 405: return nil, err",
                "// vulnerable line: 406: }",
                "// Line 407:         kubeclientset, err := kubernetes.NewForConfig(restCfg)",
                "// Line 408:         if err != nil {",
                "// vulnerable line: 409: return nil, err",
                "// vulnerable line: 410: }",
                "// Line 411:         newSecret, err := clusterauth.GenerateNewClusterManagerSecret(kubeclientset, claims)",
                "// Line 412:         if err != nil {",
                "// vulnerable line: 413: return nil, err",
                "// vulnerable line: 414: }",
                "// Line 415:         // we are using token auth, make sure we don't store client-cert information",
                "// Line 416:         clust.Config.KeyData = nil",
                "// Line 417:         clust.Config.CertData = nil",
                "// Line 418:         clust.Config.BearerToken = string(newSecret.Data[\"token\"])",
                "// Line 419: ",
                "// Line 420:         // Test the token we just created before persisting it",
                "// Line 421:         serverVersion, err := s.kubectl.GetServerVersion(clust.RESTConfig())",
                "// Line 422:         if err != nil {",
                "// vulnerable line: 423: return nil, err",
                "// vulnerable line: 424: }",
                "// Line 425:         _, err = s.db.UpdateCluster(ctx, clust)",
                "// Line 426:         if err != nil {",
                "// vulnerable line: 427: return nil, err",
                "// vulnerable line: 428: }",
                "// Line 429:         err = s.cache.SetClusterInfo(clust.Server, &appv1.ClusterInfo{",
                "// Line 430:             ServerVersion: serverVersion,",
                "// Line 431:             ConnectionState: appv1.ConnectionState{",
                "// Line 432:                 Status:     appv1.ConnectionStatusSuccessful,",
                "// Line 433:                 ModifiedAt: &v1.Time{Time: time.Now()},",
                "// Line 434:             },",
                "// vulnerable line: 435: })",
                "// Line 436:         if err != nil {",
                "// vulnerable line: 437: return nil, err",
                "// vulnerable line: 438: }",
                "// Line 439:         err = clusterauth.RotateServiceAccountSecrets(kubeclientset, claims, newSecret)",
                "// Line 440:         if err != nil {",
                "// vulnerable line: 441: return nil, err",
                "// vulnerable line: 442: }",
                "// Line 443:         logCtx.Infof(\"Rotated auth (old: %s, new: %s)\", claims.SecretName, newSecret.Name)",
                "// vulnerable line: 444: }",
                "// Line 445:     return &cluster.ClusterResponse{}, nil",
                "// vulnerable line: 446: }",
                "// Line 447: ",
                "// Line 448: func (s *Server) toAPIResponse(clust *appv1.Cluster) *appv1.Cluster {",
                "// Line 449:     _ = s.cache.GetClusterInfo(clust.Server, &clust.Info)",
                "// Line 450: ",
                "// Line 451:     clust.Config.Password = \"\"",
                "// Line 452:     clust.Config.BearerToken = \"\"",
                "// Line 453:     clust.Config.TLSClientConfig.KeyData = nil",
                "// Line 454:     if clust.Config.ExecProviderConfig != nil {",
                "// Line 455:         // We can't know what the user has put into args or",
                "// Line 456:         // env vars on the exec provider that might be sensitive",
                "// Line 457:         // (e.g. --private-key=XXX, PASSWORD=XXX)",
                "// Line 458:         // Implicitly assumes the command executable name is non-sensitive",
                "// Line 459:         clust.Config.ExecProviderConfig.Env = make(map[string]string)",
                "// Line 460:         clust.Config.ExecProviderConfig.Args = nil",
                "// vulnerable line: 461: }",
                "// Line 462:     // populate deprecated fields for backward compatibility",
                "// Line 463:     clust.ServerVersion = clust.Info.ServerVersion",
                "// Line 464:     clust.ConnectionState = clust.Info.ConnectionState",
                "// Line 465:     return clust",
                "// vulnerable line: 466: }",
                "// Line 467: ",
                "// Line 468: // InvalidateCache invalidates cluster cache",
                "// Line 469: func (s *Server) InvalidateCache(ctx context.Context, q *cluster.ClusterQuery) (*appv1.Cluster, error) {",
                "// vulnerable line: 470: cls, err := s.getClusterWith403IfNotExist(ctx, q)",
                "// Line 471:     if err != nil {",
                "// vulnerable line: 472: return nil, err",
                "// vulnerable line: 473: }",
                "// vulnerable line: 474: if err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, CreateClusterRBACObject(cls.Project, q.Server)); err != nil {",
                "// vulnerable line: 475: return nil, err",
                "// vulnerable line: 476: }",
                "// Line 477:     now := v1.Now()",
                "// Line 478:     cls.RefreshRequestedAt = &now",
                "// Line 479:     cls, err = s.db.UpdateCluster(ctx, cls)",
                "// Line 480:     if err != nil {",
                "// vulnerable line: 481: return nil, err",
                "// vulnerable line: 482: }",
                "// Line 483:     return s.toAPIResponse(cls), nil",
                "// vulnerable line: 484: }"
            ]
        }
    ]
}