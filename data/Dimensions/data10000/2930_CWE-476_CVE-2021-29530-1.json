{
    "cve_id": "CVE-2021-29530",
    "cve_description": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
    "cve_publish_date": "2021-05-14",
    "cwe_id": "CWE-476",
    "cwe_name": "NULL Pointer Dereference",
    "cwe_description": "The product dereferences a pointer that it expects to be valid but is NULL.",
    "commit_message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
    "type_of_change": "Modification",
    "filename_of_changes": "sparse_cholesky_op.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "34",
    "number_of_lines_deleted_vulnerable_to_cve": "33",
    "vulnerable_lines": [
        "// Line_Reference 85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
        "// Line_Reference 86:                    &num_rows);",
        "// Line_Reference 229:   void ValidateInputs(OpKernelContext* ctx,",
        "// Line_Reference 230:                       const CSRSparseMatrix& sparse_matrix,",
        "// Line_Reference 231:                       const Tensor& permutation_indices, int* batch_size,",
        "// Line_Reference 232:                       int64* num_rows) {",
        "// Line_Reference 233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
        "// Line_Reference 234:                 errors::InvalidArgument(",
        "// Line_Reference 235:                     \"Asked for a CSRSparseMatrix of type \",",
        "// Line_Reference 236:                     DataTypeString(DataTypeToEnum<T>::value),",
        "// Line_Reference 237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
        "// Line_Reference 241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
        "// Line_Reference 242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
        "// Line_Reference 243:                                         \"but dense_shape has size \", rank));",
        "// Line_Reference 248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
        "// Line_Reference 249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
        "// Line_Reference 250:                                         *num_rows, \" != \", num_cols));",
        "// Line_Reference 252:     OP_REQUIRES(",
        "// Line_Reference 253:         ctx, perm_shape.dims() + 1 == rank,",
        "// Line_Reference 254:         errors::InvalidArgument(",
        "// Line_Reference 255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
        "// Line_Reference 256:             \" != \", perm_shape.dims(), \" + 1.\"));",
        "// Line_Reference 257:     OP_REQUIRES(",
        "// Line_Reference 258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
        "// Line_Reference 259:         errors::InvalidArgument(",
        "// Line_Reference 260:             \"permutation must have the same number of elements in each batch \"",
        "// Line_Reference 261:             \"as the number of rows in sparse matrix; got: \",",
        "// Line_Reference 262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
        "// Line_Reference 266:       OP_REQUIRES(",
        "// Line_Reference 267:           ctx, perm_shape.dim_size(0) == *batch_size,",
        "// Line_Reference 268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
        "// Line_Reference 269:                                   \"as sparse matrix; got: \",",
        "// Line_Reference 270:                                   perm_shape.dim_size(0), \" != \", *batch_size));"
    ]
}
