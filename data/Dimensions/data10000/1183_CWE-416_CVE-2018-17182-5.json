{
    "cve_id": "CVE-2018-17182",
    "cve_description": "An issue was discovered in the Linux kernel through 4.18.8. The vmacache_flush_all function in mm/vmacache.c mishandles sequence number overflows. An attacker can trigger a use-after-free (and possibly gain privileges) via certain thread creation, map, unmap, invalidation, and dereference operations.",
    "cve_publish_date": "2018-09-19",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "mm: get rid of vmacache_flush_all() entirely\n\nJann Horn points out that the vmacache_flush_all() function is not only\npotentially expensive, it's buggy too.  It also happens to be entirely\nunnecessary, because the sequence number overflow case can be avoided by\nsimply making the sequence number be 64-bit.  That doesn't even grow the\ndata structures in question, because the other adjacent fields are\nalready 64-bit.\n\nSo simplify the whole thing by just making the sequence number overflow\ncase go away entirely, which gets rid of all the complications and makes\nthe code faster too.  Win-win.\n\n[ Oleg Nesterov points out that the VMACACHE_FULL_FLUSHES statistics\n  also just goes away entirely with this ]\n\nReported-by: Jann Horn <jannh@google.com>\nSuggested-by: Will Deacon <will.deacon@arm.com>\nAcked-by: Davidlohr Bueso <dave@stgolabs.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "vmacache.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "38",
    "vulnerable_lines": [
        "// Line_Reference 22: /*",
        "// Line_Reference 23:  * Flush vma caches for threads that share a given mm.",
        "// Line_Reference 24:  *",
        "// Line_Reference 25:  * The operation is safe because the caller holds the mmap_sem",
        "// Line_Reference 26:  * exclusively and other threads accessing the vma cache will",
        "// Line_Reference 27:  * have mmap_sem held at least for read, so no extra locking",
        "// Line_Reference 28:  * is required to maintain the vma cache.",
        "// Line_Reference 29:  */",
        "// Line_Reference 30: void vmacache_flush_all(struct mm_struct *mm)",
        "// Line_Reference 31: {",
        "// Line_Reference 32: \tstruct task_struct *g, *p;",
        "// Line_Reference 33: ",
        "// Line_Reference 34: \tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);",
        "// Line_Reference 35: ",
        "// Line_Reference 36: \t/*",
        "// Line_Reference 37: \t * Single threaded tasks need not iterate the entire",
        "// Line_Reference 38: \t * list of process. We can avoid the flushing as well",
        "// Line_Reference 39: \t * since the mm's seqnum was increased and don't have",
        "// Line_Reference 40: \t * to worry about other threads' seqnum. Current's",
        "// Line_Reference 41: \t * flush will occur upon the next lookup.",
        "// Line_Reference 42: \t */",
        "// Line_Reference 43: \tif (atomic_read(&mm->mm_users) == 1)",
        "// Line_Reference 44: \t\treturn;",
        "// Line_Reference 45: ",
        "// Line_Reference 46: \trcu_read_lock();",
        "// Line_Reference 47: \tfor_each_process_thread(g, p) {",
        "// Line_Reference 48: \t\t/*",
        "// Line_Reference 49: \t\t * Only flush the vmacache pointers as the",
        "// Line_Reference 50: \t\t * mm seqnum is already set and curr's will",
        "// Line_Reference 51: \t\t * be set upon invalidation when the next",
        "// Line_Reference 52: \t\t * lookup is done.",
        "// Line_Reference 53: \t\t */",
        "// Line_Reference 54: \t\tif (mm == p->mm)",
        "// Line_Reference 55: \t\t\tvmacache_flush(p);",
        "// Line_Reference 56: \t}",
        "// Line_Reference 57: \trcu_read_unlock();",
        "// Line_Reference 58: }",
        "// Line_Reference 59: "
    ]
}
