{
    "cve_id": "CVE-2021-30465",
    "cve_description": "runc before 1.0.0-rc95 allows a Container Filesystem Breakout via Directory Traversal. To exploit the vulnerability, an attacker must be able to create multiple containers with a fairly specific mount configuration. The problem occurs via a symlink-exchange attack that relies on a race condition.",
    "cve_publish_date": "2021-05-27",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "rootfs: add mount destination validation\n\nBecause the target of a mount is inside a container (which may be a\nvolume that is shared with another container), there exists a race\ncondition where the target of the mount may change to a path containing\na symlink after we have sanitised the path -- resulting in us\ninadvertently mounting the path outside of the container.\n\nThis is not immediately useful because we are in a mount namespace with\nMS_SLAVE mount propagation applied to \"/\", so we cannot mount on top of\nhost paths in the host namespace. However, if any subsequent mountpoints\nin the configuration use a subdirectory of that host path as a source,\nthose subsequent mounts will use an attacker-controlled source path\n(resolved within the host rootfs) -- allowing the bind-mounting of \"/\"\ninto the container.\n\nWhile arguably configuration issues like this are not entirely within\nrunc's threat model, within the context of Kubernetes (and possibly\nother container managers that provide semi-arbitrary container creation\nprivileges to untrusted users) this is a legitimate issue. Since we\ncannot block mounting from the host into the container, we need to block\nthe first stage of this attack (mounting onto a path outside the\ncontainer).\n\nThe long-term plan to solve this would be to migrate to libpathrs, but\nas a stop-gap we implement libpathrs-like path verification through\nreadlink(/proc/self/fd/$n) and then do mount operations through the\nprocfd once it's been verified to be inside the container. The target\ncould move after we've checked it, but if it is inside the container\nthen we can assume that it is safe for the same reason that libpathrs\noperations would be safe.\n\nA slight wrinkle is the \"copyup\" functionality we provide for tmpfs,\nwhich is the only case where we want to do a mount on the host\nfilesystem. To facilitate this, I split out the copy-up functionality\nentirely so that the logic isn't interspersed with the regular tmpfs\nlogic. In addition, all dependencies on m.Destination being overwritten\nhave been removed since that pattern was just begging to be a source of\nmore mount-target bugs (we do still have to modify m.Destination for\ntmpfs-copyup but we only do it temporarily).\n\nFixes: CVE-2021-30465\nReported-by: Etienne Champetier <champetier.etienne@gmail.com>\nCo-authored-by: Noah Meyerhans <nmeyerha@amazon.com>\nReviewed-by: Samuel Karp <skarp@amazon.com>\nReviewed-by: Kir Kolyshkin <kolyshkin@gmail.com> (@kolyshkin)\nReviewed-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>\nSigned-off-by: Aleksa Sarai <cyphar@cyphar.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "container_linux.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "16",
    "number_of_lines_deleted_vulnerable_to_cve": "9",
    "vulnerable_lines": [
        "// Line_Reference 1220: \t\tm.Destination = dest",
        "// Line_Reference 1260: \t\t\tif e := unix.Unmount(u, unix.MNT_DETACH); e != nil {",
        "// Line_Reference 1261: \t\t\t\tif e != unix.EINVAL {",
        "// Line_Reference 1262: \t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'",
        "// Line_Reference 1263: \t\t\t\t\t// It probably has already been unmounted.",
        "// Line_Reference 1264: \t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %q (%v)\", u, e)",
        "// Line_Reference 1266: \t\t\t}",
        "// Line_Reference 1284: \t\t\t\tif err := unix.Mount(m.Source, m.Destination, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {",
        "// Line_Reference 1285: \t\t\t\t\treturn errorsf.Wrapf(err, \"unable to bind mount %q to %q\", m.Source, m.Destination)"
    ]
}
