* Copyright (C) 2009, 2011, 2014-2015, D. R. Commander.
/* Private subobject */
typedef struct {
struct jpeg_upsampler pub;    /* public fields */
/* Pointer to routine to do actual upsampling/conversion of one row group */
void (*upmethod) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
/* Private state for YCC->RGB conversion */
int *Cr_r_tab;                /* => table for Cr to R conversion */
int *Cb_b_tab;                /* => table for Cb to B conversion */
JLONG *Cr_g_tab;              /* => table for Cr to G conversion */
JLONG *Cb_g_tab;              /* => table for Cb to G conversion */
/* For 2:1 vertical sampling, we produce two output rows at a time.
* We need a "spare" row buffer to hold the second output row if the
* application provides just a one-row buffer; we also use the spare
* to discard the dummy last row if the image height is odd.
*/
JSAMPROW spare_row;
boolean spare_full;           /* T if spare buffer is occupied */
JDIMENSION out_row_width;     /* samples per output row */
JDIMENSION rows_to_go;        /* counts rows remaining in image */
} my_upsampler;
typedef my_upsampler *my_upsample_ptr;
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
my_upsample_ptr upsample;
upsample = (my_upsample_ptr)
sizeof(my_upsampler));
