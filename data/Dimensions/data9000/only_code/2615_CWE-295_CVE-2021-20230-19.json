*   Copyright (C) 1998-2019 Michal Trojnara <Michal.Trojnara@stunnel.org>
options_defaults();
options_apply();
if(cmdline_status) /* cannot proceed */
options_apply();
if(bind_ports())
if(change_root())
if(drop_privileges(1))
if(log_open(SINK_OUTFILE))
log_flush(LOG_MODE_ERROR);
void unbind_ports(void) {
CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);
opt=service_options.next;
service_options.next=NULL;
service_free(&service_options);
while(opt) {
/* exec+connect service */
/* purge session cache of the old SSL_CTX object */
/* this workaround won't be needed anymore after */
/* delayed deallocation calls SSL_CTX_free()     */
if(opt->ctx)
SSL_CTX_flush_sessions(opt->ctx,
(long)time(NULL)+opt->session_timeout+1);
s_log(LOG_DEBUG, "Service [%s] closed", opt->servname);
{
SERVICE_OPTIONS *garbage=opt;
opt=opt->next;
garbage->next=NULL;
service_free(garbage);
}
CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
int bind_ports(void) {
static int delay=10; /* 10ms */
options_free();
options_apply();
if(bind_ports() | exec_connect_start()) {
if(delay > 10000) /* 10s */
} else {
delay=10; /* 10ms */
