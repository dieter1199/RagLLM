private static final int PERCENT_ENCODING_MARKER = 0xFF;
private static final byte[] RAW_CHAR_TO_MARKER = new byte[256];
private static final String[] MARKER_TO_PERCENT_ENCODED_CHAR = new String[256];
for (final ReservedChar reservedChar : ReservedChar.values()) {
RAW_CHAR_TO_MARKER[reservedChar.rawChar] = reservedChar.marker;
MARKER_TO_PERCENT_ENCODED_CHAR[reservedChar.marker] = reservedChar.percentEncodedChar;
return path + "?" + query;
if (path.data[0] != '/') {
if (pathContainsDoubleDots(path)) {
return new PathAndQuery(encodeToPercents(path, true),
query != null ? encodeToPercents(query, false) : null);
// Insert a special mark so we can distinguish a raw character ('/') and
// percent-encoded character ('%2F') in a path string.
// We will encode this mark back into a percent-encoded character later.
final byte marker = RAW_CHAR_TO_MARKER['/'];
buf.ensure(2);
buf.add((byte) PERCENT_ENCODING_MARKER);
buf.add(marker);
final byte marker = RAW_CHAR_TO_MARKER[decoded];
if (marker != 0) {
// Insert a special mark so we can distinguish a raw character and percent-encoded
// character in a query string, such as '&' and '%26'.
// We will encode this mark back into a percent-encoded character later.
buf.ensure(2);
buf.add((byte) PERCENT_ENCODING_MARKER);
buf.add(marker);
buf.add((byte) ' ');
buf.add((byte) ((cp >>> 6) | 0b110_00000));
buf.add((byte) (cp & 0b111111 | 0b10_000000));
buf.add((byte) ((cp >>> 12) | 0b1110_0000));
buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
buf.add((byte) ((cp & 0b111111) | 0b10_000000));
buf.add((byte) ((cp >>> 18) | 0b11110_000));
buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
buf.add((byte) ((cp & 0b111111) | 0b10_000000));
buf.add((byte) ((cp >>> 24) | 0b111110_00));
buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));
buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
buf.add((byte) ((cp & 0b111111) | 0b10_000000));
buf.add((byte) ((cp >>> 30) | 0b1111110_0));
buf.add((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));
buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));
buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
buf.add((byte) ((cp & 0b111111) | 0b10_000000));
buf.add((byte) cp);
if (b3 == '/' && b2 == '.' && b1 == '.' && b0 == '/') {
return b0 == '/' && b1 == '.' && b2 == '.';
private static String encodeToPercents(Bytes value, boolean isPath) {
final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;
final int length = value.length;
boolean needsEncoding = false;
if (!allowedChars.get(value.data[i] & 0xFF)) {
needsEncoding = true;
break;
if (!needsEncoding) {
return new String(value.data, 0, 0, length);
final StringBuilder buf = new StringBuilder(length);
if (b == PERCENT_ENCODING_MARKER && (i + 1) < length) {
final int marker = value.data[i + 1] & 0xFF;
final String percentEncodedChar = MARKER_TO_PERCENT_ENCODED_CHAR[marker];
if (percentEncodedChar != null) {
buf.append(percentEncodedChar);
i++;
continue;
}
if (allowedChars.get(b)) {
buf.append((char) b);
} else if (b == ' ') {
if (isPath) {
buf.append("%20");
} else {
buf.append('+');
}
} else {
buf.append('%');
appendHexNibble(buf, b >>> 4);
appendHexNibble(buf, b & 0xF);
}
private static void appendHexNibble(StringBuilder buf, int nibble) {
if (nibble < 10) {
buf.append((char) ('0' + nibble));
} else {
buf.append((char) ('A' + nibble - 10));
/**
* Reserved characters which require percent-encoding. These values are only used for constructing
* {@link #RAW_CHAR_TO_MARKER} and {@link #MARKER_TO_PERCENT_ENCODED_CHAR} mapping tables.
*
* @see <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-2.2">RFC 3986, section 2.2</a>
*/
private enum ReservedChar {
GEN_DELIM_01(':', "%3A", (byte) 0x01),
GEN_DELIM_02('/', "%2F", (byte) 0x02),
GEN_DELIM_03('?', "%3F", (byte) 0x03),
GEN_DELIM_04('#', "%23", (byte) 0x04),
GEN_DELIM_05('[', "%5B", (byte) 0x05),
GEN_DELIM_06(']', "%5D", (byte) 0x06),
GEN_DELIM_07('@', "%40", (byte) 0x07),
SUB_DELIM_01('!', "%21", (byte) 0x11),
SUB_DELIM_02('$', "%24", (byte) 0x12),
SUB_DELIM_03('&', "%26", (byte) 0x13),
SUB_DELIM_04('\'', "%27", (byte) 0x14),
SUB_DELIM_05('(', "%28", (byte) 0x15),
SUB_DELIM_06(')', "%29", (byte) 0x16),
SUB_DELIM_07('*', "%2A", (byte) 0x17),
SUB_DELIM_08('+', "%2B", (byte) 0x18),
SUB_DELIM_09(',', "%2C", (byte) 0x19),
SUB_DELIM_10(';', "%3B", (byte) 0x1A),
SUB_DELIM_11('=', "%3D", (byte) 0x1B);
private final int rawChar;
private final String percentEncodedChar;
private final byte marker;
ReservedChar(int rawChar, String percentEncodedChar, byte marker) {
this.rawChar = rawChar;
this.percentEncodedChar = percentEncodedChar;
this.marker = marker;
}
}
