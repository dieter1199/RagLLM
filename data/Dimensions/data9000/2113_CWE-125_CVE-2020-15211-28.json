{
    "cve_id": "CVE-2020-15211",
    "cve_description": "In TensorFlow Lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, saved models in the flatbuffer format use a double indexing scheme: a model has a set of subgraphs, each subgraph has a set of operators and each operator has a set of input/output tensors. The flatbuffer format uses indices for the tensors, indexing into an array of tensors that is owned by the subgraph. This results in a pattern of double array indexing when trying to get the data of each tensor. However, some operators can have some tensors be optional. To handle this scenario, the flatbuffer model uses a negative `-1` value as index for these tensors. This results in special casing during validation at model loading time. Unfortunately, this means that the `-1` index is a valid tensor index for any operator, including those that don't expect optional inputs and including for output tensors. Thus, this allows writing and reading from outside the bounds of heap allocated arrays, although only at a specific offset from the start of these arrays. This results in both read and write gadgets, albeit very limited in scope. The issue is patched in several commits (46d5b0852, 00302787b7, e11f5558, cd31fd0ce, 1970c21, and fff2c83), and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that only operators which accept optional inputs use the `-1` special value and only for the tensors that they expect to be optional. Since this allow-list type approach is erro-prone, we advise upgrading to the patched code.",
    "cve_publish_date": "2020-09-25",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "[tflite]: Insert `nullptr` checks when obtaining tensors.\n\nAs part of ongoing refactoring, `tflite::GetInput`, `tflite::GetOutput`, `tflite::GetTemporary` and `tflite::GetIntermediates` will return `nullptr` in some cases. Hence, we insert the `nullptr` checks on all usages.\n\nWe also insert `nullptr` checks on usages of `tflite::GetVariableInput` and `tflite::GetOptionalInputTensor` but only in the cases where there is no obvious check that `nullptr` is acceptable (that is, we only insert the check for the output of these two functions if the tensor is accessed as if it is always not `nullptr`).\n\nPiperOrigin-RevId: 332521299\nChange-Id: I29af455bcb48d0b92e58132d951a3badbd772d56",
    "type_of_change": "Modification",
    "filename_of_changes": "detection_postprocess.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "94",
    "number_of_lines_deleted_vulnerable_to_cve": "48",
    "vulnerable_lines": [
        "// Line_Reference 149:   const TfLiteTensor* input_box_encodings =",
        "// Line_Reference 150:       GetInput(context, node, kInputTensorBoxEncodings);",
        "// Line_Reference 151:   const TfLiteTensor* input_class_predictions =",
        "// Line_Reference 152:       GetInput(context, node, kInputTensorClassPredictions);",
        "// Line_Reference 153:   const TfLiteTensor* input_anchors =",
        "// Line_Reference 154:       GetInput(context, node, kInputTensorAnchors);",
        "// Line_Reference 166:   TfLiteTensor* detection_boxes =",
        "// Line_Reference 167:       GetOutput(context, node, kOutputTensorDetectionBoxes);",
        "// Line_Reference 173:   TfLiteTensor* detection_classes =",
        "// Line_Reference 174:       GetOutput(context, node, kOutputTensorDetectionClasses);",
        "// Line_Reference 179:   TfLiteTensor* detection_scores =",
        "// Line_Reference 180:       GetOutput(context, node, kOutputTensorDetectionScores);",
        "// Line_Reference 185:   TfLiteTensor* num_detections =",
        "// Line_Reference 186:       GetOutput(context, node, kOutputTensorNumDetections);",
        "// Line_Reference 272:   const TfLiteTensor* input_box_encodings =",
        "// Line_Reference 273:       GetInput(context, node, kInputTensorBoxEncodings);",
        "// Line_Reference 277:   const TfLiteTensor* input_anchors =",
        "// Line_Reference 278:       GetInput(context, node, kInputTensorAnchors);",
        "// Line_Reference 392:   const TfLiteTensor* input_box_encodings =",
        "// Line_Reference 393:       GetInput(context, node, kInputTensorBoxEncodings);",
        "// Line_Reference 471:   const TfLiteTensor* input_box_encodings =",
        "// Line_Reference 472:       GetInput(context, node, kInputTensorBoxEncodings);",
        "// Line_Reference 473:   const TfLiteTensor* input_class_predictions =",
        "// Line_Reference 474:       GetInput(context, node, kInputTensorClassPredictions);",
        "// Line_Reference 478:   TfLiteTensor* detection_boxes =",
        "// Line_Reference 479:       GetOutput(context, node, kOutputTensorDetectionBoxes);",
        "// Line_Reference 480:   TfLiteTensor* detection_classes =",
        "// Line_Reference 481:       GetOutput(context, node, kOutputTensorDetectionClasses);",
        "// Line_Reference 482:   TfLiteTensor* detection_scores =",
        "// Line_Reference 483:       GetOutput(context, node, kOutputTensorDetectionScores);",
        "// Line_Reference 484:   TfLiteTensor* num_detections =",
        "// Line_Reference 485:       GetOutput(context, node, kOutputTensorNumDetections);",
        "// Line_Reference 598:   const TfLiteTensor* input_box_encodings =",
        "// Line_Reference 599:       GetInput(context, node, kInputTensorBoxEncodings);",
        "// Line_Reference 600:   const TfLiteTensor* input_class_predictions =",
        "// Line_Reference 601:       GetInput(context, node, kInputTensorClassPredictions);",
        "// Line_Reference 605:   TfLiteTensor* detection_boxes =",
        "// Line_Reference 606:       GetOutput(context, node, kOutputTensorDetectionBoxes);",
        "// Line_Reference 607:   TfLiteTensor* detection_classes =",
        "// Line_Reference 608:       GetOutput(context, node, kOutputTensorDetectionClasses);",
        "// Line_Reference 609:   TfLiteTensor* detection_scores =",
        "// Line_Reference 610:       GetOutput(context, node, kOutputTensorDetectionScores);",
        "// Line_Reference 611:   TfLiteTensor* num_detections =",
        "// Line_Reference 612:       GetOutput(context, node, kOutputTensorNumDetections);",
        "// Line_Reference 683:   const TfLiteTensor* input_box_encodings =",
        "// Line_Reference 684:       GetInput(context, node, kInputTensorBoxEncodings);",
        "// Line_Reference 685:   const TfLiteTensor* input_class_predictions =",
        "// Line_Reference 686:       GetInput(context, node, kInputTensorClassPredictions);"
    ]
}
