{
    "cve_id": "CVE-2018-16149",
    "cve_description": "In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification blindly trusts the declared lengths in the ASN.1 structure. Consequently, when small public exponents are being used, a remote attacker can generate purposefully crafted signatures (and put them on X.509 certificates) to induce illegal memory access and crash the verifier.",
    "cve_publish_date": "2018-11-07",
    "cwe_id": "CWE-347",
    "cwe_name": "Improper Verification of Cryptographic Signature",
    "cwe_description": "The product does not verify, or incorrectly verifies, the cryptographic signature for data.",
    "commit_message": "Apply CVE fixes for X509 parsing\n\nApply patches developed by Sze Yiu which correct a vulnerability in\nX509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",
    "type_of_change": "Modification",
    "filename_of_changes": "x509.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "64",
    "number_of_lines_deleted_vulnerable_to_cve": "38",
    "vulnerable_lines": [
        "// Line_Reference 52: ",
        "// Line_Reference 53: /**",
        "// Line_Reference 54:  * Retrieve the signature from a certificate.",
        "// Line_Reference 55:  */",
        "// Line_Reference 56: static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)",
        "// Line_Reference 57: {",
        "// Line_Reference 58:     int offset = 0;",
        "// Line_Reference 59:     const uint8_t *ptr = NULL;",
        "// Line_Reference 60: ",
        "// Line_Reference 61:     if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 ||",
        "// Line_Reference 62:             asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))",
        "// Line_Reference 63:         goto end_get_sig;",
        "// Line_Reference 64: ",
        "// Line_Reference 65:     if (asn1_sig[offset++] != ASN1_OCTET_STRING)",
        "// Line_Reference 66:         goto end_get_sig;",
        "// Line_Reference 67:     *len = get_asn1_length(asn1_sig, &offset);",
        "// Line_Reference 68:     ptr = &asn1_sig[offset];          /* all ok */",
        "// Line_Reference 69: ",
        "// Line_Reference 70: end_get_sig:",
        "// Line_Reference 71:     return ptr;",
        "// Line_Reference 72: }",
        "// Line_Reference 73: ",
        "// Line_Reference 418: static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,",
        "// Line_Reference 421:     int i, size;",
        "// Line_Reference 436:     i = 10; /* start at the first possible non-padded byte */",
        "// Line_Reference 437:     while (block[i++] && i < sig_len);",
        "// Line_Reference 438:     size = sig_len - i;",
        "// Line_Reference 439: ",
        "// Line_Reference 440:     /* get only the bit we want */",
        "// Line_Reference 441:     if (size > 0)",
        "// Line_Reference 442:     {",
        "// Line_Reference 443:         int len;",
        "// Line_Reference 444:         const uint8_t *sig_ptr = get_signature(&block[i], &len);",
        "// Line_Reference 446:         if (sig_ptr)",
        "// Line_Reference 447:         {",
        "// Line_Reference 448:             bir = bi_import(ctx, sig_ptr, len);",
        "// Line_Reference 449:         }",
        "// Line_Reference 603:     cert_sig = sig_verify(ctx, cert->signature, cert->sig_len,"
    ]
}
