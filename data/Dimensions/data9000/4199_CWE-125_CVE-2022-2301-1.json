{
    "cve_id": "CVE-2022-2301",
    "cve_description": "Buffer Over-read in GitHub repository hpjansson/chafa prior to 1.10.3.",
    "cve_publish_date": "2022-07-04",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "XwdLoader: Fix buffer over-read and improve general robustness\n\nThis commit fixes a buffer over-read that could occur due to g_ntohl()\nevaluating its argument more than once if at least one of the following\nis true:\n\n* Build target is not x86.\n* __OPTIMIZE__ is not set during compilation (e.g. -O0 was used).\n\nIt also improves robustness more generally and fixes an issue where the\nwrong field was being used to calculate the color map size, causing some\nimage files that were otherwise fine to be rejected.\n\nReported by @JieyongMa via huntr.dev.",
    "type_of_change": "Modification",
    "filename_of_changes": "xwd-loader.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "55",
    "number_of_lines_deleted_vulnerable_to_cve": "31",
    "vulnerable_lines": [
        "// Line_Reference 170: load_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)",
        "// Line_Reference 174:     const guint32 *p = (const guint32 *) &in;",
        "// Line_Reference 179:     h->header_size = g_ntohl (*(p++));",
        "// Line_Reference 180:     h->file_version = g_ntohl (*(p++));",
        "// Line_Reference 181:     h->pixmap_format = g_ntohl (*(p++));",
        "// Line_Reference 182:     h->pixmap_depth = g_ntohl (*(p++));",
        "// Line_Reference 183:     h->pixmap_width = g_ntohl (*(p++));",
        "// Line_Reference 184:     h->pixmap_height = g_ntohl (*(p++));",
        "// Line_Reference 185:     h->x_offset = g_ntohl (*(p++));",
        "// Line_Reference 186:     h->byte_order = g_ntohl (*(p++));",
        "// Line_Reference 187:     h->bitmap_unit = g_ntohl (*(p++));",
        "// Line_Reference 188:     h->bitmap_bit_order = g_ntohl (*(p++));",
        "// Line_Reference 189:     h->bitmap_pad = g_ntohl (*(p++));",
        "// Line_Reference 190:     h->bits_per_pixel = g_ntohl (*(p++));",
        "// Line_Reference 191:     h->bytes_per_line = g_ntohl (*(p++));",
        "// Line_Reference 192:     h->visual_class = g_ntohl (*(p++));",
        "// Line_Reference 193:     h->red_mask = g_ntohl (*(p++));",
        "// Line_Reference 194:     h->green_mask = g_ntohl (*(p++));",
        "// Line_Reference 195:     h->blue_mask = g_ntohl (*(p++));",
        "// Line_Reference 196:     h->bits_per_rgb = g_ntohl (*(p++));",
        "// Line_Reference 197:     h->color_map_entries = g_ntohl (*(p++));",
        "// Line_Reference 198:     h->n_colors = g_ntohl (*(p++));",
        "// Line_Reference 199:     h->window_width = g_ntohl (*(p++));",
        "// Line_Reference 200:     h->window_height = g_ntohl (*(p++));",
        "// Line_Reference 201:     h->window_x = g_ntohl (*(p++));",
        "// Line_Reference 202:     h->window_y = g_ntohl (*(p++));",
        "// Line_Reference 203:     h->window_border_width = g_ntohl (*(p++));",
        "// Line_Reference 206:      * namely, that corresponding to screen dumps from modern X.Org servers. */",
        "// Line_Reference 224:                    + h->n_colors * sizeof (XwdColor)",
        "// Line_Reference 225:                    + h->pixmap_height * h->bytes_per_line);",
        "// Line_Reference 228:         + h->header_size + h->n_colors * sizeof (XwdColor);"
    ]
}
