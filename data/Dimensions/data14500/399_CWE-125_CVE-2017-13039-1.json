{
    "cve_id": "CVE-2017-13039",
    "cve_description": "The ISAKMP parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions.",
    "cve_publish_date": "2017-09-14",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "CVE-2017-13039/IKEv1: Do more bounds checking.\n\nHave ikev1_attrmap_print() and ikev1_attr_print() do full bounds\nchecking, and return null on a bounds overflow.  Have their callers\ncheck for a null return.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
    "type_of_change": "Modification",
    "filename_of_changes": "print-isakmp.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "58",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 915: \t\t    const u_char *p, const u_char *ep,",
        "// Line_Reference 923: \telse",
        "// Line_Reference 925: \tif (ep < p + totlen) {",
        "// Line_Reference 927: \t\treturn ep + 1;",
        "// Line_Reference 941: \t\telse",
        "// Line_Reference 942: \t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);",
        "// Line_Reference 944: \t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));",
        "// Line_Reference 945: \t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));",
        "// Line_Reference 952: ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)",
        "// Line_Reference 959: \telse",
        "// Line_Reference 961: \tif (ep < p + totlen) {",
        "// Line_Reference 963: \t\treturn ep + 1;",
        "// Line_Reference 972: \t\trawprint(ndo, (const uint8_t *)&p[2], 2);",
        "// Line_Reference 974: \t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));",
        "// Line_Reference 975: \t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));",
        "// Line_Reference 1259: \t\tif (map && nmap) {",
        "// Line_Reference 1260: \t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,",
        "// Line_Reference 1261: \t\t\t\tmap, nmap);",
        "// Line_Reference 1262: \t\t} else",
        "// Line_Reference 1263: \t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);",
        "// Line_Reference 1727: \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,",
        "// Line_Reference 1728: \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);",
        "// Line_Reference 1929: \t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,",
        "// Line_Reference 1930: \t\t\t\tmap, nmap);",
        "// Line_Reference 1932: \t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);"
    ]
}
