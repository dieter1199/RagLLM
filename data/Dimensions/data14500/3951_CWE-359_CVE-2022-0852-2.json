{
    "cve_id": "CVE-2022-0852",
    "cve_description": "There is a flaw in convert2rhel. convert2rhel passes the Red Hat account password to subscription-manager via the command line, which could allow unauthorized users locally on the machine to view the password via the process command line via e.g. htop or ps. The specific impact varies upon the privileges of the Red Hat account in question, but it could affect the integrity, availability, and/or data confidentiality of other systems that are administered by that account. This occurs regardless of how the password is supplied to convert2rhel.",
    "cve_publish_date": "2022-08-29",
    "cwe_id": "CWE-359",
    "cwe_name": "Exposure of Private Personal Information to an Unauthorized Actor",
    "cwe_description": "The product does not properly prevent a person's private, personal information from being accessed by actors who either (1) are not explicitly authorized to access the information or (2) do not have the implicit consent of the person about whom the information is collected.",
    "commit_message": "Do not put the subscription-manager password onto the command line. (#492)\n\n* Do not put the subscription-manager password onto the command line.\r\n\r\nFixes CVE-2022-0852\r\n\r\nPassing values on the command line is insecure.  With this change,\r\nthe rhsm password is passed interactively to subscription-manager\r\ninstead of being passed on the commandline when we shell out to it.\r\n\r\nThe structure of this change deserves a bit of description.  Previously,\r\nwe called one function to assemble all of the information needed to\r\ninvoke subscription-manager and then returned that as a string that\r\ncould be run as a command line.  We called a second function with that\r\nstring to actually run the command.\r\n\r\nTo send the password interactively, we need to stop adding the password\r\nto the string of command line arguments but it still makes sense to keep\r\nthe code that figures out the password together with the code which\r\nfinds the other command line args.  So it makes sense to keep a single\r\nfunction to do that but return the password and other args separately.\r\n\r\nWe could use a dict, a class, or a tuple as the return value from the\r\nfunction.  That doesn't feel too ugly.  But then we need to pass that\r\nstructure into the function which takes care of invoking\r\nsubscription-manager on the command line and that *does* feel ugly.\r\nThat function would have to care about the structure of the data we pass\r\nin (If a tuple, what is the order?  If a dict, what are the field\r\nnames?, etc).  To take care of this, we can make the data structure that\r\nwe return from assembling the data a class and the function which calls\r\nsubscription-manager a method of that class because it's quite natural\r\nfor a method to have knowledge of what attributes the class contains.\r\n\r\nHmm... but now that we have a class with behaviours (methods), it starts\r\nto feel like we could do some more things.  A function that fills in the\r\nvalues of a class, validates that the data is proper, and then returns\r\nan instance of that class is really a constructor, right?  So it makes\r\nsense to move the function which assembles the data and returns the\r\nclass a constructor.  But that particular function isn't very generic:\r\nit uses knowledge of our global toolopts.tool_opts to populate the\r\nclass.  So let's write a simple __init__() that takes all of the values\r\nneeded as separate parameters and then create an alternative constructor\r\n(an @classmethod which returns an instance of the class) which gets the\r\ndata from a ToolOpt, and then calls __init__() with those values and\r\nreturns the resulting class.\r\n\r\nOkay, things are much cleaner now, but there's one more thing that we\r\ncan do.  We now have a class that has a constructor to read in data and\r\na single method that we can call to return some results.  What do we\r\ncall an object that can be called to return a result?  A function or\r\nmore generically, in python, a Callable.  We can turn this class into a\r\ncallable by renaming the method which actually invokes\r\nsubscription-manager __call__().\r\n\r\nWhat we have at the end of all this is a way to create a function which\r\nknows about the settings in tool_opts which we can then call to perform\r\nour subscription-manager needs::\r\n\r\n    registration_command = RegistrationCommand.from_tool_opts()\r\n    return_code = registration_command()\r\n\r\nOAMG-6551 #done  convert2rhel now passes the rhsm password to subscription-manager securely.\r\n\r\n* Modify the hiding of secret to hide both --password SECRET and\r\n  --password=SECRET.  Currently we only use it with passwords that we\r\n  are passing in the second form (to subscription-manager) but catching\r\n  both will future proof us in case we use this function for more things\r\n  in the future. (Eric Gustavsson)\r\n  * Note: using generator expressions was tried here but found that they\r\n    only bind the variable being iterated over at definition time, the\r\n    rest of the variables are bound when the generator is used.  This\r\n    means that constructing a set of generators in a loop doesn't really\r\n    work as the loop variables that you use in the generator will have a\r\n    different value by the time you're done.\r\n\r\n    So a nested for loop and if-else is the way to implement this.\r\n\r\n* Add global_tool_opts fixture to conftest.py which monkeypatches a\r\n  fresh ToolOpts into convert2rhel.toolopts.tool_opts.  That way tests\r\n  can modify that without worrying about polluting other tests.\r\n\r\n  * How toolopts is imported in the code makes a difference whether this\r\n    fixture is sufficient or if you need to do a little more work. If\r\n    the import is::\r\n\r\n      from convert2rhel import toolopts\r\n      do_something(toolopts.tool_opts.username)\r\n\r\n   then your test can just do::\r\n\r\n      def test_thing_that_uses_toolopts(global_tool_opts):\r\n          global_tool_opts.username = 'badger'\r\n\r\n   Most of our code, though, imports like this::\r\n\r\n      # In subscription.py, for instance\r\n      from convert2rhel.toolopts import tool_opts\r\n      do_something(tool_opts.username)\r\n\r\n   so the tests should do something like this::\r\n\r\n      def test_toolopts_differently(global_test_opts, monkeypatch):\r\n          monkeypatch.setattr(subscription, 'tool_opts', global_tool_opts)\r\n\r\n* Sometimes a process will close stdout before it is done processing.\r\n  When that happens, we need to wait() for the process to end before\r\n  closing the pty.  If we don't wait, the process will receive a HUP\r\n  signal which may end it before it is done.\r\n  * But on RHEL7, pexpect.wait() will throw an exception if you wait on\r\n    an already finished process.  So we need to ignore that exception\r\n    there.\r\n\r\nlgtm is flagging some cases where it thinks we are logging sensitive\r\ndata.  Here's why we're ignoring lgtm:\r\n\r\n* One case logs the username to the terminal as a hint for the user as\r\n  to what account is being used.  We consider username to not be\r\n  sensitive.\r\n* One case logs the subscription-manager invocation.  We run the command\r\n  line through hide_secrets() to remove private information when we do\r\n  this.\r\n* The last case logs which argument was passed to subscription-manager\r\n  without a secret attached to it.  ie: \"--password\" is passed to\r\n  subscription-manager without a password being added afterwards.  In\r\n  this case, the string \"--password\" will be logged.\r\n\r\nTesting farm doesn't have python-devel installed.\r\nWe need that to install psutil needed as a testing dependency.\r\n\r\nCo-authored-by: Daniel Diblik <ddiblik@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "subscription.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "195",
    "number_of_lines_deleted_vulnerable_to_cve": "51",
    "vulnerable_lines": [
        "// Line_Reference 112:     while True and attempt < MAX_NUM_OF_ATTEMPTS_TO_SUBSCRIBE:",
        "// Line_Reference 113:         registration_cmd = get_registration_cmd()",
        "// Line_Reference 114: ",
        "// Line_Reference 120:         output, ret_code = call_registration_cmd(registration_cmd)",
        "// Line_Reference 141: def get_registration_cmd():",
        "// Line_Reference 142:     \"\"\"Build a command for subscription-manager for registering the system.\"\"\"",
        "// Line_Reference 143:     loggerinst.info(\"Building subscription-manager command ... \")",
        "// Line_Reference 144:     registration_cmd = [\"subscription-manager\", \"register\", \"--force\"]",
        "// Line_Reference 145: ",
        "// Line_Reference 146:     loggerinst.info(\"Checking for activation key ...\")",
        "// Line_Reference 147:     if tool_opts.activation_key:",
        "// Line_Reference 148:         # Activation key has been passed",
        "// Line_Reference 149:         # -> username/password not required",
        "// Line_Reference 150:         # -> organization required",
        "// Line_Reference 151:         loggerinst.info(\"    ... activation key detected: %s\" % tool_opts.activation_key)",
        "// Line_Reference 152: ",
        "// Line_Reference 153:         # TODO: Parse the output of 'subscription-manager orgs' and let the",
        "// Line_Reference 154:         # user choose from the available organizations. If there's just one,",
        "// Line_Reference 155:         # pick it automatically.",
        "// Line_Reference 156:         # Organization is required when activation key is used",
        "// Line_Reference 158:             loggerinst.info(\"    ... org detected\")",
        "// Line_Reference 159: ",
        "// Line_Reference 160:         org = tool_opts.org",
        "// Line_Reference 161:         while not org:",
        "// Line_Reference 162:             org = utils.prompt_user(\"Organization: \")",
        "// Line_Reference 163: ",
        "// Line_Reference 164:         registration_cmd.extend((\"--activationkey=%s\" % tool_opts.activation_key, \"--org=%s\" % org))",
        "// Line_Reference 165:     else:",
        "// Line_Reference 166:         loggerinst.info(\"    ... activation key not found, username and password required\")",
        "// Line_Reference 168:         if tool_opts.username:",
        "// Line_Reference 169:             loggerinst.info(\"    ... username detected\")",
        "// Line_Reference 171:         username = tool_opts.username",
        "// Line_Reference 172:         while not username:",
        "// Line_Reference 173:             username = utils.prompt_user(\"Username: \")",
        "// Line_Reference 175:         if tool_opts.password:",
        "// Line_Reference 176:             loggerinst.info(\"    ... password detected\")",
        "// Line_Reference 178:         password = tool_opts.password",
        "// Line_Reference 179:         while not password:",
        "// Line_Reference 180:             password = utils.prompt_user(\"Password: \", password=True)",
        "// Line_Reference 182:         registration_cmd.extend((\"--username=%s\" % username, \"--password=%s\" % password))",
        "// Line_Reference 184:     if tool_opts.serverurl:",
        "// Line_Reference 185:         loggerinst.debug(\"    ... using custom RHSM URL\")",
        "// Line_Reference 186:         registration_cmd.append(\"--serverurl=%s\" % tool_opts.serverurl)",
        "// Line_Reference 188:     return registration_cmd",
        "// Line_Reference 191: def call_registration_cmd(registration_cmd):",
        "// Line_Reference 192:     \"\"\"Wrapper for run_subprocess that avoids leaking password in the log.\"\"\"",
        "// Line_Reference 193:     loggerinst.debug(\"Calling command '%s'\" % hide_password(\" \".join(registration_cmd)))",
        "// Line_Reference 194:     return utils.run_subprocess(registration_cmd, print_cmd=False)",
        "// Line_Reference 197: def hide_password(cmd):",
        "// Line_Reference 198:     \"\"\"Replace plaintext password with asterisks.\"\"\"",
        "// Line_Reference 199:     return re.sub('--password=\".*?\"', '--password=\"*****\"', cmd)"
    ]
}
