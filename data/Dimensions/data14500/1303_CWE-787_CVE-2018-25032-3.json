{
    "cve_id": "CVE-2018-25032",
    "cve_description": "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
    "cve_publish_date": "2022-03-25",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Fix a bug that can crash deflate on some input when using Z_FIXED.\n\nThis bug was reported by Danilo Ramos of Eideticom, Inc. It has\nlain in wait 13 years before being found! The bug was introduced\nin zlib 1.2.2.2, with the addition of the Z_FIXED option. That\noption forces the use of fixed Huffman codes. For rare inputs with\na large number of distant matches, the pending buffer into which\nthe compressed data is written can overwrite the distance symbol\ntable which it overlays. That results in corrupted output due to\ninvalid distances, and can result in out-of-bound accesses,\ncrashing the application.\n\nThe fix here combines the distance buffer and literal/length\nbuffers into a single symbol buffer. Now three bytes of pending\nbuffer space are opened up for each literal or length/distance\npair consumed, instead of the previous two bytes. This assures\nthat the pending buffer cannot overwrite the symbol table, since\nthe maximum fixed code compressed length/distance is 31 bits, and\nsince there are four bytes of pending space for every three bytes\nof symbol space.",
    "type_of_change": "Modification",
    "filename_of_changes": "trees.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "14",
    "number_of_lines_deleted_vulnerable_to_cve": "36",
    "vulnerable_lines": [
        "// Line_Reference 419:     s->last_lit = s->matches = 0;",
        "// Line_Reference 951:                 s->last_lit));",
        "// Line_Reference 1020:     s->d_buf[s->last_lit] = (ush)dist;",
        "// Line_Reference 1021:     s->l_buf[s->last_lit++] = (uch)lc;",
        "// Line_Reference 1036: ",
        "// Line_Reference 1037: #ifdef TRUNCATE_BLOCK",
        "// Line_Reference 1038:     /* Try to guess if it is profitable to stop the current block here */",
        "// Line_Reference 1039:     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {",
        "// Line_Reference 1040:         /* Compute an upper bound for the compressed length */",
        "// Line_Reference 1041:         ulg out_length = (ulg)s->last_lit*8L;",
        "// Line_Reference 1042:         ulg in_length = (ulg)((long)s->strstart - s->block_start);",
        "// Line_Reference 1043:         int dcode;",
        "// Line_Reference 1044:         for (dcode = 0; dcode < D_CODES; dcode++) {",
        "// Line_Reference 1045:             out_length += (ulg)s->dyn_dtree[dcode].Freq *",
        "// Line_Reference 1046:                 (5L+extra_dbits[dcode]);",
        "// Line_Reference 1047:         }",
        "// Line_Reference 1048:         out_length >>= 3;",
        "// Line_Reference 1049:         Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",",
        "// Line_Reference 1050:                s->last_lit, in_length, out_length,",
        "// Line_Reference 1051:                100L - out_length*100L/in_length));",
        "// Line_Reference 1052:         if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;",
        "// Line_Reference 1053:     }",
        "// Line_Reference 1054: #endif",
        "// Line_Reference 1055:     return (s->last_lit == s->lit_bufsize-1);",
        "// Line_Reference 1056:     /* We avoid equality with lit_bufsize because of wraparound at 64K",
        "// Line_Reference 1057:      * on 16 bit machines and because stored blocks are restricted to",
        "// Line_Reference 1058:      * 64K-1 bytes.",
        "// Line_Reference 1059:      */",
        "// Line_Reference 1072:     unsigned lx = 0;    /* running index in l_buf */",
        "// Line_Reference 1076:     if (s->last_lit != 0) do {",
        "// Line_Reference 1077:         dist = s->d_buf[lx];",
        "// Line_Reference 1078:         lc = s->l_buf[lx++];",
        "// Line_Reference 1103:         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */",
        "// Line_Reference 1104:         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,",
        "// Line_Reference 1105:                \"pendingBuf overflow\");",
        "// Line_Reference 1107:     } while (lx < s->last_lit);"
    ]
}
