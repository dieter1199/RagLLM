/**
*
* @file
* @ingroup Extensions
* @link http://www.mediawiki.org/wiki/Extension:DynamicPageList3 Documentation
* @author n:en:User:IlyaHaykinson
* @author n:en:User:Amgine
* @author w:de:Benutzer:Unendlich
* @author m:User:Dangerman <cyril.dangerville@gmail.com>
* @author m:User:Algorithmix <gero.scholz@gmx.de>
* @license GPL-2.0-or-later
*
*/
class DynamicPageListHooks {
// FATAL
const FATAL_WRONGNS = 1001;	// $1: 'namespace' or 'notnamespace'
// $2: wrong parameter given by user
// $3: list of possible titles of namespaces (except pseudo-namespaces: Media, Special)
const FATAL_WRONGLINKSTO = 1002;	// $1: linksto'
// $2: the wrong parameter given by user
const FATAL_TOOMANYCATS = 1003;	// $1: max number of categories that can be included
const FATAL_TOOFEWCATS = 1004;	// $1: min number of categories that have to be included
const FATAL_NOSELECTION = 1005;
const FATAL_CATDATEBUTNOINCLUDEDCATS = 1006;
const FATAL_CATDATEBUTMORETHAN1CAT = 1007;
const FATAL_MORETHAN1TYPEOFDATE = 1008;
const FATAL_WRONGORDERMETHOD = 1009;	// $1: param=val that is possible only with $1 as last 'ordermethod' parameter
// $2: last 'ordermethod' parameter required for $0
const FATAL_DOMINANTSECTIONRANGE = 1010;	// $1: the number of arguments in includepage
const FATAL_OPENREFERENCES = 1012;
const FATAL_MISSINGPARAMFUNCTION = 1022;
const FATAL_NOTPROTECTED = 1023;
const FATAL_SQLBUILDERROR = 1024;
// ERROR
// WARN
const WARN_UNKNOWNPARAM = 2013;	// $1: unknown parameter given by user
// $2: list of DPL available parameters separated by ', '
const WARN_PARAMNOOPTION = 2022;	// $1: Parameter given by user
const WARN_WRONGPARAM = 2014;	// $3: list of valid param values separated by ' | '
const WARN_WRONGPARAM_INT = 2015;	// $1: param name
// $2: wrong param value given by user
// $3: default param value used instead by program
const WARN_NORESULTS = 2016;
const WARN_CATOUTPUTBUTWRONGPARAMS = 2017;
const WARN_HEADINGBUTSIMPLEORDERMETHOD = 2018;	// $1: 'headingmode' value given by user
// $2: value used instead by program (which means no heading)
const WARN_DEBUGPARAMNOTFIRST = 2019;	// $1: 'log' value
const WARN_TRANSCLUSIONLOOP = 2020;	// $1: title of page that creates an infinite transclusion loop
// INFO
// DEBUG
const DEBUG_QUERY = 3021;	// $1: SQL query executed to generate the dynamic page list
// TRACE
// Output formatting
// $1: number of articles
public static $createdLinks; // the links created by DPL are collected here;
// they can be removed during the final ouput
// phase of the MediaWiki parser
/**
* DPL acting like Extension:Intersection
*
* @var bool
*/
/**
* Debugging Level
*
* @var int
*/
* Handle special on extension registration bits.
*
* @return void
public static function onRegistration() {
if ( !defined( 'DPL_VERSION' ) ) {
define( 'DPL_VERSION', '3.3.5' );
* @param object Parser object passed as a reference.
* @return bool	true
public static function onParserFirstCallInit( Parser &$parser ) {
//DPL offers the same functionality as Intersection.  So we register the <DynamicPageList> tag in case LabeledSection Extension is not installed so that the section markers are removed.
if ( \DPL\Config::getSetting( 'handleSectionTag' ) ) {
return true;
* @param object Parser object passed as a reference.
* @returnbool true
public static function setupMigration( Parser &$parser ) {
return true;
*
* @private
* @return void
\DPL\Config::init();
* @private
* @param bool	Behave Like Intersection
* @return void
* @return bool	Behaving Like Intersection
* @param string Raw User Input
* @param array Arguments on the tag.
* @param object Parser object.
* @param object PPFrame object.
* @return string HTML
* @param string Raw User Input
* @param array Arguments on the tag.
* @param object Parser object.
* @param object PPFrame object.
* @return string HTML
* @param string Raw User Input
* @param array Arguments on the tag.(While not used, it is left here for future compatibility.)
* @param object Parser object.
* @param object PPFrame object.
* @return string HTML
// entry point for user tag <dpl>  or  <DynamicPageList>
$parse = new \DPL\Parse();
if ( \DPL\Config::getSetting( 'recursiveTagParse' ) ) {
if ( isset( $reset['templates'] ) && $reset['templates'] ) {	// we can remove the templates by save/restore
if ( isset( $reset['categories'] ) && $reset['categories'] ) {	// we can remove the categories by save/restore
if ( isset( $reset['images'] ) && $reset['images'] ) {	// we can remove the images by save/restore
if ( isset( $reset['templates'] ) && $reset['templates'] ) {
$parser->getOutput()->mTemplates = $saveTemplates;
if ( isset( $reset['categories'] ) && $reset['categories'] ) {
$parser->getOutput()->mCategories = $saveCategories;
if ( isset( $reset['images'] ) && $reset['images'] ) {
$parser->getOutput()->mImages = $saveImages;
* @param object Parser object passed as a reference.
* @return string Wiki Text
public static function dplParserFunction( &$parser ) {
// callback for the parser function {{#dpl:	  or   {{DynamicPageList::
$parse = new \DPL\Parse();
return [ // parser needs to be coaxed to do further recursive processing
$parser->getPreprocessor()->preprocessToObj( $dplresult, Parser::PTD_FOR_INCLUSION ),
* From the old documentation: "Tries to guess a number that is buried in the text.  Uses a set of heuristic rules which may work or not.  The idea is to extract the number so that it can be used as a sorting value in the column of a DPL table output."
* @param object Parser object passed as a reference.
* @return string Wiki Text
public static function dplNumParserFunction( &$parser, $text = '' ) {
return \DPL\Variables::setVar( $args );
return \DPL\Variables::setVarDefault( $args );
return \DPL\Variables::getVar( $cmd );
# convert \n to a real newline character
$output = \DPL\LST::extractHeadingFromText( $parser, $page, '?title?', $text, $heading, '', $sectionHeading, true, $maxLength, $link, $trim );
$lines   = explode( "\n", $matrix );
$m       = [];
$from    = '';
$to      = '';
if ( $flip == '' | $flip == 'normal' ) {
// if (!preg_match("/Query Q/",$parser->mTitle->getText())) return '';
* @access	public
* @param	integer	Debug Level
* @return	void
* @access	public
* @return	void
// reset everything; some categories may have been fixed, however via  fixcategory=
public static function endReset( &$parser, $text ) {
// $text .= self::dumpParsedRefs($parser,"before final reset");
// $text .= self::dumpParsedRefs( $parser, 'after final reset' );
return true;
public static function endEliminate( &$parser, &$text ) {
// self::dumpParsedRefs($parser,"before final eliminate");
// echo ("<pre> elim: created Links [$nsp] = ". count(DynamicPageListHooks::$createdLinks[0][$nsp])."</pre>\n");
// echo ("<pre> elim: parser  Links [$nsp] = ". count($parser->getOutput()->mLinks[$nsp])			 ."</pre>\n");
// echo ("<pre> elim: parser  Links [$nsp] nachher = ". count($parser->getOutput()->mLinks[$nsp])	  ."</pre>\n");
// echo ("<pre> elim: created Tpls [$nsp] = ". count(DynamicPageListHooks::$createdLinks[1][$nsp])."</pre>\n");
// echo ("<pre> elim: parser  Tpls [$nsp] = ". count($parser->getOutput()->mTemplates[$nsp])			."</pre>\n");
// echo ("<pre> elim: parser  Tpls [$nsp] nachher = ". count($parser->getOutput()->mTemplates[$nsp])	 ."</pre>\n");
// $text .= self::dumpParsedRefs($parser,"after final eliminate".$parser->mTitle->getText());
/* self::$createdLinks = [
'resetLinks'=> false, 'resetTemplates' => false,
'resetCategories' => false, 'resetImages' => false, 'resetdone' => false
]; */
return true;
