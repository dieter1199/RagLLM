{
    "cve_id": "CVE-2020-12141",
    "cve_description": "An out-of-bounds read in the SNMP stack in Contiki-NG 4.4 and earlier allows an attacker to cause a denial of service and potentially disclose information via crafted SNMP packets to snmp_ber_decode_string_len_buffer in os/net/app-layer/snmp/snmp-ber.c.",
    "cve_publish_date": "2021-10-19",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Refactored SNMP engine after vulnerabilities",
    "type_of_change": "Modification",
    "filename_of_changes": "snmp-engine.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "94",
    "number_of_lines_deleted_vulnerable_to_cve": "80",
    "vulnerable_lines": [
        "// Line_Reference 2:  * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>",
        "// Line_Reference 35:  *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)",
        "// Line_Reference 45: #include \"snmp-oid.h\"",
        "// Line_Reference 51: int",
        "// Line_Reference 52: snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)",
        "// Line_Reference 55:   uint32_t i;",
        "// Line_Reference 57:   for(i = 0; i < varbinds_length; i++) {",
        "// Line_Reference 58:     resource = snmp_mib_find(varbinds[i].oid);",
        "// Line_Reference 62:         header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 66:         header->error_index_max_repetitions.error_index = i + 1;",
        "// Line_Reference 69:         (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;",
        "// Line_Reference 72:         header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 73:         header->error_index_max_repetitions.error_index = 0;",
        "// Line_Reference 76:       resource->handler(&varbinds[i], resource->oid);",
        "// Line_Reference 83: int",
        "// Line_Reference 84: snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)",
        "// Line_Reference 87:   uint32_t i;",
        "// Line_Reference 89:   for(i = 0; i < varbinds_length; i++) {",
        "// Line_Reference 90:     resource = snmp_mib_find_next(varbinds[i].oid);",
        "// Line_Reference 94:         header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 98:         header->error_index_max_repetitions.error_index = i + 1;",
        "// Line_Reference 101:         (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;",
        "// Line_Reference 104:         header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 105:         header->error_index_max_repetitions.error_index = 0;",
        "// Line_Reference 108:       resource->handler(&varbinds[i], resource->oid);",
        "// Line_Reference 115: int",
        "// Line_Reference 116: snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *varbinds_length)",
        "// Line_Reference 119:   uint32_t i, j, original_varbinds_length;",
        "// Line_Reference 120:   uint32_t oid[SNMP_MAX_NR_VALUES][SNMP_MSG_OID_MAX_LEN];",
        "// Line_Reference 127:   original_varbinds_length = *varbinds_length;",
        "// Line_Reference 128:   for(i = 0; i < original_varbinds_length; i++) {",
        "// Line_Reference 129:     snmp_oid_copy(oid[i], varbinds[i].oid);",
        "// Line_Reference 132:   *varbinds_length = 0;",
        "// Line_Reference 134:     if(i >= header->error_status_non_repeaters.non_repeaters) {",
        "// Line_Reference 138:     resource = snmp_mib_find_next(oid[i]);",
        "// Line_Reference 142:         header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 146:         header->error_index_max_repetitions.error_index = i + 1;",
        "// Line_Reference 149:         (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;",
        "// Line_Reference 152:         header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 153:         header->error_index_max_repetitions.error_index = 0;",
        "// Line_Reference 156:       if(*varbinds_length < SNMP_MAX_NR_VALUES) {",
        "// Line_Reference 157:         resource->handler(&varbinds[*varbinds_length], resource->oid);",
        "// Line_Reference 158:         (*varbinds_length)++;",
        "// Line_Reference 163:   for(i = 0; i < header->error_index_max_repetitions.max_repetitions; i++) {",
        "// Line_Reference 165:     for(j = header->error_status_non_repeaters.non_repeaters; j < original_varbinds_length; j++) {",
        "// Line_Reference 166:       resource = snmp_mib_find_next(oid[j]);",
        "// Line_Reference 170:           header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 174:           header->error_index_max_repetitions.error_index = *varbinds_length + 1;",
        "// Line_Reference 177:           if(*varbinds_length < SNMP_MAX_NR_VALUES) {",
        "// Line_Reference 178:             (&varbinds[*varbinds_length])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;",
        "// Line_Reference 179:             snmp_oid_copy((&varbinds[*varbinds_length])->oid, oid[j]);",
        "// Line_Reference 180:             (*varbinds_length)++;",
        "// Line_Reference 184:           header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;",
        "// Line_Reference 185:           header->error_index_max_repetitions.error_index = 0;",
        "// Line_Reference 188:         if(*varbinds_length < SNMP_MAX_NR_VALUES) {",
        "// Line_Reference 189:           resource->handler(&varbinds[*varbinds_length], resource->oid);",
        "// Line_Reference 190:           (*varbinds_length)++;",
        "// Line_Reference 191:           snmp_oid_copy(oid[j], resource->oid);",
        "// Line_Reference 204: unsigned char *",
        "// Line_Reference 205: snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)",
        "// Line_Reference 207:   static snmp_header_t header;",
        "// Line_Reference 208:   static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];",
        "// Line_Reference 209:   static uint32_t varbind_length = SNMP_MAX_NR_VALUES;",
        "// Line_Reference 211:   buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);",
        "// Line_Reference 212:   if(buff == NULL) {",
        "// Line_Reference 213:     return NULL;",
        "// Line_Reference 219:       return NULL;",
        "// Line_Reference 227:   case SNMP_DATA_TYPE_PDU_GET_REQUEST:",
        "// Line_Reference 228:     if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {",
        "// Line_Reference 229:       return NULL;",
        "// Line_Reference 233:   case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:",
        "// Line_Reference 234:     if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {",
        "// Line_Reference 235:       return NULL;",
        "// Line_Reference 239:   case SNMP_DATA_TYPE_PDU_GET_BULK:",
        "// Line_Reference 240:     if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {",
        "// Line_Reference 241:       return NULL;",
        "// Line_Reference 247:     return NULL;",
        "// Line_Reference 250:   header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;",
        "// Line_Reference 251:   out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);",
        "// Line_Reference 253:   return ++out;"
    ]
}
