{
    "cve_id": "CVE-2021-32701",
    "cve_description": "ORY Oathkeeper is an Identity & Access Proxy (IAP) and Access Control Decision API that authorizes HTTP requests based on sets of Access Rules. When you make a request to an endpoint that requires the scope `foo` using an access token granted with that `foo` scope, introspection will be valid and that token will be cached. The problem comes when a second requests to an endpoint that requires the scope `bar` is made before the cache has expired. Whether the token is granted or not to the `bar` scope, introspection will be valid. A patch will be released with `v0.38.12-beta.1`. Per default, caching is disabled for the `oauth2_introspection` authenticator. When caching is disabled, this vulnerability does not exist. The cache is checked in [`func (a *AuthenticatorOAuth2Introspection) Authenticate(...)`](https://github.com/ory/oathkeeper/blob/6a31df1c3779425e05db1c2a381166b087cb29a4/pipeline/authn/authenticator_oauth2_introspection.go#L152). From [`tokenFromCache()`](https://github.com/ory/oathkeeper/blob/6a31df1c3779425e05db1c2a381166b087cb29a4/pipeline/authn/authenticator_oauth2_introspection.go#L97) it seems that it only validates the token expiration date, but ignores whether the token has or not the proper scopes. The vulnerability was introduced in PR #424. During review, we failed to require appropriate test coverage by the submitter which is the primary reason that the vulnerability passed the review process.",
    "cve_publish_date": "2021-06-22",
    "cwe_id": "CWE-863",
    "cwe_name": "Incorrect Authorization",
    "cwe_description": "The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",
    "commit_message": "Merge pull request from GHSA-qvp4-rpmr-xwrr\n\nThis patch addresses a security vulnerability which would bypass token claim validation once a token is in the cache.\n\nFor more information please refer to https://github.com/ory/oathkeeper/security/advisories/GHSA-qvp4-rpmr-xwrr",
    "type_of_change": "Modification",
    "filename_of_changes": "authenticator_oauth2_introspection.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "68",
    "number_of_lines_deleted_vulnerable_to_cve": "46",
    "vulnerable_lines": [
        "// Line_Reference 97: func (a *AuthenticatorOAuth2Introspection) tokenFromCache(config *AuthenticatorOAuth2IntrospectionConfiguration, token string) (*AuthenticatorOAuth2IntrospectionResult, bool) {",
        "// Line_Reference 99: \t\treturn nil, false",
        "// Line_Reference 104: \t\treturn nil, false",
        "// Line_Reference 107: \ti := item.(*AuthenticatorOAuth2IntrospectionResult)",
        "// Line_Reference 108: \texpires := time.Unix(i.Expires, 0)",
        "// Line_Reference 109: \tif expires.Before(time.Now()) {",
        "// Line_Reference 110: \t\ta.tokenCache.Del(token)",
        "// Line_Reference 111: \t\treturn nil, false",
        "// Line_Reference 114: \treturn i, true",
        "// Line_Reference 117: func (a *AuthenticatorOAuth2Introspection) tokenToCache(config *AuthenticatorOAuth2IntrospectionConfiguration, i *AuthenticatorOAuth2IntrospectionResult, token string) {",
        "// Line_Reference 148: \ttracer.Inject(clientSpan.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))",
        "// Line_Reference 163: \tss := a.c.ToScopeStrategy(cf.ScopeStrategy, \"authenticators.oauth2_introspection.scope_strategy\")",
        "// Line_Reference 165: \ti, ok := a.tokenFromCache(cf, token)",
        "// Line_Reference 166: \tif !ok {",
        "// Line_Reference 167: \t\tbody := url.Values{\"token\": {token}}",
        "// Line_Reference 203: \t\tif len(i.TokenUse) > 0 && i.TokenUse != \"access_token\" {",
        "// Line_Reference 204: \t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Use of introspected token is not an access token but \\\"%s\\\"\", i.TokenUse)))",
        "// Line_Reference 205: \t\t}",
        "// Line_Reference 207: \t\tif !i.Active {",
        "// Line_Reference 208: \t\t\treturn errors.WithStack(helper.ErrUnauthorized.WithReason(\"Access token i says token is not active\"))",
        "// Line_Reference 209: \t\t}",
        "// Line_Reference 211: \t\tfor _, audience := range cf.Audience {",
        "// Line_Reference 212: \t\t\tif !stringslice.Has(i.Audience, audience) {",
        "// Line_Reference 213: \t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token audience is not intended for target audience %s\", audience)))",
        "// Line_Reference 214: \t\t\t}",
        "// Line_Reference 217: \t\tif len(cf.Issuers) > 0 {",
        "// Line_Reference 218: \t\t\tif !stringslice.Has(cf.Issuers, i.Issuer) {",
        "// Line_Reference 219: \t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token issuer does not match any trusted issuer\")))",
        "// Line_Reference 220: \t\t\t}",
        "// Line_Reference 223: \t\tif ss != nil {",
        "// Line_Reference 224: \t\t\tfor _, scope := range cf.Scopes {",
        "// Line_Reference 225: \t\t\t\tif !ss(strings.Split(i.Scope, \" \"), scope) {",
        "// Line_Reference 226: \t\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Scope %s was not granted\", scope)))",
        "// Line_Reference 227: \t\t\t\t}",
        "// Line_Reference 231: \t\tif len(i.Extra) == 0 {",
        "// Line_Reference 232: \t\t\ti.Extra = map[string]interface{}{}",
        "// Line_Reference 233: \t\t}",
        "// Line_Reference 235: \t\ti.Extra[\"username\"] = i.Username",
        "// Line_Reference 236: \t\ti.Extra[\"client_id\"] = i.ClientID",
        "// Line_Reference 237: \t\ti.Extra[\"scope\"] = i.Scope",
        "// Line_Reference 239: \t\tif len(i.Audience) != 0 {",
        "// Line_Reference 240: \t\t\ti.Extra[\"aud\"] = i.Audience",
        "// Line_Reference 241: \t\t}",
        "// Line_Reference 243: \t\ta.tokenToCache(cf, i, token)",
        "// Line_Reference 328: \t\tcache, _ := ristretto.NewCache(&ristretto.Config{",
        "// Line_Reference 332: \t\t\tMaxCost: int64(c.Cache.MaxCost),"
    ]
}
