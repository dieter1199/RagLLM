pub struct NoFragmentCycles<'a> {
current_fragment: Option<&'a str>,
spreads: HashMap<&'a str, Vec<Spanning<&'a str>>>,
fragment_order: Vec<&'a str>,
}
struct CycleDetector<'a> {
visited: HashSet<&'a str>,
spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,
path_indices: HashMap<&'a str, usize>,
errors: Vec<RuleError>,
}
path_indices: HashMap::new(),
let mut path = Vec::new();
detector.detect_from(frag, &mut path);
fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {
return;
self.path_indices.insert(from, path.len());
let name = &node.item;
let index = self.path_indices.get(name).cloned();
} else if !self.visited.contains(name) {
self.detect_from(name, path);
path.pop();
self.path_indices.remove(from);
