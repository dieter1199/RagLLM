int size;
BOOL capture_last_found = FALSE;
if (common->capture_last_ptr != 0)
capture_last_found = TRUE;
if (PRIVATE_DATA(cc) != 0)
length++;
length++;
length += 2;
if (common->capture_last_ptr != 0)
capture_last_found = TRUE;
if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)
length += 2 + 2;
if (common->capture_last_ptr != 0)
capture_last_found = TRUE;
if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)
if (PRIVATE_DATA(cc) != 0)
if (PRIVATE_DATA(cc) != 0)
if (PRIVATE_DATA(cc) != 0)
if (PRIVATE_DATA(cc) != 0)
if (PRIVATE_DATA(cc) != 0)
if (PRIVATE_DATA(cc) != 0)
if (PRIVATE_DATA(cc) != 0)
if (!control_head_found)
control_head_found = TRUE;
if (capture_last_found)
length++;
BOOL setsom_found = FALSE;
BOOL setmark_found = FALSE;
BOOL capture_last_found = FALSE;
BOOL control_head_found = FALSE;
control_head_found = TRUE;
if (has_quit && !setsom_found)
setsom_found = TRUE;
if (common->has_set_som && !setsom_found)
setsom_found = TRUE;
if (common->mark_ptr != 0 && !setmark_found)
setmark_found = TRUE;
if (common->capture_last_ptr != 0 && !capture_last_found)
capture_last_found = TRUE;
if (PRIVATE_DATA(cc) != 0)
private_count = 1;
private_srcw[0] = PRIVATE_DATA(cc);
private_count = 1;
offset = (GET2(cc, 1 + LINK_SIZE)) << 1;
shared_srcw[0] = OVECTOR(offset);
shared_srcw[1] = OVECTOR(offset + 1);
shared_count = 2;
if (common->capture_last_ptr != 0 && !capture_last_found)
shared_srcw[2] = common->capture_last_ptr;
shared_count = 3;
capture_last_found = TRUE;
if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)
private_count = 1;
private_srcw[0] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));
offset = (GET2(cc, 1 + LINK_SIZE)) << 1;
shared_srcw[0] = OVECTOR(offset);
shared_srcw[1] = OVECTOR(offset + 1);
shared_count = 2;
if (common->capture_last_ptr != 0 && !capture_last_found)
shared_srcw[2] = common->capture_last_ptr;
shared_count = 3;
capture_last_found = TRUE;
private_count = 2;
private_srcw[1] = OVECTOR_PRIV(GET2(cc, 1 + LINK_SIZE));
private_count = 1;
if (PRIVATE_DATA(cc))
{
private_srcw[0] = PRIVATE_DATA(cc);
}
if (PRIVATE_DATA(cc))
private_srcw[0] = PRIVATE_DATA(cc);
private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);
if (PRIVATE_DATA(cc))
private_srcw[0] = PRIVATE_DATA(cc);
private_srcw[1] = PRIVATE_DATA(cc) + sizeof(sljit_sw);
if (PRIVATE_DATA(cc))
{
private_srcw[0] = PRIVATE_DATA(cc);
}
if (PRIVATE_DATA(cc))
private_srcw[0] = PRIVATE_DATA(cc);
if (PRIVATE_DATA(cc))
private_srcw[0] = PRIVATE_DATA(cc);
private_count = 1;
private_count = 2;
private_srcw[1] = private_srcw[0] + sizeof(sljit_sw);
if (has_quit && !setmark_found)
setmark_found = TRUE;
if (common->control_head_ptr != 0 && !control_head_found)
control_head_found = TRUE;
if (!control_head_found)
control_head_found = TRUE;
break;
common->private_data_ptrs = (sljit_s32 *)SLJIT_MALLOC(total_length * (sizeof(sljit_s32) + (common->has_then ? 1 : 0)), allocator_data);
while (common->currententry != NULL)
/* Might add new entries. */
compile_recurse(common);
if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler)))
flush_stubs(common);
common->currententry = common->currententry->next;