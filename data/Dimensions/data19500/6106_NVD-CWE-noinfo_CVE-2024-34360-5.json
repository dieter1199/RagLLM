{
    "cve_id": "CVE-2024-34360",
    "cve_description": "go-spacemesh is a Go implementation of the Spacemesh protocol full node. Nodes can publish activations transactions (ATXs) which reference the incorrect previous ATX of the Smesher that created the ATX. ATXs are expected to form a single chain from the newest to the first ATX ever published by an identity. Allowing Smeshers to reference an earlier (but not the latest) ATX as previous breaks this protocol rule and can serve as an attack vector where Nodes are rewarded for holding their PoST data for less than one epoch but still being eligible for rewards. This vulnerability is fixed in go-spacemesh 1.5.2-hotfix1 and Spacemesh API 1.37.1.",
    "cve_publish_date": "2024-05-14",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Verify that previous ATX points to correct ATX when handling incoming ATXs (#27)\n\n---------\n\nCo-authored-by: Bartosz Różański <bartek.roza@gmail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "handler.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "170",
    "number_of_lines_deleted_vulnerable_to_cve": "65",
    "vulnerable_lines": [
        "// Line_Reference 216: \tvar (",
        "// Line_Reference 217: \t\tcommitmentATX *types.ATXID",
        "// Line_Reference 218: \t\terr           error",
        "// Line_Reference 219: \t)",
        "// Line_Reference 224: \t\tcommitmentATX = atx.CommitmentATX",
        "// Line_Reference 406: // storeAtx stores an ATX and notifies subscribers of the ATXID.",
        "// Line_Reference 407: func (h *Handler) storeAtx(ctx context.Context, atx *types.VerifiedActivationTx) (*mwire.MalfeasanceProof, error) {",
        "// Line_Reference 408: \tvar nonce *types.VRFPostIndex",
        "// Line_Reference 409: \tmalicious, err := h.cdb.IsMalicious(atx.SmesherID)",
        "// Line_Reference 411: \t\treturn nil, fmt.Errorf(\"checking if node is malicious: %w\", err)",
        "// Line_Reference 413: \tvar proof *mwire.MalfeasanceProof",
        "// Line_Reference 414: \tif err := h.cdb.WithTx(ctx, func(tx *sql.Tx) error {",
        "// Line_Reference 415: \t\tif malicious {",
        "// Line_Reference 416: \t\t\tif err := atxs.Add(tx, atx); err != nil && !errors.Is(err, sql.ErrObjectExists) {",
        "// Line_Reference 417: \t\t\t\treturn fmt.Errorf(\"add atx to db: %w\", err)",
        "// Line_Reference 418: \t\t\t}",
        "// Line_Reference 419: \t\t\treturn nil",
        "// Line_Reference 422: \t\tprev, err := atxs.GetByEpochAndNodeID(tx, atx.PublishEpoch, atx.SmesherID)",
        "// Line_Reference 423: \t\tif err != nil && !errors.Is(err, sql.ErrNotFound) {",
        "// Line_Reference 424: \t\t\treturn err",
        "// Line_Reference 427: \t\t// do ID check to be absolutely sure.",
        "// Line_Reference 428: \t\tif prev != nil && prev.ID() != atx.ID() {",
        "// Line_Reference 429: \t\t\tif _, ok := h.signers[atx.SmesherID]; ok {",
        "// Line_Reference 430: \t\t\t\t// if we land here we tried to publish 2 ATXs in the same epoch",
        "// Line_Reference 431: \t\t\t\t// don't punish ourselves but fail validation and thereby the handling of the incoming ATX",
        "// Line_Reference 432: \t\t\t\treturn fmt.Errorf(\"%s already published an ATX in epoch %d\", atx.SmesherID.ShortString(),",
        "// Line_Reference 433: \t\t\t\t\tatx.PublishEpoch,",
        "// Line_Reference 434: \t\t\t\t)",
        "// Line_Reference 435: \t\t\t}",
        "// Line_Reference 436: ",
        "// Line_Reference 437: \t\t\tvar atxProof mwire.AtxProof",
        "// Line_Reference 438: \t\t\tfor i, a := range []*types.VerifiedActivationTx{prev, atx} {",
        "// Line_Reference 439: \t\t\t\tatxProof.Messages[i] = mwire.AtxProofMsg{",
        "// Line_Reference 440: \t\t\t\t\tInnerMsg: types.ATXMetadata{",
        "// Line_Reference 441: \t\t\t\t\t\tPublishEpoch: a.PublishEpoch,",
        "// Line_Reference 442: \t\t\t\t\t\tMsgHash:      wire.ActivationTxToWireV1(a.ActivationTx).HashInnerBytes(),",
        "// Line_Reference 443: \t\t\t\t\t},",
        "// Line_Reference 444: \t\t\t\t\tSmesherID: a.SmesherID,",
        "// Line_Reference 445: \t\t\t\t\tSignature: a.Signature,",
        "// Line_Reference 446: \t\t\t\t}",
        "// Line_Reference 447: \t\t\t}",
        "// Line_Reference 448: \t\t\tproof = &mwire.MalfeasanceProof{",
        "// Line_Reference 449: \t\t\t\tLayer: atx.PublishEpoch.FirstLayer(),",
        "// Line_Reference 450: \t\t\t\tProof: mwire.Proof{",
        "// Line_Reference 451: \t\t\t\t\tType: mwire.MultipleATXs,",
        "// Line_Reference 452: \t\t\t\t\tData: &atxProof,",
        "// Line_Reference 453: \t\t\t\t},",
        "// Line_Reference 454: \t\t\t}",
        "// Line_Reference 455: \t\t\tencoded, err := codec.Encode(proof)",
        "// Line_Reference 456: \t\t\tif err != nil {",
        "// Line_Reference 457: \t\t\t\th.log.With().Panic(\"failed to encode malfeasance proof\", log.Err(err))",
        "// Line_Reference 458: \t\t\t}",
        "// Line_Reference 459: \t\t\tif err := identities.SetMalicious(tx, atx.SmesherID, encoded, time.Now()); err != nil {",
        "// Line_Reference 460: \t\t\t\treturn fmt.Errorf(\"add malfeasance proof: %w\", err)",
        "// Line_Reference 461: \t\t\t}",
        "// Line_Reference 462: ",
        "// Line_Reference 463: \t\t\th.log.WithContext(ctx).With().Warning(\"smesher produced more than one atx in the same epoch\",",
        "// Line_Reference 464: \t\t\t\tlog.Stringer(\"smesher\", atx.SmesherID),",
        "// Line_Reference 465: \t\t\t\tlog.Object(\"prev\", prev),",
        "// Line_Reference 466: \t\t\t\tlog.Object(\"curr\", atx),",
        "// Line_Reference 467: \t\t\t)",
        "// Line_Reference 475: \t}); err != nil {",
        "// Line_Reference 515: \tproof, err := h.handleAtx(ctx, types.Hash32{}, peer, msg)",
        "// Line_Reference 624: \tif expHash != (types.Hash32{}) && vAtx.ID().Hash32() != expHash {",
        "// Line_Reference 640: \t\tlog.Bool(\"malicious\", proof != nil))"
    ]
}
