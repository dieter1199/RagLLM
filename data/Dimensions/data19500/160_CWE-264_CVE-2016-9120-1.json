{
    "cve_id": "CVE-2016-9120",
    "cve_description": "Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.",
    "cve_publish_date": "2016-12-08",
    "cwe_id": "CWE-264",
    "cwe_name": "Permissions, Privileges, and Access Controls",
    "cwe_description": "Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",
    "commit_message": "staging/android/ion : fix a race condition in the ion driver\n\nThere is a use-after-free problem in the ion driver.\nThis is caused by a race condition in the ion_ioctl()\nfunction.\n\nA handle has ref count of 1 and two tasks on different\ncpus calls ION_IOC_FREE simultaneously.\n\ncpu 0                                   cpu 1\n-------------------------------------------------------\nion_handle_get_by_id()\n(ref == 2)\n                            ion_handle_get_by_id()\n                            (ref == 3)\n\nion_free()\n(ref == 2)\n\nion_handle_put()\n(ref == 1)\n\n                            ion_free()\n                            (ref == 0 so ion_handle_destroy() is\n                            called\n                            and the handle is freed.)\n\n                            ion_handle_put() is called and it\n                            decreases the slub's next free pointer\n\nThe problem is detected as an unaligned access in the\nspin lock functions since it uses load exclusive\n instruction. In some cases it corrupts the slub's\nfree pointer which causes a mis-aligned access to the\nnext free pointer.(kmalloc returns a pointer like\nffffc0745b4580aa). And it causes lots of other\nhard-to-debug problems.\n\nThis symptom is caused since the first member in the\nion_handle structure is the reference count and the\nion driver decrements the reference after it has been\nfreed.\n\nTo fix this problem client->lock mutex is extended\nto protect all the codes that uses the handle.\n\nSigned-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>\nReviewed-by: Laura Abbott <labbott@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "ion.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "42",
    "number_of_lines_deleted_vulnerable_to_cve": "13",
    "vulnerable_lines": [
        "// Line_Reference 390: static int ion_handle_put(struct ion_handle *handle)",
        "// Line_Reference 396: \tret = kref_put(&handle->ref, ion_handle_destroy);",
        "// Line_Reference 420: static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,",
        "// Line_Reference 425: \tmutex_lock(&client->lock);",
        "// Line_Reference 429: \tmutex_unlock(&client->lock);",
        "// Line_Reference 535: void ion_free(struct ion_client *client, struct ion_handle *handle)",
        "// Line_Reference 541: \tmutex_lock(&client->lock);",
        "// Line_Reference 546: \t\tmutex_unlock(&client->lock);",
        "// Line_Reference 550: \tion_handle_put(handle);",
        "// Line_Reference 1335: \t\thandle = ion_handle_get_by_id(client, data.handle.handle);",
        "// Line_Reference 1336: \t\tif (IS_ERR(handle))",
        "// Line_Reference 1338: \t\tion_free(client, handle);",
        "// Line_Reference 1339: \t\tion_handle_put(handle);"
    ]
}
