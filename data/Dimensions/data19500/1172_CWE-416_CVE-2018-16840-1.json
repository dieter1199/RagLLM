{
    "cve_id": "CVE-2018-16840",
    "cve_description": "A heap use-after-free flaw was found in curl versions from 7.59.0 through 7.61.1 in the code related to closing an easy handle. When closing and cleaning up an 'easy' handle in the `Curl_close()` function, the library code first frees a struct (without nulling the pointer) and might then subsequently erroneously write to a struct field within that already freed struct.",
    "cve_publish_date": "2018-10-31",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "Curl_close: clear data->multi_easy on free to avoid use-after-free\n\nRegression from b46cfbc068 (7.59.0)\nCVE-2018-16840\nReported-by: Brian Carpenter (Geeknik Labs)\n\nBug: https://curl.haxx.se/docs/CVE-2018-16840.html",
    "type_of_change": "Modification",
    "filename_of_changes": "url.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "3",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 334:   if(data->multi_easy)"
    ]
}
