{
    "cve_id": "CVE-2017-18367",
    "cve_description": "libseccomp-golang 0.9.0 and earlier incorrectly generates BPFs that OR multiple arguments rather than ANDing them. A process running under a restrictive seccomp filter that specified multiple syscall arguments could bypass intended access restrictions by specifying a single matching argument.",
    "cve_publish_date": "2019-04-24",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "golang: Resolve bug with handling of multiple argument rules\n\nIn the upstream library, when added with a single API call,\nmultiple syscall argument rules should be matched with AND\nlogic - if all of them match, the rule matches.\n\nAt present, the Golang bindings apply OR logic to this case.\nThis commit resolves this and reverts to the behavior of the\nmain library.\n\nSigned-off-by: Matthew Heon <matthew.heon@gmail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "seccomp_internal.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "37",
    "number_of_lines_deleted_vulnerable_to_cve": "27",
    "vulnerable_lines": [
        "// Line_Reference 123: // Wrapper to create an scmp_arg_cmp struct",
        "// Line_Reference 124: void*",
        "// Line_Reference 125: make_struct_arg_cmp(",
        "// Line_Reference 126:                     unsigned int arg,",
        "// Line_Reference 127:                     int compare,",
        "// Line_Reference 128:                     uint64_t a,",
        "// Line_Reference 129:                     uint64_t b",
        "// Line_Reference 130:                    )",
        "// Line_Reference 132: \tstruct scmp_arg_cmp *s = malloc(sizeof(struct scmp_arg_cmp));",
        "// Line_Reference 134: \ts->arg = arg;",
        "// Line_Reference 135: \ts->op = compare;",
        "// Line_Reference 136: \ts->datum_a = a;",
        "// Line_Reference 137: \ts->datum_b = b;",
        "// Line_Reference 139: \treturn s;",
        "// Line_Reference 242: func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, cond C.scmp_cast_t) error {",
        "// Line_Reference 243: \tvar length C.uint",
        "// Line_Reference 244: \tif cond != nil {",
        "// Line_Reference 245: \t\tlength = 1",
        "// Line_Reference 246: \t} else {",
        "// Line_Reference 247: \t\tlength = 0",
        "// Line_Reference 278: \t\tif err := f.addRuleWrapper(call, action, exact, nil); err != nil {",
        "// Line_Reference 290: \t\tfor _, cond := range conds {",
        "// Line_Reference 291: \t\t\tcmpStruct := C.make_struct_arg_cmp(C.uint(cond.Argument), cond.Op.toNative(), C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))",
        "// Line_Reference 292: \t\t\tdefer C.free(cmpStruct)",
        "// Line_Reference 294: \t\t\tif err := f.addRuleWrapper(call, action, exact, C.scmp_cast_t(cmpStruct)); err != nil {",
        "// Line_Reference 295: \t\t\t\treturn err",
        "// Line_Reference 296: \t\t\t}"
    ]
}
