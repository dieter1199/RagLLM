{
    "cve_id": "CVE-2019-18276",
    "cve_description": "An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support \"saved UID\" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use \"enable -f\" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.",
    "cve_publish_date": "2019-11-28",
    "cwe_id": "CWE-273",
    "cwe_name": "Improper Check for Dropped Privileges",
    "cwe_description": "The product attempts to drop privileges but does not check or incorrectly checks to see if the drop succeeded.",
    "commit_message": "commit bash-20190628 snapshot",
    "type_of_change": "Modification",
    "filename_of_changes": "bashline.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "49",
    "vulnerable_lines": [
        "// Line_Reference 3849:   register int c;",
        "// Line_Reference 3850:   char *send;",
        "// Line_Reference 3851:   int open;",
        "// Line_Reference 3852: ",
        "// Line_Reference 3853:   DECLARE_MBSTATE;",
        "// Line_Reference 3854: ",
        "// Line_Reference 3855:   open = 0;",
        "// Line_Reference 3856:   send = string + strlen (string);",
        "// Line_Reference 3857: ",
        "// Line_Reference 3858:   while (c = *string++)",
        "// Line_Reference 3859:     {",
        "// Line_Reference 3860:       switch (c)",
        "// Line_Reference 3861: \t{",
        "// Line_Reference 3862: \tcase '?':",
        "// Line_Reference 3863: \tcase '*':",
        "// Line_Reference 3864: \t  return (1);",
        "// Line_Reference 3865: ",
        "// Line_Reference 3866: \tcase '[':",
        "// Line_Reference 3867: \t  open++;",
        "// Line_Reference 3868: \t  continue;",
        "// Line_Reference 3869: ",
        "// Line_Reference 3870: \tcase ']':",
        "// Line_Reference 3871: \t  if (open)",
        "// Line_Reference 3872: \t    return (1);",
        "// Line_Reference 3873: \t  continue;",
        "// Line_Reference 3874: ",
        "// Line_Reference 3875: \tcase '+':",
        "// Line_Reference 3876: \tcase '@':",
        "// Line_Reference 3877: \tcase '!':",
        "// Line_Reference 3878: \t  if (*string == '(')\t/*)*/",
        "// Line_Reference 3879: \t    return (1);",
        "// Line_Reference 3880: \t  continue;",
        "// Line_Reference 3881: ",
        "// Line_Reference 3882: \tcase '\\\\':",
        "// Line_Reference 3883: \t  if (*string++ == 0)",
        "// Line_Reference 3884: \t    return (0);",
        "// Line_Reference 3885: \t}",
        "// Line_Reference 3886: ",
        "// Line_Reference 3887:       /* Advance one fewer byte than an entire multibyte character to",
        "// Line_Reference 3888: \t account for the auto-increment in the loop above. */",
        "// Line_Reference 3889: #ifdef HANDLE_MULTIBYTE",
        "// Line_Reference 3890:       string--;",
        "// Line_Reference 3891:       ADVANCE_CHAR_P (string, send - string);",
        "// Line_Reference 3892:       string++;",
        "// Line_Reference 3893: #else",
        "// Line_Reference 3894:       ADVANCE_CHAR_P (string, send - string);",
        "// Line_Reference 3895: #endif",
        "// Line_Reference 3896:     }",
        "// Line_Reference 3897:   return (0);"
    ]
}
