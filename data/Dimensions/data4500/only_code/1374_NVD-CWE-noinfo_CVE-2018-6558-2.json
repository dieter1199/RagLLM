#include <unistd.h>	// setreuid, setregid
#include <grp.h>	// setgroups
static int my_setreuid(uid_t ruid, uid_t euid)
{
return setreuid(ruid, euid);
}
static int my_setregid(gid_t rgid, gid_t egid)
{
return setregid(rgid, egid);
}
static int my_setgroups(size_t size, const gid_t *list)
{
return setgroups(size, list);
}
"os"
// SetProcessPrivileges temporarily drops the privileges of the current process
// to have the effective uid/gid of the target user. The privileges can be
// changed again with another call to SetProcessPrivileges.
func SetProcessPrivileges(target *user.User) error {
euid := util.AtoiOrPanic(target.Uid)
egid := util.AtoiOrPanic(target.Gid)
if os.Geteuid() == euid {
log.Printf("Privileges already set to %q", target.Username)
return nil
}
log.Printf("Setting privileges to %q", target.Username)
// If setting privs to root, we want to set the uid first, so we will
// then have the necessary permissions to perform the other actions.
if euid == 0 {
if err := setUids(-1, euid); err != nil {
return err
}
}
if err := setGids(-1, egid); err != nil {
return err
}
if err := setGroups(target); err != nil {
return err
// If not setting privs to root, we want to avoid dropping the uid
// util the very end.
if euid != 0 {
if err := setUids(-1, euid); err != nil {
return err
return nil
func setUids(ruid, euid int) error {
res, err := C.my_setreuid(C.uid_t(ruid), C.uid_t(euid))
log.Printf("setreuid(%d, %d) = %d (errno %v)", ruid, euid, res, err)
if res == 0 {
return nil
return errors.Wrapf(err.(syscall.Errno), "setting uids")
func setGids(rgid, egid int) error {
res, err := C.my_setregid(C.gid_t(rgid), C.gid_t(egid))
log.Printf("setregid(%d, %d) = %d (errno %v)", rgid, egid, res, err)
if res == 0 {
return nil
return errors.Wrapf(err.(syscall.Errno), "setting gids")
}
func setGroups(target *user.User) error {
groupStrings, err := target.GroupIds()
if err != nil {
return util.SystemError(err.Error())
gids := make([]C.gid_t, len(groupStrings))
for i, groupString := range groupStrings {
gids[i] = C.gid_t(util.AtoiOrPanic(groupString))
res, err := C.my_setgroups(C.size_t(len(groupStrings)), &gids[0])
log.Printf("setgroups(%v) = %d (errno %v)", gids, res, err)
return errors.Wrapf(err.(syscall.Errno), "setting groups")
