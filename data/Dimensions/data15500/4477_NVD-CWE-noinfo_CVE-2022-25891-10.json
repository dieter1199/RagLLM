{
    "cve_id": "CVE-2022-25891",
    "cve_description": "The package github.com/containrrr/shoutrrr/pkg/util before 0.6.0 are vulnerable to Denial of Service (DoS) via the util.PartitionMessage function. Exploiting this vulnerability is possible by sending exactly 2000, 4000, or 6000 characters messages.",
    "cve_publish_date": "2022-07-15",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix(discord): message size fixes (#242)\n\n* fix(discord): handle empty messages without panic\r\n* fix: off by one error when partitioning messages\r\n* test(discord): add tests for Send failures\r\n* fix(discord): typo in meta message\r\n\r\nCo-authored-by: Justin Steven <justin@justinsteven.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "partition_message_test.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "70",
    "number_of_lines_deleted_vulnerable_to_cve": "54",
    "vulnerable_lines": [
        "// Line_Reference 7: \t\"strings\"",
        "// Line_Reference 11: \tDescribe(\"creating a json payload\", func() {",
        "// Line_Reference 12: \t\tlimits := types.MessageLimit{",
        "// Line_Reference 13: \t\t\tChunkSize:      2000,",
        "// Line_Reference 14: \t\t\tTotalChunkSize: 6000,",
        "// Line_Reference 15: \t\t\tChunkCount:     10,",
        "// Line_Reference 16: \t\t}",
        "// Line_Reference 17: \t\tWhen(\"given a message that exceeds the max length\", func() {",
        "// Line_Reference 18: \t\t\tWhen(\"not splitting by lines\", func() {",
        "// Line_Reference 19: \t\t\t\tIt(\"should return a payload with chunked messages\", func() {",
        "// Line_Reference 21: \t\t\t\t\titems, _ := testPartitionMessage(42, limits, 100)",
        "// Line_Reference 23: \t\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))",
        "// Line_Reference 24: \t\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))",
        "// Line_Reference 25: \t\t\t\t\tExpect(len(items[2].Text)).To(Equal(205))",
        "// Line_Reference 26: \t\t\t\t})",
        "// Line_Reference 27: \t\t\t\tIt(\"omit characters above total max\", func() {",
        "// Line_Reference 28: \t\t\t\t\titems, _ := testPartitionMessage(62, limits, 100)",
        "// Line_Reference 30: \t\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))",
        "// Line_Reference 31: \t\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))",
        "// Line_Reference 32: \t\t\t\t\tExpect(len(items[2].Text)).To(Equal(1999))",
        "// Line_Reference 33: \t\t\t\t\tExpect(len(items[3].Text)).To(Equal(5))",
        "// Line_Reference 36: \t\t\tWhen(\"splitting by lines\", func() {",
        "// Line_Reference 37: \t\t\t\tIt(\"should return a payload with chunked messages\", func() {",
        "// Line_Reference 38: \t\t\t\t\titems, omitted := testMessageItemsFromLines(18, limits, 2)",
        "// Line_Reference 40: \t\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))",
        "// Line_Reference 41: \t\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))",
        "// Line_Reference 43: \t\t\t\t\tExpect(omitted).To(Equal(0))",
        "// Line_Reference 44: \t\t\t\t})",
        "// Line_Reference 45: \t\t\t\tIt(\"omit characters above total max\", func() {",
        "// Line_Reference 46: \t\t\t\t\titems, omitted := testMessageItemsFromLines(19, limits, 2)",
        "// Line_Reference 48: \t\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))",
        "// Line_Reference 49: \t\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))",
        "// Line_Reference 51: \t\t\t\t\tExpect(omitted).To(Equal(100))",
        "// Line_Reference 52: \t\t\t\t})",
        "// Line_Reference 53: \t\t\t\tIt(\"should trim characters above chunk size\", func() {",
        "// Line_Reference 54: \t\t\t\t\thundreds := 42",
        "// Line_Reference 55: \t\t\t\t\trepeat := 21",
        "// Line_Reference 56: \t\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)",
        "// Line_Reference 58: \t\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))",
        "// Line_Reference 59: \t\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))",
        "// Line_Reference 61: \t\t\t\t\t// Trimmed characters do not count towards the total omitted count",
        "// Line_Reference 62: \t\t\t\t\tExpect(omitted).To(Equal(0))",
        "// Line_Reference 63: \t\t\t\t})",
        "// Line_Reference 65: \t\t\t\tIt(\"omit characters above total chunk size\", func() {",
        "// Line_Reference 66: \t\t\t\t\thundreds := 100",
        "// Line_Reference 67: \t\t\t\t\trepeat := 20",
        "// Line_Reference 68: \t\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)",
        "// Line_Reference 70: \t\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))",
        "// Line_Reference 71: \t\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))",
        "// Line_Reference 72: \t\t\t\t\tExpect(len(items[2].Text)).To(Equal(limits.ChunkSize))",
        "// Line_Reference 74: \t\t\t\t\tmaxRunes := hundreds * 100",
        "// Line_Reference 75: \t\t\t\t\texpectedOmitted := maxRunes - limits.TotalChunkSize",
        "// Line_Reference 77: \t\t\t\t\tExpect(omitted).To(Equal(expectedOmitted))",
        "// Line_Reference 78: \t\t\t\t})"
    ]
}
