{
    "cve_id": "CVE-2018-25023",
    "cve_description": "An issue was discovered in the smallvec crate before 0.6.13 for Rust. It can create an uninitialized value of any type, including a reference type.",
    "cve_publish_date": "2021-12-27",
    "cwe_id": "CWE-908",
    "cwe_name": "Use of Uninitialized Resource",
    "cwe_description": "The product uses or accesses a resource that has not been initialized.",
    "commit_message": "Use MaybeUninit for storage of inline items.\n\nThis is a backport of #162 to the smallvec 0.6 branch. To avoid bumping the\nminimum Rust version, the `maybe-uninit` crate is used in place of\n`std::mem::MaybeUninit`.  To avoid breaking changes, the `Array::ptr` and\n`ptr_mut` methods are retained but are no longer used, and the API to\n`from_buf_and_len_unchecked` is unchanged.",
    "type_of_change": "Modification",
    "filename_of_changes": "lib.rs",
    "code_language": "Rust",
    "number_of_lines_added_for_mitigation": "52",
    "number_of_lines_deleted_vulnerable_to_cve": "39",
    "vulnerable_lines": [
        "// Line_Reference 59: use std::mem::ManuallyDrop;",
        "// Line_Reference 278:     inline: ManuallyDrop<A>,",
        "// Line_Reference 285:     unsafe fn inline(&self) -> &A {",
        "// Line_Reference 286:         &self.inline",
        "// Line_Reference 289:     unsafe fn inline_mut(&mut self) -> &mut A {",
        "// Line_Reference 290:         &mut self.inline",
        "// Line_Reference 293:     fn from_inline(inline: A) -> SmallVecData<A> {",
        "// Line_Reference 294:         SmallVecData { inline: ManuallyDrop::new(inline) }",
        "// Line_Reference 297:     unsafe fn into_inline(self) -> A { ManuallyDrop::into_inner(self.inline) }",
        "// Line_Reference 314:     Inline(ManuallyDrop<A>),",
        "// Line_Reference 321:     unsafe fn inline(&self) -> &A {",
        "// Line_Reference 323:             SmallVecData::Inline(ref a) => a,",
        "// Line_Reference 328:     unsafe fn inline_mut(&mut self) -> &mut A {",
        "// Line_Reference 330:             SmallVecData::Inline(ref mut a) => a,",
        "// Line_Reference 335:     fn from_inline(inline: A) -> SmallVecData<A> {",
        "// Line_Reference 336:         SmallVecData::Inline(ManuallyDrop::new(inline))",
        "// Line_Reference 339:     unsafe fn into_inline(self) -> A {",
        "// Line_Reference 341:             SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),",
        "// Line_Reference 406:         unsafe {",
        "// Line_Reference 407:             SmallVec {",
        "// Line_Reference 408:                 capacity: 0,",
        "// Line_Reference 409:                 data: SmallVecData::from_inline(mem::uninitialized()),",
        "// Line_Reference 410:             }",
        "// Line_Reference 450:                 let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());",
        "// Line_Reference 453:                 ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);",
        "// Line_Reference 486:             data: SmallVecData::from_inline(buf),",
        "// Line_Reference 526:             data: SmallVecData::from_inline(buf),",
        "// Line_Reference 574:                 (self.data.inline().ptr(), self.capacity, A::size())",
        "// Line_Reference 587:                 (self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())",
        "// Line_Reference 654:                 self.data = SmallVecData::from_inline(mem::uninitialized());",
        "// Line_Reference 655:                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);",
        "// Line_Reference 720:                 self.data = SmallVecData::from_inline(mem::uninitialized());",
        "// Line_Reference 721:                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);",
        "// Line_Reference 886:                 Ok(data.into_inline())",
        "// Line_Reference 1044:                     let mut data: A = mem::uninitialized();",
        "// Line_Reference 1045:                     ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);",
        "// Line_Reference 1590:                 fn ptr(&self) -> *const T { self.as_ptr() }",
        "// Line_Reference 1591:                 fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }",
        "// Line_Reference 1892:     #[cfg(feature = \"std\")]"
    ]
}
