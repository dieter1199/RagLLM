mark_desktop_file_trusted (CommonJob    *common,
GCancellable *cancellable,
GFile        *file,
gboolean      interactive);
mark_desktop_file_trusted (job,
job->cancellable,
dest,
FALSE);
mark_trusted_task_done (GObject      *source_object,
GAsyncResult *res,
gpointer      user_data)
mark_desktop_file_trusted (CommonJob    *common,
GCancellable *cancellable,
GFile        *file,
gboolean      interactive)
char *contents, *new_contents;
gsize length, new_length;
error = NULL;
if (!g_file_load_contents (file,
cancellable,
&contents, &length,
NULL, &error))
{
if (interactive)
{
response = run_error (common,
g_strdup (_("Unable to mark launcher trusted (executable)")),
error->message,
NULL,
FALSE,
CANCEL, RETRY,
NULL);
}
else
{
response = 0;
}
if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (common);
}
else if (response == 1)
{
goto retry;
}
else
{
g_assert_not_reached ();
}
goto out;
}
if (!g_str_has_prefix (contents, "#!"))
{
new_length = length + strlen (TRUSTED_SHEBANG);
new_contents = g_malloc (new_length);
strcpy (new_contents, TRUSTED_SHEBANG);
memcpy (new_contents + strlen (TRUSTED_SHEBANG),
contents, length);
if (!g_file_replace_contents (file,
new_contents,
new_length,
NULL,
FALSE, 0,
NULL, cancellable, &error))
{
g_free (contents);
g_free (new_contents);
if (interactive)
{
response = run_error (common,
g_strdup (_("Unable to mark launcher trusted (executable)")),
error->message,
NULL,
FALSE,
CANCEL, RETRY,
NULL);
}
else
{
response = 0;
}
if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (common);
}
else if (response == 1)
{
goto retry;
}
else
{
g_assert_not_reached ();
}
goto out;
}
g_free (new_contents);
}
g_free (contents);
mark_trusted_task_thread_func (GTask        *task,
gpointer      source_object,
gpointer      task_data,
GCancellable *cancellable)
mark_desktop_file_trusted (common,
cancellable,
job->file,
job->interactive);
nautilus_file_mark_desktop_file_trusted (GFile              *file,
GtkWindow          *parent_window,
gboolean            interactive,
NautilusOpCallback  done_callback,
gpointer            done_callback_data)
task = g_task_new (NULL, NULL, mark_trusted_task_done, job);
g_task_run_in_thread (task, mark_trusted_task_thread_func);
