{
    "cve_id": "CVE-2019-15693",
    "cve_description": "TigerVNC version prior to 1.10.1 is vulnerable to heap buffer overflow, which occurs in TightDecoder::FilterGradient. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
    "cve_publish_date": "2019-12-26",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Handle empty Tight gradient rects\n\nWe always assumed there would be one pixel per row so a rect with\na zero width would result in us writing to unknown memory.\n\nThis could theoretically be used by a malicious server to inject\ncode in to the viewer process.\n\nIssue found by Pavel Cheremushkin from Kaspersky Lab.",
    "type_of_change": "Modification",
    "filename_of_changes": "tightDecode.h",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "21",
    "number_of_lines_deleted_vulnerable_to_cve": "16",
    "vulnerable_lines": [
        "// Line_Reference 59:     /* First pixel in a row */",
        "// Line_Reference 60:     for (c = 0; c < 3; c++) {",
        "// Line_Reference 61:       pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];",
        "// Line_Reference 62:       thisRow[c] = pix[c];",
        "// Line_Reference 63:     }",
        "// Line_Reference 64:     pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);",
        "// Line_Reference 66:     /* Remaining pixels of a row */",
        "// Line_Reference 67:     for (x = 1; x < rectWidth; x++) {",
        "// Line_Reference 106:     /* First pixel in a row */",
        "// Line_Reference 107:     pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);",
        "// Line_Reference 108:     for (c = 0; c < 3; c++)",
        "// Line_Reference 109:       pix[c] += prevRow[c];",
        "// Line_Reference 111:     memcpy(thisRow, pix, sizeof(pix));",
        "// Line_Reference 113:     pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);",
        "// Line_Reference 115:     /* Remaining pixels of a row */",
        "// Line_Reference 116:     for (x = 1; x < rectWidth; x++) {"
    ]
}
