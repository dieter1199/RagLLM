{
    "cve_id": "CVE-2020-15861",
    "cve_description": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.",
    "cve_publish_date": "2020-08-20",
    "cwe_id": "CWE-59",
    "cwe_name": "Improper Link Resolution Before File Access ('Link Following')",
    "cwe_description": "The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",
    "commit_message": "CHANGES: snmpd: Stop reading and writing the mib_indexes/* files\n\nCaching directory contents is something the operating system should do\nand is not something Net-SNMP should do. Instead of storing a copy of\nthe directory contents in ${tmp_dir}/mib_indexes/${n}, always scan a\nMIB directory.",
    "type_of_change": "Modification",
    "filename_of_changes": "parse.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "55",
    "vulnerable_lines": [
        "// Line_Reference 610: static void     new_module(const char *, const char *);",
        "// Line_Reference 611: ",
        "// Line_Reference 4862: add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )",
        "// Line_Reference 4887:         if (ip)",
        "// Line_Reference 4888:             fprintf(ip, \"%s %s\\n\", token, d_name);",
        "// Line_Reference 4980:     FILE           *ip;",
        "// Line_Reference 4985: #if !(defined(WIN32) || defined(cygwin))",
        "// Line_Reference 4986:     char           *token;",
        "// Line_Reference 4987:     char space;",
        "// Line_Reference 4988:     char newline;",
        "// Line_Reference 4989:     struct stat     dir_stat, idx_stat;",
        "// Line_Reference 4990:     char            tmpstr[300];",
        "// Line_Reference 4991:     char            tmpstr1[300];",
        "// Line_Reference 4992: #endif",
        "// Line_Reference 4995: #if !(defined(WIN32) || defined(cygwin))",
        "// Line_Reference 4996:     token = netsnmp_mibindex_lookup( dirname );",
        "// Line_Reference 4997:     if (token && stat(token, &idx_stat) == 0 && stat(dirname, &dir_stat) == 0) {",
        "// Line_Reference 4998:         if (dir_stat.st_mtime < idx_stat.st_mtime) {",
        "// Line_Reference 4999:             DEBUGMSGTL((\"parse-mibs\", \"The index is good\\n\"));",
        "// Line_Reference 5000:             if ((ip = fopen(token, \"r\")) != NULL) {",
        "// Line_Reference 5001:                 fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */",
        "// Line_Reference 5002:                 while (fscanf(ip, \"%127s%c%299[^\\n]%c\", token, &space, tmpstr,",
        "// Line_Reference 5003: \t\t    &newline) == 4) {",
        "// Line_Reference 5004: ",
        "// Line_Reference 5005: \t\t    /*",
        "// Line_Reference 5006: \t\t     * If an overflow of the token or tmpstr buffers has been",
        "// Line_Reference 5007: \t\t     * found log a message and break out of the while loop,",
        "// Line_Reference 5008: \t\t     * thus the rest of the file tokens will be ignored.",
        "// Line_Reference 5009: \t\t     */",
        "// Line_Reference 5010: \t\t    if (space != ' ' || newline != '\\n') {",
        "// Line_Reference 5011: \t\t\tsnmp_log(LOG_ERR,",
        "// Line_Reference 5012: \t\t\t    \"add_mibdir: strings scanned in from %s/%s \" \\",
        "// Line_Reference 5013: \t\t\t    \"are too large.  count = %d\\n \", dirname,",
        "// Line_Reference 5014: \t\t\t    \".index\", count);",
        "// Line_Reference 5015: \t\t\t    break;",
        "// Line_Reference 5016: \t\t    }",
        "// Line_Reference 5017: ",
        "// Line_Reference 5018: \t\t    snprintf(tmpstr1, sizeof(tmpstr1), \"%s/%s\", dirname, tmpstr);",
        "// Line_Reference 5019:                     tmpstr1[ sizeof(tmpstr1)-1 ] = 0;",
        "// Line_Reference 5020:                     new_module(token, tmpstr1);",
        "// Line_Reference 5021:                     count++;",
        "// Line_Reference 5022:                 }",
        "// Line_Reference 5023:                 fclose(ip);",
        "// Line_Reference 5024:                 return count;",
        "// Line_Reference 5025:             } else",
        "// Line_Reference 5026:                 DEBUGMSGTL((\"parse-mibs\", \"Can't read index\\n\"));",
        "// Line_Reference 5027:         } else",
        "// Line_Reference 5028:             DEBUGMSGTL((\"parse-mibs\", \"Index outdated\\n\"));",
        "// Line_Reference 5029:     } else",
        "// Line_Reference 5030:         DEBUGMSGTL((\"parse-mibs\", \"No index\\n\"));",
        "// Line_Reference 5031: #endif",
        "// Line_Reference 5036:         ip = netsnmp_mibindex_new(dirname);",
        "// Line_Reference 5038:             if (add_mibfile(filenames[i], strrchr(filenames[i], '/'), ip) == 0)",
        "// Line_Reference 5043:         if (ip)",
        "// Line_Reference 5044:             fclose(ip);"
    ]
}
