{
    "cve_id": "CVE-2020-15889",
    "cve_description": "Lua 5.4.0 has a getobjname heap-based buffer over-read because youngcollection in lgc.c uses markold for an insufficient number of list members.",
    "cve_publish_date": "2020-07-21",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Fixed bug of old finalized objects in the GC\n\nWhen an object aged OLD1 is finalized, it is moved from the list\n'finobj' to the *beginning* of the list 'allgc'. So, this part of the\nlist (and not only the survival list) must be visited by 'markold'.",
    "type_of_change": "Modification",
    "filename_of_changes": "lgc.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "6",
    "vulnerable_lines": [
        "// Line_Reference 1134: ** Does a young collection. First, mark 'OLD1' objects.  (Only survival",
        "// Line_Reference 1135: ** and \"recent old\" lists can contain 'OLD1' objects. New lists cannot",
        "// Line_Reference 1136: ** contain 'OLD1' objects, at most 'OLD0' objects that were already",
        "// Line_Reference 1137: ** visited when marked old.) Then does the atomic step. Then,",
        "// Line_Reference 1138: ** sweep all lists and advance pointers. Finally, finish the collection.",
        "// Line_Reference 1143:   markold(g, g->survival, g->reallyold);"
    ]
}
