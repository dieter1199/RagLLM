{
    "cve_id": "CVE-2016-9919",
    "cve_description": "The icmp6_send function in net/ipv6/icmp.c in the Linux kernel through 4.8.12 omits a certain check of the dst data structure, which allows remote attackers to cause a denial of service (panic) via a fragmented IPv6 packet.",
    "cve_publish_date": "2016-12-08",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "net: handle no dst on skb in icmp6_send\n\nAndrey reported the following while fuzzing the kernel with syzkaller:\n\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 0 PID: 3859 Comm: a.out Not tainted 4.9.0-rc6+ #429\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\ntask: ffff8800666d4200 task.stack: ffff880067348000\nRIP: 0010:[<ffffffff833617ec>]  [<ffffffff833617ec>]\nicmp6_send+0x5fc/0x1e30 net/ipv6/icmp.c:451\nRSP: 0018:ffff88006734f2c0  EFLAGS: 00010206\nRAX: ffff8800666d4200 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: dffffc0000000000 RDI: 0000000000000018\nRBP: ffff88006734f630 R08: ffff880064138418 R09: 0000000000000003\nR10: dffffc0000000000 R11: 0000000000000005 R12: 0000000000000000\nR13: ffffffff84e7e200 R14: ffff880064138484 R15: ffff8800641383c0\nFS:  00007fb3887a07c0(0000) GS:ffff88006cc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 000000006b040000 CR4: 00000000000006f0\nStack:\n ffff8800666d4200 ffff8800666d49f8 ffff8800666d4200 ffffffff84c02460\n ffff8800666d4a1a 1ffff1000ccdaa2f ffff88006734f498 0000000000000046\n ffff88006734f440 ffffffff832f4269 ffff880064ba7456 0000000000000000\nCall Trace:\n [<ffffffff83364ddc>] icmpv6_param_prob+0x2c/0x40 net/ipv6/icmp.c:557\n [<     inline     >] ip6_tlvopt_unknown net/ipv6/exthdrs.c:88\n [<ffffffff83394405>] ip6_parse_tlv+0x555/0x670 net/ipv6/exthdrs.c:157\n [<ffffffff8339a759>] ipv6_parse_hopopts+0x199/0x460 net/ipv6/exthdrs.c:663\n [<ffffffff832ee773>] ipv6_rcv+0xfa3/0x1dc0 net/ipv6/ip6_input.c:191\n ...\n\nicmp6_send / icmpv6_send is invoked for both rx and tx paths. In both\ncases the dst->dev should be preferred for determining the L3 domain\nif the dst has been set on the skb. Fallback to the skb->dev if it has\nnot. This covers the case reported here where icmp6_send is invoked on\nRx before the route lookup.\n\nFixes: 5d41ce29e (\"net: icmp6_send should use dst dev to determine L3 domain\")\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "icmp.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 450: \telse",
        "// Line_Reference 451: \t\tiif = l3mdev_master_ifindex(skb_dst(skb)->dev);"
    ]
}
