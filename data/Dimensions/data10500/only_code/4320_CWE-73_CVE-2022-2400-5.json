//return $protocol . $host . rtrim($base_path, "/\\") . "/";
return $protocol . $host . $base_path;
if ((mb_strpos($url, "://") !== false && substr($url, 0, 7) !== "file://") || mb_substr($url, 0, 1) === "#" || mb_strpos($url, "data:") === 0 || mb_strpos($url, "mailto:") === 0 || mb_strpos($url, "tel:") === 0) {
if (strpos($url, "file://") === 0) {
$protocol = "";
if ($protocol !== "file://") {
$ret = $protocol;
}
if (!in_array(mb_strtolower($protocol), ["http://", "https://", "ftp://", "ftps://"], true)) {
// Exclude windows drive letters...
if (isset($arr["scheme"]) && $arr["scheme"] !== "file" && strlen($arr["scheme"]) > 1) {
$i = mb_stripos($url, "file://");
if ($i !== false) {
$url = mb_substr($url, $i + 7);
}
$protocol = ""; // "file://"; ? why doesn't this work... It's because of
// network filenames like //COMPU/SHARENAME
$file = basename($url);
$path = dirname($url);
// Check that the path exists
if ($path !== false) {
$path .= '/';
// generate a url to access the file if no real path found.
$protocol = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? 'https://' : 'http://';
$host = isset($_SERVER["HTTP_HOST"]) ? $_SERVER["HTTP_HOST"] : php_uname("n");
if (substr($arr["path"], 0, 1) === '/') {
$path = dirname($arr["path"]);
} else {
$path = '/' . rtrim(dirname($_SERVER["SCRIPT_NAME"]), '/') . '/' . $arr["path"];
}
"file" => $file];
$is_local_path = ($protocol === "" || $protocol === "file://");
if ($is_local_path || ini_get('allow_url_fopen')) {
} elseif (function_exists('curl_exec')) {
