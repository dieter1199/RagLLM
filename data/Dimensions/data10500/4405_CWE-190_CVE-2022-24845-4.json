{
    "cve_id": "CVE-2022-24845",
    "cve_description": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.",
    "cve_publish_date": "2022-04-13",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "Merge pull request from GHSA-j2x6-9323-fp7h\n\nThis commit addresses two issues in validating returndata, both related\nto the inferred type of the external call return.\n\nFirst, it addresses an issue with interfaces imported from JSON. The\nJSON_ABI encoding type was added in 0.3.0 as part of the calling\nconvention refactor to mimic the old code's behavior when the signature\nof a function had `is_from_json` toggled to True. However, both\nimplementations were a workaround for the fact that in\nFunctionSignatures from JSON with Bytes return types, length is set to 1\nas a hack to ensure they always typecheck - almost always resulting in a\nruntime revert.\n\nThis commit removes the JSON_ABI encoding type, so that dynamic\nreturndata from an interface defined with .json ABI file cannot result\nin a buffer overrun(!). To avoid the issue with always runtime\nreverting, codegen uses the uses the inferred ContractFunction type of\nthe Call.func member (which is both more accurate than the inferred type\nof the Call expression, and the return type on the FunctionSignature!)\nto calculate the length of the external Bytes array.\n\nSecond, this commit addresses an issue with validating call returns in\ncomplex expressions. In the following examples, the type of the call\nreturn is either inferred incorrectly or it takes a path through codegen\nwhich avoids generating runtime clamps:\n\n```\ninterface Foo:\n    def returns_int128() -> int128: view\n    def returns_Bytes3() -> Bytes[3]: view\n\nfoo: Foo\n...\nx: uint256 = convert(self.foo.returns_int128(), uint256)\ny: Bytes[32] = concat(self.foo.returns_Bytes3(), b\"\")\n```\n\nTo address this issue, if the type of returndata needs validation, this\ncommit decodes the returndata \"strictly\" into a newly allocated buffer\nat the time of the call, to avoid unvalidated data accidentally getting\ninto the runtime. This does result in extra memory traffic which is a\nperformance hit, but the performance issue can be addressed at a later\ndate with a zero-copy buffering scheme (parent Expr allocates the\nbuffer).\n\nAdditional minor fixes and cleanup:\n- fix compiler panic in new_type_to_old_type for Tuples\n- remove `_should_decode` helper function as it duplicates `needs_clamp`\n- minor optimization in returndatasize check - assert ge uses one fewer\n  instruction than assert gt.",
    "type_of_change": "Modification",
    "filename_of_changes": "external_function.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "5",
    "number_of_lines_deleted_vulnerable_to_cve": "26",
    "vulnerable_lines": [
        "// Line_Reference 7: from vyper.codegen.core import get_element_ptr, getpos, make_setter",
        "// Line_Reference 12: from vyper.codegen.types.types import (",
        "// Line_Reference 13:     BaseType,",
        "// Line_Reference 14:     ByteArrayLike,",
        "// Line_Reference 15:     DArrayType,",
        "// Line_Reference 16:     SArrayType,",
        "// Line_Reference 17:     TupleLike,",
        "// Line_Reference 18:     TupleType,",
        "// Line_Reference 19: )",
        "// Line_Reference 20: from vyper.exceptions import CompilerPanic",
        "// Line_Reference 21: ",
        "// Line_Reference 22: ",
        "// Line_Reference 23: def _should_decode(typ):",
        "// Line_Reference 24:     # either a basetype which needs to be clamped",
        "// Line_Reference 25:     # or a complex type which contains something that",
        "// Line_Reference 26:     # needs to be clamped.",
        "// Line_Reference 27:     if isinstance(typ, BaseType):",
        "// Line_Reference 28:         return typ.typ not in (\"int256\", \"uint256\", \"bytes32\")",
        "// Line_Reference 29:     if isinstance(typ, (ByteArrayLike, DArrayType)):",
        "// Line_Reference 30:         return True",
        "// Line_Reference 31:     if isinstance(typ, SArrayType):",
        "// Line_Reference 32:         return _should_decode(typ.subtype)",
        "// Line_Reference 33:     if isinstance(typ, TupleLike):",
        "// Line_Reference 34:         return any(_should_decode(t) for t in typ.tuple_members())",
        "// Line_Reference 35:     raise CompilerPanic(f\"_should_decode({typ})\")  # pragma: notest",
        "// Line_Reference 56:         if _should_decode(arg.typ):"
    ]
}
