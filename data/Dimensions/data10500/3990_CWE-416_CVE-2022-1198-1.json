{
    "cve_id": "CVE-2022-1198",
    "cve_description": "A use-after-free vulnerabilitity was discovered in drivers/net/hamradio/6pack.c of linux that allows an attacker to crash linux kernel by simulating ax25 device using 6pack driver from user space.",
    "cve_publish_date": "2022-08-29",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "drivers: hamradio: 6pack: fix UAF bug caused by mod_timer()\n\nWhen a 6pack device is detaching, the sixpack_close() will act to cleanup\nnecessary resources. Although del_timer_sync() in sixpack_close()\nwon't return if there is an active timer, one could use mod_timer() in\nsp_xmit_on_air() to wake up timer again by calling userspace syscall such\nas ax25_sendmsg(), ax25_connect() and ax25_ioctl().\n\nThis unexpected waked handler, sp_xmit_on_air(), realizes nothing about\nthe undergoing cleanup and may still call pty_write() to use driver layer\nresources that have already been released.\n\nOne of the possible race conditions is shown below:\n\n      (USE)                      |      (FREE)\nax25_sendmsg()                   |\n ax25_queue_xmit()               |\n  ...                            |\n  sp_xmit()                      |\n   sp_encaps()                   | sixpack_close()\n    sp_xmit_on_air()             |  del_timer_sync(&sp->tx_t)\n     mod_timer(&sp->tx_t,...)    |  ...\n                                 |  unregister_netdev()\n                                 |  ...\n     (wait a while)              | tty_release()\n                                 |  tty_release_struct()\n                                 |   release_tty()\n    sp_xmit_on_air()             |    tty_kref_put(tty_struct) //FREE\n     pty_write(tty_struct) //USE |    ...\n\nThe corresponding fail log is shown below:\n===============================================================\nBUG: KASAN: use-after-free in __run_timers.part.0+0x170/0x470\nWrite of size 8 at addr ffff88800a652ab8 by task swapper/2/0\n...\nCall Trace:\n  ...\n  queue_work_on+0x3f/0x50\n  pty_write+0xcd/0xe0pty_write+0xcd/0xe0\n  sp_xmit_on_air+0xb2/0x1f0\n  call_timer_fn+0x28/0x150\n  __run_timers.part.0+0x3c2/0x470\n  run_timer_softirq+0x3b/0x80\n  __do_softirq+0xf1/0x380\n  ...\n\nThis patch reorders the del_timer_sync() after the unregister_netdev()\nto avoid UAF bugs. Because the unregister_netdev() is well synchronized,\nit flushs out any pending queues, waits the refcount of net_device\ndecreases to zero and removes net_device from kernel. There is not any\nrunning routines after executing unregister_netdev(). Therefore, we could\nnot arouse timer from userspace again.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nReviewed-by: Lin Ma <linma@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "6pack.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 674: \tunregister_netdev(sp->dev);",
        "// Line_Reference 675: "
    ]
}
