} else {
last = NULL;
for (i=0; i<nbFields; i++) {
GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
if (new_node) {
e = gf_node_register(new_node, is_mem_com ? NULL : node);
if (e) return e;
if (node) {
/*special case for QP, register as the current QP*/
if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
/*we have a QP in the same scope, remove previous
NB: we assume this is the right behavior, the spec doesn't say
whether QP is cumulative or not*/
if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);
e = gf_bifs_dec_qp_set(codec, new_node);
if (e) return e;
qp_on = 1;
if (qp_local) qp_local = 2;
if (codec->force_keep_qp) {
e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
if (e) return e;
} else {
gf_node_register(new_node, NULL);
gf_node_unregister(new_node, node);
}
} else {
if (e) return e;
/*proto coding*/
else if (codec->pCurrentProto) {
/*TO DO: what happens if this is a QP node on the interface ?*/
e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
if (e) return e;
}
} else {
return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;
/*according to the spec, the QP applies to the current node itself, not just children.
If IsLocal is TRUE remove the node*/
if (qp_on && qp_local) {
if (qp_local == 2) {
} else {
//ask to get rid of QP and reactivate if we had a QP when entering the node
gf_bifs_dec_qp_remove(codec, initial_qp);
}
return GF_OK;
