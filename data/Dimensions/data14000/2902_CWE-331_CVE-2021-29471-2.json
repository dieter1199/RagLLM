{
    "cve_id": "CVE-2021-29471",
    "cve_description": "Synapse is a Matrix reference homeserver written in python (pypi package matrix-synapse). Matrix is an ecosystem for open federated Instant Messaging and VoIP. In Synapse before version 1.33.2 \"Push rules\" can specify conditions under which they will match, including `event_match`, which matches event content against a pattern including wildcards. Certain patterns can cause very poor performance in the matching engine, leading to a denial-of-service when processing moderate length events. The issue is patched in version 1.33.2. A potential workaround might be to prevent users from making custom push rules, by blocking such requests at a reverse-proxy.",
    "cve_publish_date": "2021-05-11",
    "cwe_id": "CWE-331",
    "cwe_name": "Insufficient Entropy",
    "cwe_description": "The product uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.",
    "commit_message": "Merge pull request from GHSA-x345-32rc-8h85\n\n* tests for push rule pattern matching\n\n* tests for acl pattern matching\n\n* factor out common `re.escape`\n\n* Factor out common re.compile\n\n* Factor out common anchoring code\n\n* add word_boundary support to `glob_to_regex`\n\n* Use `glob_to_regex` in push rule evaluator\n\nNB that this drops support for character classes. I don't think anyone ever\nused them.\n\n* Improve efficiency of globs with multiple wildcards\n\nThe idea here is that we compress multiple `*` globs into a single `.*`. We\nalso need to consider `?`, since `*?*` is as hard to implement efficiently as\n`**`.\n\n* add assertion on regex pattern\n\n* Fix mypy\n\n* Simplify glob_to_regex\n\n* Inline the glob_to_regex helper function\n\nSigned-off-by: Dan Callahan <danc@element.io>\n\n* Moar comments\n\nSigned-off-by: Dan Callahan <danc@element.io>\n\nCo-authored-by: Dan Callahan <danc@element.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "push_rule_evaluator.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "3",
    "number_of_lines_deleted_vulnerable_to_cve": "52",
    "vulnerable_lines": [
        "// Line_Reference 186:             r1 = _re_word_boundary(r1)",
        "// Line_Reference 215:             r = _glob_to_re(glob, word_boundary)",
        "// Line_Reference 223: def _glob_to_re(glob: str, word_boundary: bool) -> Pattern:",
        "// Line_Reference 224:     \"\"\"Generates regex for a given glob.",
        "// Line_Reference 225: ",
        "// Line_Reference 226:     Args:",
        "// Line_Reference 227:         glob",
        "// Line_Reference 228:         word_boundary: Whether to match against word boundaries or entire string.",
        "// Line_Reference 229:     \"\"\"",
        "// Line_Reference 230:     if IS_GLOB.search(glob):",
        "// Line_Reference 231:         r = re.escape(glob)",
        "// Line_Reference 232: ",
        "// Line_Reference 233:         r = r.replace(r\"\\*\", \".*?\")",
        "// Line_Reference 234:         r = r.replace(r\"\\?\", \".\")",
        "// Line_Reference 235: ",
        "// Line_Reference 236:         # handle [abc], [a-z] and [!a-z] style ranges.",
        "// Line_Reference 237:         r = GLOB_REGEX.sub(",
        "// Line_Reference 238:             lambda x: (",
        "// Line_Reference 239:                 \"[%s%s]\" % (x.group(1) and \"^\" or \"\", x.group(2).replace(r\"\\\\\\-\", \"-\"))",
        "// Line_Reference 240:             ),",
        "// Line_Reference 241:             r,",
        "// Line_Reference 242:         )",
        "// Line_Reference 243:         if word_boundary:",
        "// Line_Reference 244:             r = _re_word_boundary(r)",
        "// Line_Reference 245: ",
        "// Line_Reference 246:             return re.compile(r, flags=re.IGNORECASE)",
        "// Line_Reference 247:         else:",
        "// Line_Reference 248:             r = \"^\" + r + \"$\"",
        "// Line_Reference 249: ",
        "// Line_Reference 250:             return re.compile(r, flags=re.IGNORECASE)",
        "// Line_Reference 251:     elif word_boundary:",
        "// Line_Reference 252:         r = re.escape(glob)",
        "// Line_Reference 253:         r = _re_word_boundary(r)",
        "// Line_Reference 254: ",
        "// Line_Reference 255:         return re.compile(r, flags=re.IGNORECASE)",
        "// Line_Reference 256:     else:",
        "// Line_Reference 257:         r = \"^\" + re.escape(glob) + \"$\"",
        "// Line_Reference 258:         return re.compile(r, flags=re.IGNORECASE)",
        "// Line_Reference 259: ",
        "// Line_Reference 260: ",
        "// Line_Reference 261: def _re_word_boundary(r: str) -> str:",
        "// Line_Reference 262:     \"\"\"",
        "// Line_Reference 263:     Adds word boundary characters to the start and end of an",
        "// Line_Reference 264:     expression to require that the match occur as a whole word,",
        "// Line_Reference 265:     but do so respecting the fact that strings starting or ending",
        "// Line_Reference 266:     with non-word characters will change word boundaries.",
        "// Line_Reference 267:     \"\"\"",
        "// Line_Reference 268:     # we can't use \\b as it chokes on unicode. however \\W seems to be okay",
        "// Line_Reference 269:     # as shorthand for [^0-9A-Za-z_].",
        "// Line_Reference 270:     return r\"(^|\\W)%s(\\W|$)\" % (r,)",
        "// Line_Reference 271: ",
        "// Line_Reference 272: "
    ]
}
