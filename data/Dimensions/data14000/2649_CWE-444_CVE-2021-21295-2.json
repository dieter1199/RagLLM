{
    "cve_id": "CVE-2021-21295",
    "cve_description": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel's pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.",
    "cve_publish_date": "2021-03-09",
    "cwe_id": "CWE-444",
    "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')",
    "cwe_description": "The product acts as an intermediary HTTP agent\n         (such as a proxy or firewall) in the data flow between two\n         entities such as a client and server, but it does not\n         interpret malformed HTTP requests or responses in ways that\n         are consistent with how the messages will be processed by\n         those entities that are at the ultimate destination.",
    "commit_message": "Merge pull request from GHSA-wm47-8v5p-wjpj\n\nMotivation:\n\nAs stated by https://tools.ietf.org/html/rfc7540#section-8.1.2.6 we should report a stream error if the content-length does not match the sum of all data frames.\n\nModifications:\n\n- Verify that the sum of data frames match if a content-length header was send.\n- Handle multiple content-length headers and also handle negative values\n- Add io.netty.http2.validateContentLength system property which allows to disable the more strict validation\n- Add unit tests\n\nResult:\n\nCorrectly handle the case when the content-length header was included but not match what is send and also when content-length header is invalid",
    "type_of_change": "Modification",
    "filename_of_changes": "HttpObjectDecoder.java",
    "code_language": "Java",
    "number_of_lines_added_for_mitigation": "7",
    "number_of_lines_deleted_vulnerable_to_cve": "41",
    "vulnerable_lines": [
        "// Line_Reference 19: import static io.netty.util.internal.StringUtil.COMMA;",
        "// Line_Reference 633: ",
        "// Line_Reference 637:             //",
        "// Line_Reference 638:             // If a message is received that has multiple Content-Length header",
        "// Line_Reference 639:             //   fields with field-values consisting of the same decimal value, or a",
        "// Line_Reference 640:             //   single Content-Length header field with a field value containing a",
        "// Line_Reference 641:             //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),",
        "// Line_Reference 642:             //   indicating that duplicate Content-Length header fields have been",
        "// Line_Reference 643:             //   generated or combined by an upstream message processor, then the",
        "// Line_Reference 644:             //   recipient MUST either reject the message as invalid or replace the",
        "// Line_Reference 645:             //   duplicated field-values with a single valid Content-Length field",
        "// Line_Reference 646:             //   containing that decimal value prior to determining the message body",
        "// Line_Reference 647:             //   length or forwarding the message.",
        "// Line_Reference 648:             boolean multipleContentLengths =",
        "// Line_Reference 649:                     contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;",
        "// Line_Reference 650:             if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {",
        "// Line_Reference 651:                 if (allowDuplicateContentLengths) {",
        "// Line_Reference 652:                     // Find and enforce that all Content-Length values are the same",
        "// Line_Reference 653:                     String firstValue = null;",
        "// Line_Reference 654:                     for (String field : contentLengthFields) {",
        "// Line_Reference 655:                         String[] tokens = COMMA_PATTERN.split(field, -1);",
        "// Line_Reference 656:                         for (String token : tokens) {",
        "// Line_Reference 657:                             String trimmed = token.trim();",
        "// Line_Reference 658:                             if (firstValue == null) {",
        "// Line_Reference 659:                                 firstValue = trimmed;",
        "// Line_Reference 660:                             } else if (!trimmed.equals(firstValue)) {",
        "// Line_Reference 661:                                 throw new IllegalArgumentException(",
        "// Line_Reference 662:                                         \"Multiple Content-Length values found: \" + contentLengthFields);",
        "// Line_Reference 663:                             }",
        "// Line_Reference 664:                         }",
        "// Line_Reference 665:                     }",
        "// Line_Reference 666:                     // Replace the duplicated field-values with a single valid Content-Length field",
        "// Line_Reference 667:                     headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);",
        "// Line_Reference 668:                     contentLength = Long.parseLong(firstValue);",
        "// Line_Reference 669:                 } else {",
        "// Line_Reference 670:                     // Reject the message as invalid",
        "// Line_Reference 671:                     throw new IllegalArgumentException(",
        "// Line_Reference 672:                             \"Multiple Content-Length values found: \" + contentLengthFields);",
        "// Line_Reference 673:                 }",
        "// Line_Reference 674:             } else {",
        "// Line_Reference 675:                 contentLength = Long.parseLong(contentLengthFields.get(0));"
    ]
}
