{
    "cve_id": "CVE-2019-11940",
    "cve_description": "In the course of decompressing HPACK inside the HTTP2 protocol, an unexpected sequence of header table resize operations can place the header table into a corrupted state, leading to a use-after-free condition and undefined behavior. This issue affects Proxygen from v0.29.0 until v2017.04.03.00.",
    "cve_publish_date": "2019-12-04",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "Fixing HPACK header table resize issue\n\nSummary: On resizing the header table down and then up again, a resize can be called against the underlying vector that actually sizes it down.  This causes a lot of things to break as the code that does the resizing assumes the underlying vector is only ever resized up.\n\nReviewed By: afrind\n\nDifferential Revision: D4613681\n\nfbshipit-source-id: 35b61cab53d5bc097424d6c779f90b7fdea42002",
    "type_of_change": "Modification",
    "filename_of_changes": "HeaderTable.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "31",
    "number_of_lines_deleted_vulnerable_to_cve": "19",
    "vulnerable_lines": [
        "// Line_Reference 139:   if (capacity_ <= oldCapacity) {",
        "// Line_Reference 142:     auto oldTail = tail();",
        "// Line_Reference 143:     auto oldLength = table_.size();",
        "// Line_Reference 145:     table_.resize(newLength);",
        "// Line_Reference 146:     if (size_ > 0 && oldTail > head_) {",
        "// Line_Reference 147:       // the list wrapped around, need to move oldTail..oldLength to the end of",
        "// Line_Reference 148:       // the now-larger table_",
        "// Line_Reference 149:       std::copy(table_.begin() + oldTail, table_.begin() + oldLength,",
        "// Line_Reference 150:                 table_.begin() + newLength - (oldLength - oldTail));",
        "// Line_Reference 151:       // Update the names indecies that pointed to the old range",
        "// Line_Reference 152:       for (auto& names_it: names_) {",
        "// Line_Reference 153:         for (auto& idx: names_it.second) {",
        "// Line_Reference 154:           if (idx >= oldTail) {",
        "// Line_Reference 155:             DCHECK_LT(idx + (table_.size() - oldLength), table_.size());",
        "// Line_Reference 156:             idx += (table_.size() - oldLength);",
        "// Line_Reference 157:           } else {",
        "// Line_Reference 158:             // remaining indecies in the list were smaller than oldTail, so",
        "// Line_Reference 159:             // should be indexed from 0",
        "// Line_Reference 160:             break;"
    ]
}
