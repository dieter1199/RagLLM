use std::mem::ManuallyDrop;
inline: ManuallyDrop<A>,
unsafe fn inline(&self) -> &A {
&self.inline
unsafe fn inline_mut(&mut self) -> &mut A {
&mut self.inline
fn from_inline(inline: A) -> SmallVecData<A> {
SmallVecData { inline: ManuallyDrop::new(inline) }
unsafe fn into_inline(self) -> A { ManuallyDrop::into_inner(self.inline) }
Inline(ManuallyDrop<A>),
unsafe fn inline(&self) -> &A {
SmallVecData::Inline(ref a) => a,
unsafe fn inline_mut(&mut self) -> &mut A {
SmallVecData::Inline(ref mut a) => a,
fn from_inline(inline: A) -> SmallVecData<A> {
SmallVecData::Inline(ManuallyDrop::new(inline))
unsafe fn into_inline(self) -> A {
SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),
unsafe {
SmallVec {
capacity: 0,
data: SmallVecData::from_inline(mem::uninitialized()),
}
let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());
ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);
data: SmallVecData::from_inline(buf),
data: SmallVecData::from_inline(buf),
(self.data.inline().ptr(), self.capacity, A::size())
(self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())
self.data = SmallVecData::from_inline(mem::uninitialized());
ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
self.data = SmallVecData::from_inline(mem::uninitialized());
ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
Ok(data.into_inline())
let mut data: A = mem::uninitialized();
ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);
fn ptr(&self) -> *const T { self.as_ptr() }
fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }
#[cfg(feature = "std")]