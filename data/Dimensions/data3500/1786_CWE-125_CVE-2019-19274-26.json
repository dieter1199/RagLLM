{
    "cve_id": "CVE-2019-19274",
    "cve_description": "typed_ast 1.3.0 and 1.3.1 has a handle_keywordonly_args out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)",
    "cve_publish_date": "2019-11-26",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Fully incorporate the code from Python 3.7.2 (#78)\n\nThis is a full port, following the recipe in update_process.md. I've also tried to keep the recipe up to date and improved the automation (see tools/script). I haven't cleaned up the commits. As of #77 there are a few tests that sanity-check this (though it's far from a full test suite), and they're run by Travis-CI and AppVeyor.",
    "type_of_change": "Modification",
    "filename_of_changes": "tokenizer.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "29",
    "number_of_lines_deleted_vulnerable_to_cve": "43",
    "vulnerable_lines": [
        "// Line_Reference 43: #if PY_MINOR_VERSION >= 4",
        "// Line_Reference 45: #else",
        "// Line_Reference 46: // Python 3.3 doesn't have PyAPI_FUNC, but it's not supported on Windows anyway.",
        "// Line_Reference 47: char *PyOS_Readline(FILE *, FILE *, char *);",
        "// Line_Reference 48: #endif",
        "// Line_Reference 155:     tok->altwarning = 1;",
        "// Line_Reference 156:     tok->alterror = 1;",
        "// Line_Reference 157:     tok->alttabsize = 1;",
        "// Line_Reference 463:         bufobj = PyObject_CallObject(tok->decoding_readline, NULL);",
        "// Line_Reference 556:         PyObject *bufobj = PyObject_CallObject(readline, NULL);",
        "// Line_Reference 673:             buf = PyObject_CallObject(tok->decoding_readline, NULL);",
        "// Line_Reference 1309:     if (tok->alterror) {",
        "// Line_Reference 1310:         tok->done = E_TABSPACE;",
        "// Line_Reference 1311:         tok->cur = tok->inp;",
        "// Line_Reference 1312:         return 1;",
        "// Line_Reference 1313:     }",
        "// Line_Reference 1314:     if (tok->altwarning) {",
        "// Line_Reference 1315: #ifdef PGEN",
        "// Line_Reference 1316:         PySys_WriteStderr(\"inconsistent use of tabs and spaces \"",
        "// Line_Reference 1317:                           \"in indentation\\n\");",
        "// Line_Reference 1318: #else",
        "// Line_Reference 1319:         PySys_FormatStderr(\"%U: inconsistent use of tabs and spaces \"",
        "// Line_Reference 1320:                           \"in indentation\\n\", tok->filename);",
        "// Line_Reference 1321: #endif",
        "// Line_Reference 1322:         tok->altwarning = 0;",
        "// Line_Reference 1323:     }",
        "// Line_Reference 1324:     return 0;",
        "// Line_Reference 1404:                 col = (col/tok->tabsize + 1) * tok->tabsize;",
        "// Line_Reference 1405:                 altcol = (altcol/tok->alttabsize + 1)",
        "// Line_Reference 1406:                     * tok->alttabsize;",
        "// Line_Reference 1435:                     if (indenterror(tok)) {",
        "// Line_Reference 1436:                         return ERRORTOKEN;",
        "// Line_Reference 1437:                     }",
        "// Line_Reference 1448:                     if (indenterror(tok)) {",
        "// Line_Reference 1449:                         return ERRORTOKEN;",
        "// Line_Reference 1450:                     }",
        "// Line_Reference 1469:                     if (indenterror(tok)) {",
        "// Line_Reference 1470:                         return ERRORTOKEN;",
        "// Line_Reference 1471:                     }",
        "// Line_Reference 1577:         /* Process b\"\", r\"\", u\"\", br\"\" and rb\"\" */",
        "// Line_Reference 1619:             if (tok->async_def) {",
        "// Line_Reference 1991: #if PY_MINOR_VERSION >= 4",
        "// Line_Reference 1993: #endif"
    ]
}
