{
    "cve_id": "CVE-2022-24791",
    "cve_description": "Wasmtime is a standalone JIT-style runtime for WebAssembly, using Cranelift. There is a use after free vulnerability in Wasmtime when both running Wasm that uses externrefs and enabling epoch interruption in Wasmtime. If you are not explicitly enabling epoch interruption (it is disabled by default) then you are not affected. If you are explicitly disabling the Wasm reference types proposal (it is enabled by default) then you are also not affected. The use after free is caused by Cranelift failing to emit stack maps when there are safepoints inside cold blocks. Cold blocks occur when epoch interruption is enabled. Cold blocks are emitted at the end of compiled functions, and change the order blocks are emitted versus defined. This reordering accidentally caused Cranelift to skip emitting some stack maps because it expected to emit the stack maps in block definition order, rather than block emission order. When Wasmtime would eventually collect garbage, it would fail to find live references on the stack because of the missing stack maps, think that they were unreferenced garbage, and therefore reclaim them. Then after the collection ended, the Wasm code could use the reclaimed-too-early references, which is a use after free. Patches have been released in versions 0.34.2 and 0.35.2, which fix the vulnerability. All Wasmtime users are recommended to upgrade to these patched versions. If upgrading is not an option for you at this time, you can avoid the vulnerability by either: disabling the Wasm reference types proposal, config.wasm_reference_types(false); or by disabling epoch interruption if you were previously enabling it. config.epoch_interruption(false).",
    "cve_publish_date": "2022-03-31",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "Merge pull request from GHSA-gwc9-348x-qwv2\n\n* Run the GC smoketest with epoch support enabled as well.\n\n* Handle safepoints in cold blocks properly.\n\nCurrently, the way that we find safepoint slots for a given instruction\nrelies on the instruction index order in the safepoint list matching the\norder of instruction emission.\n\nPrevious to the introduction of cold-block support, this was trivially\nsatisfied by sorting the safepoint list: we emit instructions 0, 1, 2,\n3, 4, ..., and so if we have safepoints at instructions 1 and 4, we will\nencounter them in that order.\n\nHowever, cold blocks are supported by swizzling the emission order at\nthe last moment (to avoid having to renumber instructions partway\nthrough the compilation pipeline), so we actually emit instructions out\nof index order when cold blocks are present.\n\nReference-type support in Wasm in particular uses cold blocks for\nslowpaths, and has live refs and safepoints in these slowpaths, so we\ncan reliably \"skip\" a safepoint (not emit any metadata for it) in the\npresence of reftype usage.\n\nThis PR fixes the emission code by building a map from instruction index\nto safepoint index first, then doing lookups through this map, rather\nthan following along in-order as it emits instructions.",
    "type_of_change": "Modification",
    "filename_of_changes": "funcref.rs",
    "code_language": "Rust",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 63:         let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;"
    ]
}
