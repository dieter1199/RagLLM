{
    "cve_id": "CVE-2024-27102",
    "cve_description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-13",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "server(filesystem): rebuild everything imaginable\n\nThis wonderfully large commit replaces basically everything under the\n`server/filesystem` package, re-implementing essentially everything.\n\nThis is related to\nhttps://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9\n\nIf any vulnerabilities related to symlinks persist after this commit, I\nwill be very upset.\n\nSigned-off-by: Matthew Penner <me@matthewp.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "parser.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "130",
    "number_of_lines_deleted_vulnerable_to_cve": "116",
    "vulnerable_lines": [
        "// Line_Reference 5: \t\"os\"",
        "// Line_Reference 6: \t\"path/filepath\"",
        "// Line_Reference 170: // Parses a given configuration file and updates all of the values within as defined",
        "// Line_Reference 171: // in the API response from the Panel.",
        "// Line_Reference 172: func (f *ConfigurationFile) Parse(path string, internal bool) error {",
        "// Line_Reference 173: \tlog.WithField(\"path\", path).WithField(\"parser\", f.Parser.String()).Debug(\"parsing server configuration file\")",
        "// Line_Reference 185: \t\terr = f.parsePropertiesFile(path)",
        "// Line_Reference 186: \t\tbreak",
        "// Line_Reference 188: \t\terr = f.parseTextFile(path)",
        "// Line_Reference 189: \t\tbreak",
        "// Line_Reference 191: \t\terr = f.parseYamlFile(path)",
        "// Line_Reference 192: \t\tbreak",
        "// Line_Reference 194: \t\terr = f.parseJsonFile(path)",
        "// Line_Reference 195: \t\tbreak",
        "// Line_Reference 197: \t\terr = f.parseIniFile(path)",
        "// Line_Reference 198: \t\tbreak",
        "// Line_Reference 200: \t\terr = f.parseXmlFile(path)",
        "// Line_Reference 201: \t\tbreak",
        "// Line_Reference 203: ",
        "// Line_Reference 204: \tif errors.Is(err, os.ErrNotExist) {",
        "// Line_Reference 205: \t\t// File doesn't exist, we tried creating it, and same error is returned? Pretty",
        "// Line_Reference 206: \t\t// sure this pathway is impossible, but if not, abort here.",
        "// Line_Reference 207: \t\tif internal {",
        "// Line_Reference 208: \t\t\treturn nil",
        "// Line_Reference 209: \t\t}",
        "// Line_Reference 210: ",
        "// Line_Reference 211: \t\tb := strings.TrimSuffix(path, filepath.Base(path))",
        "// Line_Reference 212: \t\tif err := os.MkdirAll(b, 0o755); err != nil {",
        "// Line_Reference 213: \t\t\treturn errors.WithMessage(err, \"failed to create base directory for missing configuration file\")",
        "// Line_Reference 214: \t\t} else {",
        "// Line_Reference 215: \t\t\tif _, err := os.Create(path); err != nil {",
        "// Line_Reference 216: \t\t\t\treturn errors.WithMessage(err, \"failed to create missing configuration file\")",
        "// Line_Reference 217: \t\t\t}",
        "// Line_Reference 218: \t\t}",
        "// Line_Reference 219: ",
        "// Line_Reference 220: \t\treturn f.Parse(path, true)",
        "// Line_Reference 221: \t}",
        "// Line_Reference 222: ",
        "// Line_Reference 227: func (f *ConfigurationFile) parseXmlFile(path string) error {",
        "// Line_Reference 229: \tfile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)",
        "// Line_Reference 230: \tif err != nil {",
        "// Line_Reference 231: \t\treturn err",
        "// Line_Reference 232: \t}",
        "// Line_Reference 233: \tdefer file.Close()",
        "// Line_Reference 234: ",
        "// Line_Reference 294: \t// If you don't truncate the file you'll end up duplicating the data in there (or just appending",
        "// Line_Reference 295: \t// to the end of the file. We don't want to do that.",
        "// Line_Reference 300: \t// Move the cursor to the start of the file to avoid weird spacing issues.",
        "// Line_Reference 301: \tfile.Seek(0, 0)",
        "// Line_Reference 302: ",
        "// Line_Reference 306: \t// Truncate the file before attempting to write the changes.",
        "// Line_Reference 307: \tif err := os.Truncate(path, 0); err != nil {",
        "// Line_Reference 310: ",
        "// Line_Reference 311: \t// Write the XML to the file.",
        "// Line_Reference 312: \t_, err = doc.WriteTo(file)",
        "// Line_Reference 313: ",
        "// Line_Reference 314: \treturn err",
        "// Line_Reference 318: func (f *ConfigurationFile) parseIniFile(path string) error {",
        "// Line_Reference 319: \t// Ini package can't handle a non-existent file, so handle that automatically here",
        "// Line_Reference 320: \t// by creating it if not exists. Then, immediately close the file since we will use",
        "// Line_Reference 321: \t// other methods to write the new contents.",
        "// Line_Reference 322: \tfile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)",
        "// Line_Reference 323: \tif err != nil {",
        "// Line_Reference 324: \t\treturn err",
        "// Line_Reference 325: \t}",
        "// Line_Reference 326: \tfile.Close()",
        "// Line_Reference 327: ",
        "// Line_Reference 328: \tcfg, err := ini.Load(path)",
        "// Line_Reference 391: \treturn cfg.SaveTo(path)",
        "// Line_Reference 397: func (f *ConfigurationFile) parseJsonFile(path string) error {",
        "// Line_Reference 398: \tb, err := readFileBytes(path)",
        "// Line_Reference 408: \toutput := []byte(data.StringIndent(\"\", \"    \"))",
        "// Line_Reference 409: \treturn os.WriteFile(path, output, 0o644)",
        "// Line_Reference 414: func (f *ConfigurationFile) parseYamlFile(path string) error {",
        "// Line_Reference 415: \tb, err := readFileBytes(path)",
        "// Line_Reference 446: \treturn os.WriteFile(path, marshaled, 0o644)",
        "// Line_Reference 452: func (f *ConfigurationFile) parseTextFile(path string) error {",
        "// Line_Reference 453: \tinput, err := os.ReadFile(path)",
        "// Line_Reference 454: \tif err != nil {",
        "// Line_Reference 455: \t\treturn err",
        "// Line_Reference 456: \t}",
        "// Line_Reference 457: ",
        "// Line_Reference 458: \tlines := strings.Split(string(input), \"\\n\")",
        "// Line_Reference 459: \tfor i, line := range lines {",
        "// Line_Reference 463: \t\t\tif !strings.HasPrefix(line, replace.Match) {",
        "// Line_Reference 466: ",
        "// Line_Reference 467: \t\t\tlines[i] = replace.ReplaceWith.String()",
        "// Line_Reference 471: \tif err := os.WriteFile(path, []byte(strings.Join(lines, \"\\n\")), 0o644); err != nil {",
        "// Line_Reference 504: func (f *ConfigurationFile) parsePropertiesFile(path string) error {",
        "// Line_Reference 505: \tvar s strings.Builder",
        "// Line_Reference 506: \t// Open the file and attempt to load any comments that currenty exist at the start",
        "// Line_Reference 507: \t// of the file. This is kind of a hack, but should work for a majority of users for",
        "// Line_Reference 508: \t// the time being.",
        "// Line_Reference 509: \tif fd, err := os.Open(path); err != nil {",
        "// Line_Reference 510: \t\treturn errors.Wrap(err, \"parser: could not open file for reading\")",
        "// Line_Reference 511: \t} else {",
        "// Line_Reference 512: \t\tscanner := bufio.NewScanner(fd)",
        "// Line_Reference 513: \t\t// Scan until we hit a line that is not a comment that actually has content",
        "// Line_Reference 514: \t\t// on it. Keep appending the comments until that time.",
        "// Line_Reference 515: \t\tfor scanner.Scan() {",
        "// Line_Reference 516: \t\t\ttext := scanner.Text()",
        "// Line_Reference 517: \t\t\tif len(text) > 0 && text[0] != '#' {",
        "// Line_Reference 518: \t\t\t\tbreak",
        "// Line_Reference 519: \t\t\t}",
        "// Line_Reference 520: \t\t\ts.WriteString(text + \"\\n\")",
        "// Line_Reference 521: \t\t}",
        "// Line_Reference 522: \t\t_ = fd.Close()",
        "// Line_Reference 523: \t\tif err := scanner.Err(); err != nil {",
        "// Line_Reference 524: \t\t\treturn errors.WithStackIf(err)",
        "// Line_Reference 528: \tp, err := properties.LoadFile(path, properties.UTF8)",
        "// Line_Reference 566: \t// Open the file for writing.",
        "// Line_Reference 567: \tw, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)",
        "// Line_Reference 568: \tif err != nil {",
        "// Line_Reference 571: \tdefer w.Close()",
        "// Line_Reference 574: \tif _, err := w.Write([]byte(s.String())); err != nil {",
        "// Line_Reference 577: "
    ]
}
