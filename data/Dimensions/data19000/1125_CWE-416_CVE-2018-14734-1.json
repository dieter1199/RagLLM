{
    "cve_id": "CVE-2018-14734",
    "cve_description": "drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free).",
    "cve_publish_date": "2018-07-29",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "infiniband: fix a possible use-after-free bug\n\nucma_process_join() will free the new allocated \"mc\" struct,\nif there is any error after that, especially the copy_to_user().\n\nBut in parallel, ucma_leave_multicast() could find this \"mc\"\nthrough idr_find() before ucma_process_join() frees it, since it\nis already published.\n\nSo \"mc\" could be used in ucma_leave_multicast() after it is been\nallocated and freed in ucma_process_join(), since we don't refcnt\nit.\n\nFix this by separating \"publish\" from ID allocation, so that we\ncan get an ID first and publish it later after copy_to_user().\n\nFixes: c8f6a362bf3e (\"RDMA/cma: Add multicast communication support\")\nReported-by: Noam Rathaus <noamr@beyondsecurity.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: Jason Gunthorpe <jgg@mellanox.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "ucma.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "5",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 238: \tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);"
    ]
}
