{
    "cve_id": "CVE-2017-18232",
    "cve_description": "The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code.",
    "cve_publish_date": "2018-03-15",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "scsi: libsas: direct call probe and destruct\n\nIn commit 87c8331fcf72 (\"[SCSI] libsas: prevent domain rediscovery\ncompeting with ata error handling\") introduced disco mutex to prevent\nrediscovery competing with ata error handling and put the whole\nrevalidation in the mutex. But the rphy add/remove needs to wait for the\nerror handling which also grabs the disco mutex. This may leads to dead\nlock.So the probe and destruct event were introduce to do the rphy\nadd/remove asynchronously and out of the lock.\n\nThe asynchronously processed workers makes the whole discovery process\nnot atomic, the other events may interrupt the process. For example,\nif a loss of signal event inserted before the probe event, the\nsas_deform_port() is called and the port will be deleted.\n\nAnd sas_port_delete() may run before the destruct event, but the\nport-x:x is the top parent of end device or expander. This leads to\na kernel WARNING such as:\n\n[   82.042979] sysfs group 'power' not found for kobject 'phy-1:0:22'\n[   82.042983] ------------[ cut here ]------------\n[   82.042986] WARNING: CPU: 54 PID: 1714 at fs/sysfs/group.c:237\nsysfs_remove_group+0x94/0xa0\n[   82.043059] Call trace:\n[   82.043082] [<ffff0000082e7624>] sysfs_remove_group+0x94/0xa0\n[   82.043085] [<ffff00000864e320>] dpm_sysfs_remove+0x60/0x70\n[   82.043086] [<ffff00000863ee10>] device_del+0x138/0x308\n[   82.043089] [<ffff00000869a2d0>] sas_phy_delete+0x38/0x60\n[   82.043091] [<ffff00000869a86c>] do_sas_phy_delete+0x6c/0x80\n[   82.043093] [<ffff00000863dc20>] device_for_each_child+0x58/0xa0\n[   82.043095] [<ffff000008696f80>] sas_remove_children+0x40/0x50\n[   82.043100] [<ffff00000869d1bc>] sas_destruct_devices+0x64/0xa0\n[   82.043102] [<ffff0000080e93bc>] process_one_work+0x1fc/0x4b0\n[   82.043104] [<ffff0000080e96c0>] worker_thread+0x50/0x490\n[   82.043105] [<ffff0000080f0364>] kthread+0xfc/0x128\n[   82.043107] [<ffff0000080836c0>] ret_from_fork+0x10/0x50\n\nMake probe and destruct a direct call in the disco and revalidate function,\nbut put them outside the lock. The whole discovery or revalidate won't\nbe interrupted by other events. And the DISCE_PROBE and DISCE_DESTRUCT\nevent are deleted as a result of the direct call.\n\nIntroduce a new list to destruct the sas_port and put the port delete after\nthe destruct. This makes sure the right order of destroying the sysfs\nkobject and fix the warning above.\n\nIn sas_ex_revalidate_domain() have a loop to find all broadcasted\ndevice, and sometimes we have a chance to find the same expander twice.\nBecause the sas_port will be deleted at the end of the whole revalidate\nprocess, sas_port with the same name cannot be added before this.\nOtherwise the sysfs will complain of creating duplicate filename. Since\nthe LLDD will send broadcast for every device change, we can only\nprocess one expander's revalidation.\n\n[mkp: kbuild test robot warning]\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: Johannes Thumshirn <jthumshirn@suse.de>\nCC: Ewan Milne <emilne@redhat.com>\nCC: Christoph Hellwig <hch@lst.de>\nCC: Tomas Henzl <thenzl@redhat.com>\nCC: Dan Williams <dan.j.williams@intel.com>\nReviewed-by: Hannes Reinecke <hare@suse.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "sas_discover.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "18",
    "number_of_lines_deleted_vulnerable_to_cve": "14",
    "vulnerable_lines": [
        "// Line_Reference 215: static void sas_probe_devices(struct work_struct *work)",
        "// Line_Reference 218: \tstruct sas_discovery_event *ev = to_sas_discovery_event(work);",
        "// Line_Reference 219: \tstruct asd_sas_port *port = ev->port;",
        "// Line_Reference 220: ",
        "// Line_Reference 221: \tclear_bit(DISCE_PROBE, &port->disc.pending);",
        "// Line_Reference 297: \tsas_discover_event(dev->port, DISCE_PROBE);",
        "// Line_Reference 356: static void sas_destruct_devices(struct work_struct *work)",
        "// Line_Reference 359: \tstruct sas_discovery_event *ev = to_sas_discovery_event(work);",
        "// Line_Reference 360: \tstruct asd_sas_port *port = ev->port;",
        "// Line_Reference 361: ",
        "// Line_Reference 362: \tclear_bit(DISCE_DESTRUCT, &port->disc.pending);",
        "// Line_Reference 387: \t\tsas_discover_event(dev->port, DISCE_DESTRUCT);",
        "// Line_Reference 581: \t\t[DISCE_PROBE] = sas_probe_devices,",
        "// Line_Reference 584: \t\t[DISCE_DESTRUCT] = sas_destruct_devices,"
    ]
}
