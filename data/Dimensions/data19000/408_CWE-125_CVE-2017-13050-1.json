{
    "cve_id": "CVE-2017-13050",
    "cve_description": "The RPKI-Router parser in tcpdump before 4.9.2 has a buffer over-read in print-rpki-rtr.c:rpki_rtr_pdu_print().",
    "cve_publish_date": "2017-09-14",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "CVE-2017-13050/RPKI-Router: fix a few bugs\n\nThe decoder didn't properly check that the PDU length stored in the PDU\nheader is correct. The only check in place was in rpki_rtr_print() and it\ntested whether the length is zero but that is not sufficient. Make all\nnecessary length and bounds checks, both generic and type-specific, in\nrpki_rtr_pdu_print() and reduce rpki_rtr_print() to a simple loop.\n\nThis also fixes a minor bug and PDU type 0 (Serial Notify from RFC 6810\nSection 5.2) is valid again.\n\nIn rpki_rtr_pdu_print() any protocol version was considered version 0,\nfix it to skip the rest of input if the PDU protocol version is unknown.\n\nIbid, the PDU type 10 (Error Report from RFC 6810 Section 5.10) case\nblock didn't consider the \"Length of Error Text\" data element mandatory,\nput it right.\n\nIbid, when printing an encapsulated PDU, give itself (via recursion)\nrespective buffer length to make it possible to tell whether the\nencapsulated PDU fits. Do not recurse deeper than 2nd level.\n\nUpdate prior RPKI-Router test cases that now stop to decode earlier\nbecause of the stricter checks.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
    "type_of_change": "Modification",
    "filename_of_changes": "print-rpki-rtr.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "103",
    "number_of_lines_deleted_vulnerable_to_cve": "66",
    "vulnerable_lines": [
        "// Line_Reference 174: static int",
        "// Line_Reference 175: rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)",
        "// Line_Reference 184:     ND_TCHECK2(*tptr, pdu_len);",
        "// Line_Reference 258: \t    ND_TCHECK2(*tptr, encapsulated_pdu_length);",
        "// Line_Reference 259: \t    tlen = pdu_len;",
        "// Line_Reference 267: \t    tptr += sizeof(*pdu);",
        "// Line_Reference 268: \t    tlen -= sizeof(*pdu);",
        "// Line_Reference 269: ",
        "// Line_Reference 270: \t    /*",
        "// Line_Reference 271: \t     * Recurse if there is an encapsulated PDU.",
        "// Line_Reference 272: \t     */",
        "// Line_Reference 273: \t    if (encapsulated_pdu_length &&",
        "// Line_Reference 274: \t\t(encapsulated_pdu_length <= tlen)) {",
        "// Line_Reference 275: \t\tND_PRINT((ndo, \"%s-----encapsulated PDU-----\", indent_string(indent+4)));",
        "// Line_Reference 276: \t\tif (rpki_rtr_pdu_print(ndo, tptr, indent+2))",
        "// Line_Reference 277: \t\t\tgoto trunc;",
        "// Line_Reference 280: \t    tptr += encapsulated_pdu_length;",
        "// Line_Reference 281: \t    tlen -= encapsulated_pdu_length;",
        "// Line_Reference 286: \t    text_length = 0;",
        "// Line_Reference 287: \t    if (tlen > 4) {",
        "// Line_Reference 288: \t\ttext_length = EXTRACT_32BITS(tptr);",
        "// Line_Reference 289: \t\ttptr += 4;",
        "// Line_Reference 290: \t\ttlen -= 4;",
        "// Line_Reference 291: \t    }",
        "// Line_Reference 292: \t    ND_TCHECK2(*tptr, text_length);",
        "// Line_Reference 293: \t    if (text_length && (text_length <= tlen )) {",
        "// Line_Reference 295: \t\tif (fn_printn(ndo, tptr, text_length, ndo->ndo_snapend))",
        "// Line_Reference 313:     return 0;",
        "// Line_Reference 316:     return 1;",
        "// Line_Reference 322:     u_int tlen, pdu_type, pdu_len;",
        "// Line_Reference 323:     const u_char *tptr;",
        "// Line_Reference 324:     const rpki_rtr_pdu *pdu_header;",
        "// Line_Reference 325: ",
        "// Line_Reference 326:     tptr = pptr;",
        "// Line_Reference 327:     tlen = len;",
        "// Line_Reference 328: ",
        "// Line_Reference 333: ",
        "// Line_Reference 334:     while (tlen >= sizeof(rpki_rtr_pdu)) {",
        "// Line_Reference 335: ",
        "// Line_Reference 336:         ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));",
        "// Line_Reference 337: ",
        "// Line_Reference 338: \tpdu_header = (const rpki_rtr_pdu *)tptr;",
        "// Line_Reference 339:         pdu_type = pdu_header->pdu_type;",
        "// Line_Reference 340:         pdu_len = EXTRACT_32BITS(pdu_header->length);",
        "// Line_Reference 341:         ND_TCHECK2(*tptr, pdu_len);",
        "// Line_Reference 342: ",
        "// Line_Reference 343:         /* infinite loop check */",
        "// Line_Reference 344:         if (!pdu_type || !pdu_len) {",
        "// Line_Reference 345:             break;",
        "// Line_Reference 346:         }",
        "// Line_Reference 347: ",
        "// Line_Reference 348:         if (tlen < pdu_len) {",
        "// Line_Reference 349:             goto trunc;",
        "// Line_Reference 350:         }",
        "// Line_Reference 351: ",
        "// Line_Reference 352: \t/*",
        "// Line_Reference 353: \t * Print the PDU.",
        "// Line_Reference 354: \t */",
        "// Line_Reference 355: \tif (rpki_rtr_pdu_print(ndo, tptr, 8))",
        "// Line_Reference 356: \t\tgoto trunc;",
        "// Line_Reference 357: ",
        "// Line_Reference 358:         tlen -= pdu_len;",
        "// Line_Reference 359:         tptr += pdu_len;",
        "// Line_Reference 361:     return;",
        "// Line_Reference 362: trunc:",
        "// Line_Reference 363:     ND_PRINT((ndo, \"\\n\\t%s\", tstr));"
    ]
}
