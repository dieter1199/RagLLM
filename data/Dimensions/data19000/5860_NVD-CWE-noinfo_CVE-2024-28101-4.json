{
    "cve_id": "CVE-2024-28101",
    "cve_description": "The Apollo Router is a graph router written in Rust to run a federated supergraph that uses Apollo Federation. Versions 0.9.5 until 1.40.2 are subject to a Denial-of-Service (DoS) type vulnerability. When receiving compressed HTTP payloads, affected versions of the Router evaluate the `limits.http_max_request_bytes` configuration option after the entirety of the compressed payload is decompressed. If affected versions of the Router receive highly compressed payloads, this could result in significant memory consumption while the compressed payload is expanded. Router version 1.40.2 has a fix for the vulnerability. Those who are unable to upgrade may be able to implement mitigations at proxies or load balancers positioned in front of their Router fleet (e.g. Nginx, HAProxy, or cloud-native WAF services) by creating limits on HTTP body upload size. \n",
    "cve_publish_date": "2024-03-21",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "streaming body decompression\n\nClient request body was fully loaded in memory before decompressing, we\nare now decompressing it as it goes",
    "type_of_change": "Modification",
    "filename_of_changes": "utils.rs",
    "code_language": "Rust",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "88",
    "vulnerable_lines": [
        "// Line_Reference 5: use async_compression::tokio::write::BrotliDecoder;",
        "// Line_Reference 6: use async_compression::tokio::write::GzipDecoder;",
        "// Line_Reference 7: use async_compression::tokio::write::ZlibDecoder;",
        "// Line_Reference 8: use axum::http::StatusCode;",
        "// Line_Reference 9: use axum::middleware::Next;",
        "// Line_Reference 10: use axum::response::*;",
        "// Line_Reference 11: use futures::prelude::*;",
        "// Line_Reference 12: use http::header::CONTENT_ENCODING;",
        "// Line_Reference 13: use http::Request;",
        "// Line_Reference 14: use hyper::Body;",
        "// Line_Reference 17: use tokio::io::AsyncWriteExt;",
        "// Line_Reference 29: pub(super) async fn decompress_request_body(",
        "// Line_Reference 30:     req: Request<Body>,",
        "// Line_Reference 31:     next: Next<Body>,",
        "// Line_Reference 32: ) -> Result<Response, Response> {",
        "// Line_Reference 33:     let (parts, body) = req.into_parts();",
        "// Line_Reference 34:     let content_encoding = parts.headers.get(&CONTENT_ENCODING);",
        "// Line_Reference 35:     macro_rules! decode_body {",
        "// Line_Reference 36:         ($decoder: ident, $error_message: expr) => {{",
        "// Line_Reference 37:             let body_bytes = hyper::body::to_bytes(body)",
        "// Line_Reference 38:                 .map_err(|err| {",
        "// Line_Reference 39:                     (",
        "// Line_Reference 40:                         StatusCode::BAD_REQUEST,",
        "// Line_Reference 41:                         format!(\"cannot read request body: {err}\"),",
        "// Line_Reference 42:                     )",
        "// Line_Reference 43:                         .into_response()",
        "// Line_Reference 44:                 })",
        "// Line_Reference 45:                 .await?;",
        "// Line_Reference 46:             let mut decoder = $decoder::new(Vec::new());",
        "// Line_Reference 47:             decoder.write_all(&body_bytes).await.map_err(|err| {",
        "// Line_Reference 48:                 (",
        "// Line_Reference 49:                     StatusCode::BAD_REQUEST,",
        "// Line_Reference 50:                     format!(\"{}: {err}\", $error_message),",
        "// Line_Reference 51:                 )",
        "// Line_Reference 52:                     .into_response()",
        "// Line_Reference 53:             })?;",
        "// Line_Reference 54:             decoder.shutdown().await.map_err(|err| {",
        "// Line_Reference 55:                 (",
        "// Line_Reference 56:                     StatusCode::BAD_REQUEST,",
        "// Line_Reference 57:                     format!(\"{}: {err}\", $error_message),",
        "// Line_Reference 58:                 )",
        "// Line_Reference 59:                     .into_response()",
        "// Line_Reference 60:             })?;",
        "// Line_Reference 61: ",
        "// Line_Reference 62:             Ok(next",
        "// Line_Reference 63:                 .run(Request::from_parts(parts, Body::from(decoder.into_inner())))",
        "// Line_Reference 64:                 .await)",
        "// Line_Reference 65:         }};",
        "// Line_Reference 66:     }",
        "// Line_Reference 67: ",
        "// Line_Reference 68:     match content_encoding {",
        "// Line_Reference 69:         Some(content_encoding) => match content_encoding.to_str() {",
        "// Line_Reference 70:             Ok(content_encoding_str) => match content_encoding_str {",
        "// Line_Reference 71:                 \"br\" => decode_body!(BrotliDecoder, \"cannot decompress (brotli) request body\"),",
        "// Line_Reference 72:                 \"gzip\" => decode_body!(GzipDecoder, \"cannot decompress (gzip) request body\"),",
        "// Line_Reference 73:                 \"deflate\" => decode_body!(ZlibDecoder, \"cannot decompress (deflate) request body\"),",
        "// Line_Reference 74:                 \"identity\" => Ok(next.run(Request::from_parts(parts, body)).await),",
        "// Line_Reference 75:                 unknown => {",
        "// Line_Reference 76:                     let message = format!(\"unknown content-encoding header value {unknown:?}\");",
        "// Line_Reference 77:                     tracing::error!(message);",
        "// Line_Reference 78:                     u64_counter!(",
        "// Line_Reference 79:                         \"apollo_router_http_requests_total\",",
        "// Line_Reference 80:                         \"Total number of HTTP requests made.\",",
        "// Line_Reference 81:                         1,",
        "// Line_Reference 82:                         status = StatusCode::BAD_REQUEST.as_u16() as i64,",
        "// Line_Reference 83:                         error = message.clone()",
        "// Line_Reference 84:                     );",
        "// Line_Reference 85: ",
        "// Line_Reference 86:                     Err((StatusCode::BAD_REQUEST, message).into_response())",
        "// Line_Reference 87:                 }",
        "// Line_Reference 88:             },",
        "// Line_Reference 89: ",
        "// Line_Reference 90:             Err(err) => {",
        "// Line_Reference 91:                 let message = format!(\"cannot read content-encoding header: {err}\");",
        "// Line_Reference 92:                 u64_counter!(",
        "// Line_Reference 93:                     \"apollo_router_http_requests_total\",",
        "// Line_Reference 94:                     \"Total number of HTTP requests made.\",",
        "// Line_Reference 95:                     1,",
        "// Line_Reference 96:                     status = 400,",
        "// Line_Reference 97:                     error = message.clone()",
        "// Line_Reference 98:                 );",
        "// Line_Reference 99:                 Err((StatusCode::BAD_REQUEST, message).into_response())",
        "// Line_Reference 100:             }",
        "// Line_Reference 101:         },",
        "// Line_Reference 102:         None => Ok(next.run(Request::from_parts(parts, body)).await),",
        "// Line_Reference 103:     }",
        "// Line_Reference 104: }",
        "// Line_Reference 105: "
    ]
}
