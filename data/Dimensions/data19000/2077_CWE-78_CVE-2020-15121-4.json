{
    "cve_id": "CVE-2020-15121",
    "cve_description": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory.",
    "cve_publish_date": "2020-07-20",
    "cwe_id": "CWE-78",
    "cwe_name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
    "cwe_description": "The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",
    "commit_message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\r\n* Fix build with --with-openssl\r\n* Use RBuffer in r_socket_http_answer()\r\n* r_socket_http_answer: Fix read for big responses\r\n* Implement r_str_escape_sh()\r\n* Cleanup r_socket_connect() on Windows\r\n* Fix socket being created without a protocol\r\n* Fix socket connect with SSL ##socket\r\n* Use select() in r_socket_ready()\r\n* Fix read failing if received only protocol answer\r\n* Fix double-free\r\n* r_socket_http_get: Fail if req. SSL with no support\r\n* Follow redirects in r_socket_http_answer()\r\n* Fix r_socket_http_get result length with R2_CURL=1\r\n* Also follow redirects\r\n* Avoid using curl for downloading PDBs\r\n* Use r_socket_http_get() on UNIXs\r\n* Use WinINet API on Windows for r_socket_http_get()\r\n* Fix command injection\r\n* Fix r_sys_cmd_str_full output for binary data\r\n* Validate GUID on PDB download\r\n* Pass depth to socket_http_get_recursive()\r\n* Remove 'r_' and '__' from static function names\r\n* Fix is_valid_guid\r\n* Fix for comments",
    "type_of_change": "Modification",
    "filename_of_changes": "socket.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "48",
    "number_of_lines_deleted_vulnerable_to_cve": "99",
    "vulnerable_lines": [
        "// Line_Reference 264: \tstruct hostent *he;",
        "// Line_Reference 266: \tTIMEVAL Timeout;",
        "// Line_Reference 267: \tTimeout.tv_sec = timeout;",
        "// Line_Reference 268: \tTimeout.tv_usec = 0;",
        "// Line_Reference 274: \ts->fd = socket (AF_INET, SOCK_STREAM, 0);",
        "// Line_Reference 275: \tif (s->fd == R_INVALID_SOCKET) {",
        "// Line_Reference 276: \t\treturn false;",
        "// Line_Reference 277: \t}",
        "// Line_Reference 278: ",
        "// Line_Reference 279: \tunsigned long iMode = 1;",
        "// Line_Reference 280: \tint iResult = ioctlsocket (s->fd, FIONBIO, &iMode);",
        "// Line_Reference 281: \tif (iResult != NO_ERROR) {",
        "// Line_Reference 282: \t\teprintf (\"ioctlsocket error: %d\\n\", iResult);",
        "// Line_Reference 283: \t}",
        "// Line_Reference 284: \tmemset (&sa, 0, sizeof (sa));",
        "// Line_Reference 285: \tsa.sin_family = AF_INET;",
        "// Line_Reference 286: \the = (struct hostent *)gethostbyname (host);",
        "// Line_Reference 287: \tif (he == (struct hostent*)0) {",
        "// Line_Reference 288: #ifdef _MSC_VER",
        "// Line_Reference 289: \t\tclosesocket (s->fd);",
        "// Line_Reference 290: #else",
        "// Line_Reference 291: \t\tclose (s->fd);",
        "// Line_Reference 293: \t\treturn false;",
        "// Line_Reference 294: \t}",
        "// Line_Reference 295: \tsa.sin_addr = *((struct in_addr *)he->h_addr);",
        "// Line_Reference 296: \ts->port = r_socket_port_by_name (port);",
        "// Line_Reference 297: \ts->proto = proto;",
        "// Line_Reference 298: \tsa.sin_port = htons (s->port);",
        "// Line_Reference 299: \tif (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {",
        "// Line_Reference 300: #ifdef _MSC_VER",
        "// Line_Reference 301: \t\tclosesocket (s->fd);",
        "// Line_Reference 302: #else",
        "// Line_Reference 303: \t\tclose (s->fd);",
        "// Line_Reference 304: #endif",
        "// Line_Reference 305: \t\treturn false;",
        "// Line_Reference 306: \t}",
        "// Line_Reference 307: \tiMode = 0;",
        "// Line_Reference 308: \tiResult = ioctlsocket (s->fd, FIONBIO, &iMode);",
        "// Line_Reference 309: \tif (iResult != NO_ERROR) {",
        "// Line_Reference 310: \t\teprintf (\"ioctlsocket error: %d\\n\", iResult);",
        "// Line_Reference 311: \t}",
        "// Line_Reference 312: \tif (timeout > 0) {",
        "// Line_Reference 313: \t\tr_socket_block_time (s, 1, timeout, 0);",
        "// Line_Reference 314: \t}",
        "// Line_Reference 315: \tfd_set Write, Err;",
        "// Line_Reference 316: \tFD_ZERO (&Write);",
        "// Line_Reference 317: \tFD_ZERO (&Err);",
        "// Line_Reference 318: \tFD_SET (s->fd, &Write);",
        "// Line_Reference 319: \tFD_SET (s->fd, &Err);",
        "// Line_Reference 320: \tselect (0, NULL, &Write, &Err, &Timeout);",
        "// Line_Reference 321: \tif (FD_ISSET (s->fd, &Write)) {",
        "// Line_Reference 322: \t\treturn true;",
        "// Line_Reference 323: \t}",
        "// Line_Reference 324: \treturn false;",
        "// Line_Reference 325: #elif __UNIX__",
        "// Line_Reference 327: \tstruct addrinfo hints = {0};",
        "// Line_Reference 370: \t\t\t\tstruct timeval tv;",
        "// Line_Reference 371: \t\t\t\ttv.tv_sec = timeout;",
        "// Line_Reference 372: \t\t\t\ttv.tv_usec = 0;",
        "// Line_Reference 374: \t\t\t\tFD_ZERO(&wfds);",
        "// Line_Reference 375: \t\t\t\tFD_SET(s->fd, &wfds);",
        "// Line_Reference 380: \t\t\t\t\t\treturn true;",
        "// Line_Reference 394: #endif",
        "// Line_Reference 399: \t\t\tr_socket_free (s);",
        "// Line_Reference 404: \t\tif (SSL_connect (s->sfd) != 1) {",
        "// Line_Reference 405: \t\t\tr_socket_free (s);",
        "// Line_Reference 625: \tstruct timeval t;",
        "// Line_Reference 626: \tt.tv_sec = timeout;",
        "// Line_Reference 627: \tt.tv_usec = 0;",
        "// Line_Reference 662: \t\tstruct timeval tv = {0};",
        "// Line_Reference 663: \t\ttv.tv_sec = sec;",
        "// Line_Reference 664: \t\ttv.tv_usec = usec;",
        "// Line_Reference 681: // XXX: rewrite it to use select //",
        "// Line_Reference 685: #if __UNIX__",
        "// Line_Reference 686: \t//int msecs = (1000 * secs) + (usecs / 1000);",
        "// Line_Reference 687: \tint msecs = (usecs / 1000);",
        "// Line_Reference 688: \tstruct pollfd fds[1];",
        "// Line_Reference 689: \tfds[0].fd = s->fd;",
        "// Line_Reference 690: \tfds[0].events = POLLIN | POLLPRI;",
        "// Line_Reference 691: \tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;",
        "// Line_Reference 692: \treturn poll ((struct pollfd *)&fds, 1, msecs);",
        "// Line_Reference 693: #elif __WINDOWS__",
        "// Line_Reference 695: \tstruct timeval tv;",
        "// Line_Reference 701: \ttv.tv_sec = secs;",
        "// Line_Reference 702: \ttv.tv_usec = usecs;",
        "// Line_Reference 704: #else",
        "// Line_Reference 705: \treturn true; /* always ready if unknown */",
        "// Line_Reference 706: #endif",
        "// Line_Reference 797: #if __WINDOWS__",
        "// Line_Reference 798: rep:",
        "// Line_Reference 799: \t{",
        "// Line_Reference 800: \tint ret = recv (s->fd, (void *)buf, len, 0);",
        "// Line_Reference 801: \tif (ret == -1) {",
        "// Line_Reference 802: \t\tgoto rep;",
        "// Line_Reference 803: \t}",
        "// Line_Reference 804: \treturn ret;",
        "// Line_Reference 805: \t}",
        "// Line_Reference 806: #else",
        "// Line_Reference 811: #endif"
    ]
}
