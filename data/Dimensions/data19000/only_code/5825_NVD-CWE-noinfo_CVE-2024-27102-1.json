"fmt"
"github.com/karrick/godirwalk"
// BasePath is the absolute path to create the archive from where Files and Ignore are
// relative to.
BasePath string
// Stream .
for _, f := range a.Files {
if strings.HasPrefix(f, a.BasePath) {
return fmt.Errorf("archive: all entries in Files must be absolute and within BasePath: %s\n", f)
pw := NewTarProgress(tw, a.Progress)
// Configure godirwalk.
options := &godirwalk.Options{
FollowSymbolicLinks: false,
Unsorted:            true,
}
var callback godirwalk.WalkFunc
callback = a.callback(pw, func(_ string, rp string) error {
if i.MatchesPath(rp) {
return godirwalk.SkipThis
callback = a.withFilesCallback(pw)
callback = a.callback(pw)
// Set the callback function, wrapped with support for context cancellation.
options.Callback = func(path string, de *godirwalk.Dirent) error {
return callback(path, de)
}
// Recursively walk the path we are archiving.
return godirwalk.Walk(a.BasePath, options)
func (a *Archive) callback(tw *TarProgress, opts ...func(path string, relative string) error) func(path string, de *godirwalk.Dirent) error {
return func(path string, de *godirwalk.Dirent) error {
if de.IsDir() {
relative := filepath.ToSlash(strings.TrimPrefix(path, a.BasePath+string(filepath.Separator)))
if err := opt(path, relative); err != nil {
return a.addToArchive(path, relative, tw)
func (a *Archive) withFilesCallback(tw *TarProgress) func(path string, de *godirwalk.Dirent) error {
return a.callback(tw, func(p string, rp string) error {
if f != p && !strings.HasPrefix(strings.TrimSuffix(p, "/")+"/", strings.TrimSuffix(f, "/")+"/") {
// will be the godirwalk.SkipThis error.
return godirwalk.SkipThis
func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {
// Lstat the file, this will give us the same information as Stat except that it will not
// follow a symlink to its target automatically. This is important to avoid including
// files that exist outside the server root unintentionally in the backup.
s, err := os.Lstat(p)
if os.IsNotExist(err) {
return errors.WrapIff(err, "failed executing os.Lstat on '%s'", rp)
log.WithField("path", rp).WithField("readlink_err", err.Error()).Warn("failed reading symlink for target path; skipping...")
return errors.WrapIff(err, "failed to get tar#FileInfoHeader for '%s'", rp)
header.Name = rp
if err := w.WriteHeader(header); err != nil {
return errors.WrapIff(err, "failed to write tar#FileInfoHeader for '%s'", rp)
f, err := os.Open(p)
if _, err := io.CopyBuffer(w, io.LimitReader(f, header.Size), buf); err != nil {
