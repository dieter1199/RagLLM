func (a *AuthenticatorOAuth2Introspection) tokenFromCache(config *AuthenticatorOAuth2IntrospectionConfiguration, token string) (*AuthenticatorOAuth2IntrospectionResult, bool) {
return nil, false
return nil, false
i := item.(*AuthenticatorOAuth2IntrospectionResult)
expires := time.Unix(i.Expires, 0)
if expires.Before(time.Now()) {
a.tokenCache.Del(token)
return nil, false
return i, true
func (a *AuthenticatorOAuth2Introspection) tokenToCache(config *AuthenticatorOAuth2IntrospectionConfiguration, i *AuthenticatorOAuth2IntrospectionResult, token string) {
tracer.Inject(clientSpan.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))
ss := a.c.ToScopeStrategy(cf.ScopeStrategy, "authenticators.oauth2_introspection.scope_strategy")
i, ok := a.tokenFromCache(cf, token)
if !ok {
body := url.Values{"token": {token}}
if len(i.TokenUse) > 0 && i.TokenUse != "access_token" {
return errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf("Use of introspected token is not an access token but \"%s\"", i.TokenUse)))
}
if !i.Active {
return errors.WithStack(helper.ErrUnauthorized.WithReason("Access token i says token is not active"))
}
for _, audience := range cf.Audience {
if !stringslice.Has(i.Audience, audience) {
return errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf("Token audience is not intended for target audience %s", audience)))
}
if len(cf.Issuers) > 0 {
if !stringslice.Has(cf.Issuers, i.Issuer) {
return errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf("Token issuer does not match any trusted issuer")))
}
if ss != nil {
for _, scope := range cf.Scopes {
if !ss(strings.Split(i.Scope, " "), scope) {
return errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf("Scope %s was not granted", scope)))
}
if len(i.Extra) == 0 {
i.Extra = map[string]interface{}{}
}
i.Extra["username"] = i.Username
i.Extra["client_id"] = i.ClientID
i.Extra["scope"] = i.Scope
if len(i.Audience) != 0 {
i.Extra["aud"] = i.Audience
}
a.tokenToCache(cf, i, token)
cache, _ := ristretto.NewCache(&ristretto.Config{
MaxCost: int64(c.Cache.MaxCost),