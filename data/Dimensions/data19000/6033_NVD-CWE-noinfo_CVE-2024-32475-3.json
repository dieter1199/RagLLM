{
    "cve_id": "CVE-2024-32475",
    "cve_description": "Envoy is a cloud-native, open source edge and service proxy. When an upstream TLS cluster is used with `auto_sni` enabled, a request containing a `host`/`:authority` header longer than 255 characters triggers an abnormal termination of Envoy process. Envoy does not gracefully handle an error when setting SNI for outbound TLS connection. The error can occur when Envoy attempts to use the `host`/`:authority` header value longer than 255 characters as SNI for outbound TLS connection. SNI length is limited to 255 characters per the standard. Envoy always expects this operation to succeed and abnormally aborts the process when it fails. This vulnerability is fixed in 1.30.1, 1.29.4, 1.28.3, and 1.27.5.\n",
    "cve_publish_date": "2024-04-18",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "tls: fix RELEASE_ASSERT when using `auto_sni` (#33637)\n\n* tls: fix RELEASE_ASSERT when using `auto_sni`\r\n\r\nIf the `:authority` was longer than 255 characters, Envoy would\r\nRELEASE_ASSERT when creating an upstream TLS connection when\r\n`auto_sni` (https://www.envoyproxy.io/docs/envoy/v1.30.0/api-v3/config/core/v3/protocol.proto.html#config-core-v3-upstreamhttpprotocoloptions)\r\nwas used.\r\n\r\nSigned-off-by: Greg Greenway <ggreenway@apple.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "ssl_socket.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "61",
    "number_of_lines_deleted_vulnerable_to_cve": "13",
    "vulnerable_lines": [
        "// Line_Reference 29: // This SslSocket will be used when SSL secret is not fetched from SDS server.",
        "// Line_Reference 30: class NotReadySslSocket : public Network::TransportSocket {",
        "// Line_Reference 35:   absl::string_view failureReason() const override { return NotReadyReason; }",
        "// Line_Reference 50: SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,",
        "// Line_Reference 51:                      const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,",
        "// Line_Reference 52:                      Ssl::HandshakerFactoryCb handshaker_factory_cb)",
        "// Line_Reference 54:       ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),",
        "// Line_Reference 55:       info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(",
        "// Line_Reference 56:           ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {",
        "// Line_Reference 404:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,",
        "// Line_Reference 405:                                        transport_socket_options, config_->createHandshaker());",
        "// Line_Reference 453:     return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,",
        "// Line_Reference 454:                                        config_->createHandshaker());"
    ]
}
