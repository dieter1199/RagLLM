{
    "cve_id": "CVE-2019-15226",
    "cve_description": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.",
    "cve_publish_date": "2019-10-09",
    "cwe_id": "CWE-400",
    "cwe_name": "Uncontrolled Resource Consumption",
    "cwe_description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "commit_message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "conn_manager_impl.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "12",
    "number_of_lines_deleted_vulnerable_to_cve": "8",
    "vulnerable_lines": [
        "// Line_Reference 722:   ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);",
        "// Line_Reference 723:   if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {",
        "// Line_Reference 724:     sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),",
        "// Line_Reference 725:                    Code::RequestHeaderFieldsTooLarge, \"\", nullptr, is_head_request_, absl::nullopt,",
        "// Line_Reference 726:                    StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);",
        "// Line_Reference 727:     return;",
        "// Line_Reference 728:   }",
        "// Line_Reference 729: "
    ]
}
