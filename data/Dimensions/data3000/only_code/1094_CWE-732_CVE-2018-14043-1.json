if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
{
/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
* to new file. */
if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
* any permissions and to ensure that anything that has the file already open won't be able to read the new
* contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
* between deleting and creating the file where someone could create the file and have access. However,
* depending on the OS they may have access even if the file is created with no perms... */
res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
if (res != M_FS_ERROR_SUCCESS) {
return res;
}
}
* existing to rename because any check we perform may not be true when rename is called. */
/* There is a race condition where the path could not exist but be created between the exists check and calling
* want to remove any existing files (especially if the dest is a dir). */
* result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
* existing to rename because any check we perform may not be true when rename is called. */
/* There is a race condition where the path could not exist but be created between the exists check and calling
* M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
* Making dirs and symlinks is one operation and copying a file will be split into
* If we're overwriting then there could be other files in that location (especially if it's a dir). */
* We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
* it after a potential walk because we can't delete a directory that isn't empty.
* new info as necessary. */