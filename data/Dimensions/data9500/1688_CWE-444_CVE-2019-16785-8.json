{
    "cve_id": "CVE-2019-16785",
    "cve_description": "Waitress through version 1.3.1 implemented a \"MAY\" part of the RFC7230 which states: \"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.\" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. This issue is fixed in Waitress 1.4.0.",
    "cve_publish_date": "2019-12-20",
    "cwe_id": "CWE-444",
    "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')",
    "cwe_description": "The product acts as an intermediary HTTP agent\n         (such as a proxy or firewall) in the data flow between two\n         entities such as a client and server, but it does not\n         interpret malformed HTTP requests or responses in ways that\n         are consistent with how the messages will be processed by\n         those entities that are at the ultimate destination.",
    "commit_message": "Remove support for non CRLF line endings\n\nhttps://tools.ietf.org/html/rfc7230#section-3.5 says that servers MAY\nimplement their parsers to use only the LF as a delimeter between lines,\nhowever if the frontend server does NOT do the same you can potentially\nallow a single HTTP request to be treated differently by the two\nservers.\n\nThis issue can be used to cause HTTP request smuggling or HTTP desync\nwhich may lead to vulnerabilities.\n\nTo increase robustness Waitress will no longer allow bare LF for HTTP\nmessages/headers and chunked encoding and instead now enforces that the\nline endings at CRLF.",
    "type_of_change": "Modification",
    "filename_of_changes": "utilities.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "6",
    "number_of_lines_deleted_vulnerable_to_cve": "14",
    "vulnerable_lines": [
        "// Line_Reference 31:     pos1 = s.find(b\"\\n\\r\\n\")  # One kind of double newline",
        "// Line_Reference 32:     if pos1 >= 0:",
        "// Line_Reference 33:         pos1 += 3",
        "// Line_Reference 34:     pos2 = s.find(b\"\\n\\n\")  # Another kind of double newline",
        "// Line_Reference 35:     if pos2 >= 0:",
        "// Line_Reference 36:         pos2 += 2",
        "// Line_Reference 37: ",
        "// Line_Reference 38:     if pos1 >= 0:",
        "// Line_Reference 39:         if pos2 >= 0:",
        "// Line_Reference 40:             return min(pos1, pos2)",
        "// Line_Reference 41:         else:",
        "// Line_Reference 42:             return pos1",
        "// Line_Reference 43:     else:",
        "// Line_Reference 44:         return pos2"
    ]
}
