{
    "cve_id": "CVE-2018-6560",
    "cve_description": "In dbus-proxy/flatpak-proxy.c in Flatpak before 0.8.9, and 0.9.x and 0.10.x before 0.10.3, crafted D-Bus messages to the host can be used to break out of the sandbox, because whitespace handling in the proxy is not identical to whitespace handling in the daemon.",
    "cve_publish_date": "2018-02-02",
    "cwe_id": "CWE-436",
    "cwe_name": "Interpretation Conflict",
    "cwe_description": "Product A handles inputs or steps differently than Product B, which causes A to perform incorrect actions based on its perception of B's state.",
    "commit_message": "Fix vulnerability in dbus proxy\n\nDuring the authentication all client data is directly forwarded\nto the dbus daemon as is, until we detect the BEGIN command after\nwhich we start filtering the binary dbus protocol.\n\nUnfortunately the detection of the BEGIN command in the proxy\ndid not exactly match the detection in the dbus daemon. A BEGIN\nfollowed by a space or tab was considered ok in the daemon but\nnot by the proxy. This could be exploited to send arbitrary\ndbus messages to the host, which can be used to break out of\nthe sandbox.\n\nThis was noticed by Gabriel Campana of The Google Security Team.\n\nThis fix makes the detection of the authentication phase end\nmatch the dbus code. In addition we duplicate the authentication\nline validation from dbus, which includes ensuring all data is\nASCII, and limiting the size of a line to 16k. In fact, we add\nsome extra stringent checks, disallowing ASCII control chars and\nrequiring that auth lines start with a capital letter.",
    "type_of_change": "Modification",
    "filename_of_changes": "flatpak-proxy.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "89",
    "number_of_lines_deleted_vulnerable_to_cve": "38",
    "vulnerable_lines": [
        "// Line_Reference 176: /* We start looking ignoring the first cr-lf",
        "// Line_Reference 177:    since there is no previous line initially */",
        "// Line_Reference 178: #define AUTH_END_INIT_OFFSET 2",
        "// Line_Reference 179: #define AUTH_END_STRING \"\\r\\nBEGIN\\r\\n\"",
        "// Line_Reference 261:   int           auth_end_offset;",
        "// Line_Reference 410:   client->auth_end_offset = AUTH_END_INIT_OFFSET;",
        "// Line_Reference 2321:   guchar *match;",
        "// Line_Reference 2322:   int i;",
        "// Line_Reference 2324:   /* First try to match any leftover at the start */",
        "// Line_Reference 2325:   if (client->auth_end_offset > 0)",
        "// Line_Reference 2327:       gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;",
        "// Line_Reference 2328:       gsize to_match = MIN (left, buffer->pos);",
        "// Line_Reference 2329:       /* Matched at least up to to_match */",
        "// Line_Reference 2330:       if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)",
        "// Line_Reference 2332:           client->auth_end_offset += to_match;",
        "// Line_Reference 2334:           /* Matched all */",
        "// Line_Reference 2335:           if (client->auth_end_offset == strlen (AUTH_END_STRING))",
        "// Line_Reference 2336:             return to_match;",
        "// Line_Reference 2338:           /* Matched to end of buffer */",
        "// Line_Reference 2339:           return -1;",
        "// Line_Reference 2340:         }",
        "// Line_Reference 2342:       /* Did not actually match at start */",
        "// Line_Reference 2343:       client->auth_end_offset = -1;",
        "// Line_Reference 2344:     }",
        "// Line_Reference 2346:   /* Look for whole match inside buffer */",
        "// Line_Reference 2347:   match = memmem (buffer, buffer->pos,",
        "// Line_Reference 2348:                   AUTH_END_STRING, strlen (AUTH_END_STRING));",
        "// Line_Reference 2349:   if (match != NULL)",
        "// Line_Reference 2350:     return match - buffer->data + strlen (AUTH_END_STRING);",
        "// Line_Reference 2352:   /* Record longest prefix match at the end */",
        "// Line_Reference 2353:   for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)",
        "// Line_Reference 2354:     {",
        "// Line_Reference 2355:       if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)",
        "// Line_Reference 2356:         {",
        "// Line_Reference 2357:           client->auth_end_offset = i;",
        "// Line_Reference 2358:           break;",
        "// Line_Reference 2361: ",
        "// Line_Reference 2362:   return -1;"
    ]
}
