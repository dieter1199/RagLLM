File extensions like C<.html> and C<.txt> at the end of a route are automatically detected and stored in the stash
value C<format>.
# /foo      -> {controller => 'foo', action => 'bar'}
# /foo.html -> {controller => 'foo', action => 'bar', format => 'html'}
# /foo.txt  -> {controller => 'foo', action => 'bar', format => 'txt'}
$r->get('/foo')->to('foo#bar');
This for example, allows multiple templates in different formats to share the same action code. Restrictive
placeholders can also be used to limit the allowed formats.
Or you can just disable format detection with a special type of restrictive placeholder, which gets inherited by nested
routes, and then re-enable it on demand.
# /foo      -> {controller => 'foo', action => 'bar'}
# /foo.html -> undef
$r->get('/foo' => [format => 0])->to('foo#bar');
# /foo      -> {controller => 'foo', action => 'bar'}
# /foo.html -> undef
# /baz      -> undef
# /baz.txt  -> {controller => 'baz', action => 'yada', format => 'txt'}
# /baz.html -> {controller => 'baz', action => 'yada', format => 'html'}
# /baz.xml  -> undef
my $inactive = $r->under([format => 0]);
$inactive->get('/foo')->to('foo#bar');
$inactive->get('/baz' => [format => ['txt', 'html']])->to('baz#yada');
