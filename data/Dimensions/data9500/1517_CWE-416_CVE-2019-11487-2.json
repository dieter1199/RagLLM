{
    "cve_id": "CVE-2019-11487",
    "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
    "cve_publish_date": "2019-04-23",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "fs: prevent page refcount overflow in pipe_buf_get\n\nChange pipe_buf_get() to return a bool indicating whether it succeeded\nin raising the refcount of the page (if the thing in the pipe is a page).\nThis removes another mechanism for overflowing the page refcount.  All\ncallers converted to handle a failure.\n\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Matthew Wilcox <willy@infradead.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "pipe.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 192: void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "// Line_Reference 194: \tget_page(buf->page);"
    ]
}
