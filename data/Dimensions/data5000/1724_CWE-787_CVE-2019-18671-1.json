{
    "cve_id": "CVE-2019-18671",
    "cve_description": "Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.",
    "cve_publish_date": "2019-12-06",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "board: factor out tiny_dispatch\n\nAnd add stronger checks on what tiny_msg's are allowed to be decoded.",
    "type_of_change": "Modification",
    "filename_of_changes": "messages.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "85",
    "number_of_lines_deleted_vulnerable_to_cve": "71",
    "vulnerable_lines": [
        "// Line_Reference 40: /* Tiny messages */",
        "// Line_Reference 41: static bool msg_tiny_flag = false;",
        "// Line_Reference 42: static CONFIDENTIAL uint8_t msg_tiny[MSG_TINY_BFR_SZ];",
        "// Line_Reference 43: static uint16_t msg_tiny_id = MSG_TINY_TYPE_ERROR; /* Default to error type */",
        "// Line_Reference 44: ",
        "// Line_Reference 150: /*",
        "// Line_Reference 151:  * tiny_dispatch() - Process received tiny messages",
        "// Line_Reference 152:  *",
        "// Line_Reference 153:  * INPUT",
        "// Line_Reference 154:  *     - entry: pointer to message entry",
        "// Line_Reference 155:  *     - msg: pointer to received message buffer",
        "// Line_Reference 156:  *     - msg_size: size of message",
        "// Line_Reference 157:  * OUTPUT",
        "// Line_Reference 158:  *     none",
        "// Line_Reference 159:  *",
        "// Line_Reference 160:  */",
        "// Line_Reference 161: static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)",
        "// Line_Reference 162: {",
        "// Line_Reference 163:     if (!pb_parse(entry, msg, msg_size, msg_tiny)) {",
        "// Line_Reference 164:         call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,",
        "// Line_Reference 165:                                  \"Could not parse tiny protocol buffer message\");",
        "// Line_Reference 166:         return;",
        "// Line_Reference 167:     }",
        "// Line_Reference 168: ",
        "// Line_Reference 169:     msg_tiny_id = entry->msg_id;",
        "// Line_Reference 170: }",
        "// Line_Reference 171: ",
        "// Line_Reference 340: void handle_usb_rx(const void *msg, size_t len)",
        "// Line_Reference 341: {",
        "// Line_Reference 342:     if (msg_tiny_flag) {",
        "// Line_Reference 343:         uint8_t buf[64];",
        "// Line_Reference 344:         memcpy(buf, msg, sizeof(buf));",
        "// Line_Reference 345: ",
        "// Line_Reference 346:         uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;",
        "// Line_Reference 347:         uint32_t msgSize = buf[8]        |",
        "// Line_Reference 348:                 ((uint32_t)buf[7]) <<  8 |",
        "// Line_Reference 349:                 ((uint32_t)buf[6]) << 16 |",
        "// Line_Reference 350:                 ((uint32_t)buf[5]) << 24;",
        "// Line_Reference 351: ",
        "// Line_Reference 352:         if (msgSize > 64 - 9) {",
        "// Line_Reference 353:             (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");",
        "// Line_Reference 354:             return;",
        "// Line_Reference 355:         }",
        "// Line_Reference 357:         // Determine callback handler and message map type.",
        "// Line_Reference 358:         const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);",
        "// Line_Reference 359:         if (!entry) {",
        "// Line_Reference 360:             (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");",
        "// Line_Reference 361:             return;",
        "// Line_Reference 364:         tiny_dispatch(entry, buf + 9, msgSize);",
        "// Line_Reference 374:         uint8_t buf[64];",
        "// Line_Reference 375:         memcpy(buf, msg, sizeof(buf));",
        "// Line_Reference 376: ",
        "// Line_Reference 377:         uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;",
        "// Line_Reference 378:         uint32_t msgSize = buf[8]        |",
        "// Line_Reference 379:                 ((uint32_t)buf[7]) <<  8 |",
        "// Line_Reference 380:                 ((uint32_t)buf[6]) << 16 |",
        "// Line_Reference 381:                 ((uint32_t)buf[5]) << 24;",
        "// Line_Reference 382: ",
        "// Line_Reference 383:         if (msgSize > 64 - 9) {",
        "// Line_Reference 384:             (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");",
        "// Line_Reference 385:             return;",
        "// Line_Reference 386:         }",
        "// Line_Reference 387: ",
        "// Line_Reference 388:         // Determine callback handler and message map type.",
        "// Line_Reference 389:         const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);",
        "// Line_Reference 390:         if (!entry) {",
        "// Line_Reference 391:             (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");",
        "// Line_Reference 392:             return;",
        "// Line_Reference 393:         }",
        "// Line_Reference 394: ",
        "// Line_Reference 395:         tiny_dispatch(entry, buf + 9, msgSize);"
    ]
}
