"os"
func userKeyringIDLookup(uid int) (int, error) {
if keyringID, ok := keyringIDCache[uid]; ok {
return keyringID, nil
}
ruid, euid := os.Getuid(), os.Geteuid()
// If all the ids do not agree, we will have to change them
needSetUids := uid != ruid || uid != euid
// The value of KEY_SPEC_USER_KEYRING is determined by the real uid, so
// we must set the ruid appropriately. Note that this will also trigger
// the creation of the uid keyring if it does not yet exist.
if needSetUids {
defer setUids(ruid, euid) // Always reset privileges
if err := setUids(uid, 0); err != nil {
return 0, err
keyringID, err := unix.KeyctlGetKeyringID(unix.KEY_SPEC_USER_KEYRING, true)
// We still want to use this key after our privileges are reset. If we
// link the key into the process keyring, we will possess it and still
// be able to use it. However, the permissions to link are based on the
// effective uid, so we must set the euid appropriately.
if needSetUids {
if err := setUids(0, uid); err != nil {
return 0, err
}
}
if err := keyringLink(keyringID, unix.KEY_SPEC_PROCESS_KEYRING); err != nil {
