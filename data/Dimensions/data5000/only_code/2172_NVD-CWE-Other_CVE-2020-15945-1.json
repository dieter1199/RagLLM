/* Active Lua function (given call info) */
#define ci_func(ci)		(clLvalue(s2v((ci)->func)))
** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by
** 'resethookcount') are for debug only, and it is no problem if they
** get arbitrary values (causes at most one wrong hook call). 'hookmask'
** is an atomic value. We assume that pointers are atomic too (e.g., gcc
** ensures that for all platforms where it runs). Moreover, 'hook' is
** always checked before being called (see 'luaD_hook').
if (isLua(L->ci))
L->oldpc = L->ci->u.l.savedpc;
const Proto *p = ci_func(ci)->p;
pc <= L->oldpc ||  /* when jump back (loop), or when */
changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */
L->oldpc = pc;  /* 'pc' of last call to line hook */
