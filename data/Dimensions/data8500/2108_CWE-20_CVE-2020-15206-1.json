{
    "cve_id": "CVE-2020-15206",
    "cve_description": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, changing the TensorFlow's `SavedModel` protocol buffer and altering the name of required keys results in segfaults and data corruption while loading the model. This can cause a denial of service in products using `tensorflow-serving` or other inference-as-a-service installments. Fixed were added in commits f760f88b4267d981e13f4b302c437ae800445968 and fcfef195637c6e365577829c4d67681695956e7d (both going into TensorFlow 2.2.0 and 2.3.0 but not yet backported to earlier versions). However, this was not enough, as #41097 reports a different failure mode. The issue is patched in commit adf095206f25471e864a8e63a0f1caef53a0e3a6, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
    "cve_publish_date": "2020-09-25",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "Validate `NodeDef`s from `FunctionDefLibrary` of a `GraphDef`.\n\nWe already validated `NodeDef`s from a `GraphDef` but missed validating those from the `FunctionDefLibrary`. Thus, some maliciously crafted models could evade detection and cause denial of service due to a `CHECK`-fail.\n\nPiperOrigin-RevId: 332536309\nChange-Id: I052efe919ff1fe2f90815e286a1aa4c54c7b94ff",
    "type_of_change": "Modification",
    "filename_of_changes": "loader.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "31",
    "number_of_lines_deleted_vulnerable_to_cve": "15",
    "vulnerable_lines": [
        "// Line_Reference 78:     const auto node_iterator = node.attr().find(\"value\");",
        "// Line_Reference 79:     if (node_iterator != node.attr().end()) {",
        "// Line_Reference 80:       AttrValue node_value = node_iterator->second;",
        "// Line_Reference 81:       if (node_value.has_tensor()) {",
        "// Line_Reference 82:         const PartialTensorShape node_shape(node_value.tensor().tensor_shape());",
        "// Line_Reference 83:         if (node_shape.num_elements() < 0) {",
        "// Line_Reference 84:           return errors::FailedPrecondition(",
        "// Line_Reference 85:               \"Saved model contains node \\\"\", node.name(), \"\\\" (op \\\"\",",
        "// Line_Reference 86:               node.op(), \"\\\") which initializes from a tensor with \",",
        "// Line_Reference 87:               node_shape.num_elements(), \" elements\");",
        "// Line_Reference 88:         }",
        "// Line_Reference 90:     } else if (node.op() == \"Const\") {",
        "// Line_Reference 91:       return errors::FailedPrecondition(",
        "// Line_Reference 92:           \"Saved model contains node \\\"\", node.name(),",
        "// Line_Reference 93:           \"\\\" which is a constant tensor but no value has been provided\");"
    ]
}
