auto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);
* Get a property from this reference, returned as another reference
class GetRunner : public ThreePhaseTask {
GetRunner(
const ReferenceHandle& that,
Local<Value> key_handle,
MaybeLocal<Object> maybe_options,
bool inherit
) :
context{that.context},
reference{that.reference},
options{maybe_options, inherit ?
TransferOptions::Type::DeepReference : TransferOptions::Type::Reference},
inherit{inherit} {
that.CheckDisposed();
key = ExternalCopy::CopyIfPrimitive(key_handle);
if (!key) {
Local<Context> context_handle = Deref(context);
Context::Scope context_scope{context_handle};
Local<Value> key_inner = key->CopyInto();
Local<Object> object = Local<Object>::Cast(Deref(reference));
bool allow = [&]() {
if (!inherit) {
if (key_inner->IsName()) {
return Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));
} else if (key_inner->IsNumber()) {
return Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));
} else {
return false;
}
return true;
}();
Local<Value> value = allow ?
Unmaybe(object->Get(context_handle, key_inner)) :
Undefined(Isolate::GetCurrent()).As<Value>();
ret = TransferOut(value, options);
unique_ptr<ExternalCopy> key;
RemoteHandle<Context> context;
RemoteHandle<Value> reference;
return ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);
class DeleteRunner : public ThreePhaseTask {
key{ExternalCopy::CopyIfPrimitive(key_handle)},
context{that.context},
reference{that.reference} {
that.CheckDisposed();
if (!key) {
throw RuntimeTypeError("Invalid `key`");
}
}
Local<Context> context_handle = Deref(context);
Context::Scope context_scope{context_handle};
Local<Object> object = Local<Object>::Cast(Deref(reference));
result = Unmaybe(object->Delete(context_handle, key->CopyInto()));
return Boolean::New(Isolate::GetCurrent(), result);
private:
unique_ptr<ExternalCopy> key;
RemoteHandle<Context> context;
RemoteHandle<Value> reference;
bool result = false;
class SetRunner : public ThreePhaseTask {
key{ExternalCopy::CopyIfPrimitive(key_handle)},
val{TransferOut(val_handle, TransferOptions{maybe_options})},
context{that.context},
reference{that.reference} {
that.CheckDisposed();
if (!key) {
throw RuntimeTypeError("Invalid `key`");
}
}
Local<Context> context_handle = Deref(context);
Context::Scope context_scope{context_handle};
Local<Value> key_inner = key->CopyInto();
Local<Object> object = Local<Object>::Cast(Deref(reference));
Unmaybe(object->Delete(context_handle, key_inner));
Local<Value> val_inner = val->TransferIn();
did_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));
return Boolean::New(Isolate::GetCurrent(), did_set);
unique_ptr<ExternalCopy> key;
RemoteHandle<Context> context;
RemoteHandle<Value> reference;
bool did_set = false;
