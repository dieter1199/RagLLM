{
    "cve_id": "CVE-2021-30465",
    "cve_description": "runc before 1.0.0-rc95 allows a Container Filesystem Breakout via Directory Traversal. To exploit the vulnerability, an attacker must be able to create multiple containers with a fairly specific mount configuration. The problem occurs via a symlink-exchange attack that relies on a race condition.",
    "cve_publish_date": "2021-05-27",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "rootfs: add mount destination validation\n\nBecause the target of a mount is inside a container (which may be a\nvolume that is shared with another container), there exists a race\ncondition where the target of the mount may change to a path containing\na symlink after we have sanitised the path -- resulting in us\ninadvertently mounting the path outside of the container.\n\nThis is not immediately useful because we are in a mount namespace with\nMS_SLAVE mount propagation applied to \"/\", so we cannot mount on top of\nhost paths in the host namespace. However, if any subsequent mountpoints\nin the configuration use a subdirectory of that host path as a source,\nthose subsequent mounts will use an attacker-controlled source path\n(resolved within the host rootfs) -- allowing the bind-mounting of \"/\"\ninto the container.\n\nWhile arguably configuration issues like this are not entirely within\nrunc's threat model, within the context of Kubernetes (and possibly\nother container managers that provide semi-arbitrary container creation\nprivileges to untrusted users) this is a legitimate issue. Since we\ncannot block mounting from the host into the container, we need to block\nthe first stage of this attack (mounting onto a path outside the\ncontainer).\n\nThe long-term plan to solve this would be to migrate to libpathrs, but\nas a stop-gap we implement libpathrs-like path verification through\nreadlink(/proc/self/fd/$n) and then do mount operations through the\nprocfd once it's been verified to be inside the container. The target\ncould move after we've checked it, but if it is inside the container\nthen we can assume that it is safe for the same reason that libpathrs\noperations would be safe.\n\nA slight wrinkle is the \"copyup\" functionality we provide for tmpfs,\nwhich is the only case where we want to do a mount on the host\nfilesystem. To facilitate this, I split out the copy-up functionality\nentirely so that the logic isn't interspersed with the regular tmpfs\nlogic. In addition, all dependencies on m.Destination being overwritten\nhave been removed since that pattern was just begging to be a source of\nmore mount-target bugs (we do still have to modify m.Destination for\ntmpfs-copyup but we only do it temporarily).\n\nFixes: CVE-2021-30465\nReported-by: Etienne Champetier <champetier.etienne@gmail.com>\nCo-authored-by: Noah Meyerhans <nmeyerha@amazon.com>\nReviewed-by: Samuel Karp <skarp@amazon.com>\nReviewed-by: Kir Kolyshkin <kolyshkin@gmail.com> (@kolyshkin)\nReviewed-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>\nSigned-off-by: Aleksa Sarai <cyphar@cyphar.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "rootfs_linux.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "124",
    "number_of_lines_deleted_vulnerable_to_cve": "127",
    "vulnerable_lines": [
        "// Line_Reference 231: \t// update the mount with the correct dest after symlinks are resolved.",
        "// Line_Reference 232: \tm.Destination = dest",
        "// Line_Reference 269: \t\t\tflags := defaultMountFlags",
        "// Line_Reference 270: \t\t\tif m.Flags&unix.MS_RDONLY != 0 {",
        "// Line_Reference 271: \t\t\t\tflags = flags | unix.MS_RDONLY",
        "// Line_Reference 272: \t\t\t}",
        "// Line_Reference 273: \t\t\tcgroupmount := &configs.Mount{",
        "// Line_Reference 274: \t\t\t\tSource:      \"cgroup\",",
        "// Line_Reference 275: \t\t\t\tDevice:      \"cgroup\", // this is actually fstype",
        "// Line_Reference 276: \t\t\t\tDestination: subsystemPath,",
        "// Line_Reference 277: \t\t\t\tFlags:       flags,",
        "// Line_Reference 278: \t\t\t\tData:        filepath.Base(subsystemPath),",
        "// Line_Reference 279: \t\t\t}",
        "// Line_Reference 280: \t\t\tif err := mountNewCgroup(cgroupmount); err != nil {",
        "// Line_Reference 310: \tif err := unix.Mount(m.Source, dest, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {",
        "// Line_Reference 311: \t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)",
        "// Line_Reference 312: \t\tif err == unix.EPERM || err == unix.EBUSY {",
        "// Line_Reference 313: \t\t\tsrc := fs2.UnifiedMountpoint",
        "// Line_Reference 314: \t\t\tif c.cgroupns && c.cgroup2Path != \"\" {",
        "// Line_Reference 315: \t\t\t\t// Emulate cgroupns by bind-mounting",
        "// Line_Reference 316: \t\t\t\t// the container cgroup path rather than",
        "// Line_Reference 317: \t\t\t\t// the whole /sys/fs/cgroup.",
        "// Line_Reference 318: \t\t\t\tsrc = c.cgroup2Path",
        "// Line_Reference 319: \t\t\t}",
        "// Line_Reference 320: \t\t\terr = unix.Mount(src, dest, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")",
        "// Line_Reference 321: \t\t\tif err == unix.ENOENT && c.rootlessCgroups {",
        "// Line_Reference 322: \t\t\t\terr = nil",
        "// Line_Reference 328: \treturn nil",
        "// Line_Reference 334: \tdest := m.Destination",
        "// Line_Reference 335: \tif !strings.HasPrefix(dest, rootfs) {",
        "// Line_Reference 336: \t\tdest = filepath.Join(rootfs, dest)",
        "// Line_Reference 367: \t\tcopyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP",
        "// Line_Reference 368: \t\ttmpDir := \"\"",
        "// Line_Reference 369: \t\t// dest might be an absolute symlink, so it needs",
        "// Line_Reference 370: \t\t// to be resolved under rootfs.",
        "// Line_Reference 371: \t\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)",
        "// Line_Reference 372: \t\tif err != nil {",
        "// Line_Reference 373: \t\t\treturn err",
        "// Line_Reference 374: \t\t}",
        "// Line_Reference 375: \t\tm.Destination = dest",
        "// Line_Reference 382: \t\tif copyUp {",
        "// Line_Reference 383: \t\t\ttmpdir, err := prepareTmp(\"/tmp\")",
        "// Line_Reference 384: \t\t\tif err != nil {",
        "// Line_Reference 385: \t\t\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")",
        "// Line_Reference 386: \t\t\t}",
        "// Line_Reference 387: \t\t\tdefer cleanupTmp(tmpdir)",
        "// Line_Reference 388: \t\t\ttmpDir, err = ioutil.TempDir(tmpdir, \"runctmpdir\")",
        "// Line_Reference 389: \t\t\tif err != nil {",
        "// Line_Reference 390: \t\t\t\treturn newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")",
        "// Line_Reference 391: \t\t\t}",
        "// Line_Reference 392: \t\t\tdefer os.RemoveAll(tmpDir)",
        "// Line_Reference 393: \t\t\tm.Destination = tmpDir",
        "// Line_Reference 395: \t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {",
        "// Line_Reference 398: \t\tif copyUp {",
        "// Line_Reference 399: \t\t\tif err := fileutils.CopyDirectory(dest, tmpDir); err != nil {",
        "// Line_Reference 400: \t\t\t\terrMsg := fmt.Errorf(\"tmpcopyup: failed to copy %s to %s: %v\", dest, tmpDir, err)",
        "// Line_Reference 401: \t\t\t\tif err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {",
        "// Line_Reference 402: \t\t\t\t\treturn newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)",
        "// Line_Reference 403: \t\t\t\t}",
        "// Line_Reference 404: \t\t\t\treturn errMsg",
        "// Line_Reference 405: \t\t\t}",
        "// Line_Reference 406: \t\t\tif err := unix.Mount(tmpDir, dest, \"\", unix.MS_MOVE, \"\"); err != nil {",
        "// Line_Reference 407: \t\t\t\terrMsg := fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s: %v\", tmpDir, dest, err)",
        "// Line_Reference 408: \t\t\t\tif err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {",
        "// Line_Reference 409: \t\t\t\t\treturn newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)",
        "// Line_Reference 410: \t\t\t\t}",
        "// Line_Reference 411: \t\t\t\treturn errMsg",
        "// Line_Reference 412: \t\t\t}",
        "// Line_Reference 413: \t\t}",
        "// Line_Reference 457: \t\t// ensure that the destination of the mount is resolved of symlinks at mount time because",
        "// Line_Reference 458: \t\t// any previous mounts can invalidate the next mount's destination.",
        "// Line_Reference 459: \t\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other",
        "// Line_Reference 460: \t\t// evil stuff to try to escape the container's rootfs.",
        "// Line_Reference 461: \t\tvar err error",
        "// Line_Reference 462: \t\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {",
        "// Line_Reference 463: \t\t\treturn err",
        "// Line_Reference 464: \t\t}",
        "// Line_Reference 468: \t\t// update the mount with the correct dest after symlinks are resolved.",
        "// Line_Reference 469: \t\tm.Destination = dest",
        "// Line_Reference 652: func bindMountDeviceNode(dest string, node *devices.Device) error {",
        "// Line_Reference 660: \treturn unix.Mount(node.Path, dest, \"bind\", unix.MS_BIND, \"\")",
        "// Line_Reference 669: \tdest := filepath.Join(rootfs, node.Path)",
        "// Line_Reference 674: \t\treturn bindMountDeviceNode(dest, node)",
        "// Line_Reference 680: \t\t\treturn bindMountDeviceNode(dest, node)",
        "// Line_Reference 1027: \tvar (",
        "// Line_Reference 1028: \t\tdest = m.Destination",
        "// Line_Reference 1029: \t)",
        "// Line_Reference 1030: \tif !strings.HasPrefix(dest, rootfs) {",
        "// Line_Reference 1031: \t\tdest = filepath.Join(rootfs, dest)",
        "// Line_Reference 1032: \t}",
        "// Line_Reference 1033: \treturn unix.Mount(m.Source, dest, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
        "// Line_Reference 1037: // of propagation flags.",
        "// Line_Reference 1040: \t\tdest  = m.Destination",
        "// Line_Reference 1044: \tif libcontainerUtils.CleanPath(dest) == \"/dev\" {",
        "// Line_Reference 1045: \t\tflags &= ^unix.MS_RDONLY",
        "// Line_Reference 1046: \t}",
        "// Line_Reference 1047: ",
        "// Line_Reference 1048: \t// Mount it rw to allow chmod operation. A remount will be performed",
        "// Line_Reference 1049: \t// later to make it ro if set.",
        "// Line_Reference 1050: \tif m.Device == \"tmpfs\" {",
        "// Line_Reference 1054: \tcopyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP",
        "// Line_Reference 1055: \tif !(copyUp || strings.HasPrefix(dest, rootfs)) {",
        "// Line_Reference 1056: \t\tdest = filepath.Join(rootfs, dest)",
        "// Line_Reference 1057: \t}",
        "// Line_Reference 1058: ",
        "// Line_Reference 1059: \tif err := unix.Mount(m.Source, dest, m.Device, uintptr(flags), data); err != nil {",
        "// Line_Reference 1060: \t\treturn err",
        "// Line_Reference 1061: \t}",
        "// Line_Reference 1062: ",
        "// Line_Reference 1063: \tfor _, pflag := range m.PropagationFlags {",
        "// Line_Reference 1064: \t\tif err := unix.Mount(\"\", dest, \"\", uintptr(pflag), \"\"); err != nil {",
        "// Line_Reference 1065: \t\t\treturn err",
        "// Line_Reference 1067: \t}",
        "// Line_Reference 1068: \treturn nil",
        "// Line_Reference 1069: }",
        "// Line_Reference 1070: ",
        "// Line_Reference 1071: func mountNewCgroup(m *configs.Mount) error {",
        "// Line_Reference 1072: \tvar (",
        "// Line_Reference 1073: \t\tdata   = m.Data",
        "// Line_Reference 1074: \t\tsource = m.Source",
        "// Line_Reference 1075: \t)",
        "// Line_Reference 1076: \tif data == \"systemd\" {",
        "// Line_Reference 1077: \t\tdata = cgroups.CgroupNamePrefix + data",
        "// Line_Reference 1078: \t\tsource = \"systemd\"",
        "// Line_Reference 1079: \t}",
        "// Line_Reference 1080: \tif err := unix.Mount(source, m.Destination, m.Device, uintptr(m.Flags), data); err != nil {",
        "// Line_Reference 1081: \t\treturn err"
    ]
}
