{
    "cve_id": "CVE-2018-5729",
    "cve_description": "MIT krb5 1.6 or later allows an authenticated kadmin with permission to add principals to an LDAP Kerberos database to cause a denial of service (NULL pointer dereference) or bypass a DN container check by supplying tagged data that is internal to the database module.",
    "cve_publish_date": "2018-03-06",
    "cwe_id": "CWE-476",
    "cwe_name": "NULL Pointer Dereference",
    "cwe_description": "The product dereferences a pointer that it expects to be valid but is NULL.",
    "commit_message": "Fix flaws in LDAP DN checking\n\nKDB_TL_USER_INFO tl-data is intended to be internal to the LDAP KDB\nmodule, and not used in disk or wire principal entries.  Prevent\nkadmin clients from sending KDB_TL_USER_INFO tl-data by giving it a\ntype number less than 256 and filtering out type numbers less than 256\nin kadm5_create_principal_3().  (We already filter out low type\nnumbers in kadm5_modify_principal()).\n\nIn the LDAP KDB module, if containerdn and linkdn are both specified\nin a put_principal operation, check both linkdn and the computed\nstandalone_principal_dn for container membership.  To that end, factor\nout the checks into helper functions and call them on all applicable\nclient-influenced DNs.\n\nCVE-2018-5729:\n\nIn MIT krb5 1.6 or later, an authenticated kadmin user with permission\nto add principals to an LDAP Kerberos database can cause a null\ndereference in kadmind, or circumvent a DN container check, by\nsupplying tagged data intended to be internal to the database module.\nThanks to Sharwan Ram and Pooja Anil for discovering the potential\nnull dereference.\n\nCVE-2018-5730:\n\nIn MIT krb5 1.6 or later, an authenticated kadmin user with permission\nto add principals to an LDAP Kerberos database can circumvent a DN\ncontainership check by supplying both a \"linkdn\" and \"containerdn\"\ndatabase argument, or by supplying a DN string which is a left\nextension of a container DN string but is not hierarchically within\nthe container DN.\n\nticket: 8643 (new)\ntags: pullup\ntarget_version: 1.16-next\ntarget_version: 1.15-next",
    "type_of_change": "Modification",
    "filename_of_changes": "ldap_principal2.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "106",
    "number_of_lines_deleted_vulnerable_to_cve": "94",
    "vulnerable_lines": [
        "// Line_Reference 665:     char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];",
        "// Line_Reference 670:     krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;",
        "// Line_Reference 863:         /* make sure the DN falls in the subtree */",
        "// Line_Reference 864:         int              dnlen=0, subtreelen=0;",
        "// Line_Reference 865:         char             *dn=NULL;",
        "// Line_Reference 866:         krb5_boolean     outofsubtree=TRUE;",
        "// Line_Reference 867: ",
        "// Line_Reference 868:         if (xargs.dn != NULL) {",
        "// Line_Reference 869:             dn = xargs.dn;",
        "// Line_Reference 870:         } else if (xargs.linkdn != NULL) {",
        "// Line_Reference 871:             dn = xargs.linkdn;",
        "// Line_Reference 872:         } else if (standalone_principal_dn != NULL) {",
        "// Line_Reference 873:             /*",
        "// Line_Reference 874:              * Even though the standalone_principal_dn is constructed",
        "// Line_Reference 875:              * within this function, there is the containerdn input",
        "// Line_Reference 876:              * from the user that can become part of the it.",
        "// Line_Reference 877:              */",
        "// Line_Reference 878:             dn = standalone_principal_dn;",
        "// Line_Reference 879:         }",
        "// Line_Reference 880: ",
        "// Line_Reference 888:         for (tre=0; tre<ntrees; ++tre) {",
        "// Line_Reference 889:             if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {",
        "// Line_Reference 890:                 outofsubtree = FALSE;",
        "// Line_Reference 891:                 break;",
        "// Line_Reference 892:             } else {",
        "// Line_Reference 893:                 dnlen = strlen (dn);",
        "// Line_Reference 894:                 subtreelen = strlen(subtreelist[tre]);",
        "// Line_Reference 895:                 if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {",
        "// Line_Reference 896:                     outofsubtree = FALSE;",
        "// Line_Reference 897:                     break;",
        "// Line_Reference 898:                 }",
        "// Line_Reference 899:             }",
        "// Line_Reference 900:         }",
        "// Line_Reference 901: ",
        "// Line_Reference 902:         if (outofsubtree == TRUE) {",
        "// Line_Reference 903:             st = EINVAL;",
        "// Line_Reference 904:             k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));",
        "// Line_Reference 906:         }",
        "// Line_Reference 907: ",
        "// Line_Reference 908:         /*",
        "// Line_Reference 909:          * dn value will be set either by dn, linkdn or the standalone_principal_dn",
        "// Line_Reference 910:          * In the first 2 cases, the dn should be existing and in the last case we",
        "// Line_Reference 911:          * are supposed to create the ldap object. so the below should not be",
        "// Line_Reference 912:          * executed for the last case.",
        "// Line_Reference 913:          */",
        "// Line_Reference 914: ",
        "// Line_Reference 915:         if (standalone_principal_dn == NULL) {",
        "// Line_Reference 916:             /*",
        "// Line_Reference 917:              * If the ldap object is missing, this results in an error.",
        "// Line_Reference 918:              */",
        "// Line_Reference 919: ",
        "// Line_Reference 920:             /*",
        "// Line_Reference 921:              * Search for krbprincipalname attribute here.",
        "// Line_Reference 922:              * This is to find if a kerberos identity is already present",
        "// Line_Reference 923:              * on the ldap object, in which case adding a kerberos identity",
        "// Line_Reference 924:              * on the ldap object should result in an error.",
        "// Line_Reference 925:              */",
        "// Line_Reference 926:             char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};",
        "// Line_Reference 927: ",
        "// Line_Reference 928:             ldap_msgfree(result);",
        "// Line_Reference 929:             result = NULL;",
        "// Line_Reference 930:             LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);",
        "// Line_Reference 931:             if (st == LDAP_SUCCESS) {",
        "// Line_Reference 932:                 ent = ldap_first_entry(ld, result);",
        "// Line_Reference 933:                 if (ent != NULL) {",
        "// Line_Reference 934:                     if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {",
        "// Line_Reference 935:                         ldap_value_free(values);",
        "// Line_Reference 936:                     }",
        "// Line_Reference 937: ",
        "// Line_Reference 938:                     if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {",
        "// Line_Reference 939:                         krb_identity_exists = TRUE;",
        "// Line_Reference 940:                         ldap_value_free(values);",
        "// Line_Reference 941:                     }",
        "// Line_Reference 942:                 }",
        "// Line_Reference 943:             } else {",
        "// Line_Reference 944:                 st = set_ldap_error(context, st, OP_SEARCH);",
        "// Line_Reference 945:                 goto cleanup;",
        "// Line_Reference 946:             }",
        "// Line_Reference 947:         }",
        "// Line_Reference 948:     }",
        "// Line_Reference 949: ",
        "// Line_Reference 950:     /*",
        "// Line_Reference 951:      * If xargs.dn is set then the request is to add a",
        "// Line_Reference 952:      * kerberos principal on a ldap object, but if",
        "// Line_Reference 953:      * there is one already on the ldap object this",
        "// Line_Reference 954:      * should result in an error.",
        "// Line_Reference 955:      */",
        "// Line_Reference 956: ",
        "// Line_Reference 957:     if (xargs.dn != NULL && krb_identity_exists == TRUE) {",
        "// Line_Reference 958:         st = EINVAL;",
        "// Line_Reference 959:         snprintf(errbuf, sizeof(errbuf),",
        "// Line_Reference 960:                  _(\"ldap object is already kerberized\"));",
        "// Line_Reference 961:         k5_setmsg(context, st, \"%s\", errbuf);",
        "// Line_Reference 962:         goto cleanup;"
    ]
}
