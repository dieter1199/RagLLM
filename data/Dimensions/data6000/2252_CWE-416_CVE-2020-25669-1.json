{
    "cve_id": "CVE-2020-25669",
    "cve_description": "A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.",
    "cve_publish_date": "2021-05-26",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "Input: sunkbd - avoid use-after-free in teardown paths\n\nWe need to make sure we cancel the reinit work before we tear down the\ndriver structures.\n\nReported-by: Bodong Zhao <nopitydays@gmail.com>\nTested-by: Bodong Zhao <nopitydays@gmail.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "sunkbd.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "33",
    "number_of_lines_deleted_vulnerable_to_cve": "8",
    "vulnerable_lines": [
        "// Line_Reference 102: \t\tschedule_work(&sunkbd->tq);",
        "// Line_Reference 203:  * sunkbd_reinit() sets leds and beeps to a state the computer remembers they",
        "// Line_Reference 204:  * were in.",
        "// Line_Reference 207: static void sunkbd_reinit(struct work_struct *work)",
        "// Line_Reference 209: \tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);",
        "// Line_Reference 210: ",
        "// Line_Reference 211: \twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);",
        "// Line_Reference 212: "
    ]
}
