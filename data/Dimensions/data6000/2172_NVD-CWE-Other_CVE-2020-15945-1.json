{
    "cve_id": "CVE-2020-15945",
    "cve_description": "Lua through 5.4.0 has a segmentation fault in changedline in ldebug.c (e.g., when called by luaG_traceexec) because it incorrectly expects that an oldpc value is always updated upon a return of the flow of control to a function.",
    "cve_publish_date": "2020-07-24",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "Fixed bug: invalid 'oldpc' when returning to a function\n\nThe field 'L->oldpc' is not always updated when control returns to a\nfunction; an invalid value can seg. fault when computing 'changedline'.\n(One example is an error in a finalizer; control can return to\n'luaV_execute' without executing 'luaD_poscall'.) Instead of trying to\nfix all possible corner cases, it seems safer to be resilient to invalid\nvalues for 'oldpc'. Valid but wrong values at most cause an extra call\nto a line hook.",
    "type_of_change": "Modification",
    "filename_of_changes": "ldebug.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "25",
    "number_of_lines_deleted_vulnerable_to_cve": "16",
    "vulnerable_lines": [
        "// Line_Reference 36: ",
        "// Line_Reference 37: /* Active Lua function (given call info) */",
        "// Line_Reference 38: #define ci_func(ci)\t\t(clLvalue(s2v((ci)->func)))",
        "// Line_Reference 39: ",
        "// Line_Reference 130: ** Fields 'oldpc', 'basehookcount', and 'hookcount' (set by",
        "// Line_Reference 131: ** 'resethookcount') are for debug only, and it is no problem if they",
        "// Line_Reference 132: ** get arbitrary values (causes at most one wrong hook call). 'hookmask'",
        "// Line_Reference 133: ** is an atomic value. We assume that pointers are atomic too (e.g., gcc",
        "// Line_Reference 134: ** ensures that for all platforms where it runs). Moreover, 'hook' is",
        "// Line_Reference 135: ** always checked before being called (see 'luaD_hook').",
        "// Line_Reference 142:   if (isLua(L->ci))",
        "// Line_Reference 143:     L->oldpc = L->ci->u.l.savedpc;",
        "// Line_Reference 822:     const Proto *p = ci_func(ci)->p;",
        "// Line_Reference 825:         pc <= L->oldpc ||  /* when jump back (loop), or when */",
        "// Line_Reference 826:         changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */",
        "// Line_Reference 830:     L->oldpc = pc;  /* 'pc' of last call to line hook */"
    ]
}
