{
    "cve_id": "CVE-2018-6558",
    "cve_description": "The pam_fscrypt module in fscrypt before 0.2.4 may incorrectly restore primary and supplementary group IDs to the values associated with the root user, which allows attackers to gain privileges via a successful login through certain applications that use Linux-PAM (aka pam).",
    "cve_publish_date": "2018-08-23",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Ensure keyring privilege changes are reversible\n\nThis change makes sure that, when we set the ruid and euid in order to\nget the user keyring linked into the current process keyring, we will\nalways be able to reverse these changes (using a suid of 0).\n\nThis fixes an issue where \"su <user>\" would result in a system error\nwhen called by an unprivileged user. It also explains exactly how and\nwhy we are making these privilege changes.",
    "type_of_change": "Modification",
    "filename_of_changes": "keyring.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "32",
    "number_of_lines_deleted_vulnerable_to_cve": "28",
    "vulnerable_lines": [
        "// Line_Reference 25: \t\"os\"",
        "// Line_Reference 141: func userKeyringIDLookup(uid int) (int, error) {",
        "// Line_Reference 144: \tif keyringID, ok := keyringIDCache[uid]; ok {",
        "// Line_Reference 145: \t\treturn keyringID, nil",
        "// Line_Reference 146: \t}",
        "// Line_Reference 147: ",
        "// Line_Reference 148: \truid, euid := os.Getuid(), os.Geteuid()",
        "// Line_Reference 149: \t// If all the ids do not agree, we will have to change them",
        "// Line_Reference 150: \tneedSetUids := uid != ruid || uid != euid",
        "// Line_Reference 151: ",
        "// Line_Reference 152: \t// The value of KEY_SPEC_USER_KEYRING is determined by the real uid, so",
        "// Line_Reference 153: \t// we must set the ruid appropriately. Note that this will also trigger",
        "// Line_Reference 154: \t// the creation of the uid keyring if it does not yet exist.",
        "// Line_Reference 155: \tif needSetUids {",
        "// Line_Reference 156: \t\tdefer setUids(ruid, euid) // Always reset privileges",
        "// Line_Reference 157: \t\tif err := setUids(uid, 0); err != nil {",
        "// Line_Reference 158: \t\t\treturn 0, err",
        "// Line_Reference 161: \tkeyringID, err := unix.KeyctlGetKeyringID(unix.KEY_SPEC_USER_KEYRING, true)",
        "// Line_Reference 167: \t// We still want to use this key after our privileges are reset. If we",
        "// Line_Reference 168: \t// link the key into the process keyring, we will possess it and still",
        "// Line_Reference 169: \t// be able to use it. However, the permissions to link are based on the",
        "// Line_Reference 170: \t// effective uid, so we must set the euid appropriately.",
        "// Line_Reference 171: \tif needSetUids {",
        "// Line_Reference 172: \t\tif err := setUids(0, uid); err != nil {",
        "// Line_Reference 173: \t\t\treturn 0, err",
        "// Line_Reference 174: \t\t}",
        "// Line_Reference 175: \t}",
        "// Line_Reference 176: \tif err := keyringLink(keyringID, unix.KEY_SPEC_PROCESS_KEYRING); err != nil {"
    ]
}
