{
    "cve_id": "CVE-2022-21208",
    "cve_description": "The package node-opcua before 2.74.0 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.",
    "cve_publish_date": "2022-08-23",
    "cwe_id": "CWE-1284",
    "cwe_name": "Improper Validation of Specified Quantity in Input",
    "cwe_description": "The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.",
    "commit_message": "fix message chunk overflow detection",
    "type_of_change": "Modification",
    "filename_of_changes": "tcp_transport.ts",
    "code_language": "TypeScript",
    "number_of_lines_added_for_mitigation": "118",
    "number_of_lines_deleted_vulnerable_to_cve": "73",
    "vulnerable_lines": [
        "// Line_Reference 6: ",
        "// Line_Reference 10: import { createFastUninitializedBuffer } from \"node-opcua-buffer-utils\";",
        "// Line_Reference 11: import * as debug from \"node-opcua-debug\";",
        "// Line_Reference 13: import { PacketAssembler } from \"node-opcua-packet-assembler\";",
        "// Line_Reference 14: import { ErrorCallback, CallbackWithData } from \"node-opcua-status-code\";",
        "// Line_Reference 17: import { writeTCPMessageHeader } from \"./tools\";",
        "// Line_Reference 19: const debugLog = debug.make_debugLog(__filename);",
        "// Line_Reference 20: const doDebug = debug.checkDebugFlag(__filename);",
        "// Line_Reference 21: const errorLog = debug.make_errorLog(__filename);",
        "// Line_Reference 31: ",
        "// Line_Reference 55:     on(eventName: \"message\", eventHandler: (message: Buffer) => void): this;",
        "// Line_Reference 59:     once(eventName: \"message\", eventHandler: (message: Buffer) => void): this;",
        "// Line_Reference 92:     private _pendingBuffer?: any;",
        "// Line_Reference 109:         this._pendingBuffer = undefined;",
        "// Line_Reference 141:     /**",
        "// Line_Reference 142:      * ```createChunk``` is used to construct a pre-allocated chunk to store up to ```length``` bytes of data.",
        "// Line_Reference 143:      * The created chunk includes a prepended header for ```chunk_type``` of size ```self.headerSize```.",
        "// Line_Reference 144:      *",
        "// Line_Reference 145:      * @method createChunk",
        "// Line_Reference 146:      * @param msgType",
        "// Line_Reference 147:      * @param chunkType {String} chunk type. should be 'F' 'C' or 'A'",
        "// Line_Reference 148:      * @param length",
        "// Line_Reference 149:      * @return a buffer object with the required length representing the chunk.",
        "// Line_Reference 150:      *",
        "// Line_Reference 151:      * Note:",
        "// Line_Reference 152:      *  - only one chunk can be created at a time.",
        "// Line_Reference 153:      *  - a created chunk should be committed using the ```write``` method before an other one is created.",
        "// Line_Reference 154:      */",
        "// Line_Reference 155:     public createChunk(msgType: string, chunkType: string, length: number): Buffer {",
        "// Line_Reference 156:         assert(msgType === \"MSG\");",
        "// Line_Reference 157:         assert(this._pendingBuffer === undefined, \"createChunk has already been called ( use write first)\");",
        "// Line_Reference 158: ",
        "// Line_Reference 159:         const totalLength = length + this.headerSize;",
        "// Line_Reference 160:         const buffer = createFastUninitializedBuffer(totalLength);",
        "// Line_Reference 161:         writeTCPMessageHeader(\"MSG\", chunkType, totalLength, buffer);",
        "// Line_Reference 162:         this._pendingBuffer = buffer;",
        "// Line_Reference 163: ",
        "// Line_Reference 164:         return buffer;",
        "// Line_Reference 165:     }",
        "// Line_Reference 166: ",
        "// Line_Reference 171:      *",
        "// Line_Reference 172:      * Notes:",
        "// Line_Reference 173:      *  - the message chunk must have been created by ```createChunk```.",
        "// Line_Reference 174:      *  - once a message chunk has been written, it is possible to call ```createChunk``` again.",
        "// Line_Reference 175:      *",
        "// Line_Reference 177:     public write(messageChunk: Buffer): void {",
        "// Line_Reference 178:         assert(",
        "// Line_Reference 179:             this._pendingBuffer === undefined || this._pendingBuffer === messageChunk,",
        "// Line_Reference 180:             \" write should be used with buffer created by createChunk\"",
        "// Line_Reference 181:         );",
        "// Line_Reference 184:         assert([\"F\", \"C\", \"A\"].indexOf(header.messageHeader.isFinal) !== -1);",
        "// Line_Reference 185:         this._write_chunk(messageChunk);",
        "// Line_Reference 186:         this._pendingBuffer = undefined;",
        "// Line_Reference 231:     protected _write_chunk(messageChunk: Buffer): void {",
        "// Line_Reference 235:             this._socket.write(messageChunk);",
        "// Line_Reference 262:         // install packet assembler ...",
        "// Line_Reference 263:         this.packetAssembler = new PacketAssembler({",
        "// Line_Reference 264:             readMessageFunc: readRawMessageHeader,",
        "// Line_Reference 265: ",
        "// Line_Reference 266:             minimumSizeInBytes: this.headerSize",
        "// Line_Reference 267:         });",
        "// Line_Reference 268: ",
        "// Line_Reference 269:         /* istanbul ignore next */",
        "// Line_Reference 270:         if (!this.packetAssembler) {",
        "// Line_Reference 271:             throw new Error(\"Internal Error\");",
        "// Line_Reference 272:         }",
        "// Line_Reference 273:         this.packetAssembler.on(\"message\", (messageChunk: Buffer) => this._on_message_received(messageChunk));",
        "// Line_Reference 287:             this.prematureTerminate(new Error(\"socket timeout : timeout=\" + this.timeout));",
        "// Line_Reference 291:     public prematureTerminate(err: Error): void {",
        "// Line_Reference 292:         debugLog(\"prematureTerminate\", err ? err.message : \"\");",
        "// Line_Reference 294:             err.message = \"socket has timeout: EPIPE: \" + err.message;",
        "// Line_Reference 344:     private _on_message_received(messageChunk: Buffer) {",
        "// Line_Reference 353:             this.emit(\"message\", messageChunk);"
    ]
}
