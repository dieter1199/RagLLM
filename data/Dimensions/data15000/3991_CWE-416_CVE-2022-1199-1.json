{
    "cve_id": "CVE-2022-1199",
    "cve_description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
    "cve_publish_date": "2022-08-29",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "ax25: improve the incomplete fix to avoid UAF and NPD bugs\n\nThe previous commit 1ade48d0c27d (\"ax25: NPD bug when detaching\nAX25 device\") introduce lock_sock() into ax25_kill_by_device to\nprevent NPD bug. But the concurrency NPD or UAF bug will occur,\nwhen lock_sock() or release_sock() dereferences the ax25_cb->sock.\n\nThe NULL pointer dereference bug can be shown as below:\n\nax25_kill_by_device()        | ax25_release()\n                             |   ax25_destroy_socket()\n                             |     ax25_cb_del()\n  ...                        |     ...\n                             |     ax25->sk=NULL;\n  lock_sock(s->sk); //(1)    |\n  s->ax25_dev = NULL;        |     ...\n  release_sock(s->sk); //(2) |\n  ...                        |\n\nThe root cause is that the sock is set to null before dereference\nsite (1) or (2). Therefore, this patch extracts the ax25_cb->sock\nin advance, and uses ax25_list_lock to protect it, which can synchronize\nwith ax25_cb_del() and ensure the value of sock is not null before\ndereference sites.\n\nThe concurrency UAF bug can be shown as below:\n\nax25_kill_by_device()        | ax25_release()\n                             |   ax25_destroy_socket()\n  ...                        |   ...\n                             |   sock_put(sk); //FREE\n  lock_sock(s->sk); //(1)    |\n  s->ax25_dev = NULL;        |   ...\n  release_sock(s->sk); //(2) |\n  ...                        |\n\nThe root cause is that the sock is released before dereference\nsite (1) or (2). Therefore, this patch uses sock_hold() to increase\nthe refcount of sock and uses ax25_list_lock to protect it, which\ncan synchronize with ax25_cb_del() in ax25_destroy_socket() and\nensure the sock wil not be released before dereference sites.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "af_ax25.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "6",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 89: \t\t\tlock_sock(s->sk);",
        "// Line_Reference 91: \t\t\trelease_sock(s->sk);",
        "// Line_Reference 94: "
    ]
}
