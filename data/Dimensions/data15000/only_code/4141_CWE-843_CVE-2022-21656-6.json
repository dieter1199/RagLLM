for (const envoy::type::matcher::v3::StringMatcher& matcher :
subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));
// `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other
// configurations are verified and the verification succeed.
const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&
subject_alt_name_matchers) {
X509* cert,
const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&
subject_alt_name_matchers) {
for (const GENERAL_NAME* general_name : san_names.get()) {
const std::string san = Utility::generalNameAsString(general_name);
for (auto& config_san_matcher : subject_alt_name_matchers) {
// For DNS SAN, if the StringMatcher type is exact, we have to follow DNS matching semantics.
if (general_name->type == GEN_DNS &&
config_san_matcher.matcher().match_pattern_case() ==
envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact
? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))
: config_san_matcher.match(san)) {