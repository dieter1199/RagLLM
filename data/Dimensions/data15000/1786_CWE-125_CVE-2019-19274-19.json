{
    "cve_id": "CVE-2019-19274",
    "cve_description": "typed_ast 1.3.0 and 1.3.1 has a handle_keywordonly_args out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)",
    "cve_publish_date": "2019-11-26",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Fully incorporate the code from Python 3.7.2 (#78)\n\nThis is a full port, following the recipe in update_process.md. I've also tried to keep the recipe up to date and improved the automation (see tools/script). I haven't cleaned up the commits. As of #77 there are a few tests that sanity-check this (though it's far from a full test suite), and they're run by Travis-CI and AppVeyor.",
    "type_of_change": "Modification",
    "filename_of_changes": "grammar.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "24",
    "number_of_lines_deleted_vulnerable_to_cve": "24",
    "vulnerable_lines": [
        "// Line_Reference 15:     int\t\t lb_type;",
        "// Line_Reference 16:     char\t*lb_str;",
        "// Line_Reference 19: #define EMPTY 0\t\t/* Label number 0 is by definition the empty label */",
        "// Line_Reference 24:     int\t\t ll_nlabels;",
        "// Line_Reference 25:     label\t*ll_label;",
        "// Line_Reference 31:     short\ta_lbl;\t\t/* Label of this arc */",
        "// Line_Reference 32:     short\ta_arrow;\t/* State where this arc goes to */",
        "// Line_Reference 38:     int\t\t s_narcs;",
        "// Line_Reference 39:     arc\t\t*s_arc;\t\t/* Array of arcs */",
        "// Line_Reference 42:     int\t\t s_lower;\t/* Lowest label index */",
        "// Line_Reference 43:     int\t\t s_upper;\t/* Highest label index */",
        "// Line_Reference 44:     int\t\t*s_accel;\t/* Accelerator */",
        "// Line_Reference 45:     int\t\t s_accept;\t/* Nonzero for accepting state */",
        "// Line_Reference 51:     int\t\t d_type;\t/* Non-terminal this represents */",
        "// Line_Reference 52:     char\t*d_name;\t/* For printing */",
        "// Line_Reference 53:     int\t\t d_initial;\t/* Initial state */",
        "// Line_Reference 54:     int\t\t d_nstates;",
        "// Line_Reference 55:     state\t*d_state;\t/* Array of states */",
        "// Line_Reference 56:     bitset\t d_first;",
        "// Line_Reference 62:     int\t\t g_ndfas;",
        "// Line_Reference 63:     dfa\t\t*g_dfa;\t\t/* Array of DFAs */",
        "// Line_Reference 64:     labellist\t g_ll;",
        "// Line_Reference 65:     int\t\t g_start;\t/* Start symbol of the grammar */",
        "// Line_Reference 66:     int\t\t g_accel;\t/* Set if accelerators present */"
    ]
}
