{
    "cve_id": "CVE-2020-12062",
    "cve_description": "The scp client in OpenSSH 8.2 incorrectly sends duplicate responses to the server upon a utimes system call failure, which allows a malicious unprivileged user on the remote server to overwrite arbitrary files in the client's download directory by creating a crafted subdirectory anywhere on the remote server. The victim must use the command scp -rp to download a file hierarchy containing, anywhere inside, this crafted subdirectory. NOTE: the vendor points out that \"this attack can achieve no more than a hostile peer is already able to achieve within the scp protocol\" and \"utimes does not fail under normal circumstances.",
    "cve_publish_date": "2020-06-01",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "upstream: when receving a file in sink(), be careful to send at\n\nmost a single error response after the file has been opened. Otherwise the\nsource() and sink() can become desyncronised. Reported by Daniel Goujot,\nGeorges-Axel Jaloyan, Ryan Lahfa, and David Naccache.\n\nok deraadt@ markus@\n\nOpenBSD-Commit-ID: 6c14d233c97349cb811a8f7921ded3ae7d9e0035",
    "type_of_change": "Modification",
    "filename_of_changes": "scp.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "59",
    "number_of_lines_deleted_vulnerable_to_cve": "37",
    "vulnerable_lines": [
        "// Line_Reference 1: /* $OpenBSD: scp.c,v 1.208 2020/04/30 17:07:10 markus Exp $ */",
        "// Line_Reference 1234: \tenum {",
        "// Line_Reference 1235: \t\tYES, NO, DISPLAYED",
        "// Line_Reference 1236: \t} wrerr;",
        "// Line_Reference 1244: \tint setimes, targisdir, wrerrno = 0;",
        "// Line_Reference 1453: \t\twrerr = NO;",
        "// Line_Reference 1479: \t\t\t\tif (wrerr == NO) {",
        "// Line_Reference 1482: \t\t\t\t\t\twrerr = YES;",
        "// Line_Reference 1483: \t\t\t\t\t\twrerrno = errno;",
        "// Line_Reference 1491: \t\tif (count != 0 && wrerr == NO &&",
        "// Line_Reference 1493: \t\t\twrerr = YES;",
        "// Line_Reference 1494: \t\t\twrerrno = errno;",
        "// Line_Reference 1495: \t\t}",
        "// Line_Reference 1496: \t\tif (wrerr == NO && (!exists || S_ISREG(stb.st_mode)) &&",
        "// Line_Reference 1497: \t\t    ftruncate(ofd, size) != 0) {",
        "// Line_Reference 1498: \t\t\trun_err(\"%s: truncate: %s\", np, strerror(errno));",
        "// Line_Reference 1499: \t\t\twrerr = DISPLAYED;",
        "// Line_Reference 1508: \t\t\t\t\trun_err(\"%s: set mode: %s\",",
        "// Line_Reference 1510: \t\t\t\t\twrerr = DISPLAYED;",
        "// Line_Reference 1519: \t\t\t\t\trun_err(\"%s: set mode: %s\",",
        "// Line_Reference 1521: \t\t\t\t\twrerr = DISPLAYED;",
        "// Line_Reference 1524: \t\tif (close(ofd) == -1) {",
        "// Line_Reference 1525: \t\t\twrerr = YES;",
        "// Line_Reference 1526: \t\t\twrerrno = errno;",
        "// Line_Reference 1527: \t\t}",
        "// Line_Reference 1531: \t\tif (setimes && wrerr == NO) {",
        "// Line_Reference 1534: \t\t\t\trun_err(\"%s: set times: %s\",",
        "// Line_Reference 1536: \t\t\t\twrerr = DISPLAYED;",
        "// Line_Reference 1539: \t\tswitch (wrerr) {",
        "// Line_Reference 1540: \t\tcase YES:",
        "// Line_Reference 1541: \t\t\trun_err(\"%s: %s\", np, strerror(wrerrno));",
        "// Line_Reference 1542: \t\t\tbreak;",
        "// Line_Reference 1543: \t\tcase NO:",
        "// Line_Reference 1545: \t\t\tbreak;",
        "// Line_Reference 1546: \t\tcase DISPLAYED:",
        "// Line_Reference 1547: \t\t\tbreak;",
        "// Line_Reference 1548: \t\t}"
    ]
}
