{
    "cve_id": "CVE-2018-11219",
    "cve_description": "An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.",
    "cve_publish_date": "2018-06-17",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "Security: update Lua struct package for security.\n\nDuring an auditing Apple found that the \"struct\" Lua package\nwe ship with Redis (http://www.inf.puc-rio.br/~roberto/struct/) contains\na security problem. A bound-checking statement fails because of integer\noverflow. The bug exists since we initially integrated this package with\nLua, when scripting was introduced, so every version of Redis with\nEVAL/EVALSHA capabilities exposed is affected.\n\nInstead of just fixing the bug, the library was updated to the latest\nversion shipped by the author.",
    "type_of_change": "Modification",
    "filename_of_changes": "lua_struct.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "23",
    "number_of_lines_deleted_vulnerable_to_cve": "23",
    "vulnerable_lines": [
        "// Line_Reference 4: ** $Id: struct.c,v 1.4 2012/07/04 18:54:29 roberto Exp $",
        "// Line_Reference 18: ** i/In - signed/unsigned integer with size `n' (default is size of int)",
        "// Line_Reference 19: ** cn - sequence of `n' chars (from/to a string); when packing, n==0 means",
        "// Line_Reference 92: static int getnum (lua_State *L, const char **fmt, int df) {",
        "// Line_Reference 98:       if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))",
        "// Line_Reference 99:         luaL_error(L, \"integral size overflow\");",
        "// Line_Reference 120:     case 'c': return getnum(L, fmt, 1);",
        "// Line_Reference 122:       int sz = getnum(L, fmt, sizeof(int));",
        "// Line_Reference 155:       int a = getnum(L, fmt, MAXALIGN);",
        "// Line_Reference 300:   lua_settop(L, 2);",
        "// Line_Reference 306:     luaL_checkstack(L, 1, \"too many results\");",
        "// Line_Reference 312:         lua_pushnumber(L, res);",
        "// Line_Reference 322:         lua_pushnumber(L, f);",
        "// Line_Reference 329:         lua_pushnumber(L, d);",
        "// Line_Reference 334:           if (!lua_isnumber(L, -1))",
        "// Line_Reference 335:             luaL_error(L, \"format `c0' needs a previous size\");",
        "// Line_Reference 337:           lua_pop(L, 1);",
        "// Line_Reference 338:           luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");",
        "// Line_Reference 340:         lua_pushlstring(L, data+pos, size);",
        "// Line_Reference 348:         lua_pushlstring(L, data+pos, size - 1);",
        "// Line_Reference 355:   lua_pushinteger(L, pos + 1);",
        "// Line_Reference 356:   return lua_gettop(L) - 2;",
        "// Line_Reference 402: * Copyright (C) 2010-2012 Lua.org, PUC-Rio.  All rights reserved."
    ]
}
