{
    "cve_id": "CVE-2022-31124",
    "cve_description": "openssh_key_parser is an open source Python package providing utilities to parse and pack OpenSSH private and public key files. In versions prior to 0.0.6 if a field of a key is shorter than it is declared to be, the parser raises an error with a message containing the raw field value. An attacker able to modify the declared length of a key's sensitive field can thus expose the raw value of that field. Users are advised to upgrade to version 0.0.6, which no longer includes the raw field value in the error message. There are no known workarounds for this issue.",
    "cve_publish_date": "2022-07-06",
    "cwe_id": "CWE-209",
    "cwe_name": "Generation of Error Message Containing Sensitive Information",
    "cwe_description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
    "commit_message": "Improved error handling to prevent unhandled exceptions in calling code.",
    "type_of_change": "Modification",
    "filename_of_changes": "private_key_list.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "95",
    "number_of_lines_deleted_vulnerable_to_cve": "86",
    "vulnerable_lines": [
        "// Line_Reference 224:                 key list or the declared key count is negative.",
        "// Line_Reference 232:         byte_stream = PascalStyleByteStream(byte_string)",
        "// Line_Reference 234:         header = byte_stream.read_from_format_instructions_dict(",
        "// Line_Reference 235:             cls.HEADER_FORMAT_INSTRUCTIONS_DICT",
        "// Line_Reference 236:         )",
        "// Line_Reference 238:         if header['auth_magic'] != b'openssh-key-v1\\x00':",
        "// Line_Reference 239:             raise ValueError('Not an openssh-key-v1 key')",
        "// Line_Reference 241:         num_keys = header['num_keys']",
        "// Line_Reference 243:         if num_keys < 0:",
        "// Line_Reference 244:             raise ValueError('Cannot parse negative number of keys')",
        "// Line_Reference 246:         public_key_list = []",
        "// Line_Reference 247:         for i in range(num_keys):",
        "// Line_Reference 248:             public_key_bytes = byte_stream.read_from_format_instruction(",
        "// Line_Reference 251:             public_key_list.append(",
        "// Line_Reference 252:                 PublicKey.from_bytes(public_key_bytes)",
        "// Line_Reference 253:             )",
        "// Line_Reference 255:         cipher_bytes = byte_stream.read_from_format_instruction(",
        "// Line_Reference 256:             PascalStyleFormatInstruction.BYTES",
        "// Line_Reference 257:         )",
        "// Line_Reference 258: ",
        "// Line_Reference 259:         kdf_class = get_kdf_options_class(header['kdf'])",
        "// Line_Reference 260:         kdf_options = kdf_class(",
        "// Line_Reference 261:             PascalStyleByteStream(",
        "// Line_Reference 262:                 header['kdf_options']",
        "// Line_Reference 263:             ).read_from_format_instructions_dict(",
        "// Line_Reference 264:                 kdf_class.FORMAT_INSTRUCTIONS_DICT",
        "// Line_Reference 266:         )",
        "// Line_Reference 268:         cipher_class = get_cipher_class(header['cipher'])",
        "// Line_Reference 270:         if kdf_class == NoneKDFOptions:",
        "// Line_Reference 271:             passphrase = ''",
        "// Line_Reference 272:         elif passphrase is None:",
        "// Line_Reference 273:             passphrase = getpass.getpass('Key passphrase: ')",
        "// Line_Reference 275:         if issubclass(cipher_class, ConfidentialityIntegrityCipher):",
        "// Line_Reference 276:             cipher_bytes += byte_stream.read_fixed_bytes(",
        "// Line_Reference 277:                 cipher_class.TAG_LENGTH",
        "// Line_Reference 278:             )",
        "// Line_Reference 279: ",
        "// Line_Reference 280:         decipher_bytes = cipher_class.decrypt(",
        "// Line_Reference 281:             kdf_class(kdf_options),",
        "// Line_Reference 282:             passphrase,",
        "// Line_Reference 283:             cipher_bytes",
        "// Line_Reference 284:         )",
        "// Line_Reference 285: ",
        "// Line_Reference 286:         decipher_byte_stream = PascalStyleByteStream(decipher_bytes)",
        "// Line_Reference 288:         decipher_bytes_header = \\",
        "// Line_Reference 289:             decipher_byte_stream.read_from_format_instructions_dict(",
        "// Line_Reference 290:                 cls.DECIPHER_BYTES_HEADER_FORMAT_INSTRUCTIONS_DICT",
        "// Line_Reference 293:         if decipher_bytes_header['check_int_1'] \\",
        "// Line_Reference 294:                 != decipher_bytes_header['check_int_2']:",
        "// Line_Reference 295:             warnings.warn('Cipher header check numbers do not match')",
        "// Line_Reference 297:         initlist = []",
        "// Line_Reference 298:         for i in range(num_keys):",
        "// Line_Reference 299:             initlist.append(",
        "// Line_Reference 300:                 PublicPrivateKeyPair(",
        "// Line_Reference 301:                     public_key_list[i],",
        "// Line_Reference 302:                     PrivateKey.from_byte_stream(decipher_byte_stream)",
        "// Line_Reference 303:                 )",
        "// Line_Reference 304:             )",
        "// Line_Reference 305:             if initlist[i].public.header['key_type'] \\",
        "// Line_Reference 306:                     != initlist[i].private.header['key_type']:",
        "// Line_Reference 307:                 warnings.warn(",
        "// Line_Reference 308:                     f'Inconsistency between private and public '",
        "// Line_Reference 309:                     f'key types for key {i}'",
        "// Line_Reference 311:             if not all(",
        "// Line_Reference 312:                 (",
        "// Line_Reference 313:                     initlist[i].public.params[k] ==",
        "// Line_Reference 314:                     initlist[i].private.params[k]",
        "// Line_Reference 315:                 ) for k in (",
        "// Line_Reference 316:                     initlist[i].public.params.keys() &",
        "// Line_Reference 317:                     initlist[i].private.params.keys()",
        "// Line_Reference 320:                 warnings.warn(",
        "// Line_Reference 321:                     f'Inconsistency between private and public '",
        "// Line_Reference 322:                     f'values for key {i}'",
        "// Line_Reference 323:                 )",
        "// Line_Reference 324: ",
        "// Line_Reference 325:         decipher_padding = decipher_byte_stream.read()",
        "// Line_Reference 326: ",
        "// Line_Reference 327:         if (",
        "// Line_Reference 328:             len(decipher_byte_stream.getvalue()) %",
        "// Line_Reference 329:                 cipher_class.BLOCK_SIZE != 0",
        "// Line_Reference 330:         ) or not (",
        "// Line_Reference 331:             bytes(",
        "// Line_Reference 332:                 range(1, 1 + cipher_class.BLOCK_SIZE)",
        "// Line_Reference 333:             ).startswith(decipher_padding)",
        "// Line_Reference 334:         ):",
        "// Line_Reference 335:             warnings.warn('Incorrect padding at end of ciphertext')"
    ]
}
