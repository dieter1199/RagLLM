{
    "cve_id": "CVE-2022-46153",
    "cve_description": "Traefik is an open source HTTP reverse proxy and load balancer. In affected versions there is a potential vulnerability in Traefik managing TLS connections. A router configured with a not well-formatted TLSOption is exposed with an empty TLSOption. For instance, a route secured using an mTLS connection set with a wrong CA file is exposed without verifying the client certificates. Users are advised to upgrade to version 2.9.6. Users unable to upgrade should check their logs to detect the error messages and fix your TLS options.",
    "cve_publish_date": "2022-12-08",
    "cwe_id": "CWE-295",
    "cwe_name": "Improper Certificate Validation",
    "cwe_description": "The product does not validate, or incorrectly validates, a certificate.",
    "commit_message": "Handle broken TLS conf better\n\nCo-authored-by: Jean-Baptiste Doumenjou <925513+jbdoumenjou@users.noreply.github.com>\nCo-authored-by: Romain <rtribotte@users.noreply.github.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "router.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "54",
    "number_of_lines_deleted_vulnerable_to_cve": "44",
    "vulnerable_lines": [
        "// Line_Reference 30: \t// Handles all HTTP requests.",
        "// Line_Reference 32: \t// Handles (indirectly through muxerHTTPS, or directly) all HTTPS requests.",
        "// Line_Reference 35: \t// Neither is used directly, but they are held here, and recreated on config",
        "// Line_Reference 36: \t// reload, so that they can be passed to the Switcher at the end of the config",
        "// Line_Reference 37: \t// reload phase.",
        "// Line_Reference 42: \thttpsTLSConfig    *tls.Config            // default TLS config",
        "// Line_Reference 83: \t// Handling Non-TLS TCP connection early if there is neither HTTP(S) nor TLS",
        "// Line_Reference 84: \t// routers on the entryPoint, and if there is at least one non-TLS TCP router.",
        "// Line_Reference 85: \t// In the case of a non-TLS TCP client (that does not \"send\" first), we would",
        "// Line_Reference 86: \t// block forever on clientHelloInfo, which is why we want to detect and",
        "// Line_Reference 87: \t// handle that case first and foremost.",
        "// Line_Reference 155: \t\t// In order not to depart from the behavior in 2.6, we only allow an HTTPS router",
        "// Line_Reference 156: \t\t// to take precedence over a TCP-TLS router if it is _not_ an HostSNI(*) router (so",
        "// Line_Reference 157: \t\t// basically any router that has a specific HostSNI based rule).",
        "// Line_Reference 183: \t// needed to handle 404s for HTTPS, as well as all non-Host (e.g. PathPrefix) matches.",
        "// Line_Reference 197: // AddRouteTLS defines a handler for a given rule and sets the matching tlsConfig.",
        "// Line_Reference 198: func (r *Router) AddRouteTLS(rule string, priority int, target tcp.Handler, config *tls.Config) error {",
        "// Line_Reference 199: \t// TLS PassThrough",
        "// Line_Reference 200: \tif config == nil {",
        "// Line_Reference 201: \t\treturn r.muxerTCPTLS.AddRoute(rule, priority, target)",
        "// Line_Reference 202: \t}",
        "// Line_Reference 203: ",
        "// Line_Reference 204: \treturn r.muxerTCPTLS.AddRoute(rule, priority, &tcp.TLSHandler{",
        "// Line_Reference 205: \t\tNext:   target,",
        "// Line_Reference 206: \t\tConfig: config,",
        "// Line_Reference 207: \t})",
        "// Line_Reference 208: }",
        "// Line_Reference 209: ",
        "// Line_Reference 245: // SetHTTPSForwarder sets the tcp handler that will forward the TLS connections to an http handler.",
        "// Line_Reference 250: \t\terr := r.muxerHTTPS.AddRoute(\"HostSNI(`\"+sniHost+\"`)\", 0, &tcp.TLSHandler{",
        "// Line_Reference 251: \t\t\tNext:   handler,",
        "// Line_Reference 252: \t\t\tConfig: tlsConf,",
        "// Line_Reference 253: \t\t})",
        "// Line_Reference 278: \t// Peeked are the bytes that have been read from Conn for the",
        "// Line_Reference 279: \t// purposes of route matching, but have not yet been consumed",
        "// Line_Reference 280: \t// by Read calls. It set to nil by Read when fully consumed.",
        "// Line_Reference 284: \t// It can be type asserted against *net.TCPConn or other types",
        "// Line_Reference 285: \t// as needed. It should not be read from directly unless",
        "// Line_Reference 286: \t// Peeked is nil.",
        "// Line_Reference 323: \t// No valid TLS record has a type of 0x80, however SSLv2 handshakes",
        "// Line_Reference 324: \t// start with a uint16 length where the MSB is set and the first record",
        "// Line_Reference 325: \t// is always < 256 bytes long. Therefore typ == 0x80 strongly suggests",
        "// Line_Reference 326: \t// an SSLv2 client.",
        "// Line_Reference 331: \t\t\t// we consider SSLv2 as TLS and it will be refused by real TLS handshake."
    ]
}
