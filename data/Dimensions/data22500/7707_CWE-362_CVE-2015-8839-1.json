{
    "cve_id": "CVE-2015-8839",
    "cve_description": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
    "cve_publish_date": "2016-05-02",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "ext4: fix races between page faults and hole punching\n\nCurrently, page faults and hole punching are completely unsynchronized.\nThis can result in page fault faulting in a page into a range that we\nare punching after truncate_pagecache_range() has been called and thus\nwe can end up with a page mapped to disk blocks that will be shortly\nfreed. Filesystem corruption will shortly follow. Note that the same\nrace is avoided for truncate by checking page fault offset against\ni_size but there isn't similar mechanism available for punching holes.\n\nFix the problem by creating new rw semaphore i_mmap_sem in inode and\ngrab it for writing over truncate, hole punching, and other functions\nremoving blocks from extent tree and for read over page faults. We\ncannot easily use i_data_sem for this since that ranks below transaction\nstart and we need something ranking above it so that it can be held over\nthe whole truncate / hole punching operation. Also remove various\nworkarounds we had in the code to reduce race window when page fault\ncould have created pages with stale mapping information.\n\nSigned-off-by: Jan Kara <jack@suse.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "type_of_change": "Modification",
    "filename_of_changes": "extents.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "30",
    "number_of_lines_deleted_vulnerable_to_cve": "24",
    "vulnerable_lines": [
        "// Line_Reference 4773: \tstruct address_space *mapping = inode->i_mapping;",
        "// Line_Reference 4788: \t/*",
        "// Line_Reference 4789: \t * Write out all dirty pages to avoid race conditions",
        "// Line_Reference 4790: \t * Then release them.",
        "// Line_Reference 4791: \t */",
        "// Line_Reference 4792: \tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {",
        "// Line_Reference 4793: \t\tret = filemap_write_and_wait_range(mapping, offset,",
        "// Line_Reference 4794: \t\t\t\t\t\t   offset + len - 1);",
        "// Line_Reference 4795: \t\tif (ret)",
        "// Line_Reference 4796: \t\t\treturn ret;",
        "// Line_Reference 4797: \t}",
        "// Line_Reference 4798: ",
        "// Line_Reference 4859: \t\t/* Now release the pages and zero block aligned part of pages*/",
        "// Line_Reference 4860: \t\ttruncate_pagecache_range(inode, start, end - 1);",
        "// Line_Reference 4861: \t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);",
        "// Line_Reference 4862: ",
        "// Line_Reference 5527: \ttruncate_pagecache(inode, ioffset);",
        "// Line_Reference 5528: ",
        "// Line_Reference 5537: \t\tgoto out_dio;",
        "// Line_Reference 5576: out_dio:",
        "// Line_Reference 5663: \ttruncate_pagecache(inode, ioffset);",
        "// Line_Reference 5664: ",
        "// Line_Reference 5673: \t\tgoto out_dio;",
        "// Line_Reference 5744: out_dio:"
    ]
}
