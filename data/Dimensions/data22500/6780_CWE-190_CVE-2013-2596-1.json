{
    "cve_id": "CVE-2013-2596",
    "cve_description": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.",
    "cve_publish_date": "2013-04-13",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "vm: convert fb_mmap to vm_iomap_memory() helper\n\nThis is my example conversion of a few existing mmap users.  The\nfb_mmap() case is a good example because it is a bit more complicated\nthan some: fb_mmap() mmaps one of two different memory areas depending\non the page offset of the mmap (but happily there is never any mixing of\nthe two, so the helper function still works).\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "fbmem.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "14",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 1376: \tunsigned long off;",
        "// Line_Reference 1382: \tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))",
        "// Line_Reference 1383: \t\treturn -EINVAL;",
        "// Line_Reference 1384: \toff = vma->vm_pgoff << PAGE_SHIFT;",
        "// Line_Reference 1396: \t/* frame buffer memory */",
        "// Line_Reference 1398: \tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);",
        "// Line_Reference 1399: \tif (off >= len) {",
        "// Line_Reference 1400: \t\t/* memory mapped io */",
        "// Line_Reference 1401: \t\toff -= len;",
        "// Line_Reference 1402: \t\tif (info->var.accel_flags) {",
        "// Line_Reference 1403: \t\t\tmutex_unlock(&info->mm_lock);",
        "// Line_Reference 1404: \t\t\treturn -EINVAL;",
        "// Line_Reference 1405: \t\t}",
        "// Line_Reference 1407: \t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);",
        "// Line_Reference 1410: \tstart &= PAGE_MASK;",
        "// Line_Reference 1411: \tif ((vma->vm_end - vma->vm_start + off) > len)",
        "// Line_Reference 1412: \t\treturn -EINVAL;",
        "// Line_Reference 1413: \toff += start;",
        "// Line_Reference 1414: \tvma->vm_pgoff = off >> PAGE_SHIFT;",
        "// Line_Reference 1415: \t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/",
        "// Line_Reference 1417: \tfb_pgprotect(file, vma, off);",
        "// Line_Reference 1418: \tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,",
        "// Line_Reference 1419: \t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))",
        "// Line_Reference 1420: \t\treturn -EAGAIN;",
        "// Line_Reference 1421: \treturn 0;"
    ]
}
