{
    "cve_id": "CVE-2015-5283",
    "cve_description": "The sctp_init function in net/sctp/protocol.c in the Linux kernel before 4.2.3 has an incorrect sequence of protocol-initialization steps, which allows local users to cause a denial of service (panic or memory corruption) by creating SCTP sockets before all of the steps have finished.",
    "cve_publish_date": "2015-10-19",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "sctp: fix race on protocol/netns initialization\n\nConsider sctp module is unloaded and is being requested because an user\nis creating a sctp socket.\n\nDuring initialization, sctp will add the new protocol type and then\ninitialize pernet subsys:\n\n        status = sctp_v4_protosw_init();\n        if (status)\n                goto err_protosw_init;\n\n        status = sctp_v6_protosw_init();\n        if (status)\n                goto err_v6_protosw_init;\n\n        status = register_pernet_subsys(&sctp_net_ops);\n\nThe problem is that after those calls to sctp_v{4,6}_protosw_init(), it\nis possible for userspace to create SCTP sockets like if the module is\nalready fully loaded. If that happens, one of the possible effects is\nthat we will have readers for net->sctp.local_addr_list list earlier\nthan expected and sctp_net_init() does not take precautions while\ndealing with that list, leading to a potential panic but not limited to\nthat, as sctp_sock_init() will copy a bunch of blank/partially\ninitialized values from net->sctp.\n\nThe race happens like this:\n\n     CPU 0                           |  CPU 1\n  socket()                           |\n   __sock_create                     | socket()\n    inet_create                      |  __sock_create\n     list_for_each_entry_rcu(        |\n        answer, &inetsw[sock->type], |\n        list) {                      |   inet_create\n      /* no hits */                  |\n     if (unlikely(err)) {            |\n      ...                            |\n      request_module()               |\n      /* socket creation is blocked  |\n       * the module is fully loaded  |\n       */                            |\n       sctp_init                     |\n        sctp_v4_protosw_init         |\n         inet_register_protosw       |\n          list_add_rcu(&p->list,     |\n                       last_perm);   |\n                                     |  list_for_each_entry_rcu(\n                                     |     answer, &inetsw[sock->type],\n        sctp_v6_protosw_init         |     list) {\n                                     |     /* hit, so assumes protocol\n                                     |      * is already loaded\n                                     |      */\n                                     |  /* socket creation continues\n                                     |   * before netns is initialized\n                                     |   */\n        register_pernet_subsys       |\n\nSimply inverting the initialization order between\nregister_pernet_subsys() and sctp_v4_protosw_init() is not possible\nbecause register_pernet_subsys() will create a control sctp socket, so\nthe protocol must be already visible by then. Deferring the socket\ncreation to a work-queue is not good specially because we loose the\nability to handle its errors.\n\nSo, as suggested by Vlad, the fix is to split netns initialization in\ntwo moments: defaults and control socket, so that the defaults are\nalready loaded by when we register the protocol, while control socket\ninitialization is kept at the same moment it is today.\n\nFixes: 4db67e808640 (\"sctp: Make the address lists per network namespace\")\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "protocol.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "41",
    "number_of_lines_deleted_vulnerable_to_cve": "23",
    "vulnerable_lines": [
        "// Line_Reference 1189: static int __net_init sctp_net_init(struct net *net)",
        "// Line_Reference 1282: \t/* Initialize the control inode/socket for handling OOTB packets.  */",
        "// Line_Reference 1283: \tif ((status = sctp_ctl_sock_init(net))) {",
        "// Line_Reference 1284: \t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");",
        "// Line_Reference 1285: \t\tgoto err_ctl_sock_init;",
        "// Line_Reference 1286: \t}",
        "// Line_Reference 1287: ",
        "// Line_Reference 1303: err_ctl_sock_init:",
        "// Line_Reference 1304: \tsctp_dbg_objcnt_exit(net);",
        "// Line_Reference 1305: \tsctp_proc_exit(net);",
        "// Line_Reference 1314: static void __net_exit sctp_net_exit(struct net *net)",
        "// Line_Reference 1320: \t/* Free the control endpoint.  */",
        "// Line_Reference 1321: \tinet_ctl_sock_destroy(net->sctp.ctl_sock);",
        "// Line_Reference 1322: ",
        "// Line_Reference 1330: static struct pernet_operations sctp_net_ops = {",
        "// Line_Reference 1331: \t.init = sctp_net_init,",
        "// Line_Reference 1332: \t.exit = sctp_net_exit,",
        "// Line_Reference 1465: \tstatus = sctp_v4_protosw_init();",
        "// Line_Reference 1474: \tstatus = register_pernet_subsys(&sctp_net_ops);",
        "// Line_Reference 1476: \t\tgoto err_register_pernet_subsys;",
        "// Line_Reference 1492: \tunregister_pernet_subsys(&sctp_net_ops);",
        "// Line_Reference 1493: err_register_pernet_subsys:",
        "// Line_Reference 1530: \tunregister_pernet_subsys(&sctp_net_ops);"
    ]
}
