{
    "cve_id": "CVE-2014-9529",
    "cve_description": "Race condition in the key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 3.18.2 allows local users to cause a denial of service (memory corruption or panic) or possibly have unspecified other impact via keyctl commands that trigger access to a key structure member during garbage collection of a key.",
    "cve_publish_date": "2015-01-09",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "KEYS: close race between key lookup and freeing\n\nWhen a key is being garbage collected, it's key->user would get put before\nthe ->destroy() callback is called, where the key is removed from it's\nrespective tracking structures.\n\nThis leaves a key hanging in a semi-invalid state which leaves a window open\nfor a different task to try an access key->user. An example is\nfind_keyring_by_name() which would dereference key->user for a key that is\nin the process of being garbage collected (where key->user was freed but\n->destroy() wasn't called yet - so it's still present in the linked list).\n\nThis would cause either a panic, or corrupt memory.\n\nFixes CVE-2014-9529.\n\nSigned-off-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "gc.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 151: \t\tkey_user_put(key->user);",
        "// Line_Reference 152: "
    ]
}
