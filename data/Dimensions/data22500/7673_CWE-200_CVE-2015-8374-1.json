{
    "cve_id": "CVE-2015-8374",
    "cve_description": "fs/btrfs/inode.c in the Linux kernel before 4.3.3 mishandles compressed inline extents, which allows local users to obtain sensitive pre-truncation information from a file via a clone action.",
    "cve_publish_date": "2015-12-28",
    "cwe_id": "CWE-200",
    "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
    "cwe_description": "The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.",
    "commit_message": "Btrfs: fix truncation of compressed and inlined extents\n\nWhen truncating a file to a smaller size which consists of an inline\nextent that is compressed, we did not discard (or made unusable) the\ndata between the new file size and the old file size, wasting metadata\nspace and allowing for the truncated data to be leaked and the data\ncorruption/loss mentioned below.\nWe were also not correctly decrementing the number of bytes used by the\ninode, we were setting it to zero, giving a wrong report for callers of\nthe stat(2) syscall. The fsck tool also reported an error about a mismatch\nbetween the nbytes of the file versus the real space used by the file.\n\nNow because we weren't discarding the truncated region of the file, it\nwas possible for a caller of the clone ioctl to actually read the data\nthat was truncated, allowing for a security breach without requiring root\naccess to the system, using only standard filesystem operations. The\nscenario is the following:\n\n   1) User A creates a file which consists of an inline and compressed\n      extent with a size of 2000 bytes - the file is not accessible to\n      any other users (no read, write or execution permission for anyone\n      else);\n\n   2) The user truncates the file to a size of 1000 bytes;\n\n   3) User A makes the file world readable;\n\n   4) User B creates a file consisting of an inline extent of 2000 bytes;\n\n   5) User B issues a clone operation from user A's file into its own\n      file (using a length argument of 0, clone the whole range);\n\n   6) User B now gets to see the 1000 bytes that user A truncated from\n      its file before it made its file world readbale. User B also lost\n      the bytes in the range [1000, 2000[ bytes from its own file, but\n      that might be ok if his/her intention was reading stale data from\n      user A that was never supposed to be public.\n\nNote that this contrasts with the case where we truncate a file from 2000\nbytes to 1000 bytes and then truncate it back from 1000 to 2000 bytes. In\nthis case reading any byte from the range [1000, 2000[ will return a value\nof 0x00, instead of the original data.\n\nThis problem exists since the clone ioctl was added and happens both with\nand without my recent data loss and file corruption fixes for the clone\nioctl (patch \"Btrfs: fix file corruption and data loss after cloning\ninline extents\").\n\nSo fix this by truncating the compressed inline extents as we do for the\nnon-compressed case, which involves decompressing, if the data isn't already\nin the page cache, compressing the truncated version of the extent, writing\nthe compressed content into the inline extent and then truncate it.\n\nThe following test case for fstests reproduces the problem. In order for\nthe test to pass both this fix and my previous fix for the clone ioctl\nthat forbids cloning a smaller inline extent into a larger one,\nwhich is titled \"Btrfs: fix file corruption and data loss after cloning\ninline extents\", are needed. Without that other fix the test fails in a\ndifferent way that does not leak the truncated data, instead part of\ndestination file gets replaced with zeroes (because the destination file\nhas a larger inline extent than the source).\n\n  seq=`basename $0`\n  seqres=$RESULT_DIR/$seq\n  echo \"QA output created by $seq\"\n  tmp=/tmp/$$\n  status=1\t# failure is the default!\n  trap \"_cleanup; exit \\$status\" 0 1 2 3 15\n\n  _cleanup()\n  {\n      rm -f $tmp.*\n  }\n\n  # get standard environment, filters and checks\n  . ./common/rc\n  . ./common/filter\n\n  # real QA test starts here\n  _need_to_be_root\n  _supported_fs btrfs\n  _supported_os Linux\n  _require_scratch\n  _require_cloner\n\n  rm -f $seqres.full\n\n  _scratch_mkfs >>$seqres.full 2>&1\n  _scratch_mount \"-o compress\"\n\n  # Create our test files. File foo is going to be the source of a clone operation\n  # and consists of a single inline extent with an uncompressed size of 512 bytes,\n  # while file bar consists of a single inline extent with an uncompressed size of\n  # 256 bytes. For our test's purpose, it's important that file bar has an inline\n  # extent with a size smaller than foo's inline extent.\n  $XFS_IO_PROG -f -c \"pwrite -S 0xa1 0 128\"   \\\n          -c \"pwrite -S 0x2a 128 384\" \\\n          $SCRATCH_MNT/foo | _filter_xfs_io\n  $XFS_IO_PROG -f -c \"pwrite -S 0xbb 0 256\" $SCRATCH_MNT/bar | _filter_xfs_io\n\n  # Now durably persist all metadata and data. We do this to make sure that we get\n  # on disk an inline extent with a size of 512 bytes for file foo.\n  sync\n\n  # Now truncate our file foo to a smaller size. Because it consists of a\n  # compressed and inline extent, btrfs did not shrink the inline extent to the\n  # new size (if the extent was not compressed, btrfs would shrink it to 128\n  # bytes), it only updates the inode's i_size to 128 bytes.\n  $XFS_IO_PROG -c \"truncate 128\" $SCRATCH_MNT/foo\n\n  # Now clone foo's inline extent into bar.\n  # This clone operation should fail with errno EOPNOTSUPP because the source\n  # file consists only of an inline extent and the file's size is smaller than\n  # the inline extent of the destination (128 bytes < 256 bytes). However the\n  # clone ioctl was not prepared to deal with a file that has a size smaller\n  # than the size of its inline extent (something that happens only for compressed\n  # inline extents), resulting in copying the full inline extent from the source\n  # file into the destination file.\n  #\n  # Note that btrfs' clone operation for inline extents consists of removing the\n  # inline extent from the destination inode and copy the inline extent from the\n  # source inode into the destination inode, meaning that if the destination\n  # inode's inline extent is larger (N bytes) than the source inode's inline\n  # extent (M bytes), some bytes (N - M bytes) will be lost from the destination\n  # file. Btrfs could copy the source inline extent's data into the destination's\n  # inline extent so that we would not lose any data, but that's currently not\n  # done due to the complexity that would be needed to deal with such cases\n  # (specially when one or both extents are compressed), returning EOPNOTSUPP, as\n  # it's normally not a very common case to clone very small files (only case\n  # where we get inline extents) and copying inline extents does not save any\n  # space (unlike for normal, non-inlined extents).\n  $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar\n\n  # Now because the above clone operation used to succeed, and due to foo's inline\n  # extent not being shinked by the truncate operation, our file bar got the whole\n  # inline extent copied from foo, making us lose the last 128 bytes from bar\n  # which got replaced by the bytes in range [128, 256[ from foo before foo was\n  # truncated - in other words, data loss from bar and being able to read old and\n  # stale data from foo that should not be possible to read anymore through normal\n  # filesystem operations. Contrast with the case where we truncate a file from a\n  # size N to a smaller size M, truncate it back to size N and then read the range\n  # [M, N[, we should always get the value 0x00 for all the bytes in that range.\n\n  # We expected the clone operation to fail with errno EOPNOTSUPP and therefore\n  # not modify our file's bar data/metadata. So its content should be 256 bytes\n  # long with all bytes having the value 0xbb.\n  #\n  # Without the btrfs bug fix, the clone operation succeeded and resulted in\n  # leaking truncated data from foo, the bytes that belonged to its range\n  # [128, 256[, and losing data from bar in that same range. So reading the\n  # file gave us the following content:\n  #\n  # 0000000 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1\n  # *\n  # 0000200 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a\n  # *\n  # 0000400\n  echo \"File bar's content after the clone operation:\"\n  od -t x1 $SCRATCH_MNT/bar\n\n  # Also because the foo's inline extent was not shrunk by the truncate\n  # operation, btrfs' fsck, which is run by the fstests framework everytime a\n  # test completes, failed reporting the following error:\n  #\n  #  root 5 inode 257 errors 400, nbytes wrong\n\n  status=0\n  exit\n\nCc: stable@vger.kernel.org\nSigned-off-by: Filipe Manana <fdmanana@suse.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "inode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "68",
    "number_of_lines_deleted_vulnerable_to_cve": "14",
    "vulnerable_lines": [
        "// Line_Reference 4414: \t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&",
        "// Line_Reference 4417: \t\t\t\tu32 size = new_size - found_key.offset;",
        "// Line_Reference 4418: ",
        "// Line_Reference 4419: \t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))",
        "// Line_Reference 4420: \t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -",
        "// Line_Reference 4421: \t\t\t\t\t\t\tnew_size);",
        "// Line_Reference 4424: \t\t\t\t * update the ram bytes to properly reflect",
        "// Line_Reference 4425: \t\t\t\t * the new size of our item",
        "// Line_Reference 4427: \t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);",
        "// Line_Reference 4428: \t\t\t\tsize =",
        "// Line_Reference 4429: \t\t\t\t    btrfs_file_extent_calc_inline_size(size);",
        "// Line_Reference 4430: \t\t\t\tbtrfs_truncate_item(root, path, size, 1);",
        "// Line_Reference 4433: \t\t\t\tinode_sub_bytes(inode, item_end + 1 -",
        "// Line_Reference 4434: \t\t\t\t\t\tfound_key.offset);"
    ]
}
