{
    "cve_id": "CVE-2015-2778",
    "cve_description": "Quassel before 0.12-rc1 uses an incorrect data-type size when splitting a message, which allows remote attackers to cause a denial of service (crash) via a long CTCP query containing only multibyte characters.",
    "cve_publish_date": "2015-04-10",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.",
    "type_of_change": "Modification",
    "filename_of_changes": "ctcpparser.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "5",
    "number_of_lines_deleted_vulnerable_to_cve": "21",
    "vulnerable_lines": [
        "// Line_Reference 315:     QList<QByteArray> params;",
        "// Line_Reference 316:     params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));",
        "// Line_Reference 317: ",
        "// Line_Reference 318:     static const char *splitter = \" .,-!?\";",
        "// Line_Reference 319:     int maxSplitPos = message.count();",
        "// Line_Reference 320:     int splitPos = maxSplitPos;",
        "// Line_Reference 322:     int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);",
        "// Line_Reference 323:     if (overrun) {",
        "// Line_Reference 324:         maxSplitPos = message.count() - overrun -2;",
        "// Line_Reference 325:         splitPos = -1;",
        "// Line_Reference 326:         for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {",
        "// Line_Reference 327:             splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line",
        "// Line_Reference 328:         }",
        "// Line_Reference 329:         if (splitPos <= 0 || splitPos > maxSplitPos)",
        "// Line_Reference 330:             splitPos = maxSplitPos;",
        "// Line_Reference 331: ",
        "// Line_Reference 332:         params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));",
        "// Line_Reference 333:     }",
        "// Line_Reference 334:     net->putCmd(\"PRIVMSG\", params);",
        "// Line_Reference 336:     if (splitPos < message.count())",
        "// Line_Reference 337:         query(net, bufname, ctcpTag, message.mid(splitPos));"
    ]
}
