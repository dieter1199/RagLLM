{
    "cve_id": "CVE-2006-3635",
    "cve_description": "The ia64 subsystem in the Linux kernel before 2.6.26 allows local users to cause a denial of service (stack consumption and system crash) via a crafted application that leverages the mishandling of invalid Register Stack Engine (RSE) state.",
    "cve_publish_date": "2017-08-07",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "[IA64] Workaround for RSE issue\n\nProblem: An application violating the architectural rules regarding\noperation dependencies and having specific Register Stack Engine (RSE)\nstate at the time of the violation, may result in an illegal operation\nfault and invalid RSE state.  Such faults may initiate a cascade of\nrepeated illegal operation faults within OS interruption handlers.\nThe specific behavior is OS dependent.\n\nImplication: An application causing an illegal operation fault with\nspecific RSE state may result in a series of illegal operation faults\nand an eventual OS stack overflow condition.\n\nWorkaround: OS interruption handlers that switch to kernel backing\nstore implement a check for invalid RSE state to avoid the series\nof illegal operation faults.\n\nThe core of the workaround is the RSE_WORKAROUND code sequence\ninserted into each invocation of the SAVE_MIN_WITH_COVER and\nSAVE_MIN_WITH_COVER_R19 macros.  This sequence includes hard-coded\nconstants that depend on the number of stacked physical registers\nbeing 96.  The rest of this patch consists of code to disable this\nworkaround should this not be the case (with the presumption that\nif a future Itanium processor increases the number of registers, it\nwould also remove the need for this patch).\n\nMove the start of the RBS up to a mod32 boundary to avoid some\ncorner cases.\n\nThe dispatch_illegal_op_fault code outgrew the spot it was\nsquatting in when built with this patch and CONFIG_VIRT_CPU_ACCOUNTING=y\nMove it out to the end of the ivt.\n\nSigned-off-by: Tony Luck <tony.luck@intel.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "ivt.S",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "42",
    "number_of_lines_deleted_vulnerable_to_cve": "42",
    "vulnerable_lines": [
        "// Line_Reference 1079: \t/*",
        "// Line_Reference 1080: \t * Squatting in this space ...",
        "// Line_Reference 1081: \t *",
        "// Line_Reference 1082: \t * This special case dispatcher for illegal operation faults allows preserved",
        "// Line_Reference 1083: \t * registers to be modified through a callback function (asm only) that is handed",
        "// Line_Reference 1084: \t * back from the fault handler in r8. Up to three arguments can be passed to the",
        "// Line_Reference 1085: \t * callback function by returning an aggregate with the callback as its first",
        "// Line_Reference 1086: \t * element, followed by the arguments.",
        "// Line_Reference 1087: \t */",
        "// Line_Reference 1088: ENTRY(dispatch_illegal_op_fault)",
        "// Line_Reference 1089: \t.prologue",
        "// Line_Reference 1090: \t.body",
        "// Line_Reference 1091: \tSAVE_MIN_WITH_COVER",
        "// Line_Reference 1092: \tssm psr.ic | PSR_DEFAULT_BITS",
        "// Line_Reference 1093: \t;;",
        "// Line_Reference 1094: \tsrlz.i\t\t// guarantee that interruption collection is on",
        "// Line_Reference 1095: \t;;",
        "// Line_Reference 1096: (p15)\tssm psr.i\t// restore psr.i",
        "// Line_Reference 1097: \tadds r3=8,r2\t// set up second base pointer for SAVE_REST",
        "// Line_Reference 1098: \t;;",
        "// Line_Reference 1099: \talloc r14=ar.pfs,0,0,1,0\t// must be first in insn group",
        "// Line_Reference 1100: \tmov out0=ar.ec",
        "// Line_Reference 1101: \t;;",
        "// Line_Reference 1102: \tSAVE_REST",
        "// Line_Reference 1103: \tPT_REGS_UNWIND_INFO(0)",
        "// Line_Reference 1104: \t;;",
        "// Line_Reference 1105: \tbr.call.sptk.many rp=ia64_illegal_op_fault",
        "// Line_Reference 1106: .ret0:\t;;",
        "// Line_Reference 1107: \talloc r14=ar.pfs,0,0,3,0\t// must be first in insn group",
        "// Line_Reference 1108: \tmov out0=r9",
        "// Line_Reference 1109: \tmov out1=r10",
        "// Line_Reference 1110: \tmov out2=r11",
        "// Line_Reference 1111: \tmovl r15=ia64_leave_kernel",
        "// Line_Reference 1112: \t;;",
        "// Line_Reference 1113: \tmov rp=r15",
        "// Line_Reference 1114: \tmov b6=r8",
        "// Line_Reference 1115: \t;;",
        "// Line_Reference 1116: \tcmp.ne p6,p0=0,r8",
        "// Line_Reference 1117: (p6)\tbr.call.dpnt.many b6=b6\t\t// call returns to ia64_leave_kernel",
        "// Line_Reference 1118: \tbr.sptk.many ia64_leave_kernel",
        "// Line_Reference 1119: END(dispatch_illegal_op_fault)",
        "// Line_Reference 1120: "
    ]
}
