{
    "cve_id": "CVE-2014-5354",
    "cve_description": "plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.1, when the KDC uses LDAP, allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) by creating a database entry for a keyless principal, as demonstrated by a kadmin \"add_principal -nokey\" or \"purgekeys -all\" command.",
    "cve_publish_date": "2014-12-16",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "Support keyless principals in LDAP [CVE-2014-5354]\n\nOperations like \"kadmin -q 'addprinc -nokey foo'\" or\n\"kadmin -q 'purgekeys -all foo'\" result in principal entries with\nno keys present, so krb5_encode_krbsecretkey() would just return\nNULL, which then got unconditionally dereferenced in\nkrb5_add_ber_mem_ldap_mod().\n\nApply some fixes to krb5_encode_krbsecretkey() to handle zero-key\nprincipals better, correct the test for an allocation failure, and\nslightly restructure the cleanup handler to be shorter and more\nappropriate for the usage.  Once it no longer short-circuits when\nn_key_data is zero, it will produce an array of length two with both\nentries NULL, which is treated as an empty list by the LDAP library,\nthe correct behavior for a keyless principal.\n\nHowever, attributes with empty values are only handled by the LDAP\nlibrary for Modify operations, not Add operations (which only get\na sequence of Attribute, with no operation field).  Therefore, only\nadd an empty krbprincipalkey to the modlist when we will be performing a\nModify, and not when we will be performing an Add, which is conditional\non the (misspelled) create_standalone_prinicipal boolean.\n\nCVE-2014-5354:\n\nIn MIT krb5, when kadmind is configured to use LDAP for the KDC\ndatabase, an authenticated remote attacker can cause a NULL\ndereference by inserting into the database a principal entry which\ncontains no long-term keys.\n\nIn order for the LDAP KDC backend to translate a principal entry\nfrom the database abstraction layer into the form expected by the\nLDAP schema, the principal's keys are encoded into a\nNULL-terminated array of length-value entries to be stored in the\nLDAP database.  However, the subroutine which produced this array\ndid not correctly handle the case where no keys were present,\nreturning NULL instead of an empty array, and the array was\nunconditionally dereferenced while adding to the list of LDAP\noperations to perform.\n\nVersions of MIT krb5 prior to 1.12 did not expose a way for\nprincipal entries to have no long-term key material, and\ntherefore are not vulnerable.\n\n    CVSSv2 Vector: AV:N/AC:M/Au:S/C:N/I:N/A:P/E:H/RL:OF/RC:C\n\nticket: 8041 (new)\ntags: pullup\ntarget_version: 1.13.1\nsubject: kadmind with ldap backend crashes when putting keyless entries",
    "type_of_change": "Modification",
    "filename_of_changes": "ldap_principal2.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "17",
    "number_of_lines_deleted_vulnerable_to_cve": "8",
    "vulnerable_lines": [
        "// Line_Reference 409:     krb5_key_data *key_data;",
        "// Line_Reference 411:     if (n_key_data <= 0)",
        "// Line_Reference 416:     if (key_data_in == NULL)",
        "// Line_Reference 470:             for (i = 0; i <= num_versions; i++)",
        "// Line_Reference 471:                 if (ret[i] != NULL)",
        "// Line_Reference 472:                     free (ret[i]);",
        "// Line_Reference 1039:         if ((st=krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",",
        "// Line_Reference 1040:                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES, bersecretkey)) != 0)"
    ]
}
