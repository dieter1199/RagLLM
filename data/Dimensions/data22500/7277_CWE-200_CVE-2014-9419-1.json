{
    "cve_id": "CVE-2014-9419",
    "cve_description": "The __switch_to function in arch/x86/kernel/process_64.c in the Linux kernel through 3.18.1 does not ensure that Thread Local Storage (TLS) descriptors are loaded before proceeding with other steps, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application that reads a TLS base address.",
    "cve_publish_date": "2014-12-26",
    "cwe_id": "CWE-200",
    "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
    "cwe_description": "The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.",
    "commit_message": "x86_64, switch_to(): Load TLS descriptors before switching DS and ES\n\nOtherwise, if buggy user code points DS or ES into the TLS\narray, they would be corrupted after a context switch.\n\nThis also significantly improves the comments and documents some\ngotchas in the code.\n\nBefore this patch, the both tests below failed.  With this\npatch, the es test passes, although the gsbase test still fails.\n\n ----- begin es test -----\n\n/*\n * Copyright (c) 2014 Andy Lutomirski\n * GPL v2\n */\n\nstatic unsigned short GDT3(int idx)\n{\n\treturn (idx << 3) | 3;\n}\n\nstatic int create_tls(int idx, unsigned int base)\n{\n\tstruct user_desc desc = {\n\t\t.entry_number    = idx,\n\t\t.base_addr       = base,\n\t\t.limit           = 0xfffff,\n\t\t.seg_32bit       = 1,\n\t\t.contents        = 0, /* Data, grow-up */\n\t\t.read_exec_only  = 0,\n\t\t.limit_in_pages  = 1,\n\t\t.seg_not_present = 0,\n\t\t.useable         = 0,\n\t};\n\n\tif (syscall(SYS_set_thread_area, &desc) != 0)\n\t\terr(1, \"set_thread_area\");\n\n\treturn desc.entry_number;\n}\n\nint main()\n{\n\tint idx = create_tls(-1, 0);\n\tprintf(\"Allocated GDT index %d\\n\", idx);\n\n\tunsigned short orig_es;\n\tasm volatile (\"mov %%es,%0\" : \"=rm\" (orig_es));\n\n\tint errors = 0;\n\tint total = 1000;\n\tfor (int i = 0; i < total; i++) {\n\t\tasm volatile (\"mov %0,%%es\" : : \"rm\" (GDT3(idx)));\n\t\tusleep(100);\n\n\t\tunsigned short es;\n\t\tasm volatile (\"mov %%es,%0\" : \"=rm\" (es));\n\t\tasm volatile (\"mov %0,%%es\" : : \"rm\" (orig_es));\n\t\tif (es != GDT3(idx)) {\n\t\t\tif (errors == 0)\n\t\t\t\tprintf(\"[FAIL]\\tES changed from 0x%hx to 0x%hx\\n\",\n\t\t\t\t       GDT3(idx), es);\n\t\t\terrors++;\n\t\t}\n\t}\n\n\tif (errors) {\n\t\tprintf(\"[FAIL]\\tES was corrupted %d/%d times\\n\", errors, total);\n\t\treturn 1;\n\t} else {\n\t\tprintf(\"[OK]\\tES was preserved\\n\");\n\t\treturn 0;\n\t}\n}\n\n ----- end es test -----\n\n ----- begin gsbase test -----\n\n/*\n * gsbase.c, a gsbase test\n * Copyright (c) 2014 Andy Lutomirski\n * GPL v2\n */\n\nstatic unsigned char *testptr, *testptr2;\n\nstatic unsigned char read_gs_testvals(void)\n{\n\tunsigned char ret;\n\tasm volatile (\"movb %%gs:%1, %0\" : \"=r\" (ret) : \"m\" (*testptr));\n\treturn ret;\n}\n\nint main()\n{\n\tint errors = 0;\n\n\ttestptr = mmap((void *)0x200000000UL, 1, PROT_READ | PROT_WRITE,\n\t\t       MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);\n\tif (testptr == MAP_FAILED)\n\t\terr(1, \"mmap\");\n\n\ttestptr2 = mmap((void *)0x300000000UL, 1, PROT_READ | PROT_WRITE,\n\t\t       MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);\n\tif (testptr2 == MAP_FAILED)\n\t\terr(1, \"mmap\");\n\n\t*testptr = 0;\n\t*testptr2 = 1;\n\n\tif (syscall(SYS_arch_prctl, ARCH_SET_GS,\n\t\t    (unsigned long)testptr2 - (unsigned long)testptr) != 0)\n\t\terr(1, \"ARCH_SET_GS\");\n\n\tusleep(100);\n\n\tif (read_gs_testvals() == 1) {\n\t\tprintf(\"[OK]\\tARCH_SET_GS worked\\n\");\n\t} else {\n\t\tprintf(\"[FAIL]\\tARCH_SET_GS failed\\n\");\n\t\terrors++;\n\t}\n\n\tasm volatile (\"mov %0,%%gs\" : : \"r\" (0));\n\n\tif (read_gs_testvals() == 0) {\n\t\tprintf(\"[OK]\\tWriting 0 to gs worked\\n\");\n\t} else {\n\t\tprintf(\"[FAIL]\\tWriting 0 to gs failed\\n\");\n\t\terrors++;\n\t}\n\n\tusleep(100);\n\n\tif (read_gs_testvals() == 0) {\n\t\tprintf(\"[OK]\\tgsbase is still zero\\n\");\n\t} else {\n\t\tprintf(\"[FAIL]\\tgsbase was corrupted\\n\");\n\t\terrors++;\n\t}\n\n\treturn errors == 0 ? 0 : 1;\n}\n\n ----- end gsbase test -----\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nCc: <stable@vger.kernel.org>\nCc: Andi Kleen <andi@firstfloor.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http://lkml.kernel.org/r/509d27c9fec78217691c3dad91cec87e1006b34a.1418075657.git.luto@amacapital.net\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "process_64.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "73",
    "number_of_lines_deleted_vulnerable_to_cve": "28",
    "vulnerable_lines": [
        "// Line_Reference 286: \t/*",
        "// Line_Reference 287: \t * Reload esp0, LDT and the page table pointer:",
        "// Line_Reference 288: \t */",
        "// Line_Reference 291: \t/*",
        "// Line_Reference 292: \t * Switch DS and ES.",
        "// Line_Reference 293: \t * This won't pick up thread selector changes, but I guess that is ok.",
        "// Line_Reference 294: \t */",
        "// Line_Reference 295: \tsavesegment(es, prev->es);",
        "// Line_Reference 296: \tif (unlikely(next->es | prev->es))",
        "// Line_Reference 297: \t\tloadsegment(es, next->es);",
        "// Line_Reference 298: ",
        "// Line_Reference 299: \tsavesegment(ds, prev->ds);",
        "// Line_Reference 300: \tif (unlikely(next->ds | prev->ds))",
        "// Line_Reference 301: \t\tloadsegment(ds, next->ds);",
        "// Line_Reference 302: ",
        "// Line_Reference 303: ",
        "// Line_Reference 315: \t * Leave lazy mode, flushing any hypercalls made here.",
        "// Line_Reference 316: \t * This must be done before restoring TLS segments so",
        "// Line_Reference 317: \t * the GDT and LDT are properly updated, and must be",
        "// Line_Reference 318: \t * done before math_state_restore, so the TS bit is up",
        "// Line_Reference 319: \t * to date.",
        "// Line_Reference 326: \t * Segment register != 0 always requires a reload.  Also",
        "// Line_Reference 327: \t * reload when it has changed.  When prev process used 64bit",
        "// Line_Reference 328: \t * base always reload to avoid an information leak.",
        "// Line_Reference 333: \t\t * Check if the user used a selector != 0; if yes",
        "// Line_Reference 334: \t\t *  clear 64bit base, since overloaded base is always",
        "// Line_Reference 335: \t\t *  mapped to the Null selector",
        "// Line_Reference 340: \t/* when next process has a 64bit base use it */"
    ]
}
