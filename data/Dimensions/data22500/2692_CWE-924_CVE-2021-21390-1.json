{
    "cve_id": "CVE-2021-21390",
    "cve_description": "MinIO is an open-source high performance object storage service and it is API compatible with Amazon S3 cloud storage service. In MinIO before version RELEASE.2021-03-17T02-33-02Z, there is a vulnerability which enables MITM modification of request bodies that are meant to have integrity guaranteed by chunk signatures. In a PUT request using aws-chunked encoding, MinIO ordinarily verifies signatures at the end of a chunk. This check can be skipped if the client sends a false chunk size that is much greater than the actual data sent: the server accepts and completes the request without ever reaching the end of the chunk + thereby without ever checking the chunk signature. This is fixed in version RELEASE.2021-03-17T02-33-02Z. As a workaround one can avoid using \"aws-chunked\" encoding-based chunk signature upload requests instead use TLS. MinIO SDKs automatically disable chunked encoding signature when the server endpoint is configured with TLS.",
    "cve_publish_date": "2021-03-19",
    "cwe_id": "CWE-924",
    "cwe_name": "Improper Enforcement of Message Integrity During Transmission in a Communication Channel",
    "cwe_description": "The product establishes a communication channel with an endpoint and receives a message from that endpoint, but it does not sufficiently ensure that the message was not modified during transmission.",
    "commit_message": "s3v4: read and verify S3 signature v4 chunks separately (#11801)\n\nThis commit fixes a security issue in the signature v4 chunked\r\nreader. Before, the reader returned unverified data to the caller\r\nand would only verify the chunk signature once it has encountered\r\nthe end of the chunk payload.\r\n\r\nNow, the chunk reader reads the entire chunk into an in-memory buffer,\r\nverifies the signature and then returns data to the caller.\r\n\r\nIn general, this is a common security problem. We verifying data\r\nstreams, the verifier MUST NOT return data to the upper layers / its\r\ncallers as long as it has not verified the current data chunk / data\r\nsegment:\r\n```\r\nfunc (r *Reader) Read(buffer []byte) {\r\n   if err := r.readNext(r.internalBuffer); err != nil {\r\n      return err\r\n   }\r\n   if err := r.verify(r.internalBuffer); err != nil {\r\n      return err\r\n   }\r\n   copy(buffer, r.internalBuffer)\r\n}\r\n```",
    "type_of_change": "Modification",
    "filename_of_changes": "streaming-signature-v4.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "165",
    "number_of_lines_deleted_vulnerable_to_cve": "132",
    "vulnerable_lines": [
        "// Line_Reference 169: \t\tstate:             readChunkHeader,",
        "// Line_Reference 176: \treader            *bufio.Reader",
        "// Line_Reference 177: \tcred              auth.Credentials",
        "// Line_Reference 178: \tseedSignature     string",
        "// Line_Reference 179: \tseedDate          time.Time",
        "// Line_Reference 180: \tregion            string",
        "// Line_Reference 181: \tstate             chunkState",
        "// Line_Reference 182: \tlastChunk         bool",
        "// Line_Reference 183: \tchunkSignature    string",
        "// Line_Reference 185: \tn                 uint64    // Unread bytes in chunk",
        "// Line_Reference 189: // Read chunk reads the chunk token signature portion.",
        "// Line_Reference 190: func (cr *s3ChunkedReader) readS3ChunkHeader() {",
        "// Line_Reference 191: \t// Read the first chunk line until CRLF.",
        "// Line_Reference 192: \tvar hexChunkSize, hexChunkSignature []byte",
        "// Line_Reference 193: \thexChunkSize, hexChunkSignature, cr.err = readChunkLine(cr.reader)",
        "// Line_Reference 194: \tif cr.err != nil {",
        "// Line_Reference 195: \t\treturn",
        "// Line_Reference 196: \t}",
        "// Line_Reference 197: \t// <hex>;token=value - converts the hex into its uint64 form.",
        "// Line_Reference 198: \tcr.n, cr.err = parseHexUint(hexChunkSize)",
        "// Line_Reference 199: \tif cr.err != nil {",
        "// Line_Reference 200: \t\treturn",
        "// Line_Reference 201: \t}",
        "// Line_Reference 202: \tif cr.n == 0 {",
        "// Line_Reference 203: \t\tcr.err = io.EOF",
        "// Line_Reference 204: \t}",
        "// Line_Reference 205: \t// Save the incoming chunk signature.",
        "// Line_Reference 206: \tcr.chunkSignature = string(hexChunkSignature)",
        "// Line_Reference 207: }",
        "// Line_Reference 208: ",
        "// Line_Reference 209: type chunkState int",
        "// Line_Reference 210: ",
        "// Line_Reference 211: const (",
        "// Line_Reference 212: \treadChunkHeader chunkState = iota",
        "// Line_Reference 213: \treadChunkTrailer",
        "// Line_Reference 214: \treadChunk",
        "// Line_Reference 215: \tverifyChunk",
        "// Line_Reference 216: \teofChunk",
        "// Line_Reference 217: )",
        "// Line_Reference 218: ",
        "// Line_Reference 219: func (cs chunkState) String() string {",
        "// Line_Reference 220: \tstateString := \"\"",
        "// Line_Reference 221: \tswitch cs {",
        "// Line_Reference 222: \tcase readChunkHeader:",
        "// Line_Reference 223: \t\tstateString = \"readChunkHeader\"",
        "// Line_Reference 224: \tcase readChunkTrailer:",
        "// Line_Reference 225: \t\tstateString = \"readChunkTrailer\"",
        "// Line_Reference 226: \tcase readChunk:",
        "// Line_Reference 227: \t\tstateString = \"readChunk\"",
        "// Line_Reference 228: \tcase verifyChunk:",
        "// Line_Reference 229: \t\tstateString = \"verifyChunk\"",
        "// Line_Reference 230: \tcase eofChunk:",
        "// Line_Reference 231: \t\tstateString = \"eofChunk\"",
        "// Line_Reference 232: ",
        "// Line_Reference 233: \t}",
        "// Line_Reference 234: \treturn stateString",
        "// Line_Reference 235: }",
        "// Line_Reference 236: ",
        "// Line_Reference 245: \t\tswitch cr.state {",
        "// Line_Reference 246: \t\tcase readChunkHeader:",
        "// Line_Reference 247: \t\t\tcr.readS3ChunkHeader()",
        "// Line_Reference 248: \t\t\t// If we're at the end of a chunk.",
        "// Line_Reference 249: \t\t\tif cr.n == 0 && cr.err == io.EOF {",
        "// Line_Reference 250: \t\t\t\tcr.state = readChunkTrailer",
        "// Line_Reference 251: \t\t\t\tcr.lastChunk = true",
        "// Line_Reference 252: \t\t\t\tcontinue",
        "// Line_Reference 253: \t\t\t}",
        "// Line_Reference 254: \t\t\tif cr.err != nil {",
        "// Line_Reference 255: \t\t\t\treturn 0, cr.err",
        "// Line_Reference 256: \t\t\t}",
        "// Line_Reference 257: \t\t\tcr.state = readChunk",
        "// Line_Reference 258: \t\tcase readChunkTrailer:",
        "// Line_Reference 259: \t\t\tcr.err = readCRLF(cr.reader)",
        "// Line_Reference 260: \t\t\tif cr.err != nil {",
        "// Line_Reference 261: \t\t\t\treturn 0, errMalformedEncoding",
        "// Line_Reference 262: \t\t\t}",
        "// Line_Reference 263: \t\t\tcr.state = verifyChunk",
        "// Line_Reference 264: \t\tcase readChunk:",
        "// Line_Reference 265: \t\t\t// There is no more space left in the request buffer.",
        "// Line_Reference 266: \t\t\tif len(buf) == 0 {",
        "// Line_Reference 267: \t\t\t\treturn n, nil",
        "// Line_Reference 268: \t\t\t}",
        "// Line_Reference 269: \t\t\trbuf := buf",
        "// Line_Reference 270: \t\t\t// The request buffer is larger than the current chunk size.",
        "// Line_Reference 271: \t\t\t// Read only the current chunk from the underlying reader.",
        "// Line_Reference 272: \t\t\tif uint64(len(rbuf)) > cr.n {",
        "// Line_Reference 273: \t\t\t\trbuf = rbuf[:cr.n]",
        "// Line_Reference 274: \t\t\t}",
        "// Line_Reference 275: \t\t\tvar n0 int",
        "// Line_Reference 276: \t\t\tn0, cr.err = cr.reader.Read(rbuf)",
        "// Line_Reference 277: \t\t\tif cr.err != nil {",
        "// Line_Reference 278: \t\t\t\t// We have lesser than chunk size advertised in chunkHeader, this is 'unexpected'.",
        "// Line_Reference 279: \t\t\t\tif cr.err == io.EOF {",
        "// Line_Reference 280: \t\t\t\t\tcr.err = io.ErrUnexpectedEOF",
        "// Line_Reference 281: \t\t\t\t}",
        "// Line_Reference 282: \t\t\t\treturn 0, cr.err",
        "// Line_Reference 283: \t\t\t}",
        "// Line_Reference 284: ",
        "// Line_Reference 285: \t\t\t// Calculate sha256.",
        "// Line_Reference 286: \t\t\tcr.chunkSHA256Writer.Write(rbuf[:n0])",
        "// Line_Reference 287: \t\t\t// Update the bytes read into request buffer so far.",
        "// Line_Reference 288: \t\t\tn += n0",
        "// Line_Reference 289: \t\t\tbuf = buf[n0:]",
        "// Line_Reference 290: \t\t\t// Update bytes to be read of the current chunk before verifying chunk's signature.",
        "// Line_Reference 291: \t\t\tcr.n -= uint64(n0)",
        "// Line_Reference 292: ",
        "// Line_Reference 293: \t\t\t// If we're at the end of a chunk.",
        "// Line_Reference 294: \t\t\tif cr.n == 0 {",
        "// Line_Reference 295: \t\t\t\tcr.state = readChunkTrailer",
        "// Line_Reference 296: \t\t\t\tcontinue",
        "// Line_Reference 297: \t\t\t}",
        "// Line_Reference 298: \t\tcase verifyChunk:",
        "// Line_Reference 299: \t\t\t// Calculate the hashed chunk.",
        "// Line_Reference 300: \t\t\thashedChunk := hex.EncodeToString(cr.chunkSHA256Writer.Sum(nil))",
        "// Line_Reference 301: \t\t\t// Calculate the chunk signature.",
        "// Line_Reference 302: \t\t\tnewSignature := getChunkSignature(cr.cred, cr.seedSignature, cr.region, cr.seedDate, hashedChunk)",
        "// Line_Reference 303: \t\t\tif !compareSignatureV4(cr.chunkSignature, newSignature) {",
        "// Line_Reference 304: \t\t\t\t// Chunk signature doesn't match we return signature does not match.",
        "// Line_Reference 305: \t\t\t\tcr.err = errSignatureMismatch",
        "// Line_Reference 306: \t\t\t\treturn 0, cr.err",
        "// Line_Reference 307: \t\t\t}",
        "// Line_Reference 308: \t\t\t// Newly calculated signature becomes the seed for the next chunk",
        "// Line_Reference 309: \t\t\t// this follows the chaining.",
        "// Line_Reference 310: \t\t\tcr.seedSignature = newSignature",
        "// Line_Reference 311: \t\t\tcr.chunkSHA256Writer.Reset()",
        "// Line_Reference 312: \t\t\tif cr.lastChunk {",
        "// Line_Reference 313: \t\t\t\tcr.state = eofChunk",
        "// Line_Reference 314: \t\t\t} else {",
        "// Line_Reference 315: \t\t\t\tcr.state = readChunkHeader",
        "// Line_Reference 316: \t\t\t}",
        "// Line_Reference 317: \t\tcase eofChunk:",
        "// Line_Reference 318: \t\t\treturn n, io.EOF"
    ]
}
