{
    "cve_id": "CVE-2016-1251",
    "cve_description": "There is a vulnerability of type use-after-free affecting DBD::mysql (aka DBD-mysql or the Database Interface (DBI) MySQL driver for Perl) 3.x and 4.x before 4.041 when used with mysql_server_prepare=1.",
    "cve_publish_date": "2016-11-29",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "Fix use-after-free for repeated fetchrow_arrayref calls when mysql_server_prepare=1\n\nFunction dbd_st_fetch() via Renew() can reallocate output buffer for\nmysql_stmt_fetch() call. But it does not update pointer to that buffer in\nimp_sth->stmt structure initialized by mysql_stmt_bind_result() function.\nThat leads to use-after-free in any mysql function which access\nimp_sth->stmt structure (e.g. mysql_stmt_fetch()).\n\nThis patch fix this problem and properly updates pointer in imp_sth->stmt\nstructure after Renew() call.\n\nTest 40server_prepare_crash.t is extended to check for that use-after-free\ncrash.",
    "type_of_change": "Modification",
    "filename_of_changes": "40server_prepare_crash.t",
    "code_language": "Perl",
    "number_of_lines_added_for_mitigation": "42",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 13: plan tests => 17;",
        "// Line_Reference 15: ok $dbh->do(\"CREATE TEMPORARY TABLE t (i INTEGER NOT NULL, n TEXT)\");",
        "// Line_Reference 17: ok my $sth = $dbh->prepare(\"SELECT * FROM t WHERE i=? AND n=?\");"
    ]
}
