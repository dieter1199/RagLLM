{
    "cve_id": "CVE-2016-3134",
    "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
    "cve_publish_date": "2016-04-27",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "netfilter: x_tables: fix unconditional helper\n\nBen Hawkes says:\n\n In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it\n is possible for a user-supplied ipt_entry structure to have a large\n next_offset field. This field is not bounds checked prior to writing a\n counter value at the supplied offset.\n\nProblem is that mark_source_chains should not have been called --\nthe rule doesn't have a next entry, so its supposed to return\nan absolute verdict of either ACCEPT or DROP.\n\nHowever, the function conditional() doesn't work as the name implies.\nIt only checks that the rule is using wildcard address matching.\n\nHowever, an unconditional rule must also not be using any matches\n(no -m args).\n\nThe underflow validator only checked the addresses, therefore\npassing the 'unconditional absolute verdict' test, while\nmark_source_chains also tested for presence of matches, and thus\nproceeeded to the next (not-existent) rule.\n\nUnify this so that all the callers have same idea of 'unconditional rule'.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "ip6_tables.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "12",
    "vulnerable_lines": [
        "// Line_Reference 201: static inline bool unconditional(const struct ip6t_ip6 *ipv6)",
        "// Line_Reference 205: \treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;",
        "// Line_Reference 261: \t\tif (s->target_offset == sizeof(struct ip6t_entry) &&",
        "// Line_Reference 264: \t\t    t->verdict < 0 &&",
        "// Line_Reference 265: \t\t    unconditional(&s->ipv6)) {",
        "// Line_Reference 491: \t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&",
        "// Line_Reference 494: \t\t\t     t->verdict < 0 &&",
        "// Line_Reference 495: \t\t\t     unconditional(&e->ipv6)) || visited) {",
        "// Line_Reference 730: \tif (!unconditional(&e->ipv6))",
        "// Line_Reference 778: \t\t\t\tpr_err(\"Underflows must be unconditional and \"",
        "// Line_Reference 779: \t\t\t\t       \"use the STANDARD target with \"",
        "// Line_Reference 780: \t\t\t\t       \"ACCEPT/DROP\\n\");"
    ]
}
