{
    "cve_id": "CVE-2016-10190",
    "cve_description": "Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.",
    "cve_publish_date": "2017-02-09",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "http: make length/offset-related variables unsigned.\n\nFixes #5992, reported and found by Paul Cher <paulcher@icloud.com>.",
    "type_of_change": "Modification",
    "filename_of_changes": "http.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "38",
    "number_of_lines_deleted_vulnerable_to_cve": "32",
    "vulnerable_lines": [
        "// Line_Reference 65:     int64_t chunksize;",
        "// Line_Reference 66:     int64_t off, end_off, filesize;",
        "// Line_Reference 98:     int icy_data_read;",
        "// Line_Reference 100:     int icy_metaint;",
        "// Line_Reference 492:     s->filesize = -1;",
        "// Line_Reference 619:         s->off = strtoll(p, NULL, 10);",
        "// Line_Reference 621:             s->filesize = strtoll(slash + 1, NULL, 10);",
        "// Line_Reference 811:         } else if (!av_strcasecmp(tag, \"Content-Length\") && s->filesize == -1) {",
        "// Line_Reference 812:             s->filesize = strtoll(p, NULL, 10);",
        "// Line_Reference 821:             s->filesize  = -1;",
        "// Line_Reference 845:             s->icy_metaint = strtoll(p, NULL, 10);",
        "// Line_Reference 975:     s->chunksize = -1;",
        "// Line_Reference 1009:     int64_t off = s->off;",
        "// Line_Reference 1063:                            \"Range: bytes=%\"PRId64\"-\", s->off);",
        "// Line_Reference 1138:     s->filesize         = -1;",
        "// Line_Reference 1178:         int64_t target_end = s->end_off ? s->end_off : s->filesize;",
        "// Line_Reference 1179:         if ((!s->willclose || s->chunksize < 0) &&",
        "// Line_Reference 1180:             target_end >= 0 && s->off >= target_end)",
        "// Line_Reference 1183:         if (!len && (!s->willclose || s->chunksize < 0) &&",
        "// Line_Reference 1184:             target_end >= 0 && s->off < target_end) {",
        "// Line_Reference 1186:                    \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",",
        "// Line_Reference 1250:     if (s->chunksize >= 0) {",
        "// Line_Reference 1259:                 s->chunksize = strtoll(line, NULL, 16);",
        "// Line_Reference 1261:                 av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",",
        "// Line_Reference 1276:         int64_t target = h->is_streamed ? 0 : s->off;",
        "// Line_Reference 1281:         av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));",
        "// Line_Reference 1286:             av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);",
        "// Line_Reference 1341:     int remaining = s->icy_metaint - s->icy_data_read;",
        "// Line_Reference 1343:     if (remaining < 0)",
        "// Line_Reference 1458:     int64_t old_off = s->off;",
        "// Line_Reference 1469:     else if ((s->filesize == -1 && whence == SEEK_END))",
        "// Line_Reference 1624:     s->filesize   = -1;"
    ]
}
