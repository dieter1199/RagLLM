{
    "cve_id": "CVE-2013-1792",
    "cve_description": "Race condition in the install_user_keyrings function in security/keys/process_keys.c in the Linux kernel before 3.8.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) via crafted keyctl system calls that trigger keyring operations in simultaneous threads.",
    "cve_publish_date": "2013-03-22",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "keys: fix race with concurrent install_user_keyrings()\n\nThis fixes CVE-2013-1792.\n\nThere is a race in install_user_keyrings() that can cause a NULL pointer\ndereference when called concurrently for the same user if the uid and\nuid-session keyrings are not yet created.  It might be possible for an\nunprivileged user to trigger this by calling keyctl() from userspace in\nparallel immediately after logging in.\n\nAssume that we have two threads both executing lookup_user_key(), both\nlooking for KEY_SPEC_USER_SESSION_KEYRING.\n\n\tTHREAD A\t\t\tTHREAD B\n\t===============================\t===============================\n\t\t\t\t\t==>call install_user_keyrings();\n\tif (!cred->user->session_keyring)\n\t==>call install_user_keyrings()\n\t\t\t\t\t...\n\t\t\t\t\tuser->uid_keyring = uid_keyring;\n\tif (user->uid_keyring)\n\t\treturn 0;\n\t<==\n\tkey = cred->user->session_keyring [== NULL]\n\t\t\t\t\tuser->session_keyring = session_keyring;\n\tatomic_inc(&key->usage); [oops]\n\nAt the point thread A dereferences cred->user->session_keyring, thread B\nhasn't updated user->session_keyring yet, but thread A assumes it is\npopulated because install_user_keyrings() returned ok.\n\nThe race window is really small but can be exploited if, for example,\nthread B is interrupted or preempted after initializing uid_keyring, but\nbefore doing setting session_keyring.\n\nThis couldn't be reproduced on a stock kernel.  However, after placing\nsystemtap probe on 'user->session_keyring = session_keyring;' that\nintroduced some delay, the kernel could be crashed reliably.\n\nFix this by checking both pointers before deciding whether to return.\nAlternatively, the test could be done away with entirely as it is checked\ninside the mutex - but since the mutex is global, that may not be the best\nway.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nReported-by: Mateusz Guzik <mguzik@redhat.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "process_keys.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 60: \tif (user->uid_keyring) {"
    ]
}
