{
    "cve_id": "CVE-2016-10741",
    "cve_description": "In the Linux kernel before 4.9.3, fs/xfs/xfs_aops.c allows local users to cause a denial of service (system crash) because there is a race condition between direct and memory-mapped I/O (associated with a hole) that is handled with BUG_ON instead of an I/O failure.",
    "cve_publish_date": "2019-02-01",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "xfs: don't BUG() on mixed direct and mapped I/O\n\nWe've had reports of generic/095 causing XFS to BUG() in\n__xfs_get_blocks() due to the existence of delalloc blocks on a\ndirect I/O read. generic/095 issues a mix of various types of I/O,\nincluding direct and memory mapped I/O to a single file. This is\nclearly not supported behavior and is known to lead to such\nproblems. E.g., the lack of exclusion between the direct I/O and\nwrite fault paths means that a write fault can allocate delalloc\nblocks in a region of a file that was previously a hole after the\ndirect read has attempted to flush/inval the file range, but before\nit actually reads the block mapping. In turn, the direct read\ndiscovers a delalloc extent and cannot proceed.\n\nWhile the appropriate solution here is to not mix direct and memory\nmapped I/O to the same regions of the same file, the current\nBUG_ON() behavior is probably overkill as it can crash the entire\nsystem.  Instead, localize the failure to the I/O in question by\nreturning an error for a direct I/O that cannot be handled safely\ndue to delalloc blocks. Be careful to allow the case of a direct\nwrite to post-eof delalloc blocks. This can occur due to speculative\npreallocation and is safe as post-eof blocks are not accompanied by\ndirty pages in pagecache (conversely, preallocation within eof must\nhave been zeroed, and thus dirtied, before the inode size could have\nbeen increased beyond said blocks).\n\nFinally, provide an additional warning if a direct I/O write occurs\nwhile the file is memory mapped. This may not catch all problematic\nscenarios, but provides a hint that some known-to-be-problematic I/O\nmethods are in use.\n\nSigned-off-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "xfs_aops.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "20",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 1453: \tBUG_ON(direct && imap.br_startblock == DELAYSTARTBLOCK);",
        "// Line_Reference 1454: "
    ]
}
