{
    "cve_id": "CVE-2015-3331",
    "cve_description": "The __driver_rfc4106_decrypt function in arch/x86/crypto/aesni-intel_glue.c in the Linux kernel before 3.19.3 does not properly determine the memory locations used for encrypted data, which allows context-dependent attackers to cause a denial of service (buffer overflow and system crash) or possibly execute arbitrary code by triggering a crypto API call, as demonstrated by use of a libkcapi test program with an AF_ALG(aead) socket.",
    "cve_publish_date": "2015-05-27",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "crypto: aesni - fix memory usage in GCM decryption\n\nThe kernel crypto API logic requires the caller to provide the\nlength of (ciphertext || authentication tag) as cryptlen for the\nAEAD decryption operation. Thus, the cipher implementation must\ncalculate the size of the plaintext output itself and cannot simply use\ncryptlen.\n\nThe RFC4106 GCM decryption operation tries to overwrite cryptlen memory\nin req->dst. As the destination buffer for decryption only needs to hold\nthe plaintext memory but cryptlen references the input buffer holding\n(ciphertext || authentication tag), the assumption of the destination\nbuffer length in RFC4106 GCM operation leads to a too large size. This\npatch simply uses the already calculated plaintext size.\n\nIn addition, this patch fixes the offset calculation of the AAD buffer\npointer: as mentioned before, cryptlen already includes the size of the\ntag. Thus, the tag does not need to be added. With the addition, the AAD\nwill be written beyond the already allocated buffer.\n\nNote, this fixes a kernel crash that can be triggered from user space\nvia AF_ALG(aead) -- simply use the libkcapi test application\nfrom [1] and update it to use rfc4106-gcm-aes.\n\nUsing [1], the changes were tested using CAVS vectors to demonstrate\nthat the crypto operation still delivers the right results.\n\n[1] http://www.chronox.de/libkcapi.html\n\nCC: Tadeusz Struk <tadeusz.struk@intel.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Stephan Mueller <smueller@chronox.de>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
    "type_of_change": "Modification",
    "filename_of_changes": "aesni-intel_glue.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 1158: \t\tassoc = (src + req->cryptlen + auth_tag_len);",
        "// Line_Reference 1183: \t\tscatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1);"
    ]
}
