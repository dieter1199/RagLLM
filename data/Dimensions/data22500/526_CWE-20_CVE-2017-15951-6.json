{
    "cve_id": "CVE-2017-15951",
    "cve_description": "The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the \"negative\" state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls.",
    "cve_publish_date": "2017-10-28",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "KEYS: Fix race between updating and finding a negative key\n\nConsolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection\nerror into one field such that:\n\n (1) The instantiation state can be modified/read atomically.\n\n (2) The error can be accessed atomically with the state.\n\n (3) The error isn't stored unioned with the payload pointers.\n\nThis deals with the problem that the state is spread over three different\nobjects (two bits and a separate variable) and reading or updating them\natomically isn't practical, given that not only can uninstantiated keys\nchange into instantiated or rejected keys, but rejected keys can also turn\ninto instantiated keys - and someone accessing the key might not be using\nany locking.\n\nThe main side effect of this problem is that what was held in the payload\nmay change, depending on the state.  For instance, you might observe the\nkey to be in the rejected state.  You then read the cached error, but if\nthe key semaphore wasn't locked, the key might've become instantiated\nbetween the two reads - and you might now have something in hand that isn't\nactually an error code.\n\nThe state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error\ncode if the key is negatively instantiated.  The key_is_instantiated()\nfunction is replaced with key_is_positive() to avoid confusion as negative\nkeys are also 'instantiated'.\n\nAdditionally, barriering is included:\n\n (1) Order payload-set before state-set during instantiation.\n\n (2) Order state-read before payload-read when using the key.\n\nFurther separate barriering is necessary if RCU is being used to access the\npayload content after reading the payload pointers.\n\nFixes: 146aa8b1453b (\"KEYS: Merge the type-specific data with the payload data\")\nCc: stable@vger.kernel.org # v4.4+\nReported-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nReviewed-by: Eric Biggers <ebiggers@google.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "key.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "30",
    "number_of_lines_deleted_vulnerable_to_cve": "17",
    "vulnerable_lines": [
        "// Line_Reference 179: #define KEY_FLAG_INSTANTIATED\t0\t/* set if key has been instantiated */",
        "// Line_Reference 180: #define KEY_FLAG_DEAD\t\t1\t/* set if key type has been deleted */",
        "// Line_Reference 181: #define KEY_FLAG_REVOKED\t2\t/* set if key had been revoked */",
        "// Line_Reference 182: #define KEY_FLAG_IN_QUOTA\t3\t/* set if key consumes quota */",
        "// Line_Reference 183: #define KEY_FLAG_USER_CONSTRUCT\t4\t/* set if key is being constructed in userspace */",
        "// Line_Reference 184: #define KEY_FLAG_NEGATIVE\t5\t/* set if key is negative */",
        "// Line_Reference 185: #define KEY_FLAG_ROOT_CAN_CLEAR\t6\t/* set if key can be cleared by root without permission */",
        "// Line_Reference 186: #define KEY_FLAG_INVALIDATED\t7\t/* set if key has been invalidated */",
        "// Line_Reference 187: #define KEY_FLAG_BUILTIN\t8\t/* set if key is built in to the kernel */",
        "// Line_Reference 188: #define KEY_FLAG_ROOT_CAN_INVAL\t9\t/* set if key can be invalidated by root without permission */",
        "// Line_Reference 189: #define KEY_FLAG_KEEP\t\t10\t/* set if key should not be removed */",
        "// Line_Reference 190: #define KEY_FLAG_UID_KEYRING\t11\t/* set if key is a user or user session keyring */",
        "// Line_Reference 216: \t\tint reject_error;",
        "// Line_Reference 357:  * key_is_instantiated - Determine if a key has been positively instantiated",
        "// Line_Reference 363: static inline bool key_is_instantiated(const struct key *key)",
        "// Line_Reference 365: \treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&",
        "// Line_Reference 366: \t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);"
    ]
}
