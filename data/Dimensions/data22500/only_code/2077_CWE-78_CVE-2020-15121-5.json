static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {
int i;
int chsz = 1;
// r_socket_block_time (s, 1, 1, 0);
if (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {
for (i = 1; i < bufsz; i += chsz) {
buf[i] =0;
r_socket_block_time (s, 1, 0, 1000);
int olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);
if (olen != chsz) {
buf[i] = 0;
static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {
int ret, len = 0, bufsz = 32768, delta = 0;
char *dn, *buf = calloc (1, bufsz + 32); // XXX: use r_buffer here
if (!buf) {
int olen = __socket_slurp (s, (ut8*)buf, bufsz);
goto fail;
fail:
// is 's' free'd? isn't this going to cause a double free?
R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {
if (curl_env && *curl_env) {
char *encoded_url = r_str_escape (url);
char *res = r_sys_cmd_strf ("curl '%s'", encoded_url);
free (encoded_url);
*rlen = strlen (res);
free (curl_env);
if (code) {
*code = 0;
}
if (rlen) {
*rlen = 0;
}
response = r_socket_http_answer (s, code, rlen);
R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {
return r_socket_http_answer (s, code, rlen);
