ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
ext4_get_block);
struct buffer_head *page_bufs;
else
handle_t *handle = NULL;
if (max_blocks > DIO_MAX_BLOCKS)
max_blocks = DIO_MAX_BLOCKS;
dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);
handle = ext4_journal_start(inode, dio_credits);
if (IS_ERR(handle)) {
ret = PTR_ERR(handle);
goto out;
ext4_journal_stop(handle);
static void ext4_free_io_end(ext4_io_end_t *io)
{
BUG_ON(!io);
iput(io->inode);
kfree(io);
}
if (offset + size <= i_size_read(inode))
ret = ext4_convert_unwritten_extents(inode, offset, size);
ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);
struct inode *inode = io->inode;
int ret = 0;
if (ret >= 0) {
if (!list_empty(&io->list))
list_del_init(&io->list);
ext4_free_io_end(io);
if (list_empty(&EXT4_I(inode)->i_completed_io_list))
while (!list_empty(&EXT4_I(inode)->i_completed_io_list)){
io = list_entry(EXT4_I(inode)->i_completed_io_list.next,
static ext4_io_end_t *ext4_init_io_end (struct inode *inode)
io = kmalloc(sizeof(*io), GFP_NOFS);
io->error = 0;
list_add_tail(&io_end->list,
&EXT4_I(io_end->inode)->i_completed_io_list);
iocb->private = ext4_init_io_end(inode);
