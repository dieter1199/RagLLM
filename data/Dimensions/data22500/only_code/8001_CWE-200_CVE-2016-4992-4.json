static struct backentry *find_entry_internal_dn(Slapi_PBlock *pb, backend *be, const Slapi_DN *sdn, int lock, back_txn *txn, int flags);
static struct backentry * find_entry_internal(Slapi_PBlock *pb, Slapi_Backend *be, const entry_address *addr, int lock, back_txn *txn, int flags);
Slapi_Value *val=NULL;
Slapi_PBlock	*pb,
back_txn		*txn,
int				flags
slapi_pblock_get( pb, SLAPI_MANAGEDSAIT, &managedsait );
me= dn2ancestor(pb->pb_backend,sdn,&ancestorsdn,txn,&err);
slapi_send_ldap_result( pb, ( 0 == err || DB_NOTFOUND == err ) ?
LDAP_NO_SUCH_OBJECT : ( LDAP_INVALID_DN_SYNTAX == err ) ?
LDAP_INVALID_DN_SYNTAX : LDAP_OPERATIONS_ERROR,
(char*)slapi_sdn_get_dn(&ancestorsdn), NULL, 0, NULL );
Slapi_PBlock	*pb,
const char 			*uniqueid,
back_txn		*txn
back_txn *txn,
int flags
entry = find_entry_internal_dn (pb, be, addr->sdn,
lock, txn, flags);
LDAPDebug0Args( LDAP_DEBUG_ANY,
"find_entry_internal: Null target dn\n" );
back_txn *txn
return( find_entry_internal( pb, be, addr, 0/*!lock*/, txn, 0/*flags*/ ) );
back_txn *txn
return( find_entry_internal( pb, be, addr, 1/*lock*/, txn, 0/*flags*/ ) );
back_txn *txn
return( find_entry_internal( pb, be, addr, 0/*!lock*/, txn, FE_REALLY_INTERNAL ) );
back_txn *txn
return( find_entry_internal( pb, be, addr, 1/*lock*/, txn, FE_REALLY_INTERNAL ) );
back_txn *txn
return( find_entry_internal( pb, be, addr, 1/*lock*/, txn,
FE_REALLY_INTERNAL | flags ));
