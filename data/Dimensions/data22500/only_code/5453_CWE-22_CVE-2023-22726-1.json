"path"
type MkdirFS interface {
fs.FS
MkdirAll(path string, perm fs.FileMode) error
Open(name string) (fs.File, error)
OpenAtEnd(name string) (fs.File, error)
type MkdirFsImpl struct {
dir string
fs.FS
func (fsys MkdirFsImpl) MkdirAll(path string, perm fs.FileMode) error {
return os.MkdirAll(fsys.dir+"/"+path, perm)
func (fsys MkdirFsImpl) Open(name string) (fs.File, error) {
return os.OpenFile(fsys.dir+"/"+name, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
func (fsys MkdirFsImpl) OpenAtEnd(name string) (fs.File, error) {
file, err := os.OpenFile(fsys.dir+"/"+name, os.O_CREATE|os.O_RDWR, 0644)
func uploads(router *httprouter.Router, fsys MkdirFS) {
filePath := fmt.Sprintf("%s/%s", runID, itemPath)
err := fsys.MkdirAll(path.Dir(filePath), os.ModePerm)
if err != nil {
panic(err)
}
file, err := func() (fs.File, error) {
return fsys.OpenAtEnd(filePath)
return fsys.Open(filePath)
func downloads(router *httprouter.Router, fsys fs.FS) {
entries, err := fs.ReadDir(fsys, runID)
dirPath := fmt.Sprintf("%s/%s", container, itemPath)
err := fs.WalkDir(fsys, dirPath, func(path string, entry fs.DirEntry, err error) error {
rel, err := filepath.Rel(dirPath, path)
Path:            fmt.Sprintf("%s/%s", itemPath, rel),
file, err := fsys.Open(path)
file, err = fsys.Open(path + gzipExtension)
fs := os.DirFS(artifactPath)
uploads(router, MkdirFsImpl{artifactPath, fs})
downloads(router, fs)
