#include <linux/mbcache.h>
static int ext2_xattr_cache_insert(struct buffer_head *);
static struct mb_cache *ext2_xattr_cache;
if (ext2_xattr_cache_insert(bh))
if (ext2_xattr_cache_insert(bh))
if (ext2_xattr_cache_insert(bh))
struct mb_cache_entry *ce;
ce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,
bh->b_blocknr);
if (ce)
mb_cache_entry_free(ce);
if (ce)
mb_cache_entry_release(ce);
ext2_xattr_cache_insert(new_bh);
ext2_xattr_cache_insert(new_bh);
struct mb_cache_entry *ce;
ce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,
old_bh->b_blocknr);
if (ce)
mb_cache_entry_free(ce);
if (ce)
mb_cache_entry_release(ce);
struct mb_cache_entry *ce;
ce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);
if (ce)
mb_cache_entry_free(ce);
if (ce)
mb_cache_entry_release(ce);
/*
* ext2_xattr_put_super()
*
* This is called when a file system is unmounted.
*/
void
ext2_xattr_put_super(struct super_block *sb)
{
mb_cache_shrink(sb->s_bdev);
}
ext2_xattr_cache_insert(struct buffer_head *bh)
struct mb_cache_entry *ce;
ce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);
if (!ce)
return -ENOMEM;
error = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);
mb_cache_entry_free(ce);
} else {
ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
atomic_read(&ext2_xattr_cache->c_entry_count));
mb_cache_entry_release(ce);
}
struct mb_cache_entry *ce;
ce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,
hash);
if (IS_ERR(ce)) {
if (PTR_ERR(ce) == -EAGAIN)
goto again;
break;
}
if (le32_to_cpu(HDR(bh)->h_refcount) >
mb_cache_entry_release(ce);
ce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);
int __init
init_ext2_xattr(void)
ext2_xattr_cache = mb_cache_create("ext2_xattr", 6);
if (!ext2_xattr_cache)
return -ENOMEM;
return 0;
void
exit_ext2_xattr(void)
mb_cache_destroy(ext2_xattr_cache);
