{
    "cve_id": "CVE-2015-8839",
    "cve_description": "Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.",
    "cve_publish_date": "2016-05-02",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "ext4: fix races between page faults and hole punching\n\nCurrently, page faults and hole punching are completely unsynchronized.\nThis can result in page fault faulting in a page into a range that we\nare punching after truncate_pagecache_range() has been called and thus\nwe can end up with a page mapped to disk blocks that will be shortly\nfreed. Filesystem corruption will shortly follow. Note that the same\nrace is avoided for truncate by checking page fault offset against\ni_size but there isn't similar mechanism available for punching holes.\n\nFix the problem by creating new rw semaphore i_mmap_sem in inode and\ngrab it for writing over truncate, hole punching, and other functions\nremoving blocks from extent tree and for read over page faults. We\ncannot easily use i_data_sem for this since that ranks below transaction\nstart and we need something ranking above it so that it can be held over\nthe whole truncate / hole punching operation. Also remove various\nworkarounds we had in the code to reduce race window when page fault\ncould have created pages with stale mapping information.\n\nSigned-off-by: Jan Kara <jack@suse.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "type_of_change": "Modification",
    "filename_of_changes": "inode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "27",
    "number_of_lines_deleted_vulnerable_to_cve": "9",
    "vulnerable_lines": [
        "// Line_Reference 3634: \t/* Wait all existing dio workers, newcomers will block on i_mutex */",
        "// Line_Reference 3635: \text4_inode_block_unlocked_dio(inode);",
        "// Line_Reference 3636: \tinode_dio_wait(inode);",
        "// Line_Reference 3637: ",
        "// Line_Reference 3683: \t/* Now release the pages again to reduce race window */",
        "// Line_Reference 3684: \tif (last_block_offset > first_block_offset)",
        "// Line_Reference 3685: \t\ttruncate_pagecache_range(inode, first_block_offset,",
        "// Line_Reference 3686: \t\t\t\t\t last_block_offset);",
        "// Line_Reference 3687: "
    ]
}
