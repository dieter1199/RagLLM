{
    "cve_id": "CVE-2014-5471",
    "cve_description": "Stack consumption vulnerability in the parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel through 3.16.1 allows local users to cause a denial of service (uncontrolled recursion, and system crash or reboot) via a crafted iso9660 image with a CL entry referring to a directory entry that has a CL entry.",
    "cve_publish_date": "2014-09-01",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "isofs: Fix unbounded recursion when processing relocated directories\n\nWe did not check relocated directory in any way when processing Rock\nRidge 'CL' tag. Thus a corrupted isofs image can possibly have a CL\nentry pointing to another CL entry leading to possibly unbounded\nrecursion in kernel code and thus stack overflow or deadlocks (if there\nis a loop created from CL entries).\n\nFix the problem by not allowing CL entry to point to a directory entry\nwith CL entry (such use makes no good sense anyway) and by checking\nwhether CL entry doesn't point to itself.\n\nCC: stable@vger.kernel.org\nReported-by: Chris Evans <cevans@google.com>\nSigned-off-by: Jan Kara <jack@suse.cz>",
    "type_of_change": "Modification",
    "filename_of_changes": "inode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "8",
    "number_of_lines_deleted_vulnerable_to_cve": "7",
    "vulnerable_lines": [
        "// Line_Reference 64: static int isofs_read_inode(struct inode *);",
        "// Line_Reference 1262: static int isofs_read_inode(struct inode *inode)",
        "// Line_Reference 1407: \t\tparse_rock_ridge_inode(de, inode);",
        "// Line_Reference 1486: struct inode *isofs_iget(struct super_block *sb,",
        "// Line_Reference 1487: \t\t\t unsigned long block,",
        "// Line_Reference 1488: \t\t\t unsigned long offset)",
        "// Line_Reference 1510: \t\tret = isofs_read_inode(inode);"
    ]
}
