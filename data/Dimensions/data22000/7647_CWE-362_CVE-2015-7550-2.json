{
    "cve_id": "CVE-2015-7550",
    "cve_description": "The keyctl_read_key function in security/keys/keyctl.c in the Linux kernel before 4.3.4 does not properly use a semaphore, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted application that leverages a race condition between keyctl_revoke and keyctl_read calls.",
    "cve_publish_date": "2016-02-08",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "KEYS: Fix race between read and revoke\n\nThis fixes CVE-2015-7550.\n\nThere's a race between keyctl_read() and keyctl_revoke().  If the revoke\nhappens between keyctl_read() checking the validity of a key and the key's\nsemaphore being taken, then the key type read method will see a revoked key.\n\nThis causes a problem for the user-defined key type because it assumes in\nits read method that there will always be a payload in a non-revoked key\nand doesn't check for a NULL pointer.\n\nFix this by making keyctl_read() check the validity of a key after taking\nsemaphore instead of before.\n\nI think the bug was introduced with the original keyrings code.\n\nThis was discovered by a multithreaded test program generated by syzkaller\n(http://github.com/google/syzkaller).  Here's a cleaned up version:\n\n\t#include <sys/types.h>\n\t#include <keyutils.h>\n\t#include <pthread.h>\n\tvoid *thr0(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\tkeyctl_revoke(key);\n\t\treturn 0;\n\t}\n\tvoid *thr1(void *arg)\n\t{\n\t\tkey_serial_t key = (unsigned long)arg;\n\t\tchar buffer[16];\n\t\tkeyctl_read(key, buffer, 16);\n\t\treturn 0;\n\t}\n\tint main()\n\t{\n\t\tkey_serial_t key = add_key(\"user\", \"%\", \"foo\", 3, KEY_SPEC_USER_KEYRING);\n\t\tpthread_t th[5];\n\t\tpthread_create(&th[0], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[1], 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_create(&th[2], 0, thr0, (void *)(unsigned long)key);\n\t\tpthread_create(&th[3], 0, thr1, (void *)(unsigned long)key);\n\t\tpthread_join(th[0], 0);\n\t\tpthread_join(th[1], 0);\n\t\tpthread_join(th[2], 0);\n\t\tpthread_join(th[3], 0);\n\t\treturn 0;\n\t}\n\nBuild as:\n\n\tcc -o keyctl-race keyctl-race.c -lkeyutils -lpthread\n\nRun as:\n\n\twhile keyctl-race; do :; done\n\nas it may need several iterations to crash the kernel.  The crash can be\nsummarised as:\n\n\tBUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n\tIP: [<ffffffff81279b08>] user_read+0x56/0xa3\n\t...\n\tCall Trace:\n\t [<ffffffff81276aa9>] keyctl_read_key+0xb6/0xd7\n\t [<ffffffff81277815>] SyS_keyctl+0x83/0xe0\n\t [<ffffffff815dbb97>] entry_SYSCALL_64_fastpath+0x12/0x6f\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "keyctl.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "9",
    "number_of_lines_deleted_vulnerable_to_cve": "9",
    "vulnerable_lines": [
        "// Line_Reference 754: \tret = key_validate(key);",
        "// Line_Reference 755: \tif (ret == 0) {",
        "// Line_Reference 756: \t\tret = -EOPNOTSUPP;",
        "// Line_Reference 757: \t\tif (key->type->read) {",
        "// Line_Reference 758: \t\t\t/* read the data with the semaphore held (since we",
        "// Line_Reference 759: \t\t\t * might sleep) */",
        "// Line_Reference 760: \t\t\tdown_read(&key->sem);",
        "// Line_Reference 762: \t\t\tup_read(&key->sem);",
        "// Line_Reference 763: \t\t}"
    ]
}
