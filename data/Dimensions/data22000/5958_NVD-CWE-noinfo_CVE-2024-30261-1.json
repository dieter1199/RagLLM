{
    "cve_id": "CVE-2024-30261",
    "cve_description": "Undici is an HTTP/1.1 client, written from scratch for Node.js. An attacker can alter the `integrity` option passed to `fetch()`, allowing `fetch()` to accept requests as valid even if they have been tampered. This vulnerability was patched in version(s) 5.28.4 and 6.11.1.",
    "cve_publish_date": "2024-04-04",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-9qxr-qj54-h672\n\nCo-authored-by: uzlopak <aras.abbasi@googlemail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "util.js",
    "code_language": "JavaScript",
    "number_of_lines_added_for_mitigation": "105",
    "number_of_lines_deleted_vulnerable_to_cve": "33",
    "vulnerable_lines": [
        "// Line_Reference 568:   // 3. If parsedMetadata is the empty set, return true.",
        "// Line_Reference 573:   // 4. Let metadata be the result of getting the strongest",
        "// Line_Reference 575:   const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))",
        "// Line_Reference 576:   // get the strongest algorithm",
        "// Line_Reference 577:   const strongest = list[0].algo",
        "// Line_Reference 578:   // get all entries that use the strongest algorithm; ignore weaker",
        "// Line_Reference 579:   const metadata = list.filter((item) => item.algo === strongest)",
        "// Line_Reference 581:   // 5. For each item in metadata:",
        "// Line_Reference 587:     let expectedValue = item.hash",
        "// Line_Reference 592:     if (expectedValue.endsWith('==')) {",
        "// Line_Reference 593:       expectedValue = expectedValue.slice(0, -2)",
        "// Line_Reference 594:     }",
        "// Line_Reference 595: ",
        "// Line_Reference 599:     if (actualValue.endsWith('==')) {",
        "// Line_Reference 600:       actualValue = actualValue.slice(0, -2)",
        "// Line_Reference 605:     if (actualValue === expectedValue) {",
        "// Line_Reference 606:       return true",
        "// Line_Reference 607:     }",
        "// Line_Reference 608: ",
        "// Line_Reference 609:     let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url')",
        "// Line_Reference 610: ",
        "// Line_Reference 611:     if (actualBase64URL.endsWith('==')) {",
        "// Line_Reference 612:       actualBase64URL = actualBase64URL.slice(0, -2)",
        "// Line_Reference 613:     }",
        "// Line_Reference 614: ",
        "// Line_Reference 615:     if (actualBase64URL === expectedValue) {",
        "// Line_Reference 620:   // 6. Return false.",
        "// Line_Reference 627: const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-(?<hash>[A-Za-z0-9+/]+={0,2}(?=\\s|$))( +[!-~]*)?/i",
        "// Line_Reference 641:   const supportedHashes = crypto.getHashes()",
        "// Line_Reference 642: ",
        "// Line_Reference 652:     if (parsedToken === null || parsedToken.groups === undefined) {",
        "// Line_Reference 661:     const algorithm = parsedToken.groups.algo",
        "// Line_Reference 665:     if (supportedHashes.includes(algorithm.toLowerCase())) {"
    ]
}
