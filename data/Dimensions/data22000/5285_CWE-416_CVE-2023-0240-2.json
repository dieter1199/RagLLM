{
    "cve_id": "CVE-2023-0240",
    "cve_description": "There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.\n\nIn the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.",
    "cve_publish_date": "2023-01-30",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "io_uring: COW io_identity on mismatch\n\nIf the io_identity doesn't completely match the task, then create a\ncopy of it and use that. The existing copy remains valid until the last\nuser of it has gone away.\n\nThis also changes the personality lookup to be indexed by io_identity,\ninstead of creds directly.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "type_of_change": "Modification",
    "filename_of_changes": "io_uring.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "170",
    "number_of_lines_deleted_vulnerable_to_cve": "52",
    "vulnerable_lines": [
        "// Line_Reference 1194: static void io_prep_async_work(struct io_kiocb *req)",
        "// Line_Reference 1199: \tio_req_init_async(req);",
        "// Line_Reference 1201: \tif (req->flags & REQ_F_ISREG) {",
        "// Line_Reference 1202: \t\tif (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
        "// Line_Reference 1203: \t\t\tio_wq_hash_work(&req->work, file_inode(req->file));",
        "// Line_Reference 1204: \t} else {",
        "// Line_Reference 1205: \t\tif (def->unbound_nonreg_file)",
        "// Line_Reference 1206: \t\t\treq->work.flags |= IO_WQ_WORK_UNBOUND;",
        "// Line_Reference 1207: \t}",
        "// Line_Reference 1209: \t    (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) &&",
        "// Line_Reference 1211: \t\treq->work.identity->files = get_files_struct(current);",
        "// Line_Reference 1212: \t\tget_nsproxy(current->nsproxy);",
        "// Line_Reference 1213: \t\treq->work.identity->nsproxy = current->nsproxy;",
        "// Line_Reference 1221: \tif (!(req->work.flags & IO_WQ_WORK_MM) &&",
        "// Line_Reference 1222: \t    (def->work_flags & IO_WQ_WORK_MM)) {",
        "// Line_Reference 1223: \t\tmmgrab(current->mm);",
        "// Line_Reference 1224: \t\treq->work.identity->mm = current->mm;",
        "// Line_Reference 1225: \t\treq->work.flags |= IO_WQ_WORK_MM;",
        "// Line_Reference 1226: \t}",
        "// Line_Reference 1231: \t\treq->work.identity->blkcg_css = blkcg_css();",
        "// Line_Reference 1236: \t\tif (css_tryget_online(req->work.identity->blkcg_css))",
        "// Line_Reference 1242: \t\treq->work.identity->creds = get_current_cred();",
        "// Line_Reference 1247: \t\tspin_lock(&current->fs->lock);",
        "// Line_Reference 1248: \t\tif (!current->fs->in_exec) {",
        "// Line_Reference 1249: \t\t\treq->work.identity->fs = current->fs;",
        "// Line_Reference 1250: \t\t\treq->work.identity->fs->users++;",
        "// Line_Reference 1257: \tif (def->needs_fsize)",
        "// Line_Reference 1258: \t\treq->work.identity->fsize = rlimit(RLIMIT_FSIZE);",
        "// Line_Reference 1259: \telse",
        "// Line_Reference 1260: \t\treq->work.identity->fsize = RLIM_INFINITY;",
        "// Line_Reference 1699: \tstruct io_uring_task *tctx;",
        "// Line_Reference 1700: \tstruct io_ring_ctx *ctx;",
        "// Line_Reference 1703: \ttctx = req->task->io_uring;",
        "// Line_Reference 1704: \tctx = req->ctx;",
        "// Line_Reference 6378: \t\treq->work.identity->creds = idr_find(&ctx->personality_idr, id);",
        "// Line_Reference 6379: \t\tif (unlikely(!req->work.identity->creds))",
        "// Line_Reference 6381: \t\tget_cred(req->work.identity->creds);",
        "// Line_Reference 8174: \tconst struct cred *cred;",
        "// Line_Reference 8176: \tcred = idr_remove(&ctx->personality_idr, id);",
        "// Line_Reference 8177: \tif (cred)",
        "// Line_Reference 8178: \t\tput_cred(cred);",
        "// Line_Reference 9248: \tconst struct cred *creds = get_current_cred();",
        "// Line_Reference 9249: \tint id;",
        "// Line_Reference 9251: \tid = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1,",
        "// Line_Reference 9252: \t\t\t\tUSHRT_MAX, GFP_KERNEL);",
        "// Line_Reference 9253: \tif (id < 0)",
        "// Line_Reference 9254: \t\tput_cred(creds);",
        "// Line_Reference 9255: \treturn id;",
        "// Line_Reference 9260: \tconst struct cred *old_creds;",
        "// Line_Reference 9262: \told_creds = idr_remove(&ctx->personality_idr, id);",
        "// Line_Reference 9263: \tif (old_creds) {",
        "// Line_Reference 9264: \t\tput_cred(old_creds);"
    ]
}
