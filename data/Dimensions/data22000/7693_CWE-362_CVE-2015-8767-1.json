{
    "cve_id": "CVE-2015-8767",
    "cve_description": "net/sctp/sm_sideeffect.c in the Linux kernel before 4.3 does not properly manage the relationship between a lock and a socket, which allows local users to cause a denial of service (deadlock) via a crafted sctp_accept call.",
    "cve_publish_date": "2016-02-08",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "sctp: Prevent soft lockup when sctp_accept() is called during a timeout event\n\nA case can occur when sctp_accept() is called by the user during\na heartbeat timeout event after the 4-way handshake.  Since\nsctp_assoc_migrate() changes both assoc->base.sk and assoc->ep, the\nbh_sock_lock in sctp_generate_heartbeat_event() will be taken with\nthe listening socket but released with the new association socket.\nThe result is a deadlock on any future attempts to take the listening\nsocket lock.\n\nNote that this race can occur with other SCTP timeouts that take\nthe bh_lock_sock() in the event sctp_accept() is called.\n\n BUG: soft lockup - CPU#9 stuck for 67s! [swapper:0]\n ...\n RIP: 0010:[<ffffffff8152d48e>]  [<ffffffff8152d48e>] _spin_lock+0x1e/0x30\n RSP: 0018:ffff880028323b20  EFLAGS: 00000206\n RAX: 0000000000000002 RBX: ffff880028323b20 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffff880028323be0 RDI: ffff8804632c4b48\n RBP: ffffffff8100bb93 R08: 0000000000000000 R09: 0000000000000000\n R10: ffff880610662280 R11: 0000000000000100 R12: ffff880028323aa0\n R13: ffff8804383c3880 R14: ffff880028323a90 R15: ffffffff81534225\n FS:  0000000000000000(0000) GS:ffff880028320000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b\n CR2: 00000000006df528 CR3: 0000000001a85000 CR4: 00000000000006e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n Process swapper (pid: 0, threadinfo ffff880616b70000, task ffff880616b6cab0)\n Stack:\n ffff880028323c40 ffffffffa01c2582 ffff880614cfb020 0000000000000000\n <d> 0100000000000000 00000014383a6c44 ffff8804383c3880 ffff880614e93c00\n <d> ffff880614e93c00 0000000000000000 ffff8804632c4b00 ffff8804383c38b8\n Call Trace:\n <IRQ>\n [<ffffffffa01c2582>] ? sctp_rcv+0x492/0xa10 [sctp]\n [<ffffffff8148c559>] ? nf_iterate+0x69/0xb0\n [<ffffffff814974a0>] ? ip_local_deliver_finish+0x0/0x2d0\n [<ffffffff8148c716>] ? nf_hook_slow+0x76/0x120\n [<ffffffff814974a0>] ? ip_local_deliver_finish+0x0/0x2d0\n [<ffffffff8149757d>] ? ip_local_deliver_finish+0xdd/0x2d0\n [<ffffffff81497808>] ? ip_local_deliver+0x98/0xa0\n [<ffffffff81496ccd>] ? ip_rcv_finish+0x12d/0x440\n [<ffffffff81497255>] ? ip_rcv+0x275/0x350\n [<ffffffff8145cfeb>] ? __netif_receive_skb+0x4ab/0x750\n ...\n\nWith lockdep debugging:\n\n =====================================\n [ BUG: bad unlock balance detected! ]\n -------------------------------------\n CslRx/12087 is trying to release lock (slock-AF_INET) at:\n [<ffffffffa01bcae0>] sctp_generate_timeout_event+0x40/0xe0 [sctp]\n but there are no more locks to release!\n\n other info that might help us debug this:\n 2 locks held by CslRx/12087:\n #0:  (&asoc->timers[i]){+.-...}, at: [<ffffffff8108ce1f>] run_timer_softirq+0x16f/0x3e0\n #1:  (slock-AF_INET){+.-...}, at: [<ffffffffa01bcac3>] sctp_generate_timeout_event+0x23/0xe0 [sctp]\n\nEnsure the socket taken is also the same one that is released by\nsaving a copy of the socket before entering the timeout event\ncritical section.\n\nSigned-off-by: Karl Heiss <kheiss@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "sm_sideeffect.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "23",
    "number_of_lines_deleted_vulnerable_to_cve": "19",
    "vulnerable_lines": [
        "// Line_Reference 247: \tstruct net *net = sock_net(asoc->base.sk);",
        "// Line_Reference 251: \tbh_lock_sock(asoc->base.sk);",
        "// Line_Reference 252: \tif (sock_owned_by_user(asoc->base.sk)) {",
        "// Line_Reference 275: \t\tasoc->base.sk->sk_err = -error;",
        "// Line_Reference 278: \tbh_unlock_sock(asoc->base.sk);",
        "// Line_Reference 288: \tstruct net *net = sock_net(asoc->base.sk);",
        "// Line_Reference 291: \tbh_lock_sock(asoc->base.sk);",
        "// Line_Reference 292: \tif (sock_owned_by_user(asoc->base.sk)) {",
        "// Line_Reference 315: \t\tasoc->base.sk->sk_err = -error;",
        "// Line_Reference 318: \tbh_unlock_sock(asoc->base.sk);",
        "// Line_Reference 368: \tstruct net *net = sock_net(asoc->base.sk);",
        "// Line_Reference 370: \tbh_lock_sock(asoc->base.sk);",
        "// Line_Reference 371: \tif (sock_owned_by_user(asoc->base.sk)) {",
        "// Line_Reference 392: \t\tasoc->base.sk->sk_err = -error;",
        "// Line_Reference 395: \tbh_unlock_sock(asoc->base.sk);",
        "// Line_Reference 406: \tstruct net *net = sock_net(asoc->base.sk);",
        "// Line_Reference 408: \tbh_lock_sock(asoc->base.sk);",
        "// Line_Reference 409: \tif (sock_owned_by_user(asoc->base.sk)) {",
        "// Line_Reference 430: \tbh_unlock_sock(asoc->base.sk);"
    ]
}
