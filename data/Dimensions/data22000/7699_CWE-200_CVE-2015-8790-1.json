{
    "cve_id": "CVE-2015-8790",
    "cve_description": "The EbmlUnicodeString::UpdateFromUTF8 function in libEBML before 1.3.3 allows context-dependent attackers to obtain sensitive information from process heap memory via a crafted UTF-8 string, which triggers an invalid memory access.",
    "cve_publish_date": "2016-01-29",
    "cwe_id": "CWE-200",
    "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
    "cwe_description": "The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.",
    "commit_message": "EbmlUnicodeString: don't read beyond end of string\n\nThe conversion from an UTF-8 encoded string into a wchar_t one was\nreading from beyond the end of the source buffer if the length indicated\nby a UTF-8 character's first byte exceeds the number of bytes actually\npresent afterwards.\n\nFixes the issue reported as Cisco TALOS-CAN-0036.",
    "type_of_change": "Modification",
    "filename_of_changes": "EbmlUnicodeString.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "38",
    "number_of_lines_deleted_vulnerable_to_cve": "23",
    "vulnerable_lines": [
        "// Line_Reference 146:   for (_Length=0, i=0; i<UTF8string.length(); _Length++) {",
        "// Line_Reference 147:     uint8 lead = static_cast<uint8>(UTF8string[i]);",
        "// Line_Reference 148:     if (lead < 0x80)",
        "// Line_Reference 149:       i++;",
        "// Line_Reference 150:     else if ((lead >> 5) == 0x6)",
        "// Line_Reference 151:       i += 2;",
        "// Line_Reference 152:     else if ((lead >> 4) == 0xe)",
        "// Line_Reference 153:       i += 3;",
        "// Line_Reference 154:     else if ((lead >> 3) == 0x1e)",
        "// Line_Reference 155:       i += 4;",
        "// Line_Reference 162:   for (j=0, i=0; i<UTF8string.length(); j++) {",
        "// Line_Reference 163:     uint8 lead = static_cast<uint8>(UTF8string[i]);",
        "// Line_Reference 164:     if (lead < 0x80) {",
        "// Line_Reference 166:       i++;",
        "// Line_Reference 167:     } else if ((lead >> 5) == 0x6) {",
        "// Line_Reference 169:       i += 2;",
        "// Line_Reference 170:     } else if ((lead >> 4) == 0xe) {",
        "// Line_Reference 172:       i += 3;",
        "// Line_Reference 173:     } else if ((lead >> 3) == 0x1e) {",
        "// Line_Reference 175:       i += 4;",
        "// Line_Reference 176:     } else",
        "// Line_Reference 177:       // Invalid char?",
        "// Line_Reference 178:       break;"
    ]
}
