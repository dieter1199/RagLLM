{
    "cve_id": "CVE-2015-7872",
    "cve_description": "The key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 4.2.6 allows local users to cause a denial of service (OOPS) via crafted keyctl commands.",
    "cve_publish_date": "2015-11-16",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "KEYS: Fix crash when attempt to garbage collect an uninstantiated keyring\n\nThe following sequence of commands:\n\n    i=`keyctl add user a a @s`\n    keyctl request2 keyring foo bar @t\n    keyctl unlink $i @s\n\ntries to invoke an upcall to instantiate a keyring if one doesn't already\nexist by that name within the user's keyring set.  However, if the upcall\nfails, the code sets keyring->type_data.reject_error to -ENOKEY or some\nother error code.  When the key is garbage collected, the key destroy\nfunction is called unconditionally and keyring_destroy() uses list_empty()\non keyring->type_data.link - which is in a union with reject_error.\nSubsequently, the kernel tries to unlink the keyring from the keyring names\nlist - which oopses like this:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff8126e051>] keyring_destroy+0x3d/0x88\n\t...\n\tWorkqueue: events key_garbage_collector\n\t...\n\tRIP: 0010:[<ffffffff8126e051>] keyring_destroy+0x3d/0x88\n\tRSP: 0018:ffff88003e2f3d30  EFLAGS: 00010203\n\tRAX: 00000000ffffff82 RBX: ffff88003bf1a900 RCX: 0000000000000000\n\tRDX: 0000000000000000 RSI: 000000003bfc6901 RDI: ffffffff81a73a40\n\tRBP: ffff88003e2f3d38 R08: 0000000000000152 R09: 0000000000000000\n\tR10: ffff88003e2f3c18 R11: 000000000000865b R12: ffff88003bf1a900\n\tR13: 0000000000000000 R14: ffff88003bf1a908 R15: ffff88003e2f4000\n\t...\n\tCR2: 00000000ffffff8a CR3: 000000003e3ec000 CR4: 00000000000006f0\n\t...\n\tCall Trace:\n\t [<ffffffff8126c756>] key_gc_unused_keys.constprop.1+0x5d/0x10f\n\t [<ffffffff8126ca71>] key_garbage_collector+0x1fa/0x351\n\t [<ffffffff8105ec9b>] process_one_work+0x28e/0x547\n\t [<ffffffff8105fd17>] worker_thread+0x26e/0x361\n\t [<ffffffff8105faa9>] ? rescuer_thread+0x2a8/0x2a8\n\t [<ffffffff810648ad>] kthread+0xf3/0xfb\n\t [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2\n\t [<ffffffff815f2ccf>] ret_from_fork+0x3f/0x70\n\t [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2\n\nNote the value in RAX.  This is a 32-bit representation of -ENOKEY.\n\nThe solution is to only call ->destroy() if the key was successfully\ninstantiated.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "gc.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 137: \t\t/* Throw away the key data */",
        "// Line_Reference 138: \t\tif (key->type->destroy)"
    ]
}
