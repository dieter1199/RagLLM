{
    "cve_id": "CVE-2016-6136",
    "cve_description": "Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a \"double fetch\" vulnerability.",
    "cve_publish_date": "2016-08-06",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "audit: fix a double fetch in audit_log_single_execve_arg()\n\nThere is a double fetch problem in audit_log_single_execve_arg()\nwhere we first check the execve(2) argumnets for any \"bad\" characters\nwhich would require hex encoding and then re-fetch the arguments for\nlogging in the audit record[1].  Of course this leaves a window of\nopportunity for an unsavory application to munge with the data.\n\nThis patch reworks things by only fetching the argument data once[2]\ninto a buffer where it is scanned and logged into the audit\nrecords(s).  In addition to fixing the double fetch, this patch\nimproves on the original code in a few other ways: better handling\nof large arguments which require encoding, stricter record length\nchecking, and some performance improvements (completely unverified,\nbut we got rid of some strlen() calls, that's got to be a good\nthing).\n\nAs part of the development of this patch, I've also created a basic\nregression test for the audit-testsuite, the test can be tracked on\nGitHub at the following link:\n\n * https://github.com/linux-audit/audit-testsuite/issues/25\n\n[1] If you pay careful attention, there is actually a triple fetch\nproblem due to a strnlen_user() call at the top of the function.\n\n[2] This is a tiny white lie, we do make a call to strnlen_user()\nprior to fetching the argument data.  I don't like it, but due to the\nway the audit record is structured we really have no choice unless we\ncopy the entire argument at once (which would require a rather\nwasteful allocation).  The good news is that with this patch the\nkernel no longer relies on this strnlen_user() value for anything\nbeyond recording it in the log, we also update it with a trustworthy\nvalue whenever possible.\n\nReported-by: Pengfei Wang <wpengfeinudt@gmail.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Paul Moore <paul@paul-moore.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "auditsc.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "164",
    "number_of_lines_deleted_vulnerable_to_cve": "168",
    "vulnerable_lines": [
        "// Line_Reference 85: /* no execve audit message should be longer than this (userspace limits) */",
        "// Line_Reference 995: /*",
        "// Line_Reference 996:  * to_send and len_sent accounting are very loose estimates.  We aren't",
        "// Line_Reference 997:  * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being",
        "// Line_Reference 998:  * within about 500 bytes (next page boundary)",
        "// Line_Reference 999:  *",
        "// Line_Reference 1000:  * why snprintf?  an int is up to 12 digits long.  if we just assumed when",
        "// Line_Reference 1001:  * logging that a[%d]= was going to be 16 characters long we would be wasting",
        "// Line_Reference 1002:  * space in every audit message.  In one 7500 byte message we can log up to",
        "// Line_Reference 1003:  * about 1000 min size arguments.  That comes down to about 50% waste of space",
        "// Line_Reference 1004:  * if we didn't do the snprintf to find out how long arg_num_len was.",
        "// Line_Reference 1005:  */",
        "// Line_Reference 1006: static int audit_log_single_execve_arg(struct audit_context *context,",
        "// Line_Reference 1007: \t\t\t\t\tstruct audit_buffer **ab,",
        "// Line_Reference 1008: \t\t\t\t\tint arg_num,",
        "// Line_Reference 1009: \t\t\t\t\tsize_t *len_sent,",
        "// Line_Reference 1010: \t\t\t\t\tconst char __user *p,",
        "// Line_Reference 1011: \t\t\t\t\tchar *buf)",
        "// Line_Reference 1013: \tchar arg_num_len_buf[12];",
        "// Line_Reference 1014: \tconst char __user *tmp_p = p;",
        "// Line_Reference 1015: \t/* how many digits are in arg_num? 5 is the length of ' a=\"\"' */",
        "// Line_Reference 1016: \tsize_t arg_num_len = snprintf(arg_num_len_buf, 12, \"%d\", arg_num) + 5;",
        "// Line_Reference 1017: \tsize_t len, len_left, to_send;",
        "// Line_Reference 1018: \tsize_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;",
        "// Line_Reference 1019: \tunsigned int i, has_cntl = 0, too_long = 0;",
        "// Line_Reference 1020: \tint ret;",
        "// Line_Reference 1021: ",
        "// Line_Reference 1022: \t/* strnlen_user includes the null we don't want to send */",
        "// Line_Reference 1023: \tlen_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;",
        "// Line_Reference 1024: ",
        "// Line_Reference 1025: \t/*",
        "// Line_Reference 1026: \t * We just created this mm, if we can't find the strings",
        "// Line_Reference 1027: \t * we just copied into it something is _very_ wrong. Similar",
        "// Line_Reference 1028: \t * for strings that are too long, we should not have created",
        "// Line_Reference 1029: \t * any.",
        "// Line_Reference 1030: \t */",
        "// Line_Reference 1031: \tif (WARN_ON_ONCE(len < 0 || len > MAX_ARG_STRLEN - 1)) {",
        "// Line_Reference 1032: \t\tsend_sig(SIGKILL, current, 0);",
        "// Line_Reference 1033: \t\treturn -1;",
        "// Line_Reference 1036: \t/* walk the whole argument looking for non-ascii chars */",
        "// Line_Reference 1038: \t\tif (len_left > MAX_EXECVE_AUDIT_LEN)",
        "// Line_Reference 1039: \t\t\tto_send = MAX_EXECVE_AUDIT_LEN;",
        "// Line_Reference 1040: \t\telse",
        "// Line_Reference 1041: \t\t\tto_send = len_left;",
        "// Line_Reference 1042: \t\tret = copy_from_user(buf, tmp_p, to_send);",
        "// Line_Reference 1043: \t\t/*",
        "// Line_Reference 1044: \t\t * There is no reason for this copy to be short. We just",
        "// Line_Reference 1045: \t\t * copied them here, and the mm hasn't been exposed to user-",
        "// Line_Reference 1046: \t\t * space yet.",
        "// Line_Reference 1047: \t\t */",
        "// Line_Reference 1048: \t\tif (ret) {",
        "// Line_Reference 1049: \t\t\tWARN_ON(1);",
        "// Line_Reference 1050: \t\t\tsend_sig(SIGKILL, current, 0);",
        "// Line_Reference 1051: \t\t\treturn -1;",
        "// Line_Reference 1052: \t\t}",
        "// Line_Reference 1053: \t\tbuf[to_send] = '\\0';",
        "// Line_Reference 1054: \t\thas_cntl = audit_string_contains_control(buf, to_send);",
        "// Line_Reference 1055: \t\tif (has_cntl) {",
        "// Line_Reference 1056: \t\t\t/*",
        "// Line_Reference 1057: \t\t\t * hex messages get logged as 2 bytes, so we can only",
        "// Line_Reference 1058: \t\t\t * send half as much in each message",
        "// Line_Reference 1059: \t\t\t */",
        "// Line_Reference 1060: \t\t\tmax_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;",
        "// Line_Reference 1061: \t\t\tbreak;",
        "// Line_Reference 1062: \t\t}",
        "// Line_Reference 1063: \t\tlen_left -= to_send;",
        "// Line_Reference 1064: \t\ttmp_p += to_send;",
        "// Line_Reference 1065: \t} while (len_left > 0);",
        "// Line_Reference 1066: ",
        "// Line_Reference 1067: \tlen_left = len;",
        "// Line_Reference 1068: ",
        "// Line_Reference 1069: \tif (len > max_execve_audit_len)",
        "// Line_Reference 1070: \t\ttoo_long = 1;",
        "// Line_Reference 1071: ",
        "// Line_Reference 1072: \t/* rewalk the argument actually logging the message */",
        "// Line_Reference 1073: \tfor (i = 0; len_left > 0; i++) {",
        "// Line_Reference 1074: \t\tint room_left;",
        "// Line_Reference 1075: ",
        "// Line_Reference 1076: \t\tif (len_left > max_execve_audit_len)",
        "// Line_Reference 1077: \t\t\tto_send = max_execve_audit_len;",
        "// Line_Reference 1078: \t\telse",
        "// Line_Reference 1079: \t\t\tto_send = len_left;",
        "// Line_Reference 1080: ",
        "// Line_Reference 1081: \t\t/* do we have space left to send this argument in this ab? */",
        "// Line_Reference 1082: \t\troom_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;",
        "// Line_Reference 1083: \t\tif (has_cntl)",
        "// Line_Reference 1084: \t\t\troom_left -= (to_send * 2);",
        "// Line_Reference 1085: \t\telse",
        "// Line_Reference 1086: \t\t\troom_left -= to_send;",
        "// Line_Reference 1087: \t\tif (room_left < 0) {",
        "// Line_Reference 1088: \t\t\t*len_sent = 0;",
        "// Line_Reference 1089: \t\t\taudit_log_end(*ab);",
        "// Line_Reference 1090: \t\t\t*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);",
        "// Line_Reference 1091: \t\t\tif (!*ab)",
        "// Line_Reference 1092: \t\t\t\treturn 0;",
        "// Line_Reference 1093: \t\t}",
        "// Line_Reference 1095: \t\t/*",
        "// Line_Reference 1096: \t\t * first record needs to say how long the original string was",
        "// Line_Reference 1097: \t\t * so we can be sure nothing was lost.",
        "// Line_Reference 1098: \t\t */",
        "// Line_Reference 1099: \t\tif ((i == 0) && (too_long))",
        "// Line_Reference 1100: \t\t\taudit_log_format(*ab, \" a%d_len=%zu\", arg_num,",
        "// Line_Reference 1101: \t\t\t\t\t has_cntl ? 2*len : len);",
        "// Line_Reference 1102: ",
        "// Line_Reference 1103: \t\t/*",
        "// Line_Reference 1104: \t\t * normally arguments are small enough to fit and we already",
        "// Line_Reference 1105: \t\t * filled buf above when we checked for control characters",
        "// Line_Reference 1106: \t\t * so don't bother with another copy_from_user",
        "// Line_Reference 1107: \t\t */",
        "// Line_Reference 1108: \t\tif (len >= max_execve_audit_len)",
        "// Line_Reference 1109: \t\t\tret = copy_from_user(buf, p, to_send);",
        "// Line_Reference 1110: \t\telse",
        "// Line_Reference 1111: \t\t\tret = 0;",
        "// Line_Reference 1112: \t\tif (ret) {",
        "// Line_Reference 1113: \t\t\tWARN_ON(1);",
        "// Line_Reference 1114: \t\t\tsend_sig(SIGKILL, current, 0);",
        "// Line_Reference 1115: \t\t\treturn -1;",
        "// Line_Reference 1117: \t\tbuf[to_send] = '\\0';",
        "// Line_Reference 1118: ",
        "// Line_Reference 1119: \t\t/* actually log it */",
        "// Line_Reference 1120: \t\taudit_log_format(*ab, \" a%d\", arg_num);",
        "// Line_Reference 1121: \t\tif (too_long)",
        "// Line_Reference 1122: \t\t\taudit_log_format(*ab, \"[%d]\", i);",
        "// Line_Reference 1123: \t\taudit_log_format(*ab, \"=\");",
        "// Line_Reference 1124: \t\tif (has_cntl)",
        "// Line_Reference 1125: \t\t\taudit_log_n_hex(*ab, buf, to_send);",
        "// Line_Reference 1126: \t\telse",
        "// Line_Reference 1127: \t\t\taudit_log_string(*ab, buf);",
        "// Line_Reference 1128: ",
        "// Line_Reference 1129: \t\tp += to_send;",
        "// Line_Reference 1130: \t\tlen_left -= to_send;",
        "// Line_Reference 1131: \t\t*len_sent += arg_num_len;",
        "// Line_Reference 1132: \t\tif (has_cntl)",
        "// Line_Reference 1133: \t\t\t*len_sent += to_send * 2;",
        "// Line_Reference 1134: \t\telse",
        "// Line_Reference 1135: \t\t\t*len_sent += to_send;",
        "// Line_Reference 1136: \t}",
        "// Line_Reference 1137: \t/* include the null we didn't log */",
        "// Line_Reference 1138: \treturn len + 1;",
        "// Line_Reference 1139: }",
        "// Line_Reference 1141: static void audit_log_execve_info(struct audit_context *context,",
        "// Line_Reference 1142: \t\t\t\t  struct audit_buffer **ab)",
        "// Line_Reference 1143: {",
        "// Line_Reference 1144: \tint i, len;",
        "// Line_Reference 1145: \tsize_t len_sent = 0;",
        "// Line_Reference 1146: \tconst char __user *p;",
        "// Line_Reference 1147: \tchar *buf;",
        "// Line_Reference 1149: \tp = (const char __user *)current->mm->arg_start;",
        "// Line_Reference 1151: \taudit_log_format(*ab, \"argc=%d\", context->execve.argc);",
        "// Line_Reference 1153: \t/*",
        "// Line_Reference 1154: \t * we need some kernel buffer to hold the userspace args.  Just",
        "// Line_Reference 1155: \t * allocate one big one rather than allocating one of the right size",
        "// Line_Reference 1156: \t * for every single argument inside audit_log_single_execve_arg()",
        "// Line_Reference 1157: \t * should be <8k allocation so should be pretty safe.",
        "// Line_Reference 1158: \t */",
        "// Line_Reference 1159: \tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);",
        "// Line_Reference 1160: \tif (!buf) {",
        "// Line_Reference 1161: \t\taudit_panic(\"out of memory for argv string\");",
        "// Line_Reference 1162: \t\treturn;",
        "// Line_Reference 1163: \t}",
        "// Line_Reference 1165: \tfor (i = 0; i < context->execve.argc; i++) {",
        "// Line_Reference 1166: \t\tlen = audit_log_single_execve_arg(context, ab, i,",
        "// Line_Reference 1167: \t\t\t\t\t\t  &len_sent, p, buf);",
        "// Line_Reference 1168: \t\tif (len <= 0)",
        "// Line_Reference 1169: \t\t\tbreak;",
        "// Line_Reference 1170: \t\tp += len;",
        "// Line_Reference 1171: \t}",
        "// Line_Reference 1172: \tkfree(buf);"
    ]
}
