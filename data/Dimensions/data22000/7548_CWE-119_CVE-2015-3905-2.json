{
    "cve_id": "CVE-2015-3905",
    "cve_description": "Buffer overflow in the set_cs_start function in t1disasm.c in t1utils before 1.39 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.",
    "cve_publish_date": "2015-06-08",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "Security fixes.\n\n- Don't overflow the small cs_start buffer (reported by Niels\n  Thykier via the debian tracker (Jakub Wilk), found with a\n  fuzzer (\"American fuzzy lop\")).\n\n- Cast arguments to <ctype.h> functions to unsigned char.",
    "type_of_change": "Modification",
    "filename_of_changes": "t1disasm.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "40",
    "vulnerable_lines": [
        "// Line_Reference 81: static int lenIV = 4;",
        "// Line_Reference 82: static char cs_start[10];",
        "// Line_Reference 93: /* If the line contains an entry of the form `/lenIV <num>' then set the global",
        "// Line_Reference 94:    lenIV to <num>.  This indicates the number of random bytes at the beginning",
        "// Line_Reference 95:    of each charstring. */",
        "// Line_Reference 96: ",
        "// Line_Reference 97: static void",
        "// Line_Reference 98: set_lenIV(char *line)",
        "// Line_Reference 99: {",
        "// Line_Reference 100:   char *p = strstr(line, \"/lenIV \");",
        "// Line_Reference 101: ",
        "// Line_Reference 102:   /* Allow lenIV to be negative. Thanks to Tom Kacvinsky <tjk@ams.org> */",
        "// Line_Reference 103:   if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {",
        "// Line_Reference 104:     lenIV = atoi(p + 7);",
        "// Line_Reference 105:   }",
        "// Line_Reference 106: }",
        "// Line_Reference 107: ",
        "// Line_Reference 108: static void",
        "// Line_Reference 109: set_cs_start(char *line)",
        "// Line_Reference 110: {",
        "// Line_Reference 111:   char *p, *q, *r;",
        "// Line_Reference 112: ",
        "// Line_Reference 113:   if ((p = strstr(line, \"string currentfile\"))) {",
        "// Line_Reference 114:     /* enforce presence of `readstring' -- 5/29/99 */",
        "// Line_Reference 115:     if (!strstr(line, \"readstring\"))",
        "// Line_Reference 116:       return;",
        "// Line_Reference 117:     /* locate the name of the charstring start command */",
        "// Line_Reference 118:     *p = '\\0';\t\t\t\t\t  /* damage line[] */",
        "// Line_Reference 119:     q = strrchr(line, '/');",
        "// Line_Reference 120:     if (q) {",
        "// Line_Reference 121:       r = cs_start;",
        "// Line_Reference 122:       ++q;",
        "// Line_Reference 123:       while (!isspace(*q) && *q != '{')",
        "// Line_Reference 124: \t*r++ = *q++;",
        "// Line_Reference 125:       *r = '\\0';",
        "// Line_Reference 126:     }",
        "// Line_Reference 127:     *p = 's';\t\t\t\t\t  /* repair line[] */",
        "// Line_Reference 128:   }",
        "// Line_Reference 129: }",
        "// Line_Reference 130: "
    ]
}
