{
    "cve_id": "CVE-2013-1797",
    "cve_description": "Use-after-free vulnerability in arch/x86/kvm/x86.c in the Linux kernel through 3.8.4 allows guest OS users to cause a denial of service (host OS memory corruption) or possibly have unspecified other impact via a crafted application that triggers use of a guest physical address (GPA) in (1) movable or (2) removable memory during an MSR_KVM_SYSTEM_TIME kvm_set_msr_common operation.",
    "cve_publish_date": "2013-03-22",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "KVM: x86: Convert MSR_KVM_SYSTEM_TIME to use gfn_to_hva_cache functions (CVE-2013-1797)\n\nThere is a potential use after free issue with the handling of\nMSR_KVM_SYSTEM_TIME.  If the guest specifies a GPA in a movable or removable\nmemory such as frame buffers then KVM might continue to write to that\naddress even after it's removed via KVM_SET_USER_MEMORY_REGION.  KVM pins\nthe page in memory so it's unlikely to cause an issue, but if the user\nspace component re-purposes the memory previously used for the guest, then\nthe guest will be able to corrupt that memory.\n\nTested: Tested against kvmclock unit test\n\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "x86.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "20",
    "number_of_lines_deleted_vulnerable_to_cve": "27",
    "vulnerable_lines": [
        "// Line_Reference 1409: \tvoid *shared_kaddr;",
        "// Line_Reference 1412: \tstruct pvclock_vcpu_time_info *guest_hv_clock;",
        "// Line_Reference 1466: \tif (!vcpu->time_page)",
        "// Line_Reference 1528: \tshared_kaddr = kmap_atomic(vcpu->time_page);",
        "// Line_Reference 1529: ",
        "// Line_Reference 1530: \tguest_hv_clock = shared_kaddr + vcpu->time_offset;",
        "// Line_Reference 1533: \tpvclock_flags = (guest_hv_clock->flags & PVCLOCK_GUEST_STOPPED);",
        "// Line_Reference 1546: \tmemcpy(shared_kaddr + vcpu->time_offset, &vcpu->hv_clock,",
        "// Line_Reference 1547: \t       sizeof(vcpu->hv_clock));",
        "// Line_Reference 1548: ",
        "// Line_Reference 1549: \tkunmap_atomic(shared_kaddr);",
        "// Line_Reference 1550: ",
        "// Line_Reference 1551: \tmark_page_dirty(v->kvm, vcpu->time >> PAGE_SHIFT);",
        "// Line_Reference 1840: \tif (vcpu->arch.time_page) {",
        "// Line_Reference 1841: \t\tkvm_release_page_dirty(vcpu->arch.time_page);",
        "// Line_Reference 1842: \t\tvcpu->arch.time_page = NULL;",
        "// Line_Reference 1843: \t}",
        "// Line_Reference 1959: \t\t/* ...but clean it before doing the actual write */",
        "// Line_Reference 1960: \t\tvcpu->arch.time_offset = data & ~(PAGE_MASK | 1);",
        "// Line_Reference 1963: \t\tif (vcpu->arch.time_offset &",
        "// Line_Reference 1964: \t\t\t\t(sizeof(struct pvclock_vcpu_time_info) - 1))",
        "// Line_Reference 1967: \t\tvcpu->arch.time_page =",
        "// Line_Reference 1968: \t\t\t\tgfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);",
        "// Line_Reference 1969: ",
        "// Line_Reference 1970: \t\tif (is_error_page(vcpu->arch.time_page))",
        "// Line_Reference 1971: \t\t\tvcpu->arch.time_page = NULL;",
        "// Line_Reference 2975: \tif (!vcpu->arch.time_page)"
    ]
}
