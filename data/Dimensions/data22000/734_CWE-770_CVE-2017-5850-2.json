{
    "cve_id": "CVE-2017-5850",
    "cve_description": "httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.",
    "cve_publish_date": "2017-03-27",
    "cwe_id": "CWE-770",
    "cwe_name": "Allocation of Resources Without Limits or Throttling",
    "cwe_description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
    "commit_message": "Reimplement httpd's support for byte ranges.\n\nThe previous implementation loaded all the output into a single output\nbuffer and used its size to determine the Content-Length of the body.\n\nThe new implementation calculates the body length first and writes the\nindividual ranges in an async way using the bufferevent mechanism.\n\nThis prevents httpd from using too much memory and applies the\nwatermark and throttling mechanisms to range requests.\n\nProblem reported by Pierre Kim (pierre.kim.sec at gmail.com)\n\nOK benno@ sunil@",
    "type_of_change": "Modification",
    "filename_of_changes": "server_file.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "63",
    "number_of_lines_deleted_vulnerable_to_cve": "94",
    "vulnerable_lines": [
        "// Line_Reference 1: /*\t$OpenBSD: server_file.c,v 1.63 2017/01/30 09:54:41 reyk Exp $\t*/",
        "// Line_Reference 4:  * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>",
        "// Line_Reference 39: #define MAX_RANGES\t4",
        "// Line_Reference 40: ",
        "// Line_Reference 41: struct range {",
        "// Line_Reference 42: \toff_t\tstart;",
        "// Line_Reference 43: \toff_t\tend;",
        "// Line_Reference 44: };",
        "// Line_Reference 58: struct range\t*parse_range(char *, size_t, int *);",
        "// Line_Reference 59: int\t\t buffer_add_range(int, struct evbuffer *, struct range *);",
        "// Line_Reference 307: \tstruct evbuffer\t\t*evb = NULL;",
        "// Line_Reference 308: \tsize_t\t\t\t content_length;",
        "// Line_Reference 310: \tuint32_t\t\t boundary;",
        "// Line_Reference 318: \tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {",
        "// Line_Reference 331: \tif ((evb = evbuffer_new()) == NULL) {",
        "// Line_Reference 332: \t\terrstr = \"failed to allocate file buffer\";",
        "// Line_Reference 333: \t\tgoto abort;",
        "// Line_Reference 334: \t}",
        "// Line_Reference 344: \t\tcontent_length = range->end - range->start + 1;",
        "// Line_Reference 345: \t\tif (buffer_add_range(fd, evb, range) == 0)",
        "// Line_Reference 346: \t\t\tgoto abort;",
        "// Line_Reference 347: ",
        "// Line_Reference 349: \t\tcontent_length = 0;",
        "// Line_Reference 350: \t\tboundary = arc4random();",
        "// Line_Reference 351: \t\t/* Generate a multipart payload of byteranges */",
        "// Line_Reference 352: \t\twhile (nranges--) {",
        "// Line_Reference 353: \t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",",
        "// Line_Reference 354: \t\t\t    boundary)) == -1)",
        "// Line_Reference 355: \t\t\t\tgoto abort;",
        "// Line_Reference 357: \t\t\tcontent_length += i;",
        "// Line_Reference 358: \t\t\tif ((i = evbuffer_add_printf(evb,",
        "// Line_Reference 359: \t\t\t    \"Content-Type: %s/%s\\r\\n\",",
        "// Line_Reference 360: \t\t\t    media->media_type, media->media_subtype)) == -1)",
        "// Line_Reference 361: \t\t\t\tgoto abort;",
        "// Line_Reference 363: \t\t\tcontent_length += i;",
        "// Line_Reference 364: \t\t\tif ((i = evbuffer_add_printf(evb,",
        "// Line_Reference 366: \t\t\t    range->start, range->end, st->st_size)) == -1)",
        "// Line_Reference 369: \t\t\tcontent_length += i;",
        "// Line_Reference 370: \t\t\tif (buffer_add_range(fd, evb, range) == 0)",
        "// Line_Reference 371: \t\t\t\tgoto abort;",
        "// Line_Reference 373: \t\t\tcontent_length += range->end - range->start + 1;",
        "// Line_Reference 374: \t\t\trange++;",
        "// Line_Reference 376: ",
        "// Line_Reference 377: \t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",",
        "// Line_Reference 378: \t\t    boundary)) == -1)",
        "// Line_Reference 380: ",
        "// Line_Reference 381: \t\tcontent_length += i;",
        "// Line_Reference 388: \t\t    \"byteranges; boundary=%ud\", boundary);",
        "// Line_Reference 392: \tclose(fd);",
        "// Line_Reference 393: \tfd = -1;",
        "// Line_Reference 407: \tif (server_bufferevent_write_buffer(clt, evb) == -1)",
        "// Line_Reference 410: \tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);",
        "// Line_Reference 411: \tif (clt->clt_persist)",
        "// Line_Reference 412: \t\tclt->clt_toread = TOREAD_HTTP_HEADER;",
        "// Line_Reference 413: \telse",
        "// Line_Reference 414: \t\tclt->clt_toread = TOREAD_HTTP_NONE;",
        "// Line_Reference 415: \tclt->clt_done = 0;",
        "// Line_Reference 418: \tevbuffer_free(evb);",
        "// Line_Reference 426: \tif (evb != NULL)",
        "// Line_Reference 427: \t\tevbuffer_free(evb);",
        "// Line_Reference 671: struct range *",
        "// Line_Reference 672: parse_range(char *str, size_t file_sz, int *nranges)",
        "// Line_Reference 674: \tstatic struct range\t ranges[MAX_RANGES];",
        "// Line_Reference 680: \t\treturn (NULL);",
        "// Line_Reference 685: \t\treturn (NULL);",
        "// Line_Reference 691: \t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)",
        "// Line_Reference 695: \t\tif (i == MAX_RANGES)",
        "// Line_Reference 696: \t\t\treturn (NULL);",
        "// Line_Reference 701: \tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)",
        "// Line_Reference 704: \t*nranges = i;",
        "// Line_Reference 705: \treturn (i ? ranges : NULL);",
        "// Line_Reference 755: ",
        "// Line_Reference 756: int",
        "// Line_Reference 757: buffer_add_range(int fd, struct evbuffer *evb, struct range *range)",
        "// Line_Reference 758: {",
        "// Line_Reference 759: \tchar\tbuf[BUFSIZ];",
        "// Line_Reference 760: \tsize_t\tn, range_sz;",
        "// Line_Reference 761: \tssize_t\tnread;",
        "// Line_Reference 762: ",
        "// Line_Reference 763: \tif (lseek(fd, range->start, SEEK_SET) == -1)",
        "// Line_Reference 764: \t\treturn (0);",
        "// Line_Reference 765: ",
        "// Line_Reference 766: \trange_sz = range->end - range->start + 1;",
        "// Line_Reference 767: \twhile (range_sz) {",
        "// Line_Reference 768: \t\tn = MINIMUM(range_sz, sizeof(buf));",
        "// Line_Reference 769: \t\tif ((nread = read(fd, buf, n)) == -1)",
        "// Line_Reference 770: \t\t\treturn (0);",
        "// Line_Reference 771: ",
        "// Line_Reference 772: \t\tevbuffer_add(evb, buf, nread);",
        "// Line_Reference 773: \t\trange_sz -= nread;",
        "// Line_Reference 774: \t}",
        "// Line_Reference 775: ",
        "// Line_Reference 776: \treturn (1);",
        "// Line_Reference 777: }"
    ]
}
