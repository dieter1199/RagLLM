{
    "cve_id": "CVE-2015-1333",
    "cve_description": "Memory leak in the __key_link_end function in security/keys/keyring.c in the Linux kernel before 4.1.4 allows local users to cause a denial of service (memory consumption) via many add_key system calls that refer to existing keys.",
    "cve_publish_date": "2015-08-31",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "KEYS: ensure we free the assoc array edit if edit is valid\n\n__key_link_end is not freeing the associated array edit structure\nand this leads to a 512 byte memory leak each time an identical\nexisting key is added with add_key().\n\nThe reason the add_key() system call returns okay is that\nkey_create_or_update() calls __key_link_begin() before checking to see\nwhether it can update a key directly rather than adding/replacing - which\nit turns out it can.  Thus __key_link() is not called through\n__key_instantiate_and_link() and __key_link_end() must cancel the edit.\n\nCVE-2015-1333\n\nSigned-off-by: Colin Ian King <colin.king@canonical.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "keyring.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "5",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 1184: \tif (edit && !edit->dead_leaf) {",
        "// Line_Reference 1185: \t\tkey_payload_reserve(keyring,",
        "// Line_Reference 1186: \t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);"
    ]
}
