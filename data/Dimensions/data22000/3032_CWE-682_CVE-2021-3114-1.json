{
    "cve_id": "CVE-2021-3114",
    "cve_description": "In Go before 1.14.14 and 1.15.x before 1.15.7, crypto/elliptic/p224.go can generate incorrect outputs, related to an underflow of the lowest limb during the final complete reduction in the P-224 field.",
    "cve_publish_date": "2021-01-26",
    "cwe_id": "CWE-682",
    "cwe_name": "Incorrect Calculation",
    "cwe_description": "The product performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management.",
    "commit_message": "crypto/elliptic: fix P-224 field reduction\n\nThis patch fixes two independent bugs in p224Contract, the function that\nperforms the final complete reduction in the P-224 field. Incorrect\noutputs due to these bugs were observable from a high-level\nP224().ScalarMult() call.\n\nThe first bug was in the calculation of out3GT. That mask was supposed\nto be all ones if the third limb of the value is greater than the third\nlimb of P (out[3] > 0xffff000). Instead, it was also set if they are\nequal. That meant that if the third limb was equal, the value was always\nconsidered greater than or equal to P, even when the three bottom limbs\nwere all zero. There is exactly one affected value, P - 1, which would\ntrigger the subtraction by P even if it's lower than P already.\n\nThe second bug was more easily hit, and is the one that caused the known\nhigh-level incorrect output: after the conditional subtraction by P, a\npotential underflow of the lowest limb was not handled. Any values that\ntrigger the subtraction by P (values between P and 2^224-1, and P - 1\ndue to the bug above) but have a zero lowest limb would produce invalid\noutputs. Those conditions apply to the intermediate representation\nbefore the subtraction, so they are hard to trace to precise inputs.\n\nThis patch also adds a test suite for the P-224 field arithmetic,\nincluding a custom fuzzer that automatically explores potential edge\ncases by combining limb values that have various meanings in the code.\ncontractMatchesBigInt in TestP224Contract finds the second bug in less\nthan a second without being tailored to it, and could eventually find\nthe first one too by combining 0, (1 << 28) - 1, and the difference of\n(1 << 28) and (1 << 12).\n\nThe incorrect P224().ScalarMult() output was found by the\nelliptic-curve-differential-fuzzer project running on OSS-Fuzz and\nreported by Philippe Antoine (Catena cyber).\n\nFixes CVE-2021-3114\nFixes #43786\n\nChange-Id: I50176602d544de3da854270d66a293bcaca57ad7\nReviewed-on: https://go-review.googlesource.com/c/go/+/284779\nRun-TryBot: Roland Shoemaker <roland@golang.org>\nTryBot-Result: Go Bot <gobot@golang.org>\nTrust: Ian Lance Taylor <iant@golang.org>\nTrust: Roland Shoemaker <roland@golang.org>\nReviewed-by: Filippo Valsorda <filippo@golang.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "p224.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "26",
    "number_of_lines_deleted_vulnerable_to_cve": "15",
    "vulnerable_lines": [
        "// Line_Reference 389: // On exit, in[i] < 2**28",
        "// Line_Reference 403: \t// We may just have made out[i] negative. So we carry down. If we made",
        "// Line_Reference 428: \t//      and top is zero.",
        "// Line_Reference 430: \t//      The first value of top was in [0..16), therefore, prior to eliminating",
        "// Line_Reference 431: \t//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after",
        "// Line_Reference 432: \t//      overflowing and being reduced by the second carry chain, out[3] <=",
        "// Line_Reference 433: \t//      0xf000. Thus it cannot have overflowed when we eliminated top for the",
        "// Line_Reference 434: \t//      second time.",
        "// Line_Reference 473: \t// Everything depends on the value of out[3].",
        "// Line_Reference 474: \t//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p",
        "// Line_Reference 475: \t//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,",
        "// Line_Reference 476: \t//      then the whole value is >= p",
        "// Line_Reference 478: \tn := out[3] - 0xffff000",
        "// Line_Reference 487: \t// If out[3] > 0xffff000 then n's MSB will be zero.",
        "// Line_Reference 488: \tout3GT := ^uint32(int32(n) >> 31)"
    ]
}
