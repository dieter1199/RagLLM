{
    "cve_id": "CVE-2015-2313",
    "cve_description": "Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.2, when an application invokes the totalSize method on an object reader, allows remote peers to cause a denial of service (CPU consumption) via a crafted small message, which triggers a \"tight\" for loop.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-2312.",
    "cve_publish_date": "2017-08-09",
    "cwe_id": "CWE-400",
    "cwe_name": "Uncontrolled Resource Consumption",
    "cwe_description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "commit_message": "SECURITY: Additional CPU amplification case.\n\nUnfortunately, commit 104870608fde3c698483fdef6b97f093fc15685d missed a case of CPU amplification via struct lists with zero-sized elements.\n\nSee advisory: https://github.com/sandstorm-io/capnproto/blob/master/security-advisories/2015-03-05-0-c++-addl-cpu-amplification.md",
    "type_of_change": "Modification",
    "filename_of_changes": "layout.c++",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "24",
    "number_of_lines_deleted_vulnerable_to_cve": "18",
    "vulnerable_lines": [
        "// Line_Reference 558:             word* pos = ptr + POINTER_SIZE_IN_WORDS;",
        "// Line_Reference 560:             for (uint i = 0; i < count; i++) {",
        "// Line_Reference 561:               pos += dataSize;",
        "// Line_Reference 562: ",
        "// Line_Reference 563:               for (uint j = 0; j < pointerCount / POINTERS; j++) {",
        "// Line_Reference 564:                 zeroObject(segment, reinterpret_cast<WirePointer*>(pos));",
        "// Line_Reference 565:                 pos += POINTER_SIZE_IN_WORDS;",
        "// Line_Reference 683:             result.wordCount += wordCount + POINTER_SIZE_IN_WORDS;",
        "// Line_Reference 684: ",
        "// Line_Reference 693:             KJ_REQUIRE(elementTag->structRef.wordSize() / ELEMENTS *",
        "// Line_Reference 694:                        ElementCount64(count) <= wordCount,",
        "// Line_Reference 702:             const word* pos = ptr + POINTER_SIZE_IN_WORDS;",
        "// Line_Reference 703:             for (uint i = 0; i < count / ELEMENTS; i++) {",
        "// Line_Reference 704:               pos += dataSize;",
        "// Line_Reference 706:               for (uint j = 0; j < pointerCount / POINTERS; j++) {",
        "// Line_Reference 707:                 result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),",
        "// Line_Reference 708:                                     nestingLimit);",
        "// Line_Reference 709:                 pos += POINTER_SIZE_IN_WORDS;"
    ]
}
