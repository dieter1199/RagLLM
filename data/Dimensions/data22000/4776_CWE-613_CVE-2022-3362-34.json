{
    "cve_id": "CVE-2022-3362",
    "cve_description": "Insufficient Session Expiration in GitHub repository ikus060/rdiffweb prior to 2.5.0.",
    "cve_publish_date": "2022-11-14",
    "cwe_id": "CWE-613",
    "cwe_name": "Insufficient Session Expiration",
    "cwe_description": "According to WASC, \"Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.\"",
    "commit_message": "Delete user's session on password change\n\n* Revisit add, delete commit function\n* Clean-up Access Token using a scheduled job",
    "type_of_change": "Modification",
    "filename_of_changes": "test_user.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "34",
    "number_of_lines_deleted_vulnerable_to_cve": "106",
    "vulnerable_lines": [
        "// Line_Reference 24: import datetime",
        "// Line_Reference 35: from rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, Token, UserObject",
        "// Line_Reference 76:         self.assertIsNotNone(userobj)",
        "// Line_Reference 90:         self.assertIsNotNone(userobj)",
        "// Line_Reference 99:         UserObject.add_user('denise')",
        "// Line_Reference 123:         UserObject.add_user('annik')",
        "// Line_Reference 175:         user.add()",
        "// Line_Reference 182:         user.add()",
        "// Line_Reference 199:             user.add()",
        "// Line_Reference 215:         user.add()",
        "// Line_Reference 233:         user.add()",
        "// Line_Reference 386:         RepoObject(userid=userobj.userid, repopath='invalid').add()",
        "// Line_Reference 397:         RepoObject(userid=userobj.userid, repopath='invalid').add()",
        "// Line_Reference 415:     def test_add_access_token(self):",
        "// Line_Reference 416:         # Given a user with an email",
        "// Line_Reference 417:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 418:         userobj.email = 'test@examples.com'",
        "// Line_Reference 419:         userobj.add()",
        "// Line_Reference 420:         # When adding a new token",
        "// Line_Reference 421:         token = userobj.add_access_token('test')",
        "// Line_Reference 422:         # Then a new token get created",
        "// Line_Reference 423:         self.assertTrue(token)",
        "// Line_Reference 424:         tokenobj = Token.query.filter(Token.userid == userobj.userid).first()",
        "// Line_Reference 425:         self.assertTrue(tokenobj)",
        "// Line_Reference 426:         self.assertEqual(None, tokenobj.expiration_time)",
        "// Line_Reference 427:         self.assertEqual(None, tokenobj.access_time)",
        "// Line_Reference 428:         # Then an email is sent to the user.",
        "// Line_Reference 429:         self.listener.access_token_added.assert_called_once_with(userobj, 'test')",
        "// Line_Reference 430:         self.listener.queue_mail.assert_called_once()",
        "// Line_Reference 431: ",
        "// Line_Reference 432:     def test_add_access_token_duplicate_name(self):",
        "// Line_Reference 433:         # Given a user with an existing token",
        "// Line_Reference 434:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 435:         userobj.add_access_token('test')",
        "// Line_Reference 436:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 437:         # When adding a new token with the same name",
        "// Line_Reference 438:         with self.assertRaises(ValueError):",
        "// Line_Reference 439:             userobj.add_access_token('test')",
        "// Line_Reference 440:         # Then token is not created",
        "// Line_Reference 441:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 442:         # Then an email is not sent.",
        "// Line_Reference 443:         self.listener.access_token_added.assert_called_once_with(userobj, 'test')",
        "// Line_Reference 444: ",
        "// Line_Reference 445:     def test_delete_access_token(self):",
        "// Line_Reference 446:         # Given a user with an existing token",
        "// Line_Reference 447:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 448:         userobj.add_access_token('test')",
        "// Line_Reference 449:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 450:         # When deleting an access token",
        "// Line_Reference 451:         userobj.delete_access_token('test')",
        "// Line_Reference 452:         # Then Token get deleted",
        "// Line_Reference 453:         self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 454: ",
        "// Line_Reference 455:     def test_delete_access_token_invalid(self):",
        "// Line_Reference 456:         # Given a user with an existing token",
        "// Line_Reference 457:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 458:         userobj.add_access_token('test')",
        "// Line_Reference 459:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 460:         # When deleting an invalid access token",
        "// Line_Reference 461:         with self.assertRaises(ValueError):",
        "// Line_Reference 462:             userobj.delete_access_token('invalid')",
        "// Line_Reference 463:         # Then Token not deleted",
        "// Line_Reference 464:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 465: ",
        "// Line_Reference 466:     def test_delete_user_remove_access_tokens(self):",
        "// Line_Reference 467:         # Given a user with an existing token",
        "// Line_Reference 468:         userobj = UserObject.add_user('testuser', 'password')",
        "// Line_Reference 469:         userobj.add_access_token('test')",
        "// Line_Reference 470:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 471:         # When deleting the user",
        "// Line_Reference 472:         userobj.delete()",
        "// Line_Reference 473:         # Then Token get deleted",
        "// Line_Reference 474:         self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 475: ",
        "// Line_Reference 476:     def test_verify_access_token(self):",
        "// Line_Reference 477:         # Given a user with an existing token",
        "// Line_Reference 478:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 479:         token = userobj.add_access_token('test')",
        "// Line_Reference 480:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 481:         # When validating the token",
        "// Line_Reference 482:         # Then token is valid",
        "// Line_Reference 483:         self.assertTrue(userobj.validate_access_token(token))",
        "// Line_Reference 484: ",
        "// Line_Reference 485:     def test_verify_access_token_with_expired(self):",
        "// Line_Reference 486:         # Given a user with an existing token",
        "// Line_Reference 487:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 488:         token = userobj.add_access_token(",
        "// Line_Reference 489:             'test', expiration_time=datetime.datetime.now() - datetime.timedelta(seconds=1)",
        "// Line_Reference 490:         )",
        "// Line_Reference 491:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 492:         # When validating the token",
        "// Line_Reference 493:         # Then token is invalid",
        "// Line_Reference 494:         self.assertFalse(userobj.validate_access_token(token))",
        "// Line_Reference 495:         # Then token get removed",
        "// Line_Reference 496:         self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 497: ",
        "// Line_Reference 498:     def test_verify_access_token_with_invalid(self):",
        "// Line_Reference 499:         # Given a user with an existing token",
        "// Line_Reference 500:         userobj = UserObject.get_user(self.USERNAME)",
        "// Line_Reference 501:         userobj.add_access_token('test', expiration_time=datetime.datetime.now())",
        "// Line_Reference 502:         self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())",
        "// Line_Reference 503:         # When validating the token",
        "// Line_Reference 504:         # Then token is invalid",
        "// Line_Reference 505:         self.assertFalse(userobj.validate_access_token('invalid'))",
        "// Line_Reference 506: ",
        "// Line_Reference 526:     def test_set_password(self):"
    ]
}
