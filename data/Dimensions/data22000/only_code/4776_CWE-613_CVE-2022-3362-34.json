import datetime
from rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, Token, UserObject
self.assertIsNotNone(userobj)
self.assertIsNotNone(userobj)
UserObject.add_user('denise')
UserObject.add_user('annik')
user.add()
user.add()
user.add()
user.add()
user.add()
RepoObject(userid=userobj.userid, repopath='invalid').add()
RepoObject(userid=userobj.userid, repopath='invalid').add()
def test_add_access_token(self):
# Given a user with an email
userobj = UserObject.get_user(self.USERNAME)
userobj.email = 'test@examples.com'
userobj.add()
# When adding a new token
token = userobj.add_access_token('test')
# Then a new token get created
self.assertTrue(token)
tokenobj = Token.query.filter(Token.userid == userobj.userid).first()
self.assertTrue(tokenobj)
self.assertEqual(None, tokenobj.expiration_time)
self.assertEqual(None, tokenobj.access_time)
# Then an email is sent to the user.
self.listener.access_token_added.assert_called_once_with(userobj, 'test')
self.listener.queue_mail.assert_called_once()
def test_add_access_token_duplicate_name(self):
# Given a user with an existing token
userobj = UserObject.get_user(self.USERNAME)
userobj.add_access_token('test')
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When adding a new token with the same name
with self.assertRaises(ValueError):
userobj.add_access_token('test')
# Then token is not created
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# Then an email is not sent.
self.listener.access_token_added.assert_called_once_with(userobj, 'test')
def test_delete_access_token(self):
# Given a user with an existing token
userobj = UserObject.get_user(self.USERNAME)
userobj.add_access_token('test')
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When deleting an access token
userobj.delete_access_token('test')
# Then Token get deleted
self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid).count())
def test_delete_access_token_invalid(self):
# Given a user with an existing token
userobj = UserObject.get_user(self.USERNAME)
userobj.add_access_token('test')
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When deleting an invalid access token
with self.assertRaises(ValueError):
userobj.delete_access_token('invalid')
# Then Token not deleted
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
def test_delete_user_remove_access_tokens(self):
# Given a user with an existing token
userobj = UserObject.add_user('testuser', 'password')
userobj.add_access_token('test')
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When deleting the user
userobj.delete()
# Then Token get deleted
self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid).count())
def test_verify_access_token(self):
# Given a user with an existing token
userobj = UserObject.get_user(self.USERNAME)
token = userobj.add_access_token('test')
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When validating the token
# Then token is valid
self.assertTrue(userobj.validate_access_token(token))
def test_verify_access_token_with_expired(self):
# Given a user with an existing token
userobj = UserObject.get_user(self.USERNAME)
token = userobj.add_access_token(
'test', expiration_time=datetime.datetime.now() - datetime.timedelta(seconds=1)
)
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When validating the token
# Then token is invalid
self.assertFalse(userobj.validate_access_token(token))
# Then token get removed
self.assertEqual(0, Token.query.filter(Token.userid == userobj.userid).count())
def test_verify_access_token_with_invalid(self):
# Given a user with an existing token
userobj = UserObject.get_user(self.USERNAME)
userobj.add_access_token('test', expiration_time=datetime.datetime.now())
self.assertEqual(1, Token.query.filter(Token.userid == userobj.userid).count())
# When validating the token
# Then token is invalid
self.assertFalse(userobj.validate_access_token('invalid'))
def test_set_password(self):
