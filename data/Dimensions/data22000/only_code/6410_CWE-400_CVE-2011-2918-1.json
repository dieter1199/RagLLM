static void perf_event_output(struct perf_event *event, int nmi,
if (perf_output_begin(&handle, event, header.size, nmi, 1))
ret = perf_output_begin(&handle, event, read_event.header.size, 0, 0);
task_event->event_id.header.size, 0, 0);
comm_event->event_id.header.size, 0, 0);
mmap_event->event_id.header.size, 0, 0);
throttle_event.header.size, 1, 0);
static int __perf_event_overflow(struct perf_event *event, int nmi,
if (nmi) {
event->pending_disable = 1;
irq_work_queue(&event->pending);
} else
perf_event_disable(event);
event->overflow_handler(event, nmi, data, regs);
perf_event_output(event, nmi, data, regs);
if (nmi) {
event->pending_wakeup = 1;
irq_work_queue(&event->pending);
} else
perf_event_wakeup(event);
int perf_event_overflow(struct perf_event *event, int nmi,
return __perf_event_overflow(event, nmi, 1, data, regs);
int nmi, struct perf_sample_data *data,
if (__perf_event_overflow(event, nmi, throttle,
int nmi, struct perf_sample_data *data,
return perf_swevent_overflow(event, 1, nmi, data, regs);
perf_swevent_overflow(event, 0, nmi, data, regs);
u64 nr, int nmi,
perf_swevent_event(event, nr, nmi, data, regs);
void __perf_sw_event(u32 event_id, u64 nr, int nmi,
struct pt_regs *regs, u64 addr)
do_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);
perf_swevent_event(event, count, 1, &data, regs);
perf_swevent_event(bp, 1, 1, &sample, regs);
if (perf_event_overflow(event, 0, &data, regs))