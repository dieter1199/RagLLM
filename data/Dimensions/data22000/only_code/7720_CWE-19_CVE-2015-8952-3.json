#include <linux/mbcache.h>
static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);
struct mb_cache_entry **);
struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
struct mb_cache_entry *ce = NULL;
struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
ce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);
if (ce)
mb_cache_entry_free(ce);
if (ce)
mb_cache_entry_release(ce);
struct mb_cache_entry *ce = NULL;
struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
ce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,
bs->bh->b_blocknr);
if (ce) {
mb_cache_entry_free(ce);
ce = NULL;
}
if (ce) {
mb_cache_entry_release(ce);
ce = NULL;
}
mb_cache_entry_release(ce);
mb_cache_entry_release(ce);
/*
* ext4_xattr_put_super()
*
* This is called when a file system is unmounted.
*/
void
ext4_xattr_put_super(struct super_block *sb)
{
mb_cache_shrink(sb->s_bdev);
}
ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)
struct mb_cache_entry *ce;
ce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);
if (!ce) {
ea_bdebug(bh, "out of memory");
return;
}
error = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);
mb_cache_entry_free(ce);
if (error == -EBUSY) {
error = 0;
}
} else {
mb_cache_entry_release(ce);
}
struct mb_cache_entry **pce)
struct mb_cache_entry *ce;
struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
again:
ce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,
hash);
if (IS_ERR(ce)) {
if (PTR_ERR(ce) == -EAGAIN)
goto again;
break;
}
ce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);
struct mb_cache *
ext4_xattr_create_cache(char *name)
return mb_cache_create(name, HASH_BUCKET_BITS);
void ext4_xattr_destroy_cache(struct mb_cache *cache)
mb_cache_destroy(cache);
