static spnego_gss_ctx_id_t create_spnego_ctx(void);
create_spnego_ctx(void)
sc = create_spnego_ctx();
/*
* The actual context is not yet determined, set the output
* context handle to refer to the spnego context itself.
*/
/*
* Now, switch the output context to refer to the
* negotiated mechanism's context.
*/
*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
release_spnego_ctx(&spnego_ctx);
sc = create_spnego_ctx();
sc = create_spnego_ctx();
*context_handle = (gss_ctx_id_t)sc->ctx_handle;
release_spnego_ctx(&sc);
context_handle,
context_handle,
context_handle,
/*
* If this is still an SPNEGO mech, release it locally.
*/
if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
(void) gss_delete_sec_context(minor_status,
&(*ctx)->ctx_handle,
output_token);
(void) release_spnego_ctx(ctx);
} else {
ret = gss_delete_sec_context(minor_status,
context_handle,
output_token);
}
context_handle,
context_handle,
OM_uint32 ret;
ret = gss_import_sec_context(minor_status,
interprocess_token,
context_handle);
return (ret);
ret = gss_inquire_context(minor_status,
context_handle,
src_name,
targ_name,
lifetime_rec,
mech_type,
ctx_flags,
locally_initiated,
opened);
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context_handle,
context,
return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,