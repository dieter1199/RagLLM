#define INVALID_CHAR -2
apr_int16_t chunkbits;
BODY_CHUNK_END, /* chunk terminating CRLF */
apr_size_t len, int linelimit)
if (ctx->state == BODY_CHUNK_END) {
* Detect invalid character at beginning. This also works for empty
* chunk size lines.
return APR_EGENERAL;
ctx->chunkbits = sizeof(long) * 8;
/* handle a chunk part, or a chunk extension */
/*
* In theory, we are supposed to expect CRLF only, but our
* test suite sends LF only. Tolerate a missing CR.
*/
if (c == ';' || c == CR) {
ctx->state = BODY_CHUNK_EXT;
}
else if (c == LF) {
else if (ctx->state != BODY_CHUNK_EXT) {
int xvalue = 0;
return APR_EGENERAL;
ctx->chunkbits -= 4;
if (ctx->chunkbits <= 0 || ctx->remaining < 0) {
ap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes)
"Unknown Transfer-Encoding: %s;"
" using read-until-close", tenc);
ap_log_rerror(
APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)
"Invalid Content-Length");
return APR_ENOSPC;
ap_log_rerror(
APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)
"Requested content-length of %" APR_OFF_T_FMT
" is larger than the configured limit"
" of %" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
case BODY_CHUNK_END: {
ap_log_rerror(
APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590) "Error reading chunk %s ", (APR_ENOSPC == rv) ? "(overflow)" : "");
int merge_trailers =
conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE;
return read_chunked_trailers(ctx, f, b, merge_trailers);
ap_log_rerror(
APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591) "Read content-length of %" APR_OFF_T_FMT " is larger than the configured limit"
" of %" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
break;
