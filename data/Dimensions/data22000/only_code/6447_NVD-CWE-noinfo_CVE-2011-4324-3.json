struct nfs4_state_owner *sp, int flags,
p->o_arg.open_flags = flags,
static int can_open_cached(struct nfs4_state *state, int mode)
switch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {
static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)
if ((delegation->type & open_flags) != open_flags)
static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)
switch (open_flags) {
nfs4_state_set_mode_locked(state, state->state | open_flags);
static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)
switch (open_flags) {
static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)
nfs_set_open_stateid_locked(state, stateid, open_flags);
static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)
nfs_set_open_stateid_locked(state, open_stateid, open_flags);
update_open_stateflags(state, open_flags);
static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)
open_flags &= (FMODE_READ|FMODE_WRITE);
(deleg_cur->type & open_flags) != open_flags)
__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);
__update_open_stateid(state, open_stateid, NULL, open_flags);
static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)
if (delegation == NULL || (delegation->type & open_flags) == open_flags) {
int open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);
if (can_open_cached(state, open_mode)) {
if (can_open_cached(state, open_mode)) {
update_open_stateflags(state, open_mode);
!can_open_delegated(delegation, open_mode)) {
if (update_open_stateid(state, NULL, &stateid, open_mode))
data->o_arg.open_flags);
opendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);
static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)
opendata->o_arg.open_flags = openflags;
nfs4_close_state(&opendata->path, newstate, openflags);
int delegation_type = 0;
nfs4_close_state(&data->path, state, data->o_arg.open_flags);
if (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))
nfs4_close_state(&data->path, state, data->o_arg.open_flags);
static int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)
nfs4_return_incompatible_delegation(path->dentry->d_inode, flags & (FMODE_READ|FMODE_WRITE));
opendata = nfs4_opendata_alloc(path, sp, flags, sattr);
static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)
status = _nfs4_do_open(dir, path, flags, sattr, cred, &res);
if (calldata->arg.open_flags == 0)
calldata->arg.open_flags = FMODE_READ;
calldata->arg.open_flags = FMODE_WRITE;
calldata->arg.open_flags = 0;
static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)
if (nd->intent.open.flags & FMODE_EXEC) {
nfs4_close_sync(path, state, nd->intent.open.flags);
state = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);
nfs4_intent_set_file(nd, &path, state);
state = nfs4_do_open(dir, &path, openflags, NULL, cred);
nfs4_intent_set_file(nd, &path, state);
nfs4_close_sync(&path, state, openflags);
state = nfs4_do_open(dir, &path, flags, sattr, cred);
status = nfs4_intent_set_file(nd, &path, state);
nfs4_close_sync(&path, state, flags);