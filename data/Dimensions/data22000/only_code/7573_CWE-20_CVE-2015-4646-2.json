static int read_fragment_table(long long *directory_table_end)
int bytes = SQUASHFS_FRAGMENT_BYTES(sBlk.s.fragments);
int  indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk.s.fragments);
long long fragment_table_index[indexes];
if(sBlk.s.fragments == 0) {
*directory_table_end = sBlk.s.fragment_table_start;
return TRUE;
}
res = read_fs_bytes(fd, sBlk.s.fragment_table_start,
SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk.s.fragments),
fragment_table_index);
*directory_table_end = fragment_table_index[0];
static int read_uids_guids(long long *table_start)
long long id_index_table[indexes];
TRACE("read_uids_guids: no_ids %d\n", sBlk.s.no_ids);
ERROR("read_uids_guids: failed to allocate id table\n");
res = read_fs_bytes(fd, sBlk.s.id_table_start,
SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);
ERROR("read_uids_guids: failed to read id index table\n");
ERROR("read_uids_guids: failed to read id table block"
int indexes = SQUASHFS_LOOKUP_BLOCKS(sBlk.s.inodes);
long long export_index_table[indexes];
res = read_fs_bytes(fd, sBlk.s.lookup_table_start,
SQUASHFS_LOOKUP_BLOCK_BYTES(sBlk.s.inodes), export_index_table);
long long directory_table_end, table_start;
if(read_xattrs_from_disk(fd, &sBlk.s, no_xattrs, &table_start) == 0)
return FALSE;
if(read_uids_guids(&table_start) == FALSE)
return FALSE;
if(parse_exports_table(&table_start) == FALSE)
return FALSE;
if(read_fragment_table(&directory_table_end) == FALSE)
return FALSE;
if(read_inode_table(sBlk.s.inode_table_start,
sBlk.s.directory_table_start) == FALSE)
return FALSE;
directory_table_end) == FALSE)
return FALSE;
