import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.StringWriter;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;
import io.fusionauth.samlv2.domain.NameID;
import org.xml.sax.SAXException;
Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));
.map(this::toCertificate)
Document document = parseFromBytes(decodedResponse);
List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());
private String attributeToString(Object attribute) {
if (attribute == null) {
return null;
}
if (attribute instanceof Number) {
return attribute.toString();
} else if (attribute instanceof String) {
return (String) attribute;
} else if (attribute instanceof Element) {
return ((Element) attribute).getTextContent();
} else {
logger.warn("This library currently doesn't handle attributes of type [" + attribute.getClass() + "]");
}
return null;
}
String encodedResult = deflateAndEncode(xml);
private ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {
return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;
}
private byte[] decodeAndInflate(String encodedRequest) throws SAMLException {
byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);
Inflater inflater = new Inflater(true);
inflater.setInput(bytes);
inflater.finished();
try {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
byte[] result = new byte[bytes.length];
while (!inflater.finished()) {
int length = inflater.inflate(result);
if (length > 0) {
baos.write(result, 0, length);
}
}
return baos.toByteArray();
} catch (DataFormatException e) {
throw new SAMLException("Invalid AuthnRequest. Inflating the bytes failed.", e);
}
}
private String deflateAndEncode(byte[] result) {
Deflater deflater = new Deflater(Deflater.DEFLATED, true);
deflater.setInput(result);
deflater.finish();
byte[] deflatedResult = new byte[result.length];
int length = deflater.deflate(deflatedResult);
deflater.end();
byte[] src = Arrays.copyOf(deflatedResult, length);
return Base64.getEncoder().encodeToString(src);
}
private <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {
try {
JAXBContext context = JAXBContext.newInstance(type);
Marshaller marshaller = context.createMarshaller();
ByteArrayOutputStream baos = new ByteArrayOutputStream();
marshaller.marshal(object, baos);
return baos.toByteArray();
} catch (JAXBException e) {
throw new SAMLException("Unable to marshallRequest JAXB SAML object to bytes.", e);
}
}
@SuppressWarnings("SameParameterValue")
private <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {
try {
JAXBContext context = JAXBContext.newInstance(type);
Marshaller marshaller = context.createMarshaller();
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setNamespaceAware(true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.newDocument();
marshaller.marshal(object, document);
return document;
} catch (JAXBException | ParserConfigurationException e) {
throw new SAMLException("Unable to marshallRequest JAXB SAML object to DOM.", e);
}
}
private String marshallToString(Document document) throws TransformerException {
StringWriter sw = new StringWriter();
TransformerFactory tf = TransformerFactory.newInstance();
Transformer transformer = tf.newTransformer();
transformer.transform(new DOMSource(document), new StreamResult(sw));
return sw.toString();
}
private Document parseFromBytes(byte[] bytes) throws SAMLException {
DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
documentBuilderFactory.setNamespaceAware(true);
try {
DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();
return builder.parse(new ByteArrayInputStream(bytes));
} catch (ParserConfigurationException | SAXException | IOException e) {
throw new SAMLException("Unable to parse SAML v2.0 authentication response", e);
}
}
private NameID parseNameId(NameIDType element) {
NameID nameId = new NameID();
nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());
nameId.id = element.getValue();
return nameId;
}
result.document = parseFromBytes(xmlBytes);
private Certificate toCertificate(KeyDescriptorType keyDescriptorType) {
try {
List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();
for (Object keyDatum : keyData) {
if (keyDatum instanceof JAXBElement<?>) {
JAXBElement<?> element = (JAXBElement<?>) keyDatum;
if (element.getDeclaredType() == X509DataType.class) {
X509DataType cert = (X509DataType) element.getValue();
List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();
for (Object certDatum : certData) {
element = (JAXBElement<?>) certDatum;
if (element.getName().getLocalPart().equals("X509Certificate")) {
byte[] certBytes = (byte[]) element.getValue();
CertificateFactory cf = CertificateFactory.getInstance("X.509");
return cf.generateCertificate(new ByteArrayInputStream(certBytes));
}
}
}
}
}
return null;
} catch (CertificateException e) {
throw new IllegalArgumentException(e);
}
}
private XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {
if (instant == null) {
return null;
}
return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));
}
private ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {
if (instant == null) {
return null;
}
return instant.toGregorianCalendar().toZonedDateTime();
}
private <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {
try {
JAXBContext context = JAXBContext.newInstance(type);
Unmarshaller unmarshaller = context.createUnmarshaller();
JAXBElement<T> element = unmarshaller.unmarshal(document, type);
return element.getValue();
} catch (JAXBException e) {
throw new SAMLException("Unable to unmarshall SAML response", e);
}
}
