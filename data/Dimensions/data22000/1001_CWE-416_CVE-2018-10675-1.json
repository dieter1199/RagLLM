{
    "cve_id": "CVE-2018-10675",
    "cve_description": "The do_get_mempolicy function in mm/mempolicy.c in the Linux kernel before 4.12.9 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted system calls.",
    "cve_publish_date": "2018-05-02",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "mm/mempolicy: fix use after free when calling get_mempolicy\n\nI hit a use after free issue when executing trinity and repoduced it\nwith KASAN enabled.  The related call trace is as follows.\n\n  BUG: KASan: use after free in SyS_get_mempolicy+0x3c8/0x960 at addr ffff8801f582d766\n  Read of size 2 by task syz-executor1/798\n\n  INFO: Allocated in mpol_new.part.2+0x74/0x160 age=3 cpu=1 pid=799\n     __slab_alloc+0x768/0x970\n     kmem_cache_alloc+0x2e7/0x450\n     mpol_new.part.2+0x74/0x160\n     mpol_new+0x66/0x80\n     SyS_mbind+0x267/0x9f0\n     system_call_fastpath+0x16/0x1b\n  INFO: Freed in __mpol_put+0x2b/0x40 age=4 cpu=1 pid=799\n     __slab_free+0x495/0x8e0\n     kmem_cache_free+0x2f3/0x4c0\n     __mpol_put+0x2b/0x40\n     SyS_mbind+0x383/0x9f0\n     system_call_fastpath+0x16/0x1b\n  INFO: Slab 0xffffea0009cb8dc0 objects=23 used=8 fp=0xffff8801f582de40 flags=0x200000000004080\n  INFO: Object 0xffff8801f582d760 @offset=5984 fp=0xffff8801f582d600\n\n  Bytes b4 ffff8801f582d750: ae 01 ff ff 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ\n  Object ffff8801f582d760: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n  Object ffff8801f582d770: 6b 6b 6b 6b 6b 6b 6b a5                          kkkkkkk.\n  Redzone ffff8801f582d778: bb bb bb bb bb bb bb bb                          ........\n  Padding ffff8801f582d8b8: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ\n  Memory state around the buggy address:\n  ffff8801f582d600: fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc fc\n  ffff8801f582d680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n  >ffff8801f582d700: fc fc fc fc fc fc fc fc fc fc fc fc fb fb fb fc\n\n!shared memory policy is not protected against parallel removal by other\nthread which is normally protected by the mmap_sem.  do_get_mempolicy,\nhowever, drops the lock midway while we can still access it later.\n\nEarly premature up_read is a historical artifact from times when\nput_user was called in this path see https://lwn.net/Articles/124754/\nbut that is gone since 8bccd85ffbaf (\"[PATCH] Implement sys_* do_*\nlayering in the memory policy layer.\").  but when we have the the\ncurrent mempolicy ref count model.  The issue was introduced\naccordingly.\n\nFix the issue by removing the premature release.\n\nLink: http://lkml.kernel.org/r/1502950924-27521-1-git-send-email-zhongjiang@huawei.com\nSigned-off-by: zhong jiang <zhongjiang@huawei.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: David Rientjes <rientjes@google.com>\nCc: Mel Gorman <mgorman@techsingularity.net>\nCc: <stable@vger.kernel.org>\t[2.6+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "mempolicy.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "5",
    "vulnerable_lines": [
        "// Line_Reference 864: \tif (vma) {",
        "// Line_Reference 865: \t\tup_read(&current->mm->mmap_sem);",
        "// Line_Reference 866: \t\tvma = NULL;",
        "// Line_Reference 867: \t}",
        "// Line_Reference 868: "
    ]
}
