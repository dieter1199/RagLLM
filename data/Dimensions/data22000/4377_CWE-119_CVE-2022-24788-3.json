{
    "cve_id": "CVE-2022-24788",
    "cve_description": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.",
    "cve_publish_date": "2022-04-13",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "Merge pull request from GHSA-j2x6-9323-fp7h\n\nThis commit addresses two issues in validating returndata, both related\nto the inferred type of the external call return.\n\nFirst, it addresses an issue with interfaces imported from JSON. The\nJSON_ABI encoding type was added in 0.3.0 as part of the calling\nconvention refactor to mimic the old code's behavior when the signature\nof a function had `is_from_json` toggled to True. However, both\nimplementations were a workaround for the fact that in\nFunctionSignatures from JSON with Bytes return types, length is set to 1\nas a hack to ensure they always typecheck - almost always resulting in a\nruntime revert.\n\nThis commit removes the JSON_ABI encoding type, so that dynamic\nreturndata from an interface defined with .json ABI file cannot result\nin a buffer overrun(!). To avoid the issue with always runtime\nreverting, codegen uses the uses the inferred ContractFunction type of\nthe Call.func member (which is both more accurate than the inferred type\nof the Call expression, and the return type on the FunctionSignature!)\nto calculate the length of the external Bytes array.\n\nSecond, this commit addresses an issue with validating call returns in\ncomplex expressions. In the following examples, the type of the call\nreturn is either inferred incorrectly or it takes a path through codegen\nwhich avoids generating runtime clamps:\n\n```\ninterface Foo:\n    def returns_int128() -> int128: view\n    def returns_Bytes3() -> Bytes[3]: view\n\nfoo: Foo\n...\nx: uint256 = convert(self.foo.returns_int128(), uint256)\ny: Bytes[32] = concat(self.foo.returns_Bytes3(), b\"\")\n```\n\nTo address this issue, if the type of returndata needs validation, this\ncommit decodes the returndata \"strictly\" into a newly allocated buffer\nat the time of the call, to avoid unvalidated data accidentally getting\ninto the runtime. This does result in extra memory traffic which is a\nperformance hit, but the performance issue can be addressed at a later\ndate with a zero-copy buffering scheme (parent Expr allocates the\nbuffer).\n\nAdditional minor fixes and cleanup:\n- fix compiler panic in new_type_to_old_type for Tuples\n- remove `_should_decode` helper function as it duplicates `needs_clamp`\n- minor optimization in returndatasize check - assert ge uses one fewer\n  instruction than assert gt.",
    "type_of_change": "Modification",
    "filename_of_changes": "external_call.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "33",
    "number_of_lines_deleted_vulnerable_to_cve": "37",
    "vulnerable_lines": [
        "// Line_Reference 9:     get_element_ptr,",
        "// Line_Reference 62: def _returndata_encoding(contract_sig):",
        "// Line_Reference 63:     if contract_sig.is_from_json:",
        "// Line_Reference 64:         return Encoding.JSON_ABI",
        "// Line_Reference 65:     return Encoding.ABI",
        "// Line_Reference 67: ",
        "// Line_Reference 68: def _unpack_returndata(buf, contract_sig, skip_contract_check, context):",
        "// Line_Reference 69:     return_t = contract_sig.return_type",
        "// Line_Reference 70:     if return_t is None:",
        "// Line_Reference 74:     # if the abi signature has a different type than",
        "// Line_Reference 75:     # the vyper type, we need to wrap and unwrap the type",
        "// Line_Reference 76:     # so that the ABI decoding works correctly",
        "// Line_Reference 77:     should_unwrap_abi_tuple = return_t != contract_sig.return_type",
        "// Line_Reference 91:     # TODO move the -1 optimization to IR optimizer",
        "// Line_Reference 93:         ret += [[\"assert\", [\"gt\", \"returndatasize\", min_return_size - 1]]]",
        "// Line_Reference 95:     # add as the last IRnode a pointer to the return data structure",
        "// Line_Reference 97:     # the return type has been wrapped by the calling contract;",
        "// Line_Reference 98:     # unwrap it so downstream code isn't confused.",
        "// Line_Reference 99:     # basically this expands to buf+32 if the return type has been wrapped",
        "// Line_Reference 100:     # in a tuple AND its ABI type is dynamic.",
        "// Line_Reference 101:     # in most cases, this simply will evaluate to ret.",
        "// Line_Reference 102:     # in the special case where the return type has been wrapped",
        "// Line_Reference 103:     # in a tuple AND its ABI type is dynamic, it expands to buf+32.",
        "// Line_Reference 104:     buf = IRnode(buf, typ=return_t, encoding=_returndata_encoding(contract_sig), location=MEMORY)",
        "// Line_Reference 106:     if should_unwrap_abi_tuple:",
        "// Line_Reference 107:         buf = get_element_ptr(buf, 0, array_bounds_check=False)",
        "// Line_Reference 109:     ret += [buf]",
        "// Line_Reference 148:         buf, contract_sig, skip_contract_check, context",
        "// Line_Reference 172:     ret = IRnode.from_list(",
        "// Line_Reference 173:         sub,",
        "// Line_Reference 174:         typ=contract_sig.return_type,",
        "// Line_Reference 175:         location=MEMORY,",
        "// Line_Reference 176:         # set the encoding to ABI here, downstream code will decode and add clampers.",
        "// Line_Reference 177:         encoding=_returndata_encoding(contract_sig),",
        "// Line_Reference 178:     )",
        "// Line_Reference 179: ",
        "// Line_Reference 180:     return ret"
    ]
}
