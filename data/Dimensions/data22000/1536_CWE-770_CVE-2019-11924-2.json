{
    "cve_id": "CVE-2019-11924",
    "cve_description": "A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",
    "cve_publish_date": "2019-08-20",
    "cwe_id": "CWE-770",
    "cwe_name": "Allocation of Resources Without Limits or Throttling",
    "cwe_description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
    "commit_message": "Coalesce handshake buffers\n\nSummary:\nIt is possible that a peer might send us records in a manner such\nthat there is a 16KB record and only 1 byte of handshake message in\neach record. Since we normally just trim the IOBuf, we would end up\nholding 16K of data per actual byte of data. To prevent this we allocate a contiguous\nbuffer to copy over these bytes for handshake messages for now.\n\nThis is a partial fix for CVE-2019-11924\n\nReviewed By: ngoyal\n\nDifferential Revision: D16478044\n\nfbshipit-source-id: 464bc68eaefda065d9a327818100427377293fbd",
    "type_of_change": "Modification",
    "filename_of_changes": "RecordLayer.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "25",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 52:         unparsedHandshakeData_.append(std::move(message->fragment));"
    ]
}
