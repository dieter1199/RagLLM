{
    "cve_id": "CVE-2024-27102",
    "cve_description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-13",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "server(filesystem): rebuild everything imaginable\n\nThis wonderfully large commit replaces basically everything under the\n`server/filesystem` package, re-implementing essentially everything.\n\nThis is related to\nhttps://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9\n\nIf any vulnerabilities related to symlinks persist after this commit, I\nwill be very upset.\n\nSigned-off-by: Matthew Penner <me@matthewp.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "path.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "7",
    "number_of_lines_deleted_vulnerable_to_cve": "98",
    "vulnerable_lines": [
        "// Line_Reference 4: \t\"context\"",
        "// Line_Reference 5: \tiofs \"io/fs\"",
        "// Line_Reference 6: \t\"os\"",
        "// Line_Reference 9: \t\"sync\"",
        "// Line_Reference 12: \t\"golang.org/x/sync/errgroup\"",
        "// Line_Reference 19: \t\tsp, err := fs.SafePath(p)",
        "// Line_Reference 20: \t\tif err != nil {",
        "// Line_Reference 21: \t\t\treturn err",
        "// Line_Reference 22: \t\t}",
        "// Line_Reference 23: \t\tif fs.denylist.MatchesPath(sp) {",
        "// Line_Reference 24: \t\t\treturn errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: sp})",
        "// Line_Reference 30: // Normalizes a directory being passed in to ensure the user is not able to escape",
        "// Line_Reference 31: // from their data directory. After normalization if the directory is still within their home",
        "// Line_Reference 32: // path it is returned. If they managed to \"escape\" an error will be returned.",
        "// Line_Reference 33: //",
        "// Line_Reference 34: // This logic is actually copied over from the SFTP server code. Ideally that eventually",
        "// Line_Reference 35: // either gets ported into this application, or is able to make use of this package.",
        "// Line_Reference 36: func (fs *Filesystem) SafePath(p string) (string, error) {",
        "// Line_Reference 37: \t// Start with a cleaned up path before checking the more complex bits.",
        "// Line_Reference 38: \tr := fs.unsafeFilePath(p)",
        "// Line_Reference 39: ",
        "// Line_Reference 40: \t// At the same time, evaluate the symlink status and determine where this file or folder",
        "// Line_Reference 41: \t// is truly pointing to.",
        "// Line_Reference 42: \tep, err := filepath.EvalSymlinks(r)",
        "// Line_Reference 43: \tif err != nil && !os.IsNotExist(err) {",
        "// Line_Reference 44: \t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")",
        "// Line_Reference 45: \t} else if os.IsNotExist(err) {",
        "// Line_Reference 46: \t\t// The target of one of the symlinks (EvalSymlinks is recursive) does not exist.",
        "// Line_Reference 47: \t\t// So we get what target path does not exist and check if it's within the data",
        "// Line_Reference 48: \t\t// directory. If it is, we return the original path, otherwise we return an error.",
        "// Line_Reference 49: \t\tpErr, ok := err.(*iofs.PathError)",
        "// Line_Reference 50: \t\tif !ok {",
        "// Line_Reference 51: \t\t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")",
        "// Line_Reference 52: \t\t}",
        "// Line_Reference 53: \t\tep = pErr.Path",
        "// Line_Reference 54: \t}",
        "// Line_Reference 55: ",
        "// Line_Reference 56: \t// If the requested directory from EvalSymlinks begins with the server root directory go",
        "// Line_Reference 57: \t// ahead and return it. If not we'll return an error which will block any further action",
        "// Line_Reference 58: \t// on the file.",
        "// Line_Reference 59: \tif fs.unsafeIsInDataDirectory(ep) {",
        "// Line_Reference 60: \t\t// Returning the original path here instead of the resolved path ensures that",
        "// Line_Reference 61: \t\t// whatever the user is trying to do will work as expected. If we returned the",
        "// Line_Reference 62: \t\t// resolved path, the user would be unable to know that it is in fact a symlink.",
        "// Line_Reference 63: \t\treturn r, nil",
        "// Line_Reference 64: \t}",
        "// Line_Reference 65: ",
        "// Line_Reference 66: \treturn \"\", NewBadPathResolution(p, r)",
        "// Line_Reference 67: }",
        "// Line_Reference 68: ",
        "// Line_Reference 87: ",
        "// Line_Reference 88: // Executes the fs.SafePath function in parallel against an array of paths. If any of the calls",
        "// Line_Reference 89: // fails an error will be returned.",
        "// Line_Reference 90: func (fs *Filesystem) ParallelSafePath(paths []string) ([]string, error) {",
        "// Line_Reference 91: \tvar cleaned []string",
        "// Line_Reference 92: ",
        "// Line_Reference 93: \t// Simple locker function to avoid racy appends to the array of cleaned paths.",
        "// Line_Reference 94: \tm := new(sync.Mutex)",
        "// Line_Reference 95: \tpush := func(c string) {",
        "// Line_Reference 96: \t\tm.Lock()",
        "// Line_Reference 97: \t\tcleaned = append(cleaned, c)",
        "// Line_Reference 98: \t\tm.Unlock()",
        "// Line_Reference 99: \t}",
        "// Line_Reference 100: ",
        "// Line_Reference 101: \t// Create an error group that we can use to run processes in parallel while retaining",
        "// Line_Reference 102: \t// the ability to cancel the entire process immediately should any of it fail.",
        "// Line_Reference 103: \tg, ctx := errgroup.WithContext(context.Background())",
        "// Line_Reference 104: ",
        "// Line_Reference 105: \t// Iterate over all of the paths and generate a cleaned path, if there is an error for any",
        "// Line_Reference 106: \t// of the files, abort the process.",
        "// Line_Reference 107: \tfor _, p := range paths {",
        "// Line_Reference 108: \t\t// Create copy so we can use it within the goroutine correctly.",
        "// Line_Reference 109: \t\tpi := p",
        "// Line_Reference 110: ",
        "// Line_Reference 111: \t\t// Recursively call this function to continue digging through the directory tree within",
        "// Line_Reference 112: \t\t// a separate goroutine. If the context is canceled abort this process.",
        "// Line_Reference 113: \t\tg.Go(func() error {",
        "// Line_Reference 114: \t\t\tselect {",
        "// Line_Reference 115: \t\t\tcase <-ctx.Done():",
        "// Line_Reference 116: \t\t\t\treturn ctx.Err()",
        "// Line_Reference 117: \t\t\tdefault:",
        "// Line_Reference 118: \t\t\t\t// If the callback returns true, go ahead and keep walking deeper. This allows",
        "// Line_Reference 119: \t\t\t\t// us to programmatically continue deeper into directories, or stop digging",
        "// Line_Reference 120: \t\t\t\t// if that pathway knows it needs nothing else.",
        "// Line_Reference 121: \t\t\t\tif c, err := fs.SafePath(pi); err != nil {",
        "// Line_Reference 122: \t\t\t\t\treturn err",
        "// Line_Reference 123: \t\t\t\t} else {",
        "// Line_Reference 124: \t\t\t\t\tpush(c)",
        "// Line_Reference 125: \t\t\t\t}",
        "// Line_Reference 126: ",
        "// Line_Reference 127: \t\t\t\treturn nil",
        "// Line_Reference 128: \t\t\t}",
        "// Line_Reference 129: \t\t})",
        "// Line_Reference 130: \t}",
        "// Line_Reference 131: ",
        "// Line_Reference 132: \t// Block until all of the routines finish and have returned a value.",
        "// Line_Reference 133: \treturn cleaned, g.Wait()",
        "// Line_Reference 134: }"
    ]
}
