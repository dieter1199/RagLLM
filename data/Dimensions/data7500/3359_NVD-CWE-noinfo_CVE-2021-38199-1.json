{
    "cve_id": "CVE-2021-38199",
    "cve_description": "fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection.",
    "cve_publish_date": "2021-08-08",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "NFSv4: Initialise connection to the server in nfs4_alloc_client()\n\nSet up the connection to the NFSv4 server in nfs4_alloc_client(), before\nwe've added the struct nfs_client to the net-namespace's nfs_client_list\nso that a downed server won't cause other mounts to hang in the trunking\ndetection code.\n\nReported-by: Michael Wakabayashi <mwakabayashi@vmware.com>\nFixes: 5c6e5b60aae4 (\"NFS: Fix an Oops in the pNFS files and flexfiles connection setup to the DS\")\nSigned-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "nfs4client.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "42",
    "number_of_lines_deleted_vulnerable_to_cve": "40",
    "vulnerable_lines": [
        "// Line_Reference 200: \tint err;",
        "// Line_Reference 375: \tchar buf[INET6_ADDRSTRLEN + 1];",
        "// Line_Reference 376: \tconst char *ip_addr = cl_init->ip_addr;",
        "// Line_Reference 384: \t/* Check NFS protocol revision and initialize RPC op vector */",
        "// Line_Reference 385: \tclp->rpc_ops = &nfs_v4_clientops;",
        "// Line_Reference 386: ",
        "// Line_Reference 387: \tif (clp->cl_minorversion != 0)",
        "// Line_Reference 388: \t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);",
        "// Line_Reference 389: \t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);",
        "// Line_Reference 390: \t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);",
        "// Line_Reference 391: ",
        "// Line_Reference 392: \terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);",
        "// Line_Reference 393: \tif (error == -EINVAL)",
        "// Line_Reference 394: \t\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);",
        "// Line_Reference 395: \tif (error < 0)",
        "// Line_Reference 396: \t\tgoto error;",
        "// Line_Reference 397: ",
        "// Line_Reference 398: \t/* If no clientaddr= option was specified, find a usable cb address */",
        "// Line_Reference 399: \tif (ip_addr == NULL) {",
        "// Line_Reference 400: \t\tstruct sockaddr_storage cb_addr;",
        "// Line_Reference 401: \t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;",
        "// Line_Reference 402: ",
        "// Line_Reference 403: \t\terror = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));",
        "// Line_Reference 404: \t\tif (error < 0)",
        "// Line_Reference 405: \t\t\tgoto error;",
        "// Line_Reference 406: \t\terror = rpc_ntop(sap, buf, sizeof(buf));",
        "// Line_Reference 407: \t\tif (error < 0)",
        "// Line_Reference 408: \t\t\tgoto error;",
        "// Line_Reference 409: \t\tip_addr = (const char *)buf;",
        "// Line_Reference 410: \t}",
        "// Line_Reference 411: \tstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));",
        "// Line_Reference 412: ",
        "// Line_Reference 413: \terror = nfs_idmap_new(clp);",
        "// Line_Reference 414: \tif (error < 0) {",
        "// Line_Reference 415: \t\tdprintk(\"%s: failed to create idmapper. Error = %d\\n\",",
        "// Line_Reference 416: \t\t\t__func__, error);",
        "// Line_Reference 417: \t\tgoto error;",
        "// Line_Reference 418: \t}",
        "// Line_Reference 419: \t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);",
        "// Line_Reference 420: "
    ]
}
