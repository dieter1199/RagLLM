{
    "cve_id": "CVE-2020-7662",
    "cve_description": "websocket-extensions npm module prior to 0.1.4 allows Denial of Service (DoS) via Regex Backtracking. The extension parser may take quadratic time when parsing a header containing an unclosed string parameter value whose content is a repeating two-byte sequence of a backslash and some other character. This could be abused by an attacker to conduct Regex Denial Of Service (ReDoS) on a single-threaded server by providing a malicious payload with the Sec-WebSocket-Extensions header.",
    "cve_publish_date": "2020-06-02",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "Remove ReDoS vulnerability in the Sec-WebSocket-Extensions header parser\n\nThere is a regular expression denial of service (ReDoS) vulnerability in\nthe parser we use to process the `Sec-WebSocket-Extensions` header. It\ncan be exploited by sending an opening WebSocket handshake to a server\ncontaining a header of the form:\n\n    Sec-WebSocket-Extensions: a;b=\"\\c\\c\\c\\c\\c\\c\\c\\c\\c\\c ...\n\ni.e. a header containing an unclosed string parameter value whose\ncontent is a repeating two-byte sequence of a backslash and some other\ncharacter. The parser takes exponential time to reject this header as\ninvalid, and this can be used to exhaust the server's capacity to\nprocess requests.\n\nThis vulnerability has been assigned the identifier CVE-2020-7662 and\nwas reported by Robert McLaughlin.\n\nWe believe this flaw stems from the grammar specified for this header.\n[RFC 6455][1] defines the grammar for the header as:\n\n    Sec-WebSocket-Extensions = extension-list\n\n    extension-list    = 1#extension\n    extension         = extension-token *( \";\" extension-param )\n    extension-token   = registered-token\n    registered-token  = token\n    extension-param   = token [ \"=\" (token | quoted-string) ]\n\nIt refers to [RFC 2616][2] for the definitions of `token` and\n`quoted-string`, which are:\n\n    token          = 1*<any CHAR except CTLs or separators>\n    separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                   | \",\" | \";\" | \":\" | \"\\\" | <\">\n                   | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                   | \"{\" | \"}\" | SP | HT\n\n    quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\n    qdtext         = <any TEXT except <\">>\n    quoted-pair    = \"\\\" CHAR\n\nThese rely on the `CHAR`, `CTL` and `TEXT` grammars, which are:\n\n    CHAR           = <any US-ASCII character (octets 0 - 127)>\n    CTL            = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n    TEXT           = <any OCTET except CTLs, but including LWS>\n\nOther relevant definitions to support these:\n\n    OCTET          = <any 8-bit sequence of data>\n    LWS            = [CRLF] 1*( SP | HT )\n    CRLF           = CR LF\n\n    HT             = <US-ASCII HT, horizontal-tab (9)>\n    LF             = <US-ASCII LF, linefeed (10)>\n    CR             = <US-ASCII CR, carriage return (13)>\n    SP             = <US-ASCII SP, space (32)>\n\nTo expand some of these terms out and write them as regular expressions:\n\n    OCTET         = [\\x00-\\xFF]\n    CHAR          = [\\x00-\\x7F]\n    TEXT          = [\\t \\x21-\\x7E\\x80-\\xFF]\n\nThe allowable bytes for `token` are [\\x00-\\x7F], except [\\x00-\\x1F\\x7F]\n(leaving [\\x20-\\x7E]) and `separators`, which leaves the following set\nof allowed chars:\n\n    ! # $ % & ' * + - . ^ _ ` | ~ [0-9] [A-Z] [a-z]\n\n`quoted-string` contains a repeated pattern of either `qdtext` or\n`quoted-pair`. `qdtext` is any `TEXT` byte except <\">, and the <\">\ncharacter is ASCII 34, or 0x22. The <!> character is 0x21. So `qdtext`\ncan be written either positively as:\n\n    qdtext        = [\\t !\\x23-\\x7E\\x80-\\xFF]\n\nor negatively, as:\n\n    qdtext        = [^\\x00-\\x08\\x0A-\\x1F\\x7F\"]\n\nWe use the negative definition here. The other alternative in the\n`quoted-string` pattern is:\n\n    quoted-pair   = \\\\[\\x00-\\x7F]\n\nThe problem is that the set of bytes matched by `qdtext` includes <\\>,\nand intersects with the second element of `quoted-pair`. That means the\nsequence \\c can be matched as either two `qdtext` bytes, or as a single\n`quoted-pair`. When the regex engine fails to find a trailing <\"> to\nclose the string, it back-tracks and tries every alternate parse for the\nstring, which doubles with each pair of bytes in the input.\n\nTo fix the ReDoS flaw we need to rewrite the repeating pattern so that\nnone of its alternate branches can match the same text. For example, we\ncould try dividing the set of bytes [\\x00-\\xFF] into those that must not\nfollow a <\\>, those that may follow a <\\>, and those that must be\npreceded by <\\>, and thereby construct a pattern of the form:\n\n    (A|\\?B|\\C)*\n\nwhere A, B and C have no characters in common. In our case the three\nbranch patterns would be:\n\n    A   =   qdtext - CHAR   =   [\\x80-\\xFF]\n    B   =   qdtext & CHAR   =   [\\t !\\x23-\\x7E]\n    C   =   CHAR - qdtext   =   [\\x00-\\x08\\x0A-\\x1F\\x7F\"]\n\nThese sets do not intersect, and notice <\"> appears in set C so must be\npreceded by <\\>. But we still have a problem: <\\> (0x5C) and all the\nalphabetic characters are in set B, so the pattern \\?B can match all\nthese:\n\n    c\n    \\\n    \\c\n\nSo the sequence \\c\\c\\c... still produces exponential back-tracking. It\nalso fails to parse input like this correctly:\n\n    Sec-WebSocket-Extensions: a; b=\"c\\\", d\"\n\nBecause the grammar allows a single backslash to appear by itself, this\nis arguably a syntax error where the parameter `b` has value `c\\` and\nthen a new extension `d` begins with a <\"> appearing where it should\nnot.\n\nSo the core problem is with the grammar itself: `qdtext` matches a\nsingle backslash <\\>, and `quoted-pair` matches a pair <\\\\>. So given a\nsequence of backslashes there's no canonical parse and the grammar is\nambiguous.\n\n[RFC 7230][3] remedies this problem and makes the grammar clearer.\nFirst, it defines `token` explicitly rather than implicitly:\n\n    token          = 1*tchar\n\n    tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n                   / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n                   / DIGIT / ALPHA\n\nAnd second, it defines `quoted-string` so that backslashes cannot appear\non their own:\n\n     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n     qdtext         = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n     obs-text       = %x80-FF\n     quoted-pair    = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n\nwhere VCHAR is any printing ASCII character 0x21-0x7E. Notice `qdtext`\nis just our previous definition but with 5C excluded, so it cannot\naccept a single backslash.\n\nThis commit makes this modification to our matching patterns, and\nthereby removes the ReDoS vector. Technically this means it does not\nmatch the grammar of RFC 6455, but we expect this to have little or no\npractical impact, especially since the one main protocol extension,\n`permessage-deflate` ([RFC 7692][4]), does not have any string-valued\nparameters.\n\n[1]: https://tools.ietf.org/html/rfc6455#section-9.1\n[2]: https://tools.ietf.org/html/rfc2616#section-2.2\n[3]: https://tools.ietf.org/html/rfc7230#section-3.2.6\n[4]: https://tools.ietf.org/html/rfc7692",
    "type_of_change": "Modification",
    "filename_of_changes": "parser.js",
    "code_language": "JavaScript",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 5:     QUOTED   = /\"((?:\\\\[\\x00-\\x7f]|[^\\x00-\\x08\\x0a-\\x1f\\x7f\"])*)\"/,"
    ]
}
