describe('SMTP-Connection Tests', function() {
describe('Version test', function() {
it('Should expose version number', function() {
describe('Connection tests', function() {
beforeEach(function(done) {
onAuth: function(auth, session, callback) {
onData: function(stream, session, callback) {
stream.on('data', function() {});
onData: function(stream, session, callback) {
stream.on('data', function(chunk) {
stream.on('end', function() {
invalidServer = net.createServer(function() {});
onAuth: function(auth, session, callback) {
onData: function(stream, session, callback) {
stream.on('data', function() {});
server.listen(PORT_NUMBER, function() {
invalidServer.listen(PORT_NUMBER + 1, function() {
secureServer.listen(PORT_NUMBER + 2, function() {
insecureServer.listen(PORT_NUMBER + 3, function() {
afterEach(function(done) {
server.close(function() {
invalidServer.close(function() {
secureServer.close(function() {
insecureServer.close(function() {
it('should connect to unsecure server', function(done) {
client.connect(function() {
client.on('error', function(err) {
it('should connect to a server and upgrade with STARTTLS', function(done) {
client.connect(function() {
client.on('error', function(err) {
it('should connect to a server and upgrade with forced STARTTLS', function(done) {
client.connect(function() {
client.on('error', function(err) {
it('should connect to a server and try to upgrade STARTTLS', function(done) {
client.connect(function() {
client.on('error', function(err) {
it('should try upgrade with STARTTLS where not advertised', function(done) {
client.connect(function() {
client.once('error', function(err) {
it('should close connection after STARTTLS', function(done) {
client.connect(function() {
server.connections.forEach(function(conn) {
client.on('error', function(err) {
it('should connect to a secure server', function(done) {
client.connect(function() {
client.on('error', function(err) {
it('should emit error for invalid port', function(done) {
client.connect(function() {
client.once('error', function(err) {
it('should emit error for too large port', function(done) {
client.connect(function() {
client.once('error', function(err) {
it('should emit inactivity timeout error', function(done) {
client.connect(function() {
client.once('error', function(err) {
it('should connect through proxy', function(done) {
let runTest = function(socket) {
client.connect(function() {
function(err) {
client.on('error', function(err) {
proxyConnect(PROXY_PORT_NUMBER, '127.0.0.1', PORT_NUMBER, '127.0.0.1', function(err, socket) {
it('should connect through proxy to secure server', function(done) {
let runTest = function(socket) {
client.connect(function() {
function(err) {
client.on('error', function(err) {
proxyConnect(PROXY_PORT_NUMBER, '127.0.0.1', PORT_NUMBER + 2, '127.0.0.1', function(err, socket) {
it('should send to unsecure server', function(done) {
client.on('error', function(err) {
client.connect(function() {
server.on('data', function(connection, chunk) {
server.on('dataReady', function(connection, callback) {
expect(body.toString()).to.equal(
message
.toString()
.trim()
.replace(/\n/g, '\r\n')
);
function(err) {
describe('Login tests', function() {
beforeEach(function(done) {
onData: function(stream, session, callback) {
stream.on('data', function(chunk) {
stream.on('end', function() {
onAuth: function(auth, session, callback) {
onMailFrom: function(address, session, callback) {
onRcptTo: function(address, session, callback) {
onData: function(stream, session, callback) {
stream.on('data', function() {});
stream.on('end', function() {
let response = session.envelope.rcptTo.map(function(rcpt, i) {
onMailFrom: function(address, session, callback) {
onRcptTo: function(address, session, callback) {
server.listen(PORT_NUMBER, function() {
lmtpServer.listen(LMTP_PORT_NUMBER, function() {
client.connect(function() {
afterEach(function(done) {
server.close(function() {
it('should login', function(done) {
function(err) {
it('should return error for invalid login', function(done) {
function(err) {
it('should return error for missing credentials', function(done) {
function(err) {
it('should return error for incomplete credentials', function(done) {
function(err) {
describe('xoauth2 login', function() {
beforeEach(function(done) {
onUpdate: function(username, accessToken) {
afterEach(function(done) {
it('should login with xoauth2 string', function(done) {
function(err) {
it('should return error for invalid xoauth2 string token', function(done) {
function(err) {
it('should login with xoauth2 object', function(done) {
function(err) {
it('should fail with xoauth2 object', function(done) {
function(err) {
it('should fail with invalid xoauth2 response', function(done) {
function(err) {
describe('custom login', function() {
beforeEach(function(done) {
afterEach(function(done) {
it('should login', function(done) {
function(err) {
describe('Send without PIPELINING', function() {
beforeEach(function(done) {
client.on('end', function() {
client.connect(function() {
function(err) {
it('should send only to valid recipients without PIPELINING', function(done) {
function(err, info) {
describe('Send messages', function() {
beforeEach(function(done) {
function(err) {
it('should send message', function(done) {
function(err, info) {
it('should send multiple messages', function(done) {
function(err, info) {
client.reset(function(err) {
function(err, info) {
it('should send only to valid recipients', function(done) {
function(err, info) {
it('should reject all recipients', function(done) {
function(err, info) {
it('should reject too large SIZE arguments', function(done) {
function(err, info) {
it('should reject too large message', function(done) {
function(err, info) {
it('should declare SIZE', function(done) {
function(err, info) {
it('lmtp should send only to valid recipients', function(done) {
function(err, info) {
it('should send using SMTPUTF8', function(done) {
function(err, info) {
it('should send using 8BITMIME', function(done) {
function(err, info) {
it('should receive error for 8-bit content without 8BITMIME declaration', function(done) {
function(err) {
it('should return error for invalidly formatted recipients', function(done) {
function(err) {
it('should return error for no valid recipients', function(done) {
function(err) {
it('should return error for invalid sender', function(done) {
function(err) {
it('should send message string', function(done) {
server.on('data', function(connection, chunk) {
server.on('dataReady', function(connection, callback) {
function(err) {
it('should send message buffer', function(done) {
server.on('data', function(connection, chunk) {
server.on('dataReady', function(connection, callback) {
expect(body.toString()).to.equal(
message
.toString()
.trim()
.replace(/\n/g, '\r\n')
);
function(err) {
it('should send message stream', function(done) {
server.on('data', function(connection, chunk) {
server.on('dataReady', function(connection, callback) {
expect(body.toString()).to.equal(
message
.toString()
.trim()
.replace(/\n/g, '\r\n')
);
function(err) {
let socket = net.connect(port, host, function() {
let onSocketData = function(chunk) {
socket.on('error', function(err) {