{
    "cve_id": "CVE-2021-38203",
    "cve_description": "btrfs in the Linux kernel before 5.13.4 allows attackers to cause a denial of service (deadlock) via processes that trigger allocation of new system chunks during times when there is a shortage of free space in the system space_info.",
    "cve_publish_date": "2021-08-08",
    "cwe_id": "CWE-667",
    "cwe_name": "Improper Locking",
    "cwe_description": "The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.",
    "commit_message": "btrfs: fix deadlock with concurrent chunk allocations involving system chunks\n\nWhen a task attempting to allocate a new chunk verifies that there is not\ncurrently enough free space in the system space_info and there is another\ntask that allocated a new system chunk but it did not finish yet the\ncreation of the respective block group, it waits for that other task to\nfinish creating the block group. This is to avoid exhaustion of the system\nchunk array in the superblock, which is limited, when we have a thundering\nherd of tasks allocating new chunks. This problem was described and fixed\nby commit eafa4fd0ad0607 (\"btrfs: fix exhaustion of the system chunk array\ndue to concurrent allocations\").\n\nHowever there are two very similar scenarios where this can lead to a\ndeadlock:\n\n1) Task B allocated a new system chunk and task A is waiting on task B\n   to finish creation of the respective system block group. However before\n   task B ends its transaction handle and finishes the creation of the\n   system block group, it attempts to allocate another chunk (like a data\n   chunk for an fallocate operation for a very large range). Task B will\n   be unable to progress and allocate the new chunk, because task A set\n   space_info->chunk_alloc to 1 and therefore it loops at\n   btrfs_chunk_alloc() waiting for task A to finish its chunk allocation\n   and set space_info->chunk_alloc to 0, but task A is waiting on task B\n   to finish creation of the new system block group, therefore resulting\n   in a deadlock;\n\n2) Task B allocated a new system chunk and task A is waiting on task B to\n   finish creation of the respective system block group. By the time that\n   task B enter the final phase of block group allocation, which happens\n   at btrfs_create_pending_block_groups(), when it modifies the extent\n   tree, the device tree or the chunk tree to insert the items for some\n   new block group, it needs to allocate a new chunk, so it ends up at\n   btrfs_chunk_alloc() and keeps looping there because task A has set\n   space_info->chunk_alloc to 1, but task A is waiting for task B to\n   finish creation of the new system block group and release the reserved\n   system space, therefore resulting in a deadlock.\n\nIn short, the problem is if a task B needs to allocate a new chunk after\nit previously allocated a new system chunk and if another task A is\ncurrently waiting for task B to complete the allocation of the new system\nchunk.\n\nUnfortunately this deadlock scenario introduced by the previous fix for\nthe system chunk array exhaustion problem does not have a simple and short\nfix, and requires a big change to rework the chunk allocation code so that\nchunk btree updates are all made in the first phase of chunk allocation.\nAnd since this deadlock regression is being frequently hit on zoned\nfilesystems and the system chunk array exhaustion problem is triggered\nin more extreme cases (originally observed on PowerPC with a node size\nof 64K when running the fallocate tests from stress-ng), revert the\nchanges from that commit. The next patch in the series, with a subject\nof \"btrfs: rework chunk allocation to avoid exhaustion of the system\nchunk array\" does the necessary changes to fix the system chunk array\nexhaustion problem.\n\nReported-by: Naohiro Aota <naohiro.aota@wdc.com>\nLink: https://lore.kernel.org/linux-btrfs/20210621015922.ewgbffxuawia7liz@naota-xeon/\nFixes: eafa4fd0ad0607 (\"btrfs: fix exhaustion of the system chunk array due to concurrent allocations\")\nCC: stable@vger.kernel.org # 5.12+\nTested-by: Shin'ichiro Kawasaki <shinichiro.kawasaki@wdc.com>\nTested-by: Naohiro Aota <naohiro.aota@wdc.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nTested-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "transaction.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "7",
    "vulnerable_lines": [
        "// Line_Reference 99: ",
        "// Line_Reference 100: \t/*",
        "// Line_Reference 101: \t * The number of bytes currently reserved, by all transaction handles",
        "// Line_Reference 102: \t * attached to this transaction, for metadata extents of the chunk tree.",
        "// Line_Reference 103: \t */",
        "// Line_Reference 104: \tatomic64_t chunk_bytes_reserved;",
        "// Line_Reference 105: \twait_queue_head_t chunk_reserve_wait;"
    ]
}
