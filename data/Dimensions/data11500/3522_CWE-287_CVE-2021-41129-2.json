{
    "cve_id": "CVE-2021-41129",
    "cve_description": "Pterodactyl is an open-source game server management panel built with PHP 7, React, and Go. A malicious user can modify the contents of a `confirmation_token` input during the two-factor authentication process to reference a cache value not associated with the login attempt. In rare cases this can allow a malicious actor to authenticate as a random user in the Panel. The malicious user must target an account with two-factor authentication enabled, and then must provide a correct two-factor authentication token before being authenticated as that user. Due to a validation flaw in the logic handling user authentication during the two-factor authentication process a malicious user can trick the system into loading credentials for an arbitrary user by modifying the token sent to the server. This authentication flaw is present in the `LoginCheckpointController@__invoke` method which handles two-factor authentication for a user. This controller looks for a request input parameter called `confirmation_token` which is expected to be a 64 character random alpha-numeric string that references a value within the Panel's cache containing a `user_id` value. This value is then used to fetch the user that attempted to login, and lookup their two-factor authentication token. Due to the design of this system, any element in the cache that contains only digits could be referenced by a malicious user, and whatever value is stored at that position would be used as the `user_id`. There are a few different areas of the Panel that store values into the cache that are integers, and a user who determines what those cache keys are could pass one of those keys which would cause this code pathway to reference an arbitrary user. At its heart this is a high-risk login bypass vulnerability. However, there are a few additional conditions that must be met in order for this to be successfully executed, notably: 1.) The account referenced by the malicious cache key must have two-factor authentication enabled. An account without two-factor authentication would cause an exception to be triggered by the authentication logic, thusly exiting this authentication flow. 2.) Even if the malicious user is able to reference a valid cache key that references a valid user account with two-factor authentication, they must provide a valid two-factor authentication token. However, due to the design of this endpoint once a valid user account is found with two-factor authentication enabled there is no rate-limiting present, thusly allowing an attacker to brute force combinations until successful. This leads to a third condition that must be met: 3.) For the duration of this attack sequence the cache key being referenced must continue to exist with a valid `user_id` value. Depending on the specific key being used for this attack, this value may disappear quickly, or be changed by other random user interactions on the Panel, outside the control of the attacker. In order to mitigate this vulnerability the underlying authentication logic was changed to use an encrypted session store that the user is therefore unable to control the value of. This completely removed the use of a user-controlled value being used. In addition, the code was audited to ensure this type of vulnerability is not present elsewhere.",
    "cve_publish_date": "2021-10-06",
    "cwe_id": "CWE-287",
    "cwe_name": "Improper Authentication",
    "cwe_description": "When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",
    "commit_message": "Fix security vulnerability when authenticating a two-factor authentication token for a user\n\nSee associated security advisory for technical details on the content of this security fix.\n\nGHSA ID: GHSA-5vfx-8w6m-h3v4",
    "type_of_change": "Modification",
    "filename_of_changes": "LoginCheckpointController.php",
    "code_language": "PHP",
    "number_of_lines_added_for_mitigation": "54",
    "number_of_lines_deleted_vulnerable_to_cve": "53",
    "vulnerable_lines": [
        "// Line_Reference 6: use Illuminate\\Auth\\AuthManager;",
        "// Line_Reference 9: use Illuminate\\Contracts\\Config\\Repository;",
        "// Line_Reference 13: use Illuminate\\Contracts\\Cache\\Repository as CacheRepository;",
        "// Line_Reference 14: use Pterodactyl\\Contracts\\Repository\\UserRepositoryInterface;",
        "// Line_Reference 15: use Pterodactyl\\Repositories\\Eloquent\\RecoveryTokenRepository;",
        "// Line_Reference 19:     /**",
        "// Line_Reference 20:      * @var \\Illuminate\\Contracts\\Cache\\Repository",
        "// Line_Reference 21:      */",
        "// Line_Reference 22:     private $cache;",
        "// Line_Reference 23: ",
        "// Line_Reference 24:     /**",
        "// Line_Reference 25:      * @var \\Pterodactyl\\Contracts\\Repository\\UserRepositoryInterface",
        "// Line_Reference 26:      */",
        "// Line_Reference 27:     private $repository;",
        "// Line_Reference 29:     /**",
        "// Line_Reference 30:      * @var \\PragmaRX\\Google2FA\\Google2FA",
        "// Line_Reference 31:      */",
        "// Line_Reference 32:     private $google2FA;",
        "// Line_Reference 34:     /**",
        "// Line_Reference 35:      * @var \\Illuminate\\Contracts\\Encryption\\Encrypter",
        "// Line_Reference 36:      */",
        "// Line_Reference 37:     private $encrypter;",
        "// Line_Reference 39:     /**",
        "// Line_Reference 40:      * @var \\Pterodactyl\\Repositories\\Eloquent\\RecoveryTokenRepository",
        "// Line_Reference 41:      */",
        "// Line_Reference 42:     private $recoveryTokenRepository;",
        "// Line_Reference 47:     public function __construct(",
        "// Line_Reference 48:         AuthManager $auth,",
        "// Line_Reference 49:         Encrypter $encrypter,",
        "// Line_Reference 50:         Google2FA $google2FA,",
        "// Line_Reference 51:         Repository $config,",
        "// Line_Reference 52:         CacheRepository $cache,",
        "// Line_Reference 53:         RecoveryTokenRepository $recoveryTokenRepository,",
        "// Line_Reference 54:         UserRepositoryInterface $repository",
        "// Line_Reference 55:     ) {",
        "// Line_Reference 56:         parent::__construct($auth, $config);",
        "// Line_Reference 59:         $this->cache = $cache;",
        "// Line_Reference 60:         $this->repository = $repository;",
        "// Line_Reference 62:         $this->recoveryTokenRepository = $recoveryTokenRepository;",
        "// Line_Reference 84:         $token = $request->input('confirmation_token');",
        "// Line_Reference 87:             $user = User::query()->findOrFail($this->cache->get($token, 0));",
        "// Line_Reference 89:             $this->incrementLoginAttempts($request);",
        "// Line_Reference 90: ",
        "// Line_Reference 91:             return $this->sendFailedLoginResponse(",
        "// Line_Reference 92:                 $request,",
        "// Line_Reference 93:                 null,",
        "// Line_Reference 94:                 'The authentication token provided has expired, please refresh the page and try again.'",
        "// Line_Reference 95:             );",
        "// Line_Reference 107:                 $this->cache->delete($token);",
        "// Line_Reference 108: ",
        "// Line_Reference 113:         $this->incrementLoginAttempts($request);",
        "// Line_Reference 114: ",
        "// Line_Reference 115:         return $this->sendFailedLoginResponse($request, $user, !empty($recoveryToken) ? 'The recovery token provided is not valid.' : null);"
    ]
}
