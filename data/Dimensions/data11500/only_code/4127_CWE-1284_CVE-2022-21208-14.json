public receiveBufferSize: number;
public sendBufferSize: number;
public maxMessageSize: number;
public maxChunkCount: number;
public protocolVersion: number;
this.receiveBufferSize = 0;
this.sendBufferSize = 0;
this.maxMessageSize = 0;
this.maxChunkCount = 0;
this.protocolVersion = 0;
if (debugLog) {
debugLog(chalk.cyan("_abortWithError"));
assert(typeof callback === "function", "expecting a callback");
/* istanbul ignore else */
if (!this._aborted) {
this._aborted = 1;
setTimeout(() => {
// send the error message and close the connection
assert(Object.prototype.hasOwnProperty.call(StatusCodes, statusCode.name));
/* istanbul ignore next*/
if (doDebug) {
debugLog(chalk.red(" Server aborting because ") + chalk.cyan(statusCode.name));
debugLog(chalk.red(" extraErrorDescription   ") + chalk.cyan(extraErrorDescription));
}
const errorResponse = new TCPErrorMessage({
reason: statusCode.description,
statusCode
});
const messageChunk = packTcpMessage("ERR", errorResponse);
this.write(messageChunk);
this.disconnect(() => {
this._aborted = 2;
callback(new Error(extraErrorDescription + " StatusCode = " + statusCode.name));
});
}, ServerTCP_transport.throttleTime);
} else {
callback(new Error(statusCode.name));
}
}
private _send_ACK_response(helloMessage: HelloMessage): void {
assert(helloMessage.receiveBufferSize >= minimumBufferSize);
assert(helloMessage.sendBufferSize >= minimumBufferSize);
this.receiveBufferSize = clamp_value(helloMessage.receiveBufferSize, 8192, 512 * 1024);
this.sendBufferSize = clamp_value(helloMessage.sendBufferSize, 8192, 512 * 1024);
this.maxMessageSize = clamp_value(helloMessage.maxMessageSize, 100000, 64 * 1024 * 1024);
this.maxChunkCount = clamp_value(helloMessage.maxChunkCount, 0, 65535);
