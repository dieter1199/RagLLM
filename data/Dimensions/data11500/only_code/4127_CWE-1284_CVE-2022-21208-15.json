import { createFastUninitializedBuffer } from "node-opcua-buffer-utils";
import * as debug from "node-opcua-debug";
import { PacketAssembler } from "node-opcua-packet-assembler";
import { ErrorCallback, CallbackWithData } from "node-opcua-status-code";
import { writeTCPMessageHeader } from "./tools";
const debugLog = debug.make_debugLog(__filename);
const doDebug = debug.checkDebugFlag(__filename);
const errorLog = debug.make_errorLog(__filename);
on(eventName: "message", eventHandler: (message: Buffer) => void): this;
once(eventName: "message", eventHandler: (message: Buffer) => void): this;
private _pendingBuffer?: any;
this._pendingBuffer = undefined;
/**
* ```createChunk``` is used to construct a pre-allocated chunk to store up to ```length``` bytes of data.
* The created chunk includes a prepended header for ```chunk_type``` of size ```self.headerSize```.
*
* @method createChunk
* @param msgType
* @param chunkType {String} chunk type. should be 'F' 'C' or 'A'
* @param length
* @return a buffer object with the required length representing the chunk.
*
* Note:
*  - only one chunk can be created at a time.
*  - a created chunk should be committed using the ```write``` method before an other one is created.
*/
public createChunk(msgType: string, chunkType: string, length: number): Buffer {
assert(msgType === "MSG");
assert(this._pendingBuffer === undefined, "createChunk has already been called ( use write first)");
const totalLength = length + this.headerSize;
const buffer = createFastUninitializedBuffer(totalLength);
writeTCPMessageHeader("MSG", chunkType, totalLength, buffer);
this._pendingBuffer = buffer;
return buffer;
}
*
* Notes:
*  - the message chunk must have been created by ```createChunk```.
*  - once a message chunk has been written, it is possible to call ```createChunk``` again.
*
public write(messageChunk: Buffer): void {
assert(
this._pendingBuffer === undefined || this._pendingBuffer === messageChunk,
" write should be used with buffer created by createChunk"
);
assert(["F", "C", "A"].indexOf(header.messageHeader.isFinal) !== -1);
this._write_chunk(messageChunk);
this._pendingBuffer = undefined;
protected _write_chunk(messageChunk: Buffer): void {
this._socket.write(messageChunk);
// install packet assembler ...
this.packetAssembler = new PacketAssembler({
readMessageFunc: readRawMessageHeader,
minimumSizeInBytes: this.headerSize
});
/* istanbul ignore next */
if (!this.packetAssembler) {
throw new Error("Internal Error");
}
this.packetAssembler.on("message", (messageChunk: Buffer) => this._on_message_received(messageChunk));
this.prematureTerminate(new Error("socket timeout : timeout=" + this.timeout));
public prematureTerminate(err: Error): void {
debugLog("prematureTerminate", err ? err.message : "");
err.message = "socket has timeout: EPIPE: " + err.message;
private _on_message_received(messageChunk: Buffer) {
this.emit("message", messageChunk);
