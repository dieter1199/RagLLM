exploreCertificate
import { ServerTCP_transport } from "node-opcua-transport";
public readonly messageBuilder: MessageBuilder;
this.messageBuilder = new MessageBuilder({
name: "server",
objectFactory: options.objectFactory,
privateKey: this.getPrivateKey()
});
this.messageBuilder.on("error", (err) => {
// istanbul ignore next
if (doDebug) {
debugLog(chalk.red("xxxxx error "), err.message.yellow, err.stack);
debugLog(chalk.red("xxxxx Server is now closing socket, without further notice"));
}
// close socket immediately
this.close(undefined);
});
assert(this.messageBuilder, "dispose already called ?");
// xx this.messageBuilder = null;
(this as any).transport = null;
this.messageBuilder.setSecurity(securityMode, securityPolicy);
this.transport.on("message", (messageChunk: Buffer) => {
assert(this.messageBuilder);
this.messageBuilder.feed(messageChunk);
public send_fatal_error_and_abort(
statusCode: StatusCode,
description: string,
message: Message,
callback: ErrorCallback
): void {
/* istanbul ignore next */
if (!(this.messageBuilder && this.messageBuilder.sequenceHeader && this.messageBuilder.securityHeader)) {
return this._on_OpenSecureChannelRequestError(StatusCodes.BadCommunicationError, "internal error", message, callback);
}
this._on_common_message(request, msgType, requestId, channelId);
.on("start_chunk", () => {
this.messageBuilder.removeListener("message", messageHandler);
this.messageBuilder.removeListener("error", errorHandler);
this.messageBuilder.once("error", errorHandler);
this.messageBuilder.once("message", messageHandler);
const cryptoFactory = this.messageBuilder.cryptoFactory;
const cryptoFactory = this.messageBuilder.cryptoFactory;
return this.send_fatal_error_and_abort(StatusCodes.BadInternalError, "invalid request", message, callback);
const cryptoFactory = this.messageBuilder.cryptoFactory;
this.messageBuilder.pushNewToken(this.securityToken, derivedClientKeys);
if (this.messageBuilder.sequenceHeader === null) {
requestId = this.messageBuilder.sequenceHeader.requestId;
return this.send_fatal_error_and_abort(
this.send_fatal_error_and_abort(serviceResult, description, message, callback);
