{
    "cve_id": "CVE-2022-23628",
    "cve_description": "OPA is an open source, general-purpose policy engine. Under certain conditions, pretty-printing an abstract syntax tree (AST) that contains synthetic nodes could change the logic of some statements by reordering array literals. Example of policies impacted are those that parse and compare web paths. **All of these** three conditions have to be met to create an adverse effect: 1. An AST of Rego had to be **created programmatically** such that it ends up containing terms without a location (such as wildcard variables). 2. The AST had to be **pretty-printed** using the `github.com/open-policy-agent/opa/format` package. 3. The result of the pretty-printing had to be **parsed and evaluated again** via an OPA instance using the bundles, or the Golang packages. If any of these three conditions are not met, you are not affected. Notably, all three would be true if using **optimized bundles**, i.e. bundles created with `opa build -O=1` or higher. In that case, the optimizer would fulfil condition (1.), the result of that would be pretty-printed when writing the bundle to disk, fulfilling (2.). When the bundle was then used, we'd satisfy (3.). As a workaround users may disable optimization when creating bundles.",
    "cve_publish_date": "2022-02-09",
    "cwe_id": "CWE-682",
    "cwe_name": "Incorrect Calculation",
    "cwe_description": "The product performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management.",
    "commit_message": "format: don't group iterable when one has defaulted location (#4260)\n\nAs mentioned in the comment, empty file names happen when the format\r\npackage's Ast() function does a sweep of its input, and adds a\r\n\"default location\" to everything that has a nil location.\r\n\r\nDuring PE, when generated the pairs to save in saveUnify, we'll\r\nreturn Var Terms without locations. Fixing that seemed like a bigger\r\nhurdle, so I went this route.\r\n\r\nThe new check is such that if any term has the default file in\r\nits location, such as would happen if we're formatting code that\r\nwas created programmatically (not parsed), we'll group the terms'\r\nelements, but print them in one line.\r\n\r\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "format.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "20",
    "number_of_lines_deleted_vulnerable_to_cve": "10",
    "vulnerable_lines": [
        "// Line_Reference 157: \treturn ast.NewLocation([]byte(x.String()), \"\", 1, 1)",
        "// Line_Reference 898: \t// partial evaluation in a bundle build with optimization. For those vars,",
        "// Line_Reference 899: \t// there is no location, and the grouping based on source location will",
        "// Line_Reference 900: \t// yield a bad result. So if there's a generated variable among elements,",
        "// Line_Reference 901: \t// we'll render the elements all in one line.",
        "// Line_Reference 902: \tvis := ast.NewVarVisitor()",
        "// Line_Reference 904: \t\tvis.Walk(elem)",
        "// Line_Reference 905: \t}",
        "// Line_Reference 906: \tfor v := range vis.Vars() {",
        "// Line_Reference 907: \t\tif v.IsGenerated() {"
    ]
}
