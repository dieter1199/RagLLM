{
    "cve_id": "CVE-2022-3008",
    "cve_description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
    "cve_publish_date": "2022-09-05",
    "cwe_id": "CWE-77",
    "cwe_name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')",
    "cwe_description": "The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.",
    "commit_message": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
    "type_of_change": "Modification",
    "filename_of_changes": "tiny_gltf.h",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "44",
    "number_of_lines_deleted_vulnerable_to_cve": "20",
    "vulnerable_lines": [
        "// Line_Reference 111: #define TINYGLTF_COMPONENT_TYPE_DOUBLE (5130) // OpenGL double type. Note that some of glTF 2.0 validator does not support double type even the schema seems allow any value of integer: https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22",
        "// Line_Reference 616:   //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently not used.",
        "// Line_Reference 1305:   /// Set warning message to `warn` for example it fails to load asserts.",
        "// Line_Reference 1306:   /// Returns false and set error string to `err` if there's an error.",
        "// Line_Reference 1608: #include <wordexp.h>",
        "// Line_Reference 1936:          this->wrapS == other.wrapS &&",
        "// Line_Reference 1937:          this->wrapT == other.wrapT;",
        "// Line_Reference 1939:          //this->wrapR == other.wrapR",
        "// Line_Reference 2045:   if (idx != std::string::npos)",
        "// Line_Reference 2046:     return filepath.substr(idx + 1);",
        "// Line_Reference 4245:   if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",",
        "// Line_Reference 4246:                        true, \"SparseAccessor\")) {",
        "// Line_Reference 4252:                        true, \"SparseAccessor\")) {",
        "// Line_Reference 4258:                        true, \"SparseAccessor\")) {",
        "// Line_Reference 5097:   //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;",
        "// Line_Reference 5102:   //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension",
        "// Line_Reference 5111:   //sampler->wrapR = wrapR;",
        "// Line_Reference 7174:   //SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);",
        "// Line_Reference 7537:   const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;",
        "// Line_Reference 7538:   const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;"
    ]
}
