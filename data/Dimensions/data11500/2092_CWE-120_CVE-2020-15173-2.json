{
    "cve_id": "CVE-2020-15173",
    "cve_description": "In ACCEL-PPP (an implementation of PPTP/PPPoE/L2TP/SSTP), there is a buffer overflow when receiving an l2tp control packet ith an AVP which type is a string and no hidden flags, length set to less than 6. If your application is used in open networks or there are untrusted nodes in the network it is highly recommended to apply the patch. The problem was patched with commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b As a workaround changes of commit 2324bcd5ba12cf28f47357a8f03cd41b7c04c52b can be applied to older versions.",
    "cve_publish_date": "2020-09-09",
    "cwe_id": "CWE-120",
    "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
    "cwe_description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
    "commit_message": "l2tp: fix RCE through buffer overflow & fix LE/BE compatibility\n\nUnsufficent checks of valid l2tp header & avp length cause possible\nRCE through buffer overflow, reported by https://github.com/WinMin\nswings & leommxj, Chaitin Security Research Lab. Add missed header\nlength and avp length validation to fix the issue.\n\nOrder of struct bitfields is implementation-defined so current code\ndoesn't play well with big-endian arch. switch to explicit flag bit\nchecking/gathering to fix the issue.\n\nRFC 2661 and 3931 requires that length, seqeuence flags must be set\nand offset flag must not be set, so avp-premissive can't help in\nthis cases.",
    "type_of_change": "Modification",
    "filename_of_changes": "packet.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "114",
    "number_of_lines_deleted_vulnerable_to_cve": "89",
    "vulnerable_lines": [
        "// Line_Reference 31: \tif (pack->hdr.ver == 2) {",
        "// Line_Reference 34: \t} else {",
        "// Line_Reference 75: \tpack->hdr.ver = ver;",
        "// Line_Reference 76: \tpack->hdr.T = 1;",
        "// Line_Reference 77: \tpack->hdr.L = 1;",
        "// Line_Reference 78: \tpack->hdr.S = 1;",
        "// Line_Reference 159: \tif (avp->length < sizeof(struct l2tp_avp_t) + 2) {",
        "// Line_Reference 164: \t\t\t ntohs(avp->type), avp->length);",
        "// Line_Reference 167: \tattr_len = avp->length - sizeof(struct l2tp_avp_t);",
        "// Line_Reference 231: \tint n, length;",
        "// Line_Reference 232: \tuint8_t *buf;",
        "// Line_Reference 235: \tstruct l2tp_dict_attr_t *da;",
        "// Line_Reference 236: \tstruct l2tp_attr_t *attr, *RV = NULL;",
        "// Line_Reference 237: \tuint8_t *ptr;",
        "// Line_Reference 238: \tstruct l2tp_packet_t *pack;",
        "// Line_Reference 240: \tsocklen_t len = sizeof(addr);",
        "// Line_Reference 241: \tstruct msghdr msg;",
        "// Line_Reference 242: \tchar msg_control[128];",
        "// Line_Reference 243: \tstruct cmsghdr *cmsg;",
        "// Line_Reference 247:   *p = NULL;",
        "// Line_Reference 252: \t\tmsg.msg_controllen = 128;",
        "// Line_Reference 255: ",
        "// Line_Reference 279: \tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &len);",
        "// Line_Reference 280: ",
        "// Line_Reference 292: \tif (n < 6) {",
        "// Line_Reference 298: \tif (hdr->T == 0)",
        "// Line_Reference 300: ",
        "// Line_Reference 301: \tif (n < ntohs(hdr->length)) {",
        "// Line_Reference 303: \t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, ntohs(hdr->length));",
        "// Line_Reference 306: ",
        "// Line_Reference 307: \tif (hdr->ver == 2) {",
        "// Line_Reference 308: \t\tif (hdr->L == 0) {",
        "// Line_Reference 309: \t\t\tif (conf_verbose)",
        "// Line_Reference 310: \t\t\t\tlog_warn(\"l2tp: incorrect message received (L=0)\\n\");",
        "// Line_Reference 311: \t\t\tif (!conf_avp_permissive)",
        "// Line_Reference 312: \t\t\t    goto out_err_hdr;",
        "// Line_Reference 313: \t\t}",
        "// Line_Reference 314: ",
        "// Line_Reference 315: \t\tif (hdr->S == 0) {",
        "// Line_Reference 317: \t\t\t\tlog_warn(\"l2tp: incorrect message received (S=0)\\n\");",
        "// Line_Reference 318: \t\t\tif (!conf_avp_permissive)",
        "// Line_Reference 319: \t\t\t    goto out_err_hdr;",
        "// Line_Reference 322: \t\tif (hdr->O == 1) {",
        "// Line_Reference 323: \t\t\tif (conf_verbose)",
        "// Line_Reference 324: \t\t\t\tlog_warn(\"l2tp: incorrect message received (O=1)\\n\");",
        "// Line_Reference 325: \t\t\tif (!conf_avp_permissive)",
        "// Line_Reference 326: \t\t\t    goto out_err_hdr;",
        "// Line_Reference 327: \t\t}",
        "// Line_Reference 328: \t} else if (hdr->ver != 3) {",
        "// Line_Reference 330: \t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\", hdr->ver);",
        "// Line_Reference 345: \tlength = ntohs(hdr->length) - sizeof(*hdr);",
        "// Line_Reference 347: \twhile (length) {",
        "// Line_Reference 348: \t\t*(uint16_t *)ptr = ntohs(*(uint16_t *)ptr);",
        "// Line_Reference 349: \t\tavp = (struct l2tp_avp_t *)ptr;",
        "// Line_Reference 351: \t\tif (avp->length > length) {",
        "// Line_Reference 362: \t\t\tif (conf_verbose)",
        "// Line_Reference 363: \t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\", ntohs(avp->type), avp->M);",
        "// Line_Reference 364: \t\t\tif (avp->M && !conf_avp_permissive)",
        "// Line_Reference 367: \t\t\tif (da->M != -1 && da->M != avp->M) {",
        "// Line_Reference 368: \t\t\t\tif (conf_verbose)",
        "// Line_Reference 369: \t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\", ntohs(avp->type), avp->M, da->M);",
        "// Line_Reference 374: \t\t\tif (da->H != -1 && da->H != avp->H) {",
        "// Line_Reference 375: \t\t\t\tif (conf_verbose)",
        "// Line_Reference 376: \t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\", ntohs(avp->type), avp->H, da->H);",
        "// Line_Reference 381: \t\t\tif (avp->H) {",
        "// Line_Reference 396: \t\t\t}",
        "// Line_Reference 398: \t\t\tattr = mempool_alloc(attr_pool);",
        "// Line_Reference 399: \t\t\tmemset(attr, 0, sizeof(*attr));",
        "// Line_Reference 400: \t\t\tlist_add_tail(&attr->entry, &pack->attrs);",
        "// Line_Reference 401: ",
        "// Line_Reference 402: \t\t\tif (avp->H) {",
        "// Line_Reference 406: \t\t\t\torig_avp_len = avp->length;",
        "// Line_Reference 411: \t\t\tattr->M = avp->M;",
        "// Line_Reference 450: \t\tptr += avp->length;",
        "// Line_Reference 451: \t\tlength -= avp->length;",
        "// Line_Reference 476: \tuint8_t *buf = mempool_alloc(buf_pool);",
        "// Line_Reference 479: \tuint8_t *ptr;",
        "// Line_Reference 480: \tint n;",
        "// Line_Reference 481: \tint len = sizeof(pack->hdr);",
        "// Line_Reference 489: ",
        "// Line_Reference 490: \tptr = buf + sizeof(pack->hdr);",
        "// Line_Reference 500: \t\tavp->M = attr->M;",
        "// Line_Reference 501: \t\tavp->H = attr->H;",
        "// Line_Reference 502: \t\tavp->length = sizeof(*avp) + attr->length;",
        "// Line_Reference 503: \t\t*(uint16_t *)ptr = htons(*(uint16_t *)ptr);",
        "// Line_Reference 529: \tn = sendto(sock, buf, ntohs(pack->hdr.length), 0,",
        "// Line_Reference 530: \t\t   &pack->addr, sizeof(pack->addr));",
        "// Line_Reference 544: \tif (n != ntohs(pack->hdr.length)) {",
        "// Line_Reference 546: \t\t\tlog_warn(\"l2tp: short write (%i/%i)\\n\", n, ntohs(pack->hdr.length));"
    ]
}
