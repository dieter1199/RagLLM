{
    "cve_id": "CVE-2022-36085",
    "cve_description": "Open Policy Agent (OPA) is an open source, general-purpose policy engine. The Rego compiler provides a (deprecated) `WithUnsafeBuiltins` function, which allows users to provide a set of built-in functions that should be deemed unsafe — and as such rejected — by the compiler if encountered in the policy compilation stage. A bypass of this protection has been found, where the use of the `with` keyword to mock such a built-in function (a feature introduced in OPA v0.40.0), isn’t taken into account by `WithUnsafeBuiltins`. Multiple conditions need to be met in order to create an adverse effect. Version 0.43.1 contains a patch for this issue. As a workaround, avoid using the `WithUnsafeBuiltins` function and use the `capabilities` feature instead.",
    "cve_publish_date": "2022-09-08",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "ast/compile: respect unsafeBuiltinMap for 'with' replacements (#5107)\n\nThe changes are necessary for both the Compiler and the QueryCompiler. Tests\r\nhave been added to ensure that the code path through the rego package has also\r\nbeen fixed.\r\n\r\nFixes CVE-2022-36085.\r\n\r\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "compile.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "33",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 2199: \t\t\tbody, err := rewriteWithModifiersInBody(c, f, body)",
        "// Line_Reference 2478: \tvar unsafe map[string]struct{}",
        "// Line_Reference 2479: \tif qc.unsafeBuiltins != nil {",
        "// Line_Reference 2480: \t\tunsafe = qc.unsafeBuiltins",
        "// Line_Reference 2481: \t} else {",
        "// Line_Reference 2482: \t\tunsafe = qc.compiler.unsafeBuiltinsMap",
        "// Line_Reference 2483: \t}",
        "// Line_Reference 2484: \terrs := checkUnsafeBuiltins(unsafe, body)",
        "// Line_Reference 2501: \tbody, err := rewriteWithModifiersInBody(qc.compiler, f, body)",
        "// Line_Reference 4788: func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {",
        "// Line_Reference 4791: \t\texprs, err := rewriteWithModifier(c, f, body[i])",
        "// Line_Reference 4806: func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {",
        "// Line_Reference 4810: \t\teval, err := validateWith(c, expr, i)",
        "// Line_Reference 4825: func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {",
        "// Line_Reference 4857: \t\t\t\t\t\tif validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
        "// Line_Reference 4858: \t\t\t\t\t\t\treturn false, nil",
        "// Line_Reference 4865: \tcase isBuiltinRefOrVar(c.builtins, target):",
        "// Line_Reference 4879: \t\tif validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
        "// Line_Reference 4880: \t\t\treturn false, nil",
        "// Line_Reference 4909: func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {",
        "// Line_Reference 4912: \t\t\treturn true",
        "// Line_Reference 4915: \treturn isBuiltinRefOrVar(bs, value)",
        "// Line_Reference 4936: func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {",
        "// Line_Reference 4940: \t\treturn ok",
        "// Line_Reference 4942: \treturn false"
    ]
}
