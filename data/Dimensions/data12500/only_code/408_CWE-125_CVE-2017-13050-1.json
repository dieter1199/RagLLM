static int
rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)
ND_TCHECK2(*tptr, pdu_len);
ND_TCHECK2(*tptr, encapsulated_pdu_length);
tlen = pdu_len;
tptr += sizeof(*pdu);
tlen -= sizeof(*pdu);
/*
* Recurse if there is an encapsulated PDU.
*/
if (encapsulated_pdu_length &&
(encapsulated_pdu_length <= tlen)) {
ND_PRINT((ndo, "%s-----encapsulated PDU-----", indent_string(indent+4)));
if (rpki_rtr_pdu_print(ndo, tptr, indent+2))
goto trunc;
tptr += encapsulated_pdu_length;
tlen -= encapsulated_pdu_length;
text_length = 0;
if (tlen > 4) {
text_length = EXTRACT_32BITS(tptr);
tptr += 4;
tlen -= 4;
}
ND_TCHECK2(*tptr, text_length);
if (text_length && (text_length <= tlen )) {
if (fn_printn(ndo, tptr, text_length, ndo->ndo_snapend))
return 0;
return 1;
u_int tlen, pdu_type, pdu_len;
const u_char *tptr;
const rpki_rtr_pdu *pdu_header;
tptr = pptr;
tlen = len;
while (tlen >= sizeof(rpki_rtr_pdu)) {
ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));
pdu_header = (const rpki_rtr_pdu *)tptr;
pdu_type = pdu_header->pdu_type;
pdu_len = EXTRACT_32BITS(pdu_header->length);
ND_TCHECK2(*tptr, pdu_len);
/* infinite loop check */
if (!pdu_type || !pdu_len) {
break;
}
if (tlen < pdu_len) {
goto trunc;
}
/*
* Print the PDU.
*/
if (rpki_rtr_pdu_print(ndo, tptr, 8))
goto trunc;
tlen -= pdu_len;
tptr += pdu_len;
return;
trunc:
ND_PRINT((ndo, "\n\t%s", tstr));
