use Dompdf\Dompdf;
/**
* Current dompdf instance
*
* @var Dompdf
*/
protected static $_dompdf;
* @param Dompdf $dompdf    The Dompdf instance
* @throws ImageException
* @return array             An array with two elements: The local path to the image and the image extension
static function resolve_url($url, $protocol, $host, $base_path, Dompdf $dompdf)
self::$_dompdf = $dompdf;
$protocol = mb_strtolower($protocol);
$parsed_url = Helpers::explode_url($url);
$remote = ($protocol && $protocol !== "file://") || ($parsed_url['protocol'] !== "");
$data_uri = strpos($parsed_url['protocol'], "data:") === 0;
$full_url = null;
$enable_remote = $dompdf->getOptions()->getIsRemoteEnabled();
$tempfile = false;
// Remote not allowed and is not DataURI
if (!$enable_remote && $remote && !$data_uri) {
throw new ImageException("Remote file access is disabled.", E_WARNING);
// remote allowed or DataURI
if (($enable_remote && $remote) || $data_uri) {
// Download remote files to a temporary directory
$full_url = Helpers::build_url($protocol, $host, $base_path, $url);
// From cache
if (isset(self::$_cache[$full_url])) {
$resolved_url = self::$_cache[$full_url];
} // From remote
else {
$tmp_dir = $dompdf->getOptions()->getTempDir();
if (($resolved_url = @tempnam($tmp_dir, "ca_dompdf_img_")) === false) {
throw new ImageException("Unable to create temporary image in " . $tmp_dir, E_WARNING);
$tempfile = $resolved_url;
$image = null;
if ($data_uri) {
if ($parsed_data_uri = Helpers::parse_data_uri($url)) {
$image = $parsed_data_uri['data'];
}
} else {
list($image, $http_response_header) = Helpers::getFileContent($full_url, $dompdf->getHttpContext());
}
// Image not found or invalid
if ($image === null) {
$msg = ($data_uri ? "Data-URI could not be parsed" : "Image not found");
throw new ImageException($msg, E_WARNING);
} // Image found, put in cache and process
else {
//e.g. fetch.php?media=url.jpg&cache=1
//- Image file name might be one of the dynamic parts of the url, don't strip off!
//- a remote url does not need to have a file extension at all
//- local cached file does not have a matching file extension
//Therefore get image type from the content
if (@file_put_contents($resolved_url, $image) === false) {
throw new ImageException("Unable to create temporary image in " . $tmp_dir, E_WARNING);
}
} // Not remote, local image
else {
$resolved_url = Helpers::build_url($protocol, $host, $base_path, $url);
if ($protocol === "" || $protocol === "file://") {
$realfile = realpath($resolved_url);
$rootDir = realpath($dompdf->getOptions()->getRootDir());
if (strpos($realfile, $rootDir) !== 0) {
$chroot = $dompdf->getOptions()->getChroot();
$chrootValid = false;
foreach ($chroot as $chrootPath) {
$chrootPath = realpath($chrootPath);
if ($chrootPath !== false && strpos($realfile, $chrootPath) === 0) {
$chrootValid = true;
break;
}
}
if ($chrootValid !== true) {
throw new ImageException("Permission denied on $resolved_url. The file could not be found under the paths specified by Options::chroot.", E_WARNING);
}
}
if (!$realfile) {
throw new ImageException("File '$realfile' not found.", E_WARNING);
}
$resolved_url = $realfile;
} // Check is the file is an image
else {
list($width, $height, $type) = Helpers::dompdf_getimagesize($resolved_url, $dompdf->getHttpContext());
// Known image type
if ($width && $height && in_array($type, ["gif", "png", "jpeg", "bmp", "svg","webp"], true)) {
//Don't put replacement image into cache - otherwise it will be deleted on cache cleanup.
//Only execute on successful caching of remote image.
if ($enable_remote && $remote || $data_uri) {
self::$_cache[$full_url] = $resolved_url;
}
} // Unknown image type
else {
throw new ImageException("Image type unknown", E_WARNING);
}
$type = "png";
unlink($file);
