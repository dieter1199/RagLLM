assert re.match(
br".+ HTTP/\d\.\d\r\n$", start_line
), "Start line does not look like HTTP request: " + repr(start_line)
self,
host,
port=None,
key_file=None,
cert_file=None,
strict=None,
timeout=None,
proxy_info=None,
self,
host,
port=None,
key_file=None,
cert_file=None,
strict=None,
timeout=None,
proxy_info=None,
gresult[0] = Exception(
"Request count expected={0} actual={1}".format(
request_count, gcounter[0]
)
)
if (
not undefined_body_length
and proto != "HTTP/1.0"
and "content-length" not in headers
):
raise Exception(
"httplib2.tests.http_response_bytes: client could not figure response body length"
)
"{proto} {status}\r\n{headers}\r\n".format(
proto=proto, status=status, headers=header_string
).encode()
+ body
def http_parse_auth(s):
"""https://tools.ietf.org/html/rfc7235#section-2.1
"""
scheme, rest = s.split(" ", 1)
result = {}
while True:
m = httplib2.WWW_AUTH_RELAXED.search(rest)
if not m:
break
if len(m.groups()) == 3:
key, value, rest = m.groups()
result[key.lower()] = httplib2.UNQUOTE_PAIRS.sub(r"\1", value)
return result
if " " not in auth_header:
scheme, data = auth_header.split(" ", 1)
scheme = scheme.lower()
decoded = base64.b64decode(data).decode()
auth_info = http_parse_auth(data)
body="auth-info opaque mismatch expected={} actual={}".format(
server_opaque, client_opaque
).encode()
ha1 = hasher(
":".join((allow_username, realm, allow_password)).encode()
).hexdigest()
":".join(
(ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)
).encode()
":".join(
(
ha1,
client_nonce,
client_nc,
client_cnonce,
client_qop,
rspauth_ha2,
)
).encode()
"authentication-info": " ".join(
)
auth_info = http_parse_auth(x_wsse)
client_username = auth_info.get("username", "")
client_nonce = auth_info.get("nonce", "")
client_created = auth_info.get("created", "")
client_digest = auth_info.get("passworddigest", "")
print("$$$ check client={} == real={}".format(client_digest, digest_b64))
