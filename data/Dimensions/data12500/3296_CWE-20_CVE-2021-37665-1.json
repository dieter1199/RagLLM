{
    "cve_id": "CVE-2021-37665",
    "cve_description": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",
    "cve_publish_date": "2021-08-12",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "Reorganize and add more validation to MKL requantization\n\nPiperOrigin-RevId: 387901341\nChange-Id: I2515b9034c64e113db0bcec8337d30643ab0a0f1",
    "type_of_change": "Modification",
    "filename_of_changes": "mkl_requantize_per_channel_op.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "25",
    "number_of_lines_deleted_vulnerable_to_cve": "15",
    "vulnerable_lines": [
        "// Line_Reference 66:       size_t depth = input_min_vec.NumElements();",
        "// Line_Reference 67:       OP_REQUIRES(",
        "// Line_Reference 68:           ctx, input.dims() == 4,",
        "// Line_Reference 69:           errors::InvalidArgument(\"Current RequantizePerChannel operator\"",
        "// Line_Reference 70:                                   \"supports 4D tensors only.\"));",
        "// Line_Reference 71:       OP_REQUIRES(",
        "// Line_Reference 72:           ctx, input_min_vec.dim_size(0) == depth,",
        "// Line_Reference 73:           errors::InvalidArgument(\"input_min has incorrect size, expected \",",
        "// Line_Reference 74:                                   depth, \" was \", input_min_vec.dim_size(0)));",
        "// Line_Reference 75:       OP_REQUIRES(",
        "// Line_Reference 76:           ctx, input_max_vec.dim_size(0) == depth,",
        "// Line_Reference 77:           errors::InvalidArgument(\"input_max has incorrect size, expected \",",
        "// Line_Reference 78:                                   depth, \" was \", input_max_vec.dim_size(0)));",
        "// Line_Reference 79: ",
        "// Line_Reference 80:       if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);"
    ]
}
