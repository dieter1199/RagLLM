{
    "cve_id": "CVE-2019-11487",
    "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
    "cve_publish_date": "2019-04-23",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "mm: make page ref count overflow check tighter and more explicit\n\nWe have a VM_BUG_ON() to check that the page reference count doesn't\nunderflow (or get close to overflow) by checking the sign of the count.\n\nThat's all fine, but we actually want to allow people to use a \"get page\nref unless it's already very high\" helper function, and we want that one\nto use the sign of the page ref (without triggering this VM_BUG_ON).\n\nChange the VM_BUG_ON to only check for small underflows (or _very_ close\nto overflowing), and ignore overflows which have strayed into negative\nterritory.\n\nAcked-by: Matthew Wilcox <willy@infradead.org>\nCc: Jann Horn <jannh@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "mm.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "5",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 975: \tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);"
    ]
}
