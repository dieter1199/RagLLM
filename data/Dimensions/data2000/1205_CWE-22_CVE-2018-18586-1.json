{
    "cve_id": "CVE-2018-18586",
    "cve_description": "chmextract.c in the chmextract sample program, as distributed with libmspack before 0.8alpha, does not protect against absolute/relative pathnames in CHM files, leading to Directory Traversal. NOTE: the vendor disputes that this is a libmspack vulnerability, because chmextract.c was only intended as a source-code example, not a supported application",
    "cve_publish_date": "2018-10-23",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "add anti \"../\" and leading slash protection to chmextract",
    "type_of_change": "Modification",
    "filename_of_changes": "chmextract.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "17",
    "number_of_lines_deleted_vulnerable_to_cve": "123",
    "vulnerable_lines": [
        "// Line_Reference 28: #define FILENAME \".test.chmx\"",
        "// Line_Reference 29: ",
        "// Line_Reference 54: /**",
        "// Line_Reference 55:  * Creates a UNIX filename from the internal CAB filename and the given",
        "// Line_Reference 56:  * parameters.",
        "// Line_Reference 57:  *",
        "// Line_Reference 58:  * @param fname  the internal CAB filename.",
        "// Line_Reference 59:  * @param dir    a directory path to prepend to the output filename.",
        "// Line_Reference 60:  * @param lower  if non-zero, filename should be made lower-case.",
        "// Line_Reference 61:  * @param isunix if zero, MS-DOS path seperators are used in the internal",
        "// Line_Reference 62:  *               CAB filename. If non-zero, UNIX path seperators are used.",
        "// Line_Reference 63:  * @param utf8   if non-zero, the internal CAB filename is encoded in UTF8.",
        "// Line_Reference 64:  * @return a freshly allocated and created filename, or NULL if there was",
        "// Line_Reference 65:  *         not enough memory.",
        "// Line_Reference 66:  * @see unix_path_seperators()",
        "// Line_Reference 67:  */",
        "// Line_Reference 68: static char *create_output_name(unsigned char *fname, unsigned char *dir,",
        "// Line_Reference 69: \t\t\t int lower, int isunix, int utf8)",
        "// Line_Reference 70: {",
        "// Line_Reference 71:   unsigned char *p, *name, c, *fe, sep, slash;",
        "// Line_Reference 72:   unsigned int x;",
        "// Line_Reference 73: ",
        "// Line_Reference 74:   sep   = (isunix) ? '/'  : '\\\\'; /* the path-seperator */",
        "// Line_Reference 75:   slash = (isunix) ? '\\\\' : '/';  /* the other slash */",
        "// Line_Reference 76: ",
        "// Line_Reference 77:   /* length of filename */",
        "// Line_Reference 78:   x = strlen((char *) fname);",
        "// Line_Reference 79:   /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */",
        "// Line_Reference 80:   if (utf8) x *= 3;",
        "// Line_Reference 81:   /* length of output directory */",
        "// Line_Reference 82:   if (dir) x += strlen((char *) dir);",
        "// Line_Reference 83: ",
        "// Line_Reference 84:   if (!(name = (unsigned char *) malloc(x + 2))) {",
        "// Line_Reference 85:     fprintf(stderr, \"out of memory!\\n\");",
        "// Line_Reference 86:     return NULL;",
        "// Line_Reference 87:   }",
        "// Line_Reference 88: ",
        "// Line_Reference 89:   /* start with blank name */",
        "// Line_Reference 90:   *name = '\\0';",
        "// Line_Reference 91: ",
        "// Line_Reference 92:   /* add output directory if needed */",
        "// Line_Reference 93:   if (dir) {",
        "// Line_Reference 94:     strcpy((char *) name, (char *) dir);",
        "// Line_Reference 95:     strcat((char *) name, \"/\");",
        "// Line_Reference 96:   }",
        "// Line_Reference 97: ",
        "// Line_Reference 98:   /* remove leading slashes */",
        "// Line_Reference 99:   while (*fname == sep) fname++;",
        "// Line_Reference 100: ",
        "// Line_Reference 101:   /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX",
        "// Line_Reference 102:    * slashes as we go. Also lowercases characters if needed.",
        "// Line_Reference 103:    */",
        "// Line_Reference 104:   p = &name[strlen((char *)name)];",
        "// Line_Reference 105:   fe = &fname[strlen((char *)fname)];",
        "// Line_Reference 106: ",
        "// Line_Reference 107:   if (utf8) {",
        "// Line_Reference 108:     /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.",
        "// Line_Reference 109:      * %000000000xxxxxxx -> %0xxxxxxx",
        "// Line_Reference 110:      * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy",
        "// Line_Reference 111:      * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz",
        "// Line_Reference 112:      *",
        "// Line_Reference 113:      * Therefore, the inverse is as follows:",
        "// Line_Reference 114:      * First char:",
        "// Line_Reference 115:      *  0x00 - 0x7F = one byte char",
        "// Line_Reference 116:      *  0x80 - 0xBF = invalid",
        "// Line_Reference 117:      *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)",
        "// Line_Reference 118:      *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)",
        "// Line_Reference 119:      *  0xF0 - 0xFF = invalid",
        "// Line_Reference 120:      */",
        "// Line_Reference 121:     do {",
        "// Line_Reference 122:       if (fname >= fe) {",
        "// Line_Reference 123: \tfree(name);",
        "// Line_Reference 124: \treturn NULL;",
        "// Line_Reference 125:       }",
        "// Line_Reference 126: ",
        "// Line_Reference 127:       /* get next UTF8 char */",
        "// Line_Reference 128:       if ((c = *fname++) < 0x80) x = c;",
        "// Line_Reference 129:       else {",
        "// Line_Reference 130: \tif ((c >= 0xC0) && (c < 0xE0)) {",
        "// Line_Reference 131: \t  x = (c & 0x1F) << 6;",
        "// Line_Reference 132: \t  x |= *fname++ & 0x3F;",
        "// Line_Reference 133: \t}",
        "// Line_Reference 134: \telse if ((c >= 0xE0) && (c < 0xF0)) {",
        "// Line_Reference 135: \t  x = (c & 0xF) << 12;",
        "// Line_Reference 136: \t  x |= (*fname++ & 0x3F) << 6;",
        "// Line_Reference 137: \t  x |= *fname++ & 0x3F;",
        "// Line_Reference 138: \t}",
        "// Line_Reference 139: \telse x = '?';",
        "// Line_Reference 140:       }",
        "// Line_Reference 141: ",
        "// Line_Reference 142:       /* whatever is the path seperator -> '/'",
        "// Line_Reference 143:        * whatever is the other slash    -> '\\\\'",
        "// Line_Reference 144:        * otherwise, if lower is set, the lowercase version */",
        "// Line_Reference 145:       if      (x == sep)   x = '/';",
        "// Line_Reference 146:       else if (x == slash) x = '\\\\';",
        "// Line_Reference 147:       else if (lower)      x = (unsigned int) tolower((int) x);",
        "// Line_Reference 148: ",
        "// Line_Reference 149:       /* integer back to UTF8 */",
        "// Line_Reference 150:       if (x < 0x80) {",
        "// Line_Reference 151: \t*p++ = (unsigned char) x;",
        "// Line_Reference 152:       }",
        "// Line_Reference 153:       else if (x < 0x800) {",
        "// Line_Reference 154: \t*p++ = 0xC0 | (x >> 6);",
        "// Line_Reference 155: \t*p++ = 0x80 | (x & 0x3F);",
        "// Line_Reference 156:       }",
        "// Line_Reference 157:       else {",
        "// Line_Reference 158: \t*p++ = 0xE0 | (x >> 12);",
        "// Line_Reference 159: \t*p++ = 0x80 | ((x >> 6) & 0x3F);",
        "// Line_Reference 160: \t*p++ = 0x80 | (x & 0x3F);",
        "// Line_Reference 161:       }",
        "// Line_Reference 162:     } while (x);",
        "// Line_Reference 163:   }",
        "// Line_Reference 164:   else {",
        "// Line_Reference 165:     /* regular non-utf8 version */",
        "// Line_Reference 166:     do {",
        "// Line_Reference 167:       c = *fname++;",
        "// Line_Reference 168:       if      (c == sep)   c = '/';",
        "// Line_Reference 169:       else if (c == slash) c = '\\\\';",
        "// Line_Reference 170:       else if (lower)      c = (unsigned char) tolower((int) c);",
        "// Line_Reference 171:     } while ((*p++ = c));",
        "// Line_Reference 172:   }",
        "// Line_Reference 173:   return (char *) name;",
        "// Line_Reference 208: \t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);"
    ]
}
