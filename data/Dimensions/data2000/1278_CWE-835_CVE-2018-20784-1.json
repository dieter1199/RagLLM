{
    "cve_id": "CVE-2018-20784",
    "cve_description": "In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",
    "cve_publish_date": "2019-02-22",
    "cwe_id": "CWE-835",
    "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
    "cwe_description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
    "commit_message": "sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c\n\nZhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the\nscheduler under high loads, starting at around the v4.18 time frame,\nand Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list\nmanipulation.\n\nDo a (manual) revert of:\n\n  a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\n\nIt turns out that the list_del_leaf_cfs_rq() introduced by this commit\nis a surprising property that was not considered in followup commits\nsuch as:\n\n  9c2791f936ef (\"sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list\")\n\nAs Vincent Guittot explains:\n\n \"I think that there is a bigger problem with commit a9e7f6544b9c and\n  cfs_rq throttling:\n\n  Let take the example of the following topology TG2 --> TG1 --> root:\n\n   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1\n      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in\n      one path because it has never been used and can't be throttled so\n      tmp_alone_branch will point to leaf_cfs_rq_list at the end.\n\n   2) Then TG1 is throttled\n\n   3) and we add TG3 as a new child of TG1.\n\n   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1\n      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.\n\n  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.\n  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1\n  cfs_rq is removed from the list.\n  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list\n  but tmp_alone_branch still points to TG3 cfs_rq because its throttled\n  parent can't be enqueued when the lock is released.\n  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.\n\n  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch\n  points on another TG cfs_rq, the next TG cfs_rq that will be added,\n  will be linked outside rq->leaf_cfs_rq_list - which is bad.\n\n  In addition, we can break the ordering of the cfs_rq in\n  rq->leaf_cfs_rq_list but this ordering is used to update and\n  propagate the update from leaf down to root.\"\n\nInstead of trying to work through all these cases and trying to reproduce\nthe very high loads that produced the lockup to begin with, simplify\nthe code temporarily by reverting a9e7f6544b9c - which change was clearly\nnot thought through completely.\n\nThis (hopefully) gives us a kernel that doesn't lock up so people\ncan continue to enjoy their holidays without worrying about regressions. ;-)\n\n[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]\n\nAnalyzed-by: Xie XiuQi <xiexiuqi@huawei.com>\nAnalyzed-by: Vincent Guittot <vincent.guittot@linaro.org>\nReported-by: Zhipeng Xie <xiezhipeng1@huawei.com>\nReported-by: Sargun Dhillon <sargun@sargun.me>\nReported-by: Xie XiuQi <xiexiuqi@huawei.com>\nTested-by: Zhipeng Xie <xiezhipeng1@huawei.com>\nTested-by: Sargun Dhillon <sargun@sargun.me>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Vincent Guittot <vincent.guittot@linaro.org>\nCc: <stable@vger.kernel.org> # v4.13+\nCc: Bin Li <huawei.libin@huawei.com>\nCc: Mike Galbraith <efault@gmx.de>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Tejun Heo <tj@kernel.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nFixes: a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")\nLink: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "fair.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "9",
    "number_of_lines_deleted_vulnerable_to_cve": "34",
    "vulnerable_lines": [
        "// Line_Reference 355: /* Iterate thr' all leaf cfs_rq's on a runqueue */",
        "// Line_Reference 356: #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\t\t\\",
        "// Line_Reference 357: \tlist_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,\t\\",
        "// Line_Reference 358: \t\t\t\t leaf_cfs_rq_list)",
        "// Line_Reference 450: #define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\\",
        "// Line_Reference 451: \t\tfor (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)",
        "// Line_Reference 7650: static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)",
        "// Line_Reference 7651: {",
        "// Line_Reference 7652: \tif (cfs_rq->load.weight)",
        "// Line_Reference 7653: \t\treturn false;",
        "// Line_Reference 7654: ",
        "// Line_Reference 7655: \tif (cfs_rq->avg.load_sum)",
        "// Line_Reference 7656: \t\treturn false;",
        "// Line_Reference 7657: ",
        "// Line_Reference 7658: \tif (cfs_rq->avg.util_sum)",
        "// Line_Reference 7659: \t\treturn false;",
        "// Line_Reference 7660: ",
        "// Line_Reference 7661: \tif (cfs_rq->avg.runnable_load_sum)",
        "// Line_Reference 7662: \t\treturn false;",
        "// Line_Reference 7663: ",
        "// Line_Reference 7664: \treturn true;",
        "// Line_Reference 7665: }",
        "// Line_Reference 7666: ",
        "// Line_Reference 7670: \tstruct cfs_rq *cfs_rq, *pos;",
        "// Line_Reference 7682: \tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {",
        "// Line_Reference 7697: \t\t/*",
        "// Line_Reference 7698: \t\t * There can be a lot of idle CPU cgroups.  Don't let fully",
        "// Line_Reference 7699: \t\t * decayed cfs_rqs linger on the list.",
        "// Line_Reference 7700: \t\t */",
        "// Line_Reference 7701: \t\tif (cfs_rq_is_decayed(cfs_rq))",
        "// Line_Reference 7702: \t\t\tlist_del_leaf_cfs_rq(cfs_rq);",
        "// Line_Reference 7703: ",
        "// Line_Reference 10573: \tstruct cfs_rq *cfs_rq, *pos;",
        "// Line_Reference 10576: \tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)"
    ]
}
