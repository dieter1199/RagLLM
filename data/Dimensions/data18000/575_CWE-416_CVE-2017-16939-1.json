{
    "cve_id": "CVE-2017-16939",
    "cve_description": "The XFRM dump policy implementation in net/xfrm/xfrm_user.c in the Linux kernel before 4.13.11 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted SO_RCVBUF setsockopt system call in conjunction with XFRM_MSG_GETPOLICY Netlink messages.",
    "cve_publish_date": "2017-11-24",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "ipsec: Fix aborted xfrm policy dump crash\n\nAn independent security researcher, Mohamed Ghannam, has reported\nthis vulnerability to Beyond Security's SecuriTeam Secure Disclosure\nprogram.\n\nThe xfrm_dump_policy_done function expects xfrm_dump_policy to\nhave been called at least once or it will crash.  This can be\ntriggered if a dump fails because the target socket's receive\nbuffer is full.\n\nThis patch fixes it by using the cb->start mechanism to ensure that\nthe initialisation is always done regardless of the buffer situation.\n\nFixes: 12a169e7d8f4 (\"ipsec: Put dumpers on the dump list\")\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "xfrm_user.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "15",
    "number_of_lines_deleted_vulnerable_to_cve": "10",
    "vulnerable_lines": [
        "// Line_Reference 1696: \tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];",
        "// Line_Reference 1706: \tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];",
        "// Line_Reference 1709: \tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >",
        "// Line_Reference 1710: \t\t     sizeof(cb->args) - sizeof(cb->args[0]));",
        "// Line_Reference 1711: ",
        "// Line_Reference 1717: \tif (!cb->args[0]) {",
        "// Line_Reference 1718: \t\tcb->args[0] = 1;",
        "// Line_Reference 1719: \t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);",
        "// Line_Reference 1720: \t}",
        "// Line_Reference 1721: "
    ]
}
