{
    "cve_id": "CVE-2022-47940",
    "cve_description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.18 before 5.18.18. fs/ksmbd/smb2pdu.c lacks length validation in the non-padding case in smb2_write.",
    "cve_publish_date": "2022-12-23",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "ksmbd: validate length in smb2_write()\n\nThe SMB2 Write packet contains data that is to be written\nto a file or to a pipe. Depending on the client, there may\nbe padding between the header and the data field.\nCurrently, the length is validated only in the case padding\nis present.\n\nSince the DataOffset field always points to the beginning\nof the data, there is no need to have a special case for\npadding. By removing this, the length is validated in both\ncases.\n\nSigned-off-by: Marios Makassikis <mmakassikis@freebox.fr>\nAcked-by: Namjae Jeon <linkinjeon@kernel.org>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "smb2pdu.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "19",
    "number_of_lines_deleted_vulnerable_to_cve": "30",
    "vulnerable_lines": [
        "// Line_Reference 6331: \tif (le16_to_cpu(req->DataOffset) ==",
        "// Line_Reference 6332: \t    offsetof(struct smb2_write_req, Buffer)) {",
        "// Line_Reference 6333: \t\tdata_buf = (char *)&req->Buffer[0];",
        "// Line_Reference 6334: \t} else {",
        "// Line_Reference 6335: \t\tif ((u64)le16_to_cpu(req->DataOffset) + length >",
        "// Line_Reference 6336: \t\t    get_rfc1002_len(work->request_buf)) {",
        "// Line_Reference 6337: \t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",",
        "// Line_Reference 6338: \t\t\t       le16_to_cpu(req->DataOffset),",
        "// Line_Reference 6339: \t\t\t       get_rfc1002_len(work->request_buf));",
        "// Line_Reference 6340: \t\t\terr = -EINVAL;",
        "// Line_Reference 6341: \t\t\tgoto out;",
        "// Line_Reference 6342: \t\t}",
        "// Line_Reference 6343: ",
        "// Line_Reference 6344: \t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +",
        "// Line_Reference 6345: \t\t\t\tle16_to_cpu(req->DataOffset));",
        "// Line_Reference 6492: \t\tif (le16_to_cpu(req->DataOffset) ==",
        "// Line_Reference 6493: \t\t    offsetof(struct smb2_write_req, Buffer)) {",
        "// Line_Reference 6494: \t\t\tdata_buf = (char *)&req->Buffer[0];",
        "// Line_Reference 6495: \t\t} else {",
        "// Line_Reference 6496: \t\t\tif ((u64)le16_to_cpu(req->DataOffset) + length >",
        "// Line_Reference 6497: \t\t\t    get_rfc1002_len(work->request_buf)) {",
        "// Line_Reference 6498: \t\t\t\tpr_err(\"invalid write data offset %u, smb_len %u\\n\",",
        "// Line_Reference 6499: \t\t\t\t       le16_to_cpu(req->DataOffset),",
        "// Line_Reference 6500: \t\t\t\t       get_rfc1002_len(work->request_buf));",
        "// Line_Reference 6501: \t\t\t\terr = -EINVAL;",
        "// Line_Reference 6502: \t\t\t\tgoto out;",
        "// Line_Reference 6503: \t\t\t}",
        "// Line_Reference 6504: ",
        "// Line_Reference 6505: \t\t\tdata_buf = (char *)(((char *)&req->hdr.ProtocolId) +",
        "// Line_Reference 6506: \t\t\t\t\tle16_to_cpu(req->DataOffset));"
    ]
}
