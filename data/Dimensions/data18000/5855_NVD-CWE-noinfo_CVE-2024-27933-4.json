{
    "cve_id": "CVE-2024-27933",
    "cve_description": "Deno is a JavaScript, TypeScript, and WebAssembly runtime. In version 1.39.0, use of raw file descriptors in `op_node_ipc_pipe()` leads to premature close of arbitrary file descriptors, allowing standard input to be re-opened as a different resource resulting in permission prompt bypass. Node child_process IPC relies on the JS side to pass the raw IPC file descriptor to `op_node_ipc_pipe()`, which returns a `IpcJsonStreamResource` ID associated with the file descriptor. On closing the resource, the raw file descriptor is closed together.\n\nUse of raw file descriptors in `op_node_ipc_pipe()` leads to premature close of arbitrary file descriptors. This allow standard input (fd 0) to be closed and re-opened for a different resource, which allows a silent permission prompt bypass. This is exploitable by an attacker controlling the code executed inside a Deno runtime to obtain arbitrary code execution on the host machine regardless of permissions.\n\nThis bug is known to be exploitable. There is a working exploit that achieves arbitrary code execution by bypassing prompts from zero permissions, additionally abusing the fact that Cache API lacks filesystem permission checks. The attack can be conducted silently as stderr can also be closed, suppressing all prompt outputs.\n\nVersion 1.39.1 fixes the bug.\n",
    "cve_publish_date": "2024-03-21",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "fix(node): child_process IPC on Windows (#21597)\n\nThis PR implements the child_process IPC pipe between parent and child.\r\nThe implementation uses Windows named pipes created by parent and passes\r\nthe inheritable file handle to the child.\r\n\r\nI've also replace parts of the initial implementation which passed the\r\nraw parent fd to JS with resource ids instead. This way no file handle\r\nis exposed to the JS land (both parent and child).\r\n\r\n`IpcJsonStreamResource` can stream upto 800MB/s of JSON data on Win 11\r\nAMD Ryzen 7 16GB (without `memchr` vectorization)",
    "type_of_change": "Modification",
    "filename_of_changes": "process.rs",
    "code_language": "Rust",
    "number_of_lines_added_for_mitigation": "134",
    "number_of_lines_deleted_vulnerable_to_cve": "13",
    "vulnerable_lines": [
        "// Line_Reference 144:   #[cfg(unix)]",
        "// Line_Reference 210: type CreateCommand = (",
        "// Line_Reference 211:   std::process::Command,",
        "// Line_Reference 212:   // TODO(@littledivy): Ideally this would return Option<ResourceId> but we are dealing with file descriptors",
        "// Line_Reference 213:   // all the way until setupChannel which makes it easier to share code between parent and child fork.",
        "// Line_Reference 214:   Option<i32>,",
        "// Line_Reference 215: );",
        "// Line_Reference 340:       let pipe_fd = Some(fd1);",
        "// Line_Reference 345:       return Ok((command, pipe_fd));",
        "// Line_Reference 363:   pipe_fd: Option<i32>,",
        "// Line_Reference 369:   pipe_fd: Option<i32>,",
        "// Line_Reference 462:   let (command, pipe_fd) = create_command(state, args, &api_name)?;",
        "// Line_Reference 463:   spawn_child(state, command, pipe_fd)"
    ]
}
