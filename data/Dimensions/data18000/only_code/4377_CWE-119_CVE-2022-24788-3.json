get_element_ptr,
def _returndata_encoding(contract_sig):
if contract_sig.is_from_json:
return Encoding.JSON_ABI
return Encoding.ABI
def _unpack_returndata(buf, contract_sig, skip_contract_check, context):
return_t = contract_sig.return_type
if return_t is None:
# if the abi signature has a different type than
# the vyper type, we need to wrap and unwrap the type
# so that the ABI decoding works correctly
should_unwrap_abi_tuple = return_t != contract_sig.return_type
# TODO move the -1 optimization to IR optimizer
ret += [["assert", ["gt", "returndatasize", min_return_size - 1]]]
# add as the last IRnode a pointer to the return data structure
# the return type has been wrapped by the calling contract;
# unwrap it so downstream code isn't confused.
# basically this expands to buf+32 if the return type has been wrapped
# in a tuple AND its ABI type is dynamic.
# in most cases, this simply will evaluate to ret.
# in the special case where the return type has been wrapped
# in a tuple AND its ABI type is dynamic, it expands to buf+32.
buf = IRnode(buf, typ=return_t, encoding=_returndata_encoding(contract_sig), location=MEMORY)
if should_unwrap_abi_tuple:
buf = get_element_ptr(buf, 0, array_bounds_check=False)
ret += [buf]
buf, contract_sig, skip_contract_check, context
ret = IRnode.from_list(
sub,
typ=contract_sig.return_type,
location=MEMORY,
# set the encoding to ABI here, downstream code will decode and add clampers.
encoding=_returndata_encoding(contract_sig),
)
return ret
