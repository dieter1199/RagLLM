const MountMax = 10000
// attachTreeLocked attaches the mount tree at mnt to vd and propagates the
// mount to vd.mount's peers and followers. This method consumes the reference
// on vd. It is analogous to fs/namespace.c:attach_recursive_mnt() in Linux.
func (vfs *VirtualFilesystem) attachTreeLocked(ctx context.Context, mnt *Mount, vd VirtualDentry) error {
mp, err := vfs.lockMountpoint(vd)
if err != nil {
return err
}
mp.DecRef(ctx)
var propMnts map[*Mount]struct{}
return vfs.attachTreeLocked(ctx, mnt, vd)
vfs.delayDecRef(targetVd)
if err := vfs.attachTreeLocked(ctx, clone, targetVd); err != nil {
if mntns := MountNamespaceFromContext(ctx); mntns != nil {
vfs.delayDecRef(mntns)
if mntns != mnt.ns {
return linuxerr.EINVAL
}
if mntns := MountNamespaceFromContext(ctx); mntns != nil {
vfs.delayDecRef(mntns)
if mntns != vd.mount.ns {
return linuxerr.EINVAL
}
if vd.mount == vd.mount.ns.root {
return linuxerr.EINVAL
}
return false
ns := MountNamespaceFromContext(ctx)
vfs.delayDecRef(ns)
if oldRoot.mount.ns != ns || newRoot.mount.ns != ns {
vfs.connectLocked(oldRoot.mount, putOld, ns)
vfs.connectLocked(newRoot.mount, rootMp, ns)
