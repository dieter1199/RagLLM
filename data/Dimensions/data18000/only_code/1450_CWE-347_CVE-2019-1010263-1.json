$kid_keys = eval { decode_json($kid_keys) } unless ref $kid_keys;
return undef unless ref $kid_keys eq 'HASH';
#REMOVED: $header->{typ} = 'JWT' if !exists $header->{typ} && $args{auto_typ};
my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};
if ($header->{kid} && $args{kid_keys}) {
$key = $k if defined $k;
croak "JWE: missing 'key'" if !$key;
#REMOVED: $header->{typ} = 'JWT' if !exists $header->{typ} && $args{auto_typ};
my $aa = $args{accepted_alg};
if (ref($aa) eq 'Regexp') {
croak "JWS: alg '$header->{alg}' does not match accepted_alg" if $header->{alg} !~ $aa;
}
elsif ($aa && (ref($aa) eq 'ARRAY' || !ref($aa))) {
my %acca = ref $aa ? map { $_ => 1 } @$aa : ( $aa => 1 );
croak "JWS: alg '$header->{alg}' not in accepted_alg" if !$acca{$header->{alg}};
}
# key
my $key = defined $args{keypass} ? [$args{key}, $args{keypass}] : $args{key};
my $kid = exists $header->{kid} ? $header->{kid} : $unprotected_header->{kid};
if (!defined $key && defined $kid && $args{kid_keys}) {
my $k = _kid_lookup($kid, $args{kid_keys}, $alg);
$key = $k if defined $k;
# if no key given, try to use 'jwk' value from header
$key = $header->{jwk} if !$key && $header->{jwk};
croak "JWS: missing 'key'" if !$key && $alg ne 'none';
my $valid = _verify_jws($b64u_header, $b64u_payload, $b64u_sig, $alg, $key);
croak "JWS: decode failed" if !$valid;
When the token header contains 'kid' item the corresponding key is looked up in C<kid_keys> list and used for token