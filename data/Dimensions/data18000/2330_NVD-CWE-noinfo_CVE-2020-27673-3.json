{
    "cve_id": "CVE-2020-27673",
    "cve_description": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. Guest OS users can cause a denial of service (host OS hang) via a high rate of events to dom0, aka CID-e99502f76271.",
    "cve_publish_date": "2020-10-22",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "xen/events: defer eoi in case of excessive number of events\n\nIn case rogue guests are sending events at high frequency it might\nhappen that xen_evtchn_do_upcall() won't stop processing events in\ndom0. As this is done in irq handling a crash might be the result.\n\nIn order to avoid that, delay further inter-domain events after some\ntime in xen_evtchn_do_upcall() by forcing eoi processing into a\nworker on the same cpu, thus inhibiting new events coming in.\n\nThe time after which eoi processing is to be delayed is configurable\nvia a new module parameter \"event_loop_timeout\" which specifies the\nmaximum event loop time in jiffies (default: 2, the value was chosen\nafter some tests showing that a value of 2 was the lowest with an\nonly slight drop of dom0 network throughput while multiple guests\nperformed an event storm).\n\nHow long eoi processing will be delayed can be specified via another\nparameter \"event_eoi_delay\" (again in jiffies, default 10, again the\nvalue was chosen after testing with different delay values).\n\nThis is part of XSA-332.\n\nCc: stable@vger.kernel.org\nReported-by: Julien Grall <julien@xen.org>\nSigned-off-by: Juergen Gross <jgross@suse.com>\nReviewed-by: Stefano Stabellini <sstabellini@kernel.org>\nReviewed-by: Wei Liu <wl@xen.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "events_fifo.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "19",
    "vulnerable_lines": [
        "// Line_Reference 278: static void handle_irq_for_port(evtchn_port_t port)",
        "// Line_Reference 279: {",
        "// Line_Reference 280: \tint irq;",
        "// Line_Reference 281: ",
        "// Line_Reference 282: \tirq = get_evtchn_to_irq(port);",
        "// Line_Reference 283: \tif (irq != -1)",
        "// Line_Reference 284: \t\tgeneric_handle_irq(irq);",
        "// Line_Reference 285: }",
        "// Line_Reference 286: ",
        "// Line_Reference 287: static void consume_one_event(unsigned cpu,",
        "// Line_Reference 289: \t\t\t      unsigned priority, unsigned long *ready,",
        "// Line_Reference 290: \t\t\t      bool drop)",
        "// Line_Reference 323: \t\tif (unlikely(drop))",
        "// Line_Reference 326: \t\t\thandle_irq_for_port(port);",
        "// Line_Reference 332: static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)",
        "// Line_Reference 344: \t\tconsume_one_event(cpu, control_block, q, &ready, drop);",
        "// Line_Reference 349: static void evtchn_fifo_handle_events(unsigned cpu)",
        "// Line_Reference 351: \t__evtchn_fifo_handle_events(cpu, false);",
        "// Line_Reference 419: \t__evtchn_fifo_handle_events(cpu, true);"
    ]
}
