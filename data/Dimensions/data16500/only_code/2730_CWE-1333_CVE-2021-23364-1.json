return Object.keys(e2c).slice(-versions).map(function (i) {
return 'chrome ' + e2c[i]
})
return data.versions.filter(function (v) {
return data.released.indexOf(v) === -1
}).map(nameMapper(data.name))
regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
select: function (context, year, month, date) {
year = parseInt(year)
month = parseInt(month || '01') - 1
date = parseInt(date || '01')
return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context)
}
regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
select: function (context, coverage, statMode) {
coverage = parseFloat(coverage)
var usage = browserslist.usage.global
if (statMode) {
if (statMode.match(/^\s+in\s+my\s+stats$/)) {
if (!context.customUsage) {
throw new BrowserslistError(
'Custom usage statistics was not provided'
)
}
usage = context.customUsage
} else {
var match = statMode.match(/\s+in\s+((alt-)?\w\w)/)
var place = match[1]
if (place.length === 2) {
place = place.toUpperCase()
} else {
place = place.toLowerCase()
}
env.loadCountry(browserslist.usage, place, browserslist.data)
usage = browserslist.usage[place]
}
}
var versions = Object.keys(usage).sort(function (a, b) {
return usage[b] - usage[a]
})
var coveraged = 0
var result = []
var version
for (var i = 0; i <= versions.length; i++) {
version = versions[i]
if (usage[version] === 0) break
coveraged += usage[version]
result.push(version)
if (coveraged >= coverage) break
}
return result
}
return Object.keys(e2c).filter(function (i) {
var parsed = parseFloat(i)
return parsed >= from && parsed <= to
}).map(function (i) {
return 'chrome ' + e2c[i]
})
var nodeVersions = jsReleases.filter(function (i) {
return i.name === 'nodejs'
}).map(function (i) {
return i.version
})
var semverRegExp = /^(0|[1-9]\d*)(\.(0|[1-9]\d*)){0,2}$/
if (!semverRegExp.test(from)) {
throw new BrowserslistError(
'Unknown version ' + from + ' of Node.js')
}
if (!semverRegExp.test(to)) {
throw new BrowserslistError(
'Unknown version ' + to + ' of Node.js')
}
var nodeVersions = jsReleases.filter(function (i) {
return i.name === 'nodejs'
}).map(function (i) {
return i.version
})
'Unknown version ' + version + ' of electron')
regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
select: function (context, version) {
var nodeReleases = jsReleases.filter(function (i) {
return i.name === 'nodejs'
})
var matched = nodeReleases.filter(function (i) {
return isVersionsMatch(i.version, version)
})
if (matched.length === 0) {
if (context.ignoreUnknownVersions) {
return []
} else {
throw new BrowserslistError(
'Unknown version ' + version + ' of Node.js')
}
}
return ['node ' + matched[matched.length - 1].version]
}
var queries = Object.keys(jsEOL).filter(function (key) {
return now < Date.parse(jsEOL[key].end) &&
now > Date.parse(jsEOL[key].start) &&
isEolReleased(key)
}).map(function (key) {
return 'node ' + key.slice(1)
})
'Unknown version ' + version + ' of ' + name)
'Specify versions in Browserslist query for browser ' + name)