var reader io.ReadCloser
if u.Scheme == "https" || u.Scheme == "http" {
req, err := http.NewRequest(http.MethodGet, u.String(), nil)
if err != nil {
return content, AdminError{
Code:       AdminUpdateUnexpectedFailure,
Message:    err.Error(),
StatusCode: http.StatusInternalServerError,
}
req.Header.Set("User-Agent", getUserAgent(mode))
client := &http.Client{Transport: getUpdateTransport(timeout)}
resp, err := client.Do(req)
if err != nil {
if xnet.IsNetworkOrHostDown(err, false) {
return content, AdminError{
Code:       AdminUpdateURLNotReachable,
Message:    err.Error(),
StatusCode: http.StatusServiceUnavailable,
}
}
Code:       AdminUpdateUnexpectedFailure,
StatusCode: http.StatusInternalServerError,
if resp == nil {
return content, AdminError{
Code:       AdminUpdateUnexpectedFailure,
Message:    fmt.Sprintf("No response from server to download URL %s", u),
StatusCode: http.StatusInternalServerError,
}
reader = resp.Body
defer xhttp.DrainBody(resp.Body)
if resp.StatusCode != http.StatusOK {
return content, AdminError{
Code:       AdminUpdateUnexpectedFailure,
Message:    fmt.Sprintf("Error downloading URL %s. Response: %v", u, resp.Status),
StatusCode: resp.StatusCode,
}
} else {
reader, err = os.Open(u.Path)
if err != nil {
return content, AdminError{
Code:       AdminUpdateURLNotReachable,
Message:    err.Error(),
StatusCode: http.StatusServiceUnavailable,
}
contentBytes, err := ioutil.ReadAll(reader)
