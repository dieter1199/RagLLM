{
    "cve_id": "CVE-2022-23308",
    "cve_description": "valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.",
    "cve_publish_date": "2022-02-26",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "[CVE-2022-23308] Use-after-free of ID and IDREF attributes\n\nIf a document is parsed with XML_PARSE_DTDVALID and without\nXML_PARSE_NOENT, the value of ID attributes has to be normalized after\npotentially expanding entities in xmlRemoveID. Otherwise, later calls\nto xmlGetID can return a pointer to previously freed memory.\n\nID attributes which are empty or contain only whitespace after\nentity expansion are affected in a similar way. This is fixed by\nnot storing such attributes in the ID table.\n\nThe test to detect streaming mode when validating against a DTD was\nbroken. In connection with the defects above, this could result in a\nuse-after-free when using the xmlReader interface with validation.\nFix detection of streaming mode to avoid similar issues. (This changes\nthe expected result of a test case. But as far as I can tell, using the\nXML reader with XIncludes referencing the root document never worked\nproperly, anyway.)\n\nAll of these issues can result in denial of service. Using xmlReader\nwith validation could result in disclosure of memory via the error\nchannel, typically stderr. The security impact of xmlGetID returning\na pointer to freed memory depends on the application. The typical use\ncase of calling xmlGetID on an unmodified document is not affected.",
    "type_of_change": "Modification",
    "filename_of_changes": "valid.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "55",
    "number_of_lines_deleted_vulnerable_to_cve": "33",
    "vulnerable_lines": [
        "// Line_Reference 2653:     if (value == NULL) {",
        "// Line_Reference 2684:     if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {",
        "// Line_Reference 3012:     if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {",
        "// Line_Reference 4031:     xmlChar *ret, *dst;",
        "// Line_Reference 4032:     const xmlChar *src;",
        "// Line_Reference 4073:     src = value;",
        "// Line_Reference 4074:     dst = ret;",
        "// Line_Reference 4075:     while (*src == 0x20) src++;",
        "// Line_Reference 4076:     while (*src != 0) {",
        "// Line_Reference 4077: \tif (*src == 0x20) {",
        "// Line_Reference 4078: \t    while (*src == 0x20) src++;",
        "// Line_Reference 4079: \t    if (*src != 0)",
        "// Line_Reference 4080: \t\t*dst++ = 0x20;",
        "// Line_Reference 4081: \t} else {",
        "// Line_Reference 4082: \t    *dst++ = *src++;",
        "// Line_Reference 4083: \t}",
        "// Line_Reference 4084:     }",
        "// Line_Reference 4085:     *dst = 0;",
        "// Line_Reference 4117:     xmlChar *ret, *dst;",
        "// Line_Reference 4118:     const xmlChar *src;",
        "// Line_Reference 4148:     src = value;",
        "// Line_Reference 4149:     dst = ret;",
        "// Line_Reference 4150:     while (*src == 0x20) src++;",
        "// Line_Reference 4151:     while (*src != 0) {",
        "// Line_Reference 4152: \tif (*src == 0x20) {",
        "// Line_Reference 4153: \t    while (*src == 0x20) src++;",
        "// Line_Reference 4154: \t    if (*src != 0)",
        "// Line_Reference 4155: \t\t*dst++ = 0x20;",
        "// Line_Reference 4156: \t} else {",
        "// Line_Reference 4157: \t    *dst++ = *src++;",
        "// Line_Reference 4158: \t}",
        "// Line_Reference 4159:     }",
        "// Line_Reference 4160:     *dst = 0;"
    ]
}
