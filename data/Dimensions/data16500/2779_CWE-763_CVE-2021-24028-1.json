{
    "cve_id": "CVE-2021-24028",
    "cve_description": "An invalid free in Thrift's table-based serialization can cause the application to crash or potentially result in code execution or other undesirable effects. This issue affects Facebook Thrift prior to v2021.02.22.00.",
    "cve_publish_date": "2021-04-14",
    "cwe_id": "CWE-763",
    "cwe_name": "Release of Invalid Pointer or Reference",
    "cwe_description": "The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.",
    "commit_message": "Fix handling of invalid union data in table-based serializer\n\nSummary:\nFix handling of invalid union data in the table-based serializer. Previously if the input contained duplicate union data, previous active member of the union was overwritten without calling the destructor of the old object, potentially causing a memory leak. In addition to that, if the second piece of data was incomplete the wrong destructor would be called during stack unwinding causing a segfault, data corruption or other undesirable effects.\n\nFix the issue by clearing the union if there is an active member.\n\nAlso fix the type of the data member that holds the active field id (it's `int`, not `FieldID`).\n\nReviewed By: yfeldblum\n\nDifferential Revision: D26440248\n\nfbshipit-source-id: fae9ab96566cf07e14dabe9663b2beb680a01bb4",
    "type_of_change": "Modification",
    "filename_of_changes": "TableBasedSerializer.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "17",
    "number_of_lines_deleted_vulnerable_to_cve": "17",
    "vulnerable_lines": [
        "// Line_Reference 189: const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {",
        "// Line_Reference 190:   return *reinterpret_cast<const FieldID*>(",
        "// Line_Reference 191:       offset + static_cast<const char*>(object));",
        "// Line_Reference 594:     const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);",
        "// Line_Reference 595:     // Found it.",
        "// Line_Reference 596:     if (fieldInfo) {",
        "// Line_Reference 597:       void* unionVal = getMember(*fieldInfo, object);",
        "// Line_Reference 598:       // Default construct and placement new into the member union.",
        "// Line_Reference 599:       structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](",
        "// Line_Reference 600:           unionVal);",
        "// Line_Reference 601:       read(iprot, *fieldInfo->typeInfo, readState, unionVal);",
        "// Line_Reference 602:       const_cast<FieldID&>(activeUnionMemberId(",
        "// Line_Reference 603:           object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;",
        "// Line_Reference 674:     const auto& unionId =",
        "// Line_Reference 675:         activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);",
        "// Line_Reference 679:         unionId,",
        "// Line_Reference 681:     if (found < end && found->id == unionId) {"
    ]
}
