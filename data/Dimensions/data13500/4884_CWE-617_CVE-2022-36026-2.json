{
    "cve_id": "CVE-2022-36026",
    "cve_description": "TensorFlow is an open source platform for machine learning. If `QuantizeAndDequantizeV3` is given a nonscalar `num_bits` input tensor, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
    "cve_publish_date": "2022-09-16",
    "cwe_id": "CWE-617",
    "cwe_name": "Reachable Assertion",
    "cwe_description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
    "commit_message": "Validate the rank and number of elements of the `num_bits` tensor for QuantizeAndDequantizeV3.\n\nQuantizeAndDequantizeV3Op, which accepts `num_bits` as a tensor, has a precondition that it should be rank <= 1 and the number of elements should be 1.\nThis change adds a validation for the Compute() method for this condition.\n\nPiperOrigin-RevId: 463755293",
    "type_of_change": "Modification",
    "filename_of_changes": "quantize_and_dequantize_op.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "106",
    "number_of_lines_deleted_vulnerable_to_cve": "105",
    "vulnerable_lines": [
        "// Line_Reference 24: #include \"tensorflow/core/kernels/quantize_and_dequantize_op.h\"",
        "// Line_Reference 25: ",
        "// Line_Reference 35: typedef Eigen::ThreadPoolDevice CPUDevice;",
        "// Line_Reference 36: typedef Eigen::GpuDevice GPUDevice;",
        "// Line_Reference 52:                 errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,",
        "// Line_Reference 53:                                         \" with signed_input_ \", signed_input_));",
        "// Line_Reference 61:         errors::InvalidArgument(\"Round mode string must be \"",
        "// Line_Reference 62:                                 \"'HALF_UP' or \"",
        "// Line_Reference 63:                                 \"'HALF_TO_EVEN', is '\" +",
        "// Line_Reference 64:                                 round_mode_string + \"'\"));",
        "// Line_Reference 75:     OP_REQUIRES(",
        "// Line_Reference 76:         ctx, axis_ >= -1,",
        "// Line_Reference 77:         errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));",
        "// Line_Reference 78:     OP_REQUIRES(",
        "// Line_Reference 79:         ctx, (axis_ == -1 || axis_ < input.shape().dims()),",
        "// Line_Reference 80:         errors::InvalidArgument(\"Shape must be at least rank \", axis_ + 1,",
        "// Line_Reference 94:                     errors::InvalidArgument(\"Invalid range: input_min \",",
        "// Line_Reference 95:                                             min_val, \" > input_max \", max_val));",
        "// Line_Reference 97:         OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,",
        "// Line_Reference 98:                     errors::InvalidArgument(",
        "// Line_Reference 99:                         \"input_min_tensor has incorrect size, was \",",
        "// Line_Reference 100:                         input_min_tensor.dim_size(0), \" expected \", depth,",
        "// Line_Reference 101:                         \" to match dim \", axis_, \" of the input \",",
        "// Line_Reference 102:                         input_min_tensor.shape()));",
        "// Line_Reference 103:         OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,",
        "// Line_Reference 104:                     errors::InvalidArgument(",
        "// Line_Reference 105:                         \"input_max_tensor has incorrect size, was \",",
        "// Line_Reference 106:                         input_max_tensor.dim_size(0), \" expected \", depth,",
        "// Line_Reference 107:                         \" to match dim \", axis_, \" of the input \",",
        "// Line_Reference 108:                         input_max_tensor.shape()));",
        "// Line_Reference 161:     OP_REQUIRES(",
        "// Line_Reference 162:         ctx, axis_ >= -1,",
        "// Line_Reference 163:         errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));",
        "// Line_Reference 165:                 errors::InvalidArgument(",
        "// Line_Reference 169:     OP_REQUIRES(",
        "// Line_Reference 170:         ctx, input.IsSameSize(gradient),",
        "// Line_Reference 171:         errors::InvalidArgument(\"gradient and input must be the same size\"));",
        "// Line_Reference 176:                 errors::InvalidArgument(",
        "// Line_Reference 182:                 errors::InvalidArgument(",
        "// Line_Reference 186:       OP_REQUIRES(",
        "// Line_Reference 187:           ctx, input_min_tensor.dim_size(0) == depth,",
        "// Line_Reference 188:           errors::InvalidArgument(\"min has incorrect size, expected \", depth,",
        "// Line_Reference 190:       OP_REQUIRES(",
        "// Line_Reference 191:           ctx, input_max_tensor.dim_size(0) == depth,",
        "// Line_Reference 192:           errors::InvalidArgument(\"max has incorrect size, expected \", depth,",
        "// Line_Reference 206:       OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),",
        "// Line_Reference 207:                   errors::InvalidArgument(",
        "// Line_Reference 208:                       \"input_min must be a scalar if axis is unspecified\"));",
        "// Line_Reference 209:       OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),",
        "// Line_Reference 210:                   errors::InvalidArgument(",
        "// Line_Reference 211:                       \"input_max must be a scalar if axis is unspecified\"));",
        "// Line_Reference 255:                 errors::InvalidArgument(",
        "// Line_Reference 262:     Tensor num_bits_tensor;",
        "// Line_Reference 263:     num_bits_tensor = ctx->input(3);",
        "// Line_Reference 264:     int num_bits_val = num_bits_tensor.scalar<int32>()();",
        "// Line_Reference 266:     OP_REQUIRES(",
        "// Line_Reference 267:         ctx, num_bits_val > 0 && num_bits_val < (signed_input_ ? 62 : 63),",
        "// Line_Reference 268:         errors::InvalidArgument(\"num_bits is out of range: \", num_bits_val,",
        "// Line_Reference 269:                                 \" with signed_input_ \", signed_input_));",
        "// Line_Reference 277:         auto min_val = input_min_tensor.scalar<T>()();",
        "// Line_Reference 278:         auto max_val = input_max_tensor.scalar<T>()();",
        "// Line_Reference 280:                     errors::InvalidArgument(\"Invalid range: input_min \",",
        "// Line_Reference 281:                                             min_val, \" > input_max \", max_val));",
        "// Line_Reference 283:         OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,",
        "// Line_Reference 284:                     errors::InvalidArgument(",
        "// Line_Reference 285:                         \"input_min_tensor has incorrect size, was \",",
        "// Line_Reference 286:                         input_min_tensor.dim_size(0), \" expected \", depth,",
        "// Line_Reference 287:                         \" to match dim \", axis_, \" of the input \",",
        "// Line_Reference 288:                         input_min_tensor.shape()));",
        "// Line_Reference 289:         OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,",
        "// Line_Reference 290:                     errors::InvalidArgument(",
        "// Line_Reference 291:                         \"input_max_tensor has incorrect size, was \",",
        "// Line_Reference 292:                         input_max_tensor.dim_size(0), \" expected \", depth,",
        "// Line_Reference 293:                         \" to match dim \", axis_, \" of the input \",",
        "// Line_Reference 294:                         input_max_tensor.shape()));",
        "// Line_Reference 334:                 errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,",
        "// Line_Reference 335:                                         \" with signed_input_ \", signed_input_));",
        "// Line_Reference 340:       OP_REQUIRES(",
        "// Line_Reference 341:           ctx, input_min_ <= input_max_,",
        "// Line_Reference 342:           errors::InvalidArgument(\"Invalid range: input_min \", input_min_,",
        "// Line_Reference 374: // Specializations for CPUDevice.",
        "// Line_Reference 378: struct QuantizeAndDequantizeOneScaleFunctor<CPUDevice, T> {",
        "// Line_Reference 379:   void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,",
        "// Line_Reference 384:     QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(",
        "// Line_Reference 391: struct QuantizeAndDequantizePerChannelFunctor<CPUDevice, T> {",
        "// Line_Reference 392:   void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,",
        "// Line_Reference 397:     QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(",
        "// Line_Reference 404: struct QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice, T> {",
        "// Line_Reference 405:   void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,",
        "// Line_Reference 412:     QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(",
        "// Line_Reference 419: struct QuantizeAndDequantizePerChannelGradientFunctor<CPUDevice, T> {",
        "// Line_Reference 420:   void operator()(const CPUDevice& d,",
        "// Line_Reference 428:     QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(",
        "// Line_Reference 434: template struct functor::QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice,",
        "// Line_Reference 437:     CPUDevice, double>;",
        "// Line_Reference 445:                           QuantizeAndDequantizeV2Op<CPUDevice, T>);            \\",
        "// Line_Reference 449:                           QuantizeAndDequantizeV3Op<CPUDevice, T>);            \\",
        "// Line_Reference 453:                           QuantizeAndDequantizeV2Op<CPUDevice, T>);            \\",
        "// Line_Reference 457:                           QuantizeAndDequantizeV4GradientOp<CPUDevice, T>);    \\",
        "// Line_Reference 460:       QuantizeAndDequantizeOp<CPUDevice, T>);",
        "// Line_Reference 473:                           QuantizeAndDequantizeV2Op<GPUDevice, T>);            \\",
        "// Line_Reference 480:                           QuantizeAndDequantizeV3Op<GPUDevice, T>);            \\",
        "// Line_Reference 486:                           QuantizeAndDequantizeV2Op<GPUDevice, T>);            \\",
        "// Line_Reference 492:                           QuantizeAndDequantizeV4GradientOp<GPUDevice, T>);    \\",
        "// Line_Reference 495:       QuantizeAndDequantizeOp<GPUDevice, T>);"
    ]
}
