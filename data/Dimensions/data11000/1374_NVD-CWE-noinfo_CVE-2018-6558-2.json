{
    "cve_id": "CVE-2018-6558",
    "cve_description": "The pam_fscrypt module in fscrypt before 0.2.4 may incorrectly restore primary and supplementary group IDs to the values associated with the root user, which allows attackers to gain privileges via a successful login through certain applications that use Linux-PAM (aka pam).",
    "cve_publish_date": "2018-08-23",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Ensure setting user privileges is reversible\n\nThis change makes sure after dropping then elevating privileges for a\nprocess, the euid, guid, and groups are all the same as they were\noriginally. This significantly simplifies the privilege logic.\n\nThis fixes CVE-2018-6558, which allowed an unprivleged user to gain\nmembership in the root group (gid 0) due to the groups not being\nproperly reset in the process.",
    "type_of_change": "Modification",
    "filename_of_changes": "privileges.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "76",
    "number_of_lines_deleted_vulnerable_to_cve": "70",
    "vulnerable_lines": [
        "// Line_Reference 47: #include <unistd.h>\t// setreuid, setregid",
        "// Line_Reference 48: #include <grp.h>\t// setgroups",
        "// Line_Reference 49: ",
        "// Line_Reference 50: static int my_setreuid(uid_t ruid, uid_t euid)",
        "// Line_Reference 51: {",
        "// Line_Reference 52: \treturn setreuid(ruid, euid);",
        "// Line_Reference 53: }",
        "// Line_Reference 54: ",
        "// Line_Reference 55: static int my_setregid(gid_t rgid, gid_t egid)",
        "// Line_Reference 56: {",
        "// Line_Reference 57: \treturn setregid(rgid, egid);",
        "// Line_Reference 58: }",
        "// Line_Reference 59: ",
        "// Line_Reference 60: static int my_setgroups(size_t size, const gid_t *list)",
        "// Line_Reference 61: {",
        "// Line_Reference 62: \treturn setgroups(size, list);",
        "// Line_Reference 63: }",
        "// Line_Reference 69: \t\"os\"",
        "// Line_Reference 78: // SetProcessPrivileges temporarily drops the privileges of the current process",
        "// Line_Reference 79: // to have the effective uid/gid of the target user. The privileges can be",
        "// Line_Reference 80: // changed again with another call to SetProcessPrivileges.",
        "// Line_Reference 81: func SetProcessPrivileges(target *user.User) error {",
        "// Line_Reference 82: \teuid := util.AtoiOrPanic(target.Uid)",
        "// Line_Reference 83: \tegid := util.AtoiOrPanic(target.Gid)",
        "// Line_Reference 84: \tif os.Geteuid() == euid {",
        "// Line_Reference 85: \t\tlog.Printf(\"Privileges already set to %q\", target.Username)",
        "// Line_Reference 86: \t\treturn nil",
        "// Line_Reference 87: \t}",
        "// Line_Reference 88: \tlog.Printf(\"Setting privileges to %q\", target.Username)",
        "// Line_Reference 90: \t// If setting privs to root, we want to set the uid first, so we will",
        "// Line_Reference 91: \t// then have the necessary permissions to perform the other actions.",
        "// Line_Reference 92: \tif euid == 0 {",
        "// Line_Reference 93: \t\tif err := setUids(-1, euid); err != nil {",
        "// Line_Reference 94: \t\t\treturn err",
        "// Line_Reference 95: \t\t}",
        "// Line_Reference 96: \t}",
        "// Line_Reference 97: \tif err := setGids(-1, egid); err != nil {",
        "// Line_Reference 98: \t\treturn err",
        "// Line_Reference 99: \t}",
        "// Line_Reference 100: \tif err := setGroups(target); err != nil {",
        "// Line_Reference 101: \t\treturn err",
        "// Line_Reference 103: \t// If not setting privs to root, we want to avoid dropping the uid",
        "// Line_Reference 104: \t// util the very end.",
        "// Line_Reference 105: \tif euid != 0 {",
        "// Line_Reference 106: \t\tif err := setUids(-1, euid); err != nil {",
        "// Line_Reference 107: \t\t\treturn err",
        "// Line_Reference 110: \treturn nil",
        "// Line_Reference 113: func setUids(ruid, euid int) error {",
        "// Line_Reference 114: \tres, err := C.my_setreuid(C.uid_t(ruid), C.uid_t(euid))",
        "// Line_Reference 115: \tlog.Printf(\"setreuid(%d, %d) = %d (errno %v)\", ruid, euid, res, err)",
        "// Line_Reference 116: \tif res == 0 {",
        "// Line_Reference 117: \t\treturn nil",
        "// Line_Reference 119: \treturn errors.Wrapf(err.(syscall.Errno), \"setting uids\")",
        "// Line_Reference 122: func setGids(rgid, egid int) error {",
        "// Line_Reference 123: \tres, err := C.my_setregid(C.gid_t(rgid), C.gid_t(egid))",
        "// Line_Reference 124: \tlog.Printf(\"setregid(%d, %d) = %d (errno %v)\", rgid, egid, res, err)",
        "// Line_Reference 125: \tif res == 0 {",
        "// Line_Reference 126: \t\treturn nil",
        "// Line_Reference 128: \treturn errors.Wrapf(err.(syscall.Errno), \"setting gids\")",
        "// Line_Reference 129: }",
        "// Line_Reference 131: func setGroups(target *user.User) error {",
        "// Line_Reference 132: \tgroupStrings, err := target.GroupIds()",
        "// Line_Reference 133: \tif err != nil {",
        "// Line_Reference 134: \t\treturn util.SystemError(err.Error())",
        "// Line_Reference 136: \tgids := make([]C.gid_t, len(groupStrings))",
        "// Line_Reference 137: \tfor i, groupString := range groupStrings {",
        "// Line_Reference 138: \t\tgids[i] = C.gid_t(util.AtoiOrPanic(groupString))",
        "// Line_Reference 140: \tres, err := C.my_setgroups(C.size_t(len(groupStrings)), &gids[0])",
        "// Line_Reference 141: \tlog.Printf(\"setgroups(%v) = %d (errno %v)\", gids, res, err)",
        "// Line_Reference 145: \treturn errors.Wrapf(err.(syscall.Errno), \"setting groups\")"
    ]
}
