{
    "cve_id": "CVE-2019-20172",
    "cve_description": "Kernel/VM/MemoryManager.cpp in SerenityOS before 2019-12-30 does not reject syscalls with pointers into the kernel-only virtual address space, which allows local users to gain privileges by overwriting a return address that was found on the kernel stack.",
    "cve_publish_date": "2019-12-31",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "Kernel: User pointer validation should reject kernel-only addresses\n\nWe were happily allowing syscalls with pointers into kernel-only\nregions (virtual address >= 0xc0000000).\n\nThis patch fixes that by only considering user regions in the current\nprocess, and also double-checking the Region::is_user_accessible() flag\nbefore approving an access.\n\nThanks to Fire30 for finding the bug! :^)",
    "type_of_change": "Modification",
    "filename_of_changes": "MemoryManager.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "4",
    "vulnerable_lines": [
        "// Line_Reference 595:     auto* region = region_from_vaddr(process, vaddr);",
        "// Line_Reference 596:     return region && region->is_readable();",
        "// Line_Reference 601:     auto* region = region_from_vaddr(process, vaddr);",
        "// Line_Reference 602:     return region && region->is_writable();"
    ]
}
