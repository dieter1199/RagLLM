{
    "cve_id": "CVE-2017-11472",
    "cve_description": "The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
    "cve_publish_date": "2017-07-20",
    "cwe_id": "CWE-755",
    "cwe_name": "Improper Handling of Exceptional Conditions",
    "cwe_description": "The product does not handle or incorrectly handles an exceptional condition.",
    "commit_message": "ACPICA: Namespace: fix operand cache leak\n\nACPICA commit a23325b2e583556eae88ed3f764e457786bf4df6\n\nI found some ACPI operand cache leaks in ACPI early abort cases.\n\nBoot log of ACPI operand cache leak is as follows:\n>[    0.174332] ACPI: Added _OSI(Module Device)\n>[    0.175504] ACPI: Added _OSI(Processor Device)\n>[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions)\n>[    0.177032] ACPI: Added _OSI(Processor Aggregator Device)\n>[    0.178284] ACPI: SCI (IRQ16705) allocation failed\n>[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install\nSystem Control Interrupt handler (20160930/evevent-131)\n>[    0.180008] ACPI: Unable to start the ACPI Interpreter\n>[    0.181125] ACPI Error: Could not remove SCI handler\n(20160930/evmisc-281)\n>[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has\nobjects\n>[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2\n>[    0.186820] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS\nvirtual_box 12/01/2006\n>[    0.188000] Call Trace:\n>[    0.188000]  ? dump_stack+0x5c/0x7d\n>[    0.188000]  ? kmem_cache_destroy+0x224/0x230\n>[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22\n>[    0.188000]  ? acpi_os_delete_cache+0xa/0xd\n>[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b\n>[    0.188000]  ? acpi_terminate+0x5/0xf\n>[    0.188000]  ? acpi_init+0x288/0x32e\n>[    0.188000]  ? __class_create+0x4c/0x80\n>[    0.188000]  ? video_setup+0x7a/0x7a\n>[    0.188000]  ? do_one_initcall+0x4e/0x1b0\n>[    0.188000]  ? kernel_init_freeable+0x194/0x21a\n>[    0.188000]  ? rest_init+0x80/0x80\n>[    0.188000]  ? kernel_init+0xa/0x100\n>[    0.188000]  ? ret_from_fork+0x25/0x30\n\nWhen early abort is occurred due to invalid ACPI information, Linux kernel\nterminates ACPI by calling acpi_terminate() function. The function calls\nacpi_ns_terminate() function to delete namespace data and ACPI operand cache\n(acpi_gbl_module_code_list).\n\nBut the deletion code in acpi_ns_terminate() function is wrapped in\nACPI_EXEC_APP definition, therefore the code is only executed when the\ndefinition exists. If the define doesn't exist, ACPI operand cache\n(acpi_gbl_module_code_list) is leaked, and stack dump is shown in kernel log.\n\nThis causes a security threat because the old kernel (<= 4.9) shows memory\nlocations of kernel functions in stack dump, therefore kernel ASLR can be\nneutralized.\n\nTo fix ACPI operand leak for enhancing security, I made a patch which\nremoves the ACPI_EXEC_APP define in acpi_ns_terminate() function for\nexecuting the deletion code unconditionally.\n\nLink: https://github.com/acpica/acpica/commit/a23325b2\nSigned-off-by: Seunghun Han <kkamagui@gmail.com>\nSigned-off-by: Lv Zheng <lv.zheng@intel.com>\nSigned-off-by: Bob Moore <robert.moore@intel.com>\nSigned-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "nsutils.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "9",
    "number_of_lines_deleted_vulnerable_to_cve": "14",
    "vulnerable_lines": [
        "// Line_Reference 600: #ifdef ACPI_EXEC_APP",
        "// Line_Reference 601: \t{",
        "// Line_Reference 602: \t\tunion acpi_operand_object *prev;",
        "// Line_Reference 603: \t\tunion acpi_operand_object *next;",
        "// Line_Reference 605: \t\t/* Delete any module-level code blocks */",
        "// Line_Reference 606: ",
        "// Line_Reference 607: \t\tnext = acpi_gbl_module_code_list;",
        "// Line_Reference 608: \t\twhile (next) {",
        "// Line_Reference 609: \t\t\tprev = next;",
        "// Line_Reference 610: \t\t\tnext = next->method.mutex;",
        "// Line_Reference 611: \t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */",
        "// Line_Reference 612: \t\t\tacpi_ut_remove_reference(prev);",
        "// Line_Reference 613: \t\t}",
        "// Line_Reference 615: #endif"
    ]
}
