{
    "cve_id": "CVE-2024-24747",
    "cve_description": "MinIO is a High Performance Object Storage. When someone creates an access key, it inherits the permissions of the parent key. Not only for `s3:*` actions, but also `admin:*` actions. Which means unless somewhere above in the access-key hierarchy, the `admin` rights are denied, access keys will be able to simply override their own `s3` permissions to something more permissive. The vulnerability is fixed in RELEASE.2024-01-31T20-20-33Z.",
    "cve_publish_date": "2024-01-31",
    "cwe_id": "CWE-269",
    "cwe_name": "Improper Privilege Management",
    "cwe_description": "The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.",
    "commit_message": "fix: permission checks for editing access keys (#18928)\n\nWith this change, only a user with `UpdateServiceAccountAdminAction`\r\npermission is able to edit access keys.\r\n\r\nWe would like to let a user edit their own access keys, however the\r\nfeature needs to be re-designed for better security and integration with\r\nexternal systems like AD/LDAP and OpenID.\r\n\r\nThis change prevents privilege escalation via service accounts.",
    "type_of_change": "Modification",
    "filename_of_changes": "iam.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "14",
    "number_of_lines_deleted_vulnerable_to_cve": "31",
    "vulnerable_lines": [
        "// Line_Reference 977: \t// Add all the necessary claims for the service accounts.",
        "// Line_Reference 1851: \t// Now check if we have a sessionPolicy.",
        "// Line_Reference 1852: \tspolicy, ok := args.Claims[sessionPolicyNameExtracted]",
        "// Line_Reference 1853: \tif !ok {",
        "// Line_Reference 1854: \t\treturn false",
        "// Line_Reference 1855: \t}",
        "// Line_Reference 1856: ",
        "// Line_Reference 1857: \tspolicyStr, ok := spolicy.(string)",
        "// Line_Reference 1858: \tif !ok {",
        "// Line_Reference 1859: \t\t// Sub policy if set, should be a string reject",
        "// Line_Reference 1860: \t\t// malformed/malicious requests.",
        "// Line_Reference 1861: \t\treturn false",
        "// Line_Reference 1862: \t}",
        "// Line_Reference 1863: ",
        "// Line_Reference 1864: \t// Check if policy is parseable.",
        "// Line_Reference 1865: \tsubPolicy, err := policy.ParseConfig(bytes.NewReader([]byte(spolicyStr)))",
        "// Line_Reference 1866: \tif err != nil {",
        "// Line_Reference 1867: \t\t// Log any error in input session policy config.",
        "// Line_Reference 1868: \t\tlogger.LogIf(GlobalContext, err)",
        "// Line_Reference 1869: \t\treturn false",
        "// Line_Reference 1870: \t}",
        "// Line_Reference 1871: ",
        "// Line_Reference 1872: \t// This can only happen if policy was set but with an empty JSON.",
        "// Line_Reference 1873: \tif subPolicy.Version == \"\" && len(subPolicy.Statements) == 0 {",
        "// Line_Reference 1874: \t\treturn isOwnerDerived || combinedPolicy.IsAllowed(parentArgs)",
        "// Line_Reference 1875: \t}",
        "// Line_Reference 1876: ",
        "// Line_Reference 1877: \tif subPolicy.Version == \"\" {",
        "// Line_Reference 1878: \t\treturn false",
        "// Line_Reference 1881: \treturn subPolicy.IsAllowed(parentArgs) && (isOwnerDerived || combinedPolicy.IsAllowed(parentArgs))",
        "// Line_Reference 2004: \treturn hasSessionPolicy, subPolicy.IsAllowed(args)"
    ]
}
