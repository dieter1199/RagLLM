{
    "cve_id": "CVE-2013-0217",
    "cve_description": "Memory leak in drivers/net/xen-netback/netback.c in the Xen netback functionality in the Linux kernel before 3.7.8 allows guest OS users to cause a denial of service (memory consumption) by triggering certain error conditions.",
    "cve_publish_date": "2013-02-18",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "xen/netback: don't leak pages on failure in xen_netbk_tx_check_gop.\n\nSigned-off-by: Matthew Daley <mattjd@gmail.com>\nReviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nAcked-by: Ian Campbell <ian.campbell@citrix.com>\nAcked-by: Jan Beulich <JBeulich@suse.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "netback.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "13",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 150: static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx);",
        "// Line_Reference 1010: \tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;",
        "// Line_Reference 1011: \tstruct xenvif *vif = pending_tx_info[pending_idx].vif;",
        "// Line_Reference 1012: \tstruct xen_netif_tx_request *txp;",
        "// Line_Reference 1019: \tif (unlikely(err)) {",
        "// Line_Reference 1020: \t\tpending_ring_idx_t index;",
        "// Line_Reference 1021: \t\tindex = pending_index(netbk->pending_prod++);",
        "// Line_Reference 1022: \t\ttxp = &pending_tx_info[pending_idx].req;",
        "// Line_Reference 1023: \t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);",
        "// Line_Reference 1024: \t\tnetbk->pending_ring[index] = pending_idx;",
        "// Line_Reference 1025: \t\txenvif_put(vif);",
        "// Line_Reference 1026: \t}",
        "// Line_Reference 1033: \t\tpending_ring_idx_t index;",
        "// Line_Reference 1042: \t\t\t\txen_netbk_idx_release(netbk, pending_idx);",
        "// Line_Reference 1047: \t\ttxp = &netbk->pending_tx_info[pending_idx].req;",
        "// Line_Reference 1048: \t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);",
        "// Line_Reference 1049: \t\tindex = pending_index(netbk->pending_prod++);",
        "// Line_Reference 1050: \t\tnetbk->pending_ring[index] = pending_idx;",
        "// Line_Reference 1051: \t\txenvif_put(vif);",
        "// Line_Reference 1059: \t\txen_netbk_idx_release(netbk, pending_idx);",
        "// Line_Reference 1062: \t\t\txen_netbk_idx_release(netbk, pending_idx);",
        "// Line_Reference 1096: \t\txen_netbk_idx_release(netbk, pending_idx);",
        "// Line_Reference 1479: \t\t\txen_netbk_idx_release(netbk, pending_idx);",
        "// Line_Reference 1531: static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)",
        "// Line_Reference 1545: \tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);"
    ]
}
