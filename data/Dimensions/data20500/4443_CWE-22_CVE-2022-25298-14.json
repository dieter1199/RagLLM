{
    "cve_id": "CVE-2022-25298",
    "cve_description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
    "cve_publish_date": "2022-02-18",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "fix static file serving security issue; fix url path encoding issue",
    "type_of_change": "Modification",
    "filename_of_changes": "url.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "46",
    "number_of_lines_deleted_vulnerable_to_cve": "47",
    "vulnerable_lines": [
        "// Line_Reference 32: bool Decode(string_view encoded, std::string* raw) {",
        "// Line_Reference 33:   for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {",
        "// Line_Reference 34:     if (*iter == '%') {",
        "// Line_Reference 35:       if (++iter == encoded.end()) {",
        "// Line_Reference 36:         // Invalid URI string, two hexadecimal digits must follow '%'.",
        "// Line_Reference 37:         return false;",
        "// Line_Reference 38:       }",
        "// Line_Reference 39: ",
        "// Line_Reference 40:       int h_decimal = 0;",
        "// Line_Reference 41:       if (!HexToDecimal(*iter, &h_decimal)) {",
        "// Line_Reference 42:         return false;",
        "// Line_Reference 43:       }",
        "// Line_Reference 44: ",
        "// Line_Reference 45:       if (++iter == encoded.end()) {",
        "// Line_Reference 46:         // Invalid URI string, two hexadecimal digits must follow '%'.",
        "// Line_Reference 47:         return false;",
        "// Line_Reference 48:       }",
        "// Line_Reference 49: ",
        "// Line_Reference 50:       int l_decimal = 0;",
        "// Line_Reference 51:       if (!HexToDecimal(*iter, &l_decimal)) {",
        "// Line_Reference 52:         return false;",
        "// Line_Reference 53:       }",
        "// Line_Reference 54: ",
        "// Line_Reference 55:       raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));",
        "// Line_Reference 56: ",
        "// Line_Reference 57:     } else if (*iter > 127 || *iter < 0) {",
        "// Line_Reference 58:       // Invalid encoded URI string, must be entirely ASCII.",
        "// Line_Reference 59:       return false;",
        "// Line_Reference 60:     } else {",
        "// Line_Reference 61:       raw->push_back(*iter);",
        "// Line_Reference 62:     }",
        "// Line_Reference 63:   }",
        "// Line_Reference 64: ",
        "// Line_Reference 65:   return true;",
        "// Line_Reference 66: }",
        "// Line_Reference 67: ",
        "// Line_Reference 68: // Unsafe decode.",
        "// Line_Reference 69: // Return the original string on failure.",
        "// Line_Reference 70: std::string DecodeUnsafe(string_view encoded) {",
        "// Line_Reference 71:   std::string raw;",
        "// Line_Reference 72:   if (Decode(encoded, &raw)) {",
        "// Line_Reference 73:     return raw;",
        "// Line_Reference 74:   }",
        "// Line_Reference 75:   return ToString(encoded);",
        "// Line_Reference 76: }",
        "// Line_Reference 77: ",
        "// Line_Reference 321:         parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });"
    ]
}
