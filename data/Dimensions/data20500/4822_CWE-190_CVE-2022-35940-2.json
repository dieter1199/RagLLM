{
    "cve_id": "CVE-2022-35940",
    "cve_description": "TensorFlow is an open source platform for machine learning. The `RaggedRangOp` function takes an argument `limits` that is eventually used to construct a `TensorShape` as an `int64`. If `limits` is a very large float, it can overflow when converted to an `int64`. This triggers an `InvalidArgument` but also throws an abort signal that crashes the program. We have patched the issue in GitHub commit 37cefa91bee4eace55715eeef43720b958a01192. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
    "cve_publish_date": "2022-09-16",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "[security] Fix int overflow in RaggedRangeOp.\n\nPiperOrigin-RevId: 461749624",
    "type_of_change": "Modification",
    "filename_of_changes": "ragged_range_op.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "20",
    "number_of_lines_deleted_vulnerable_to_cve": "15",
    "vulnerable_lines": [
        "// Line_Reference 81:       rt_nested_splits(row + 1) =",
        "// Line_Reference 82:           rt_nested_splits(row) + RangeSize(start, limit, delta);",
        "// Line_Reference 102: ",
        "// Line_Reference 103:  private:",
        "// Line_Reference 104:   // Returns the number of elements in the specified range.",
        "// Line_Reference 105:   SPLITS_TYPE RangeSize(T start, T limit, T delta) {",
        "// Line_Reference 106:     if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {",
        "// Line_Reference 107:       return 0;",
        "// Line_Reference 108:     }",
        "// Line_Reference 109:     // The following is copied from tensorflow::RangeOp::Compute().",
        "// Line_Reference 110:     return (std::is_integral<T>::value",
        "// Line_Reference 111:                 ? ((std::abs(limit - start) + std::abs(delta) - 1) /",
        "// Line_Reference 112:                    std::abs(delta))",
        "// Line_Reference 113:                 : std::ceil(std::abs((limit - start) / delta)));",
        "// Line_Reference 114:   }"
    ]
}
