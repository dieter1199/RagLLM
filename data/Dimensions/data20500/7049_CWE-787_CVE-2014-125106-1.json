{
    "cve_id": "CVE-2014-125106",
    "cve_description": "Nanopb before 0.3.1 allows size_t overflows in pb_dec_bytes and pb_dec_string.",
    "cve_publish_date": "2023-06-17",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Protect against size_t overflows in pb_dec_bytes/pb_dec_string.\n\nPossible consequences of bug:\n1) Denial of service by causing a crash\n   Possible when all of the following apply:\n      - Untrusted data is passed to pb_decode()\n      - The top-level message contains a static string field as the first field.\n   Causes a single write of '0' byte to 1 byte before the message struct.\n\n2) Remote code execution\n   Possible when all of the following apply:\n      - 64-bit platform\n      - The message or a submessage contains a static/pointer string field.\n      - Decoding directly from a custom pb_istream_t\n      - bytes_left on the stream is set to larger than 4 GB\n   Causes a write of up to 4 GB of data past the string field.\n\n3) Possible heap corruption or remote code execution\n   Possible when all of the following apply:\n      - less than 64-bit platform\n      - The message or a submessage contains a pointer-type bytes field.\n   Causes a write of sizeof(pb_size_t) bytes of data past a 0-byte long\n   malloc()ed buffer. On many malloc() implementations, this causes at\n   most a crash. However, remote code execution through a controlled jump\n   cannot be ruled out.\n\n--\n\nDetailed analysis follows\n\nIn the following consideration, I define \"platform bitness\" as equal to\nnumber of bits in size_t datatype. Therefore most 8-bit platforms are\nregarded as 16-bit for the purposes of this discussion.\n\n1. The overflow in pb_dec_string\n\nThe overflow happens in this computation:\n\nuint32_t size;\nsize_t alloc_size;\nalloc_size = size + 1;\n\nThere are two ways in which the overflow can occur: In the uint32_t\naddition, or in the cast to size_t. This depends on the platform\nbitness.\n\nOn 32- and 64-bit platforms, the size has to be UINT32_MAX for the\noverflow to occur. In that case alloc_size will be 0.\n\nOn 16-bit platforms, overflow will happen whenever size is more than\nUINT16_MAX, and resulting alloc_size is attacker controlled.\n\nFor static fields, the alloc_size value is just checked against the\nfield data size. For pointer fields, the alloc_size value is passed to\nmalloc(). End result in both cases is the same, the storage is 0 or\njust a few bytes in length.\n\nOn 16-bit platforms, another overflow occurs in the call to pb_read(),\nwhen passing the original size. An attacker will want the passed value\nto be larger than the alloc_size, therefore the only reasonable choice\nis to have size = UINT16_MAX and alloc_size = 0. Any larger multiple\nwill truncate to the same values.\n\nAt this point we have read atleast the tag and the string length of the\nmessage, i.e. atleast 3 bytes. The maximum initial value for stream\nbytes_left is SIZE_MAX, thus at this point at most SIZE_MAX-3 bytes are\nremaining.\n\nOn 32-bit and 16-bit platforms this means that the size passed to\npb_read() is always larger than the number of remaining bytes. This\ncauses pb_read() to fail immediately, before reading any bytes.\n\nOn 64-bit platforms, it is possible for the bytes_left value to be set\nto a value larger than UINT32_MAX, which is the wraparound point in\nsize calculation. In this case pb_read() will succeed and write up to 4\nGB of attacker controlled data over the RAM that comes after the string\nfield.\n\nOn all platforms, there is an unconditional write of a terminating null\nbyte. Because the size of size_t typically reflects the size of the\nprocessor address space, a write at UINT16_MAX or UINT32_MAX bytes\nafter the string field actually wraps back to before the string field.\nConsequently, on 32-bit and 16-bit platforms, the bug causes a single\nwrite of '0' byte at one byte before the string field.\n\nIf the string field is in the middle of a message, this will just\ncorrupt other data in the message struct. Because the message contents\nis attacker controlled anyway, this is a non-issue. However, if the\nstring field is the first field in the top-level message, it can\ncorrupt other data on the stack/heap before it. Typically a single '0'\nwrite at a location not controlled by attacker is enough only for a\ndenial-of-service attack.\n\nWhen using pointer fields and malloc(), the attacker controlled\nalloc_size will cause a 0-size allocation to happen. By the same logic\nas before, on 32-bit and 16-bit platforms this causes a '0' byte write\nonly. On 64-bit platforms, however, it will again allow up to 4 GB of\nmalicious data to be written over memory, if the stream length allows\nthe read.\n\n2. The overflow in pb_dec_bytes\n\nThis overflow happens in the PB_BYTES_ARRAY_T_ALLOCSIZE macro:\n\nThe computation is done in size_t data type this time. This means that\nan overflow is possible only when n is larger than SIZE_MAX -\noffsetof(..). The offsetof value in this case is equal to\nsizeof(pb_size_t) bytes.\n\nBecause the incoming size value is limited to 32 bits, no overflow can\nhappen here on 64-bit platforms.\n\nThe size will be passed to pb_read(). Like before, on 32-bit and 16-bit\nplatforms the read will always fail before writing anything.\n\nThis leaves only the write of bdest->size as exploitable. On statically\nallocated fields, the size field will always be allocated, regardless\nof alloc_size. In this case, no buffer overflow is possible here, but\nuser code could possibly use the attacker controlled size value and\nread past a buffer.\n\nIf the field is allocated through malloc(), this will allow a write of\nsizeof(pb_size_t) attacker controlled bytes to past a 0-byte long\nbuffer. In typical malloc implementations, this will either fit in\nunused alignment padding area, or cause a heap corruption and a crash.\nUnder very exceptional situation it could allow attacker to influence\nthe behaviour of malloc(), possibly jumping into an attacker-controlled\nlocation and thus leading to remote code execution.",
    "type_of_change": "Modification",
    "filename_of_changes": "pb_decode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "13",
    "number_of_lines_deleted_vulnerable_to_cve": "7",
    "vulnerable_lines": [
        "// Line_Reference 1085:         if (!allocate_field(stream, dest, PB_BYTES_ARRAY_T_ALLOCSIZE(size), 1))",
        "// Line_Reference 1092:         if (PB_BYTES_ARRAY_T_ALLOCSIZE(size) > field->data_size)",
        "// Line_Reference 1096: ",
        "// Line_Reference 1097:     if (size > PB_SIZE_MAX)",
        "// Line_Reference 1098:     {",
        "// Line_Reference 1099:         PB_RETURN_ERROR(stream, \"bytes overflow\");",
        "// Line_Reference 1100:     }"
    ]
}
