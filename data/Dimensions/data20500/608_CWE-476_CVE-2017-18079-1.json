{
    "cve_id": "CVE-2017-18079",
    "cve_description": "drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.",
    "cve_publish_date": "2018-01-29",
    "cwe_id": "CWE-476",
    "cwe_name": "NULL Pointer Dereference",
    "cwe_description": "The product dereferences a pointer that it expects to be valid but is NULL.",
    "commit_message": "Input: i8042 - fix crash at boot time\n\nThe driver checks port->exists twice in i8042_interrupt(), first when\ntrying to assign temporary \"serio\" variable, and second time when deciding\nwhether it should call serio_interrupt(). The value of port->exists may\nchange between the 2 checks, and we may end up calling serio_interrupt()\nwith a NULL pointer:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000050\nIP: [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40\nPGD 0\nOops: 0002 [#1] SMP\nlast sysfs file:\nCPU 0\nModules linked in:\n\nPid: 1, comm: swapper Not tainted 2.6.32-358.el6.x86_64 #1 QEMU Standard PC (i440FX + PIIX, 1996)\nRIP: 0010:[<ffffffff8150feaf>]  [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40\nRSP: 0018:ffff880028203cc0  EFLAGS: 00010082\nRAX: 0000000000010000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000282 RSI: 0000000000000098 RDI: 0000000000000050\nRBP: ffff880028203cc0 R08: ffff88013e79c000 R09: ffff880028203ee0\nR10: 0000000000000298 R11: 0000000000000282 R12: 0000000000000050\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000098\nFS:  0000000000000000(0000) GS:ffff880028200000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b\nCR2: 0000000000000050 CR3: 0000000001a85000 CR4: 00000000001407f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess swapper (pid: 1, threadinfo ffff88013e79c000, task ffff88013e79b500)\nStack:\nffff880028203d00 ffffffff813de186 ffffffffffffff02 0000000000000000\n<d> 0000000000000000 0000000000000000 0000000000000000 0000000000000098\n<d> ffff880028203d70 ffffffff813e0162 ffff880028203d20 ffffffff8103b8ac\nCall Trace:\n<IRQ>\n [<ffffffff813de186>] serio_interrupt+0x36/0xa0\n[<ffffffff813e0162>] i8042_interrupt+0x132/0x3a0\n[<ffffffff8103b8ac>] ? kvm_clock_read+0x1c/0x20\n[<ffffffff8103b8b9>] ? kvm_clock_get_cycles+0x9/0x10\n[<ffffffff810e1640>] handle_IRQ_event+0x60/0x170\n[<ffffffff8103b154>] ? kvm_guest_apic_eoi_write+0x44/0x50\n[<ffffffff810e3d8e>] handle_edge_irq+0xde/0x180\n[<ffffffff8100de89>] handle_irq+0x49/0xa0\n[<ffffffff81516c8c>] do_IRQ+0x6c/0xf0\n[<ffffffff8100b9d3>] ret_from_intr+0x0/0x11\n[<ffffffff81076f63>] ? __do_softirq+0x73/0x1e0\n[<ffffffff8109b75b>] ? hrtimer_interrupt+0x14b/0x260\n[<ffffffff8100c1cc>] ? call_softirq+0x1c/0x30\n[<ffffffff8100de05>] ? do_softirq+0x65/0xa0\n[<ffffffff81076d95>] ? irq_exit+0x85/0x90\n[<ffffffff81516d80>] ? smp_apic_timer_interrupt+0x70/0x9b\n[<ffffffff8100bb93>] ? apic_timer_interrupt+0x13/0x20\n\nTo avoid the issue let's change the second check to test whether serio is\nNULL or not.\n\nAlso, let's take i8042_lock in i8042_start() and i8042_stop() instead of\ntrying to be overly smart and using memory barriers.\n\nSigned-off-by: Chen Hong <chenhong3@huawei.com>\n[dtor: take lock in i8042_start()/i8042_stop()]\nCc: stable@vger.kernel.org\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "i8042.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "9",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 440: \tmb();",
        "// Line_Reference 462: \tport->serio = NULL;",
        "// Line_Reference 579: \tif (likely(port->exists && !filtered))"
    ]
}
