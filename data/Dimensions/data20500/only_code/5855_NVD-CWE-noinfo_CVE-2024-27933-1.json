#[cfg(unix)]
pub use unix::*;
#[cfg(windows)]
pub use windows::*;
pub struct ChildPipeFd(pub i32);
#[cfg(unix)]
mod unix {
#[op2(fast)]
#[smi]
pub fn op_node_ipc_pipe(
state: &mut OpState,
#[smi] fd: i32,
) -> Result<ResourceId, AnyError> {
Ok(state.resource_table.add(IpcJsonStreamResource::new(fd)?))
}
struct IpcJsonStreamResource {
fn new(stream: RawFd) -> Result<Self, std::io::Error> {
// Safety: The fd is part of a pair of connected sockets create by child process
// implementation.
let unix_stream = UnixStream::from_std(unsafe {
std::os::unix::net::UnixStream::from_raw_fd(stream)
})?;
let (read_half, write_half) = unix_stream.into_split();
fn from_unix_stream(stream: UnixStream) -> Self {
let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;
let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));
let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;
let mut buf = [0u8; 1024];
let n = fd2.read(&mut buf).await?;
assert_eq!(&buf[..n], b"\"hello\"\n");
/* Similar to how ops would use the resource */
let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));
let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;
let mut buf = [0u8; 1024];
let n = fd2.read(&mut buf).await?;
assert_eq!(&buf[..n], b"\"hello\"\n\"world\"\n");
let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));
let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;
let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));
#[cfg(windows)]
mod windows {
use deno_core::error::AnyError;
use deno_core::op2;
#[op2(fast)]
pub fn op_node_ipc_pipe() -> Result<(), AnyError> {
Err(deno_core::error::not_supported())
}
#[op2(fast)]
#[smi]
pub fn op_node_child_ipc_pipe() -> Result<i32, AnyError> {
Ok(-1)
}
#[op2(async)]
pub async fn op_node_ipc_write() -> Result<(), AnyError> {
Err(deno_core::error::not_supported())
}
#[op2(async)]
pub async fn op_node_ipc_read() -> Result<(), AnyError> {
Err(deno_core::error::not_supported())
}
}
