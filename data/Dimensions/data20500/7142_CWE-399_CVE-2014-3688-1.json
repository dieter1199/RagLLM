{
    "cve_id": "CVE-2014-3688",
    "cve_description": "The SCTP implementation in the Linux kernel before 3.17.4 allows remote attackers to cause a denial of service (memory consumption) by triggering a large number of chunks in an association's output queue, as demonstrated by ASCONF probes, related to net/sctp/inqueue.c and net/sctp/sm_statefuns.c.",
    "cve_publish_date": "2014-11-30",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "net: sctp: fix remote memory pressure from excessive queueing\n\nThis scenario is not limited to ASCONF, just taken as one\nexample triggering the issue. When receiving ASCONF probes\nin the form of ...\n\n  -------------- INIT[ASCONF; ASCONF_ACK] ------------->\n  <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n  ---- ASCONF_a; [ASCONF_b; ...; ASCONF_n;] JUNK ------>\n  [...]\n  ---- ASCONF_m; [ASCONF_o; ...; ASCONF_z;] JUNK ------>\n\n... where ASCONF_a, ASCONF_b, ..., ASCONF_z are good-formed\nASCONFs and have increasing serial numbers, we process such\nASCONF chunk(s) marked with !end_of_packet and !singleton,\nsince we have not yet reached the SCTP packet end. SCTP does\nonly do verification on a chunk by chunk basis, as an SCTP\npacket is nothing more than just a container of a stream of\nchunks which it eats up one by one.\n\nWe could run into the case that we receive a packet with a\nmalformed tail, above marked as trailing JUNK. All previous\nchunks are here goodformed, so the stack will eat up all\nprevious chunks up to this point. In case JUNK does not fit\ninto a chunk header and there are no more other chunks in\nthe input queue, or in case JUNK contains a garbage chunk\nheader, but the encoded chunk length would exceed the skb\ntail, or we came here from an entirely different scenario\nand the chunk has pdiscard=1 mark (without having had a flush\npoint), it will happen, that we will excessively queue up\nthe association's output queue (a correct final chunk may\nthen turn it into a response flood when flushing the\nqueue ;)): I ran a simple script with incremental ASCONF\nserial numbers and could see the server side consuming\nexcessive amount of RAM [before/after: up to 2GB and more].\n\nThe issue at heart is that the chunk train basically ends\nwith !end_of_packet and !singleton markers and since commit\n2e3216cd54b1 (\"sctp: Follow security requirement of responding\nwith 1 packet\") therefore preventing an output queue flush\npoint in sctp_do_sm() -> sctp_cmd_interpreter() on the input\nchunk (chunk = event_arg) even though local_cork is set,\nbut its precedence has changed since then. In the normal\ncase, the last chunk with end_of_packet=1 would trigger the\nqueue flush to accommodate possible outgoing bundling.\n\nIn the input queue, sctp_inq_pop() seems to do the right thing\nin terms of discarding invalid chunks. So, above JUNK will\nnot enter the state machine and instead be released and exit\nthe sctp_assoc_bh_rcv() chunk processing loop. It's simply\nthe flush point being missing at loop exit. Adding a try-flush\napproach on the output queue might not work as the underlying\ninfrastructure might be long gone at this point due to the\nside-effect interpreter run.\n\nOne possibility, albeit a bit of a kludge, would be to defer\ninvalid chunk freeing into the state machine in order to\npossibly trigger packet discards and thus indirectly a queue\nflush on error. It would surely be better to discard chunks\nas in the current, perhaps better controlled environment, but\ngoing back and forth, it's simply architecturally not possible.\nI tried various trailing JUNK attack cases and it seems to\nlook good now.\n\nJoint work with Vlad Yasevich.\n\nFixes: 2e3216cd54b1 (\"sctp: Follow security requirement of responding with 1 packet\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "inqueue.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "7",
    "number_of_lines_deleted_vulnerable_to_cve": "26",
    "vulnerable_lines": [
        "// Line_Reference 143: ",
        "// Line_Reference 145: \t\t\tskb_pull(chunk->skb,",
        "// Line_Reference 146: \t\t\t\t chunk->chunk_end - chunk->skb->data);",
        "// Line_Reference 147: ",
        "// Line_Reference 148: \t\t\t/* Verify that we have at least chunk headers",
        "// Line_Reference 149: \t\t\t * worth of buffer left.",
        "// Line_Reference 150: \t\t\t */",
        "// Line_Reference 151: \t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {",
        "// Line_Reference 152: \t\t\t\tsctp_chunk_free(chunk);",
        "// Line_Reference 153: \t\t\t\tchunk = queue->in_progress = NULL;",
        "// Line_Reference 154: \t\t\t}",
        "// Line_Reference 190: \tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {",
        "// Line_Reference 194: \t\t/* RFC 2960, Section 6.10  Bundling",
        "// Line_Reference 195: \t\t *",
        "// Line_Reference 196: \t\t * Partial chunks MUST NOT be placed in an SCTP packet.",
        "// Line_Reference 197: \t\t * If the receiver detects a partial chunk, it MUST drop",
        "// Line_Reference 198: \t\t * the chunk.",
        "// Line_Reference 199: \t\t *",
        "// Line_Reference 200: \t\t * Since the end of the chunk is past the end of our buffer",
        "// Line_Reference 201: \t\t * (which contains the whole packet, we can freely discard",
        "// Line_Reference 202: \t\t * the whole packet.",
        "// Line_Reference 203: \t\t */",
        "// Line_Reference 204: \t\tsctp_chunk_free(chunk);",
        "// Line_Reference 205: \t\tchunk = queue->in_progress = NULL;",
        "// Line_Reference 206: ",
        "// Line_Reference 207: \t\treturn NULL;"
    ]
}
