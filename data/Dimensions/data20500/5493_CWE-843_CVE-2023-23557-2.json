{
    "cve_id": "CVE-2023-23557",
    "cve_description": "An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
    "cve_publish_date": "2023-05-18",
    "cwe_id": "CWE-843",
    "cwe_name": "Access of Resource Using Incompatible Type ('Type Confusion')",
    "cwe_description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
    "commit_message": "Use copyDataProperties slow path for objects with accessors\n\nSummary:\nFix a bug present in `hermesBuiltinCopyDataProperties`.\n`hermesBuiltinCopyDataProperties` is meant to copy an object. It does\nthis by iterating over all the properties in the source object, and\nthen writing the key-value pair into a new object which is returned.The\niteration is done using `JSObject::forEachOwnPropertyWhile`, providing\na callback to process each property. It will take the property id, look\nit up in the source object using `getNamedPropertyValue_RJS`, then take\nthat resulting value and write it into the target. However, that API\nexplicitly states the following:\n\n> Obviously the callbacks shouldn't be  doing naughty things like modifying\nthe property map or creating new hidden classes (even implicitly)\n\nBut, `getNamedPropertyValue_RJS` can\nperform arbitrary JS execution if it is a getter, including\nadding/deleting new properties, which would modify the object's\nHiddenClass, thus violating `JSObject::forEachOwnPropertyWhile`'s\nprecondition.Therefore, the fix is to use the correct, but slower path,\nwhenever there is an accessor on the object. This code path is more 1:1\nto the spec. At the beginning, it will simply find all the properties\nof the source object using `JSObject::getOwnPropertyKeys` and then\niterate on those, rather than use `JSObject::forEachOwnPropertyWhile`.\nThis way, we are allowed to manipulate the source object however we\nwish, which is necessary in order to call `getNamedPropertyValue_RJS`.\n\nReviewed By: neildhar\n\nDifferential Revision: D41701871\n\nfbshipit-source-id: c4be179f57d52827f12ca26b1ab8d17cdccd7447",
    "type_of_change": "Modification",
    "filename_of_changes": "HermesBuiltin.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "17",
    "number_of_lines_deleted_vulnerable_to_cve": "16",
    "vulnerable_lines": [
        "// Line_Reference 254:   assert(",
        "// Line_Reference 255:       from->isProxyObject() &&",
        "// Line_Reference 256:       \"copyDataPropertiesSlowPath_RJS is only for Proxy\");",
        "// Line_Reference 257: ",
        "// Line_Reference 259:   auto cr = JSProxy::getOwnPropertyKeys(",
        "// Line_Reference 313:     CallResult<bool> crb =",
        "// Line_Reference 314:         JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);",
        "// Line_Reference 318:     if (*crb && desc.flags.enumerable) {",
        "// Line_Reference 321:           JSProxy::getComputed(from, runtime, nextKeyHandle, from);",
        "// Line_Reference 383:   if (source->isProxyObject()) {",
        "// Line_Reference 461:         auto cr =",
        "// Line_Reference 462:             JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);",
        "// Line_Reference 463:         if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))",
        "// Line_Reference 464:           return false;",
        "// Line_Reference 465: ",
        "// Line_Reference 466:         valueHandle = std::move(*cr);"
    ]
}
