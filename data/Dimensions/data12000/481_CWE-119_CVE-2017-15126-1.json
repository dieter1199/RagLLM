{
    "cve_id": "CVE-2017-15126",
    "cve_description": "A use-after-free flaw was found in fs/userfaultfd.c in the Linux kernel before 4.13.6. The issue is related to the handling of fork failure when dealing with event messages. Failure to fork correctly can lead to a situation where a fork event will be removed from an already freed list of events with userfaultfd_ctx_put().",
    "cve_publish_date": "2018-01-14",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "userfaultfd: non-cooperative: fix fork use after free\n\nWhen reading the event from the uffd, we put it on a temporary\nfork_event list to detect if we can still access it after releasing and\nretaking the event_wqh.lock.\n\nIf fork aborts and removes the event from the fork_event all is fine as\nlong as we're still in the userfault read context and fork_event head is\nstill alive.\n\nWe've to put the event allocated in the fork kernel stack, back from\nfork_event list-head to the event_wqh head, before returning from\nuserfaultfd_ctx_read, because the fork_event head lifetime is limited to\nthe userfaultfd_ctx_read stack lifetime.\n\nForgetting to move the event back to its event_wqh place then results in\n__remove_wait_queue(&ctx->event_wqh, &ewq->wq); in\nuserfaultfd_event_wait_completion to remove it from a head that has been\nalready freed from the reader stack.\n\nThis could only happen if resolve_userfault_fork failed (for example if\nthere are no file descriptors available to allocate the fork uffd).  If\nit succeeded it was put back correctly.\n\nFurthermore, after find_userfault_evt receives a fork event, the forked\nuserfault context in fork_nctx and uwq->msg.arg.reserved.reserved1 can\nbe released by the fork thread as soon as the event_wqh.lock is\nreleased.  Taking a reference on the fork_nctx before dropping the lock\nprevents an use after free in resolve_userfault_fork().\n\nIf the fork side aborted and it already released everything, we still\ntry to succeed resolve_userfault_fork(), if possible.\n\nFixes: 893e26e61d04eac9 (\"userfaultfd: non-cooperative: Add fork() event\")\nLink: http://lkml.kernel.org/r/20170920180413.26713-1-aarcange@redhat.com\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Mark Rutland <mark.rutland@arm.com>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nCc: Pavel Emelyanov <xemul@virtuozzo.com>\nCc: Mike Rapoport <rppt@linux.vnet.ibm.com>\nCc: \"Dr. David Alan Gilbert\" <dgilbert@redhat.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "userfaultfd.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "56",
    "number_of_lines_deleted_vulnerable_to_cve": "10",
    "vulnerable_lines": [
        "// Line_Reference 1095: \t\tif (!ret) {",
        "// Line_Reference 1096: \t\t\tspin_lock(&ctx->event_wqh.lock);",
        "// Line_Reference 1097: \t\t\tif (!list_empty(&fork_event)) {",
        "// Line_Reference 1098: \t\t\t\tuwq = list_first_entry(&fork_event,",
        "// Line_Reference 1099: \t\t\t\t\t\t       typeof(*uwq),",
        "// Line_Reference 1100: \t\t\t\t\t\t       wq.entry);",
        "// Line_Reference 1101: \t\t\t\tlist_del(&uwq->wq.entry);",
        "// Line_Reference 1102: \t\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);",
        "// Line_Reference 1104: \t\t\t}",
        "// Line_Reference 1105: \t\t\tspin_unlock(&ctx->event_wqh.lock);"
    ]
}
