pub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {
let validate = || {
// We must ensure a transaction can pay the cost of its data bytes.
// If it can't it should not be included in a block.
let mut gasometer = evm::gasometer::Gasometer::new(
transaction.gas_limit.low_u64(),
<T as pallet_evm::Config>::config(),
);
let transaction_cost = match transaction.action {
TransactionAction::Call(_) => {
evm::gasometer::call_transaction_cost(&transaction.input)
}
TransactionAction::Create => {
evm::gasometer::create_transaction_cost(&transaction.input)
}
};
if gasometer.record_transaction(transaction_cost).is_err() {
return InvalidTransaction::Custom(
TransactionValidationError::InvalidGasLimit as u8,
)
.into();
}
if let Some(chain_id) = transaction.signature.chain_id() {
if chain_id != T::ChainId::get() {
return InvalidTransaction::Custom(
TransactionValidationError::InvalidChainId as u8,
)
.into();
}
}
if transaction.gas_limit >= T::BlockGasLimit::get() {
return InvalidTransaction::Custom(
TransactionValidationError::InvalidGasLimit as u8,
)
.into();
}
let account_data = pallet_evm::Pallet::<T>::account_basic(&origin);
if transaction.nonce < account_data.nonce {
return InvalidTransaction::Stale.into();
}
let fee = transaction.gas_price.saturating_mul(transaction.gas_limit);
let total_payment = transaction.value.saturating_add(fee);
if account_data.balance < total_payment {
return InvalidTransaction::Payment.into();
}
let min_gas_price = T::FeeCalculator::min_gas_price();
if transaction.gas_price < min_gas_price {
return InvalidTransaction::Payment.into();
}
let mut builder = ValidTransactionBuilder::default()
.and_provides((origin, transaction.nonce))
.priority(transaction.gas_price.unique_saturated_into());
if transaction.nonce > account_data.nonce {
if let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {
builder = builder.and_requires((origin, prev_nonce))
}
}
builder.build()
};
Some(validate())
Self::do_transact(source, transaction).expect(
Self::do_transact(source, transaction)
fn do_transact(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {
