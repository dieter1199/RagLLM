* Copyright (C) 2010-2020 Oryx Embedded SARL. All rights reserved.
* @version 2.0.0
#include <limits.h>
revisionId = enc28j60ReadReg(interface, ENC28J60_REG_EREVID);
enc28j60WriteReg(interface, ENC28J60_REG_ECOCON, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_MAADR1, interface->macAddr.b[0]);
enc28j60WriteReg(interface, ENC28J60_REG_MAADR2, interface->macAddr.b[1]);
enc28j60WriteReg(interface, ENC28J60_REG_MAADR3, interface->macAddr.b[2]);
enc28j60WriteReg(interface, ENC28J60_REG_MAADR4, interface->macAddr.b[3]);
enc28j60WriteReg(interface, ENC28J60_REG_MAADR5, interface->macAddr.b[4]);
enc28j60WriteReg(interface, ENC28J60_REG_MAADR6, interface->macAddr.b[5]);
enc28j60WriteReg(interface, ENC28J60_REG_ERXSTL, LSB(ENC28J60_RX_BUFFER_START));
enc28j60WriteReg(interface, ENC28J60_REG_ERXSTH, MSB(ENC28J60_RX_BUFFER_START));
enc28j60WriteReg(interface, ENC28J60_REG_ERXNDL, LSB(ENC28J60_RX_BUFFER_STOP));
enc28j60WriteReg(interface, ENC28J60_REG_ERXNDH, MSB(ENC28J60_RX_BUFFER_STOP));
//The ERXRDPT register defines a location within the FIFO
//where the receive hardware is forbidden to write to
enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTL, LSB(ENC28J60_RX_BUFFER_STOP));
enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTH, MSB(ENC28J60_RX_BUFFER_STOP));
enc28j60WriteReg(interface, ENC28J60_REG_ERXFCON, ERXFCON_UCEN |
ERXFCON_CRCEN | ERXFCON_HTEN | ERXFCON_BCEN);
enc28j60WriteReg(interface, ENC28J60_REG_EHT0, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT1, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT2, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT3, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT4, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT5, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT6, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EHT7, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_MACON2, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_MACON1,
MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
//Enable automatic padding to at least 60 bytes, always append a valid CRC
//and check frame length. MAC can operate in half-duplex or full-duplex mode
enc28j60WriteReg(interface, ENC28J60_REG_MACON3, MACON3_PADCFG(1) |
MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX);
enc28j60WriteReg(interface, ENC28J60_REG_MACON3, MACON3_PADCFG(1) |
MACON3_TXCRCEN | MACON3_FRMLNEN);
enc28j60WriteReg(interface, ENC28J60_REG_MACON4, MACON4_DEFER);
enc28j60WriteReg(interface, ENC28J60_REG_MAMXFLL, LSB(ETH_MAX_FRAME_SIZE));
enc28j60WriteReg(interface, ENC28J60_REG_MAMXFLH, MSB(ETH_MAX_FRAME_SIZE));
enc28j60WriteReg(interface, ENC28J60_REG_MABBIPG, 0x15);
enc28j60WriteReg(interface, ENC28J60_REG_MABBIPG, 0x12);
enc28j60WriteReg(interface, ENC28J60_REG_MAIPGL, 0x12);
enc28j60WriteReg(interface, ENC28J60_REG_MAIPGH, 0x0C);
enc28j60WriteReg(interface, ENC28J60_REG_MACLCON2, 63);
enc28j60WritePhyReg(interface, ENC28J60_PHY_REG_PHCON1, PHCON1_PDPXMD);
enc28j60WritePhyReg(interface, ENC28J60_PHY_REG_PHCON1, 0x0000);
enc28j60WritePhyReg(interface, ENC28J60_PHY_REG_PHCON2, PHCON2_HDLDIS);
enc28j60WritePhyReg(interface, ENC28J60_PHY_REG_PHLCON,
PHLCON_LACFG(4) | PHLCON_LBCFG(7) | PHLCON_LFRQ(0) | PHLCON_STRCH);
enc28j60WriteReg(interface, ENC28J60_REG_EIR, 0x00);
enc28j60WriteReg(interface, ENC28J60_REG_EIE, EIE_INTIE |
EIE_PKTIE | EIE_LINKIE | EIE_TXIE | EIE_TXERIE);
enc28j60WritePhyReg(interface, ENC28J60_PHY_REG_PHIE,
PHIE_PLNKIE | PHIE_PGEIE);
enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_RXEN);
enc28j60ClearBit(interface, ENC28J60_REG_EIE, EIE_INTIE);
status = enc28j60ReadReg(interface, ENC28J60_REG_EIR);
if((status & EIR_LINKIF) != 0)
enc28j60ClearBit(interface, ENC28J60_REG_EIE, EIE_LINKIE);
if((status & EIR_PKTIF) != 0)
enc28j60ClearBit(interface, ENC28J60_REG_EIE, EIE_PKTIE);
if((status & (EIR_TXIF | EIE_TXERIE)) != 0)
enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_TXIF | EIE_TXERIE);
enc28j60SetBit(interface, ENC28J60_REG_EIE, EIE_INTIE);
status = enc28j60ReadReg(interface, ENC28J60_REG_EIR);
if((status & EIR_LINKIF) != 0)
enc28j60ReadPhyReg(interface, ENC28J60_PHY_REG_PHIR);
enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_LINKIF);
value = enc28j60ReadPhyReg(interface, ENC28J60_PHY_REG_PHSTAT2);
if((value & PHSTAT2_LSTAT) != 0)
if((status & EIR_PKTIF) != 0)
enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_PKTIF);
enc28j60SetBit(interface, ENC28J60_REG_EIE, EIE_LINKIE | EIE_PKTIE);
enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_TXRST);
enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_TXRST);
enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_TXIF | EIR_TXERIF);
enc28j60WriteReg(interface, ENC28J60_REG_ETXSTL, LSB(ENC28J60_TX_BUFFER_START));
enc28j60WriteReg(interface, ENC28J60_REG_ETXSTH, MSB(ENC28J60_TX_BUFFER_START));
enc28j60WriteReg(interface, ENC28J60_REG_EWRPTL, LSB(ENC28J60_TX_BUFFER_START));
enc28j60WriteReg(interface, ENC28J60_REG_EWRPTH, MSB(ENC28J60_TX_BUFFER_START));
enc28j60WriteReg(interface, ENC28J60_REG_ETXNDL, LSB(ENC28J60_TX_BUFFER_START + length));
enc28j60WriteReg(interface, ENC28J60_REG_ETXNDH, MSB(ENC28J60_TX_BUFFER_START + length));
enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_TXRTS);
uint16_t n;
if(enc28j60ReadReg(interface, ENC28J60_REG_EPKTCNT))
enc28j60WriteReg(interface, ENC28J60_REG_ERDPTL, LSB(context->nextPacket));
enc28j60WriteReg(interface, ENC28J60_REG_ERDPTH, MSB(context->nextPacket));
//Read the first two bytes, which are the address of the next packet
enc28j60ReadBuffer(interface, (uint8_t *) &context->nextPacket, sizeof(uint16_t));
//Get the length of the received frame in bytes
enc28j60ReadBuffer(interface, (uint8_t *) &n, sizeof(uint16_t));
//Read the receive status vector (RSV)
enc28j60ReadBuffer(interface, (uint8_t *) &status, sizeof(uint16_t));
if((status & RSV_RECEIVED_OK) != 0)
n = MIN(n, ETH_MAX_FRAME_SIZE);
enc28j60ReadBuffer(interface, context->rxBuffer, n);
enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTL, LSB(ENC28J60_RX_BUFFER_STOP));
enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTH, MSB(ENC28J60_RX_BUFFER_STOP));
enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTL, LSB(context->nextPacket - 1));
enc28j60WriteReg(interface, ENC28J60_REG_ERXRDPTH, MSB(context->nextPacket - 1));
enc28j60SetBit(interface, ENC28J60_REG_ECON2, ECON2_PKTDEC);
nicProcessPacket(interface, context->rxBuffer, n, &ancillary);
enc28j60WriteReg(interface, ENC28J60_REG_EHT0, hashTable[0]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT1, hashTable[1]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT2, hashTable[2]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT3, hashTable[3]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT4, hashTable[4]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT5, hashTable[5]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT6, hashTable[6]);
enc28j60WriteReg(interface, ENC28J60_REG_EHT7, hashTable[7]);
TRACE_DEBUG("  EHT0 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT0));
TRACE_DEBUG("  EHT1 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT1));
TRACE_DEBUG("  EHT2 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT2));
TRACE_DEBUG("  EHT3 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT3));
TRACE_DEBUG("  EHT0 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT4));
TRACE_DEBUG("  EHT1 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT5));
TRACE_DEBUG("  EHT2 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT6));
TRACE_DEBUG("  EHT3 = %02" PRIX8 "\r\n", enc28j60ReadReg(interface, ENC28J60_REG_EHT7));
//Select specified bank
switch(bank)
case BANK_0:
enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1 | ECON1_BSEL0);
break;
case BANK_1:
enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL0);
enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1);
break;
case BANK_2:
enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL0);
enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1);
break;
case BANK_3:
enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1 | ECON1_BSEL0);
break;
default:
//Invalid bank
break;
enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);
enc28j60WriteReg(interface, ENC28J60_REG_MIWRL, LSB(data));
enc28j60WriteReg(interface, ENC28J60_REG_MIWRH, MSB(data));
while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)
enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);
enc28j60WriteReg(interface, ENC28J60_REG_MICMD, MICMD_MIIRD);
while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)
enc28j60WriteReg(interface, ENC28J60_REG_MICMD, 0);
data = enc28j60ReadReg(interface, ENC28J60_REG_MIRDL);
data |= enc28j60ReadReg(interface, ENC28J60_REG_MIRDH) << 8;