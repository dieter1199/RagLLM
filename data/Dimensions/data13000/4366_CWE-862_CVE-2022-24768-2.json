{
    "cve_id": "CVE-2022-24768",
    "cve_description": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All unpatched versions of Argo CD starting with 1.0.0 are vulnerable to an improper access control bug, allowing a malicious user to potentially escalate their privileges to admin-level. Versions starting with 0.8.0 and 0.5.0 contain limited versions of this issue. To perform exploits, an authorized Argo CD user must have push access to an Application's source git or Helm repository or `sync` and `override` access to an Application. Once a user has that access, different exploitation levels are possible depending on their other RBAC privileges. A patch for this vulnerability has been released in Argo CD versions 2.3.2, 2.2.8, and 2.1.14. Some mitigation measures are available but do not serve as a substitute for upgrading. To avoid privilege escalation, limit who has push access to Application source repositories or `sync` + `override` access to Applications; and limit which repositories are available in projects where users have `update` access to Applications. To avoid unauthorized resource inspection/tampering, limit who has `delete`, `get`, or `action` access to Applications.",
    "cve_publish_date": "2022-03-23",
    "cwe_id": "CWE-862",
    "cwe_name": "Missing Authorization",
    "cwe_description": "The product does not perform an authorization check when an actor attempts to access a resource or perform an action.",
    "commit_message": "Merge pull request from GHSA-2f5v-8r3f-8pww\n\n* fix: application resource APIs must enforce project restrictions\n\nSigned-off-by: Alexander Matyushentsev <AMatyushentsev@gmail.com>\n\n* Fix unit tests\n\nSigned-off-by: jannfis <jann@mistrust.net>\n\nCo-authored-by: jannfis <jann@mistrust.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "app_management_test.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "111",
    "number_of_lines_deleted_vulnerable_to_cve": "50",
    "vulnerable_lines": [
        "// Line_Reference 1049: func TestPermissions(t *testing.T) {",
        "// Line_Reference 1050: \tEnsureCleanState(t)",
        "// Line_Reference 1051: \tappName := Name()",
        "// Line_Reference 1052: \t_, err := RunCli(\"proj\", \"create\", \"test\")",
        "// Line_Reference 1053: \tassert.NoError(t, err)",
        "// Line_Reference 1055: \t// make sure app cannot be created without permissions in project",
        "// Line_Reference 1056: \t_, err = RunCli(\"app\", \"create\", appName, \"--repo\", RepoURL(RepoURLTypeFile),",
        "// Line_Reference 1057: \t\t\"--path\", guestbookPath, \"--project\", \"test\", \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())",
        "// Line_Reference 1058: \tassert.Error(t, err)",
        "// Line_Reference 1059: \tsourceError := fmt.Sprintf(\"application repo %s is not permitted in project 'test'\", RepoURL(RepoURLTypeFile))",
        "// Line_Reference 1060: \tdestinationError := fmt.Sprintf(\"application destination {%s %s} is not permitted in project 'test'\", KubernetesInternalAPIServerAddr, DeploymentNamespace())",
        "// Line_Reference 1062: \tassert.Contains(t, err.Error(), sourceError)",
        "// Line_Reference 1063: \tassert.Contains(t, err.Error(), destinationError)",
        "// Line_Reference 1065: \tproj, err := AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Get(context.Background(), \"test\", metav1.GetOptions{})",
        "// Line_Reference 1066: \tassert.NoError(t, err)",
        "// Line_Reference 1068: \tproj.Spec.Destinations = []ApplicationDestination{{Server: \"*\", Namespace: \"*\"}}",
        "// Line_Reference 1069: \tproj.Spec.SourceRepos = []string{\"*\"}",
        "// Line_Reference 1070: \tproj, err = AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Update(context.Background(), proj, metav1.UpdateOptions{})",
        "// Line_Reference 1071: \tassert.NoError(t, err)",
        "// Line_Reference 1073: \t// make sure controller report permissions issues in conditions",
        "// Line_Reference 1074: \t_, err = RunCli(\"app\", \"create\", appName, \"--repo\", RepoURL(RepoURLTypeFile),",
        "// Line_Reference 1075: \t\t\"--path\", guestbookPath, \"--project\", \"test\", \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())",
        "// Line_Reference 1076: \tassert.NoError(t, err)",
        "// Line_Reference 1077: \tdefer func() {",
        "// Line_Reference 1078: \t\terr = AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Delete(context.Background(), appName, metav1.DeleteOptions{})",
        "// Line_Reference 1079: \t\tassert.NoError(t, err)",
        "// Line_Reference 1080: \t}()",
        "// Line_Reference 1082: \tproj.Spec.Destinations = []ApplicationDestination{}",
        "// Line_Reference 1083: \tproj.Spec.SourceRepos = []string{}",
        "// Line_Reference 1084: \t_, err = AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Update(context.Background(), proj, metav1.UpdateOptions{})",
        "// Line_Reference 1085: \tassert.NoError(t, err)",
        "// Line_Reference 1086: \ttime.Sleep(1 * time.Second)",
        "// Line_Reference 1087: \tcloser, client, err := ArgoCDClientset.NewApplicationClient()",
        "// Line_Reference 1088: \tassert.NoError(t, err)",
        "// Line_Reference 1089: \tdefer io.Close(closer)",
        "// Line_Reference 1091: \trefresh := string(RefreshTypeNormal)",
        "// Line_Reference 1092: \tapp, err := client.Get(context.Background(), &applicationpkg.ApplicationQuery{Name: &appName, Refresh: &refresh})",
        "// Line_Reference 1093: \tassert.NoError(t, err)",
        "// Line_Reference 1095: \tdestinationErrorExist := false",
        "// Line_Reference 1096: \tsourceErrorExist := false",
        "// Line_Reference 1097: \tfor i := range app.Status.Conditions {",
        "// Line_Reference 1098: \t\tif strings.Contains(app.Status.Conditions[i].Message, destinationError) {",
        "// Line_Reference 1099: \t\t\tdestinationErrorExist = true",
        "// Line_Reference 1100: \t\t}",
        "// Line_Reference 1101: \t\tif strings.Contains(app.Status.Conditions[i].Message, sourceError) {",
        "// Line_Reference 1102: \t\t\tsourceErrorExist = true",
        "// Line_Reference 1103: \t\t}",
        "// Line_Reference 1104: \t}",
        "// Line_Reference 1105: \tassert.True(t, destinationErrorExist)",
        "// Line_Reference 1106: \tassert.True(t, sourceErrorExist)"
    ]
}
