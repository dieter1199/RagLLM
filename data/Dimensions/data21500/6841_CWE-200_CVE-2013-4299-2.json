{
    "cve_id": "CVE-2013-4299",
    "cve_description": "Interpretation conflict in drivers/md/dm-snap-persistent.c in the Linux kernel through 3.11.6 allows remote authenticated users to obtain sensitive information or modify data via a crafted mapping to a snapshot block device.",
    "cve_publish_date": "2013-10-24",
    "cwe_id": "CWE-200",
    "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
    "cwe_description": "The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.",
    "commit_message": "dm snapshot: fix data corruption\n\nThis patch fixes a particular type of data corruption that has been\nencountered when loading a snapshot's metadata from disk.\n\nWhen we allocate a new chunk in persistent_prepare, we increment\nps->next_free and we make sure that it doesn't point to a metadata area\nby further incrementing it if necessary.\n\nWhen we load metadata from disk on device activation, ps->next_free is\npositioned after the last used data chunk. However, if this last used\ndata chunk is followed by a metadata area, ps->next_free is positioned\nerroneously to the metadata area. A newly-allocated chunk is placed at\nthe same location as the metadata area, resulting in data or metadata\ncorruption.\n\nThis patch changes the code so that ps->next_free skips the metadata\narea when metadata are loaded in function read_exceptions.\n\nThe patch also moves a piece of code from persistent_prepare_exception\nto a separate function skip_metadata to avoid code duplication.\n\nCVE-2013-4299\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nCc: stable@vger.kernel.org\nCc: Mike Snitzer <snitzer@redhat.com>\nSigned-off-by: Alasdair G Kergon <agk@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "dm-snap-persistent.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "12",
    "number_of_lines_deleted_vulnerable_to_cve": "6",
    "vulnerable_lines": [
        "// Line_Reference 619: \tuint32_t stride;",
        "// Line_Reference 620: \tchunk_t next_free;",
        "// Line_Reference 633: \tstride = (ps->exceptions_per_area + 1);",
        "// Line_Reference 634: \tnext_free = ++ps->next_free;",
        "// Line_Reference 635: \tif (sector_div(next_free, stride) == 1)",
        "// Line_Reference 636: \t\tps->next_free++;"
    ]
}
