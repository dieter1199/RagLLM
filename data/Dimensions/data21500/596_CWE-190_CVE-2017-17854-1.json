{
    "cve_id": "CVE-2017-17854",
    "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (integer overflow and memory corruption) or possibly have unspecified other impact by leveraging unrestricted integer values for pointer arithmetic.",
    "cve_publish_date": "2017-12-27",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "bpf: fix integer overflows\n\nThere were various issues related to the limited size of integers used in\nthe verifier:\n - `off + size` overflow in __check_map_access()\n - `off + reg->off` overflow in check_mem_access()\n - `off + reg->var_off.value` overflow or 32-bit truncation of\n   `reg->var_off.value` in check_mem_access()\n - 32-bit truncation in check_stack_boundary()\n\nMake sure that any integer math cannot overflow by not allowing\npointer math with large values.\n\nAlso reduce the scope of \"scalar op scalar\" tracking.\n\nFixes: f1174f77b50c (\"bpf/verifier: rework value tracking\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "bpf_verifier.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 18: #define BPF_MAX_VAR_OFF\t(1ULL << 31)",
        "// Line_Reference 22: #define BPF_MAX_VAR_SIZ\tINT_MAX"
    ]
}
