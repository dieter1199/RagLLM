{
    "cve_id": "CVE-2012-2133",
    "cve_description": "Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data.",
    "cve_publish_date": "2012-07-03",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https://lkml.org/lkml/2011/8/11/28 or\nhttp://marc.info/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "inode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "21",
    "number_of_lines_deleted_vulnerable_to_cve": "33",
    "vulnerable_lines": [
        "// Line_Reference 629: \t\tif (sbinfo->max_blocks >= 0) {",
        "// Line_Reference 630: \t\t\tbuf->f_blocks = sbinfo->max_blocks;",
        "// Line_Reference 631: \t\t\tbuf->f_bavail = buf->f_bfree = sbinfo->free_blocks;",
        "// Line_Reference 877: \tsbinfo->max_blocks = config.nr_blocks;",
        "// Line_Reference 878: \tsbinfo->free_blocks = config.nr_blocks;",
        "// Line_Reference 903: int hugetlb_get_quota(struct address_space *mapping, long delta)",
        "// Line_Reference 904: {",
        "// Line_Reference 905: \tint ret = 0;",
        "// Line_Reference 906: \tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);",
        "// Line_Reference 907: ",
        "// Line_Reference 908: \tif (sbinfo->free_blocks > -1) {",
        "// Line_Reference 909: \t\tspin_lock(&sbinfo->stat_lock);",
        "// Line_Reference 910: \t\tif (sbinfo->free_blocks - delta >= 0)",
        "// Line_Reference 911: \t\t\tsbinfo->free_blocks -= delta;",
        "// Line_Reference 912: \t\telse",
        "// Line_Reference 913: \t\t\tret = -ENOMEM;",
        "// Line_Reference 914: \t\tspin_unlock(&sbinfo->stat_lock);",
        "// Line_Reference 915: \t}",
        "// Line_Reference 916: ",
        "// Line_Reference 917: \treturn ret;",
        "// Line_Reference 918: }",
        "// Line_Reference 919: ",
        "// Line_Reference 920: void hugetlb_put_quota(struct address_space *mapping, long delta)",
        "// Line_Reference 921: {",
        "// Line_Reference 922: \tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);",
        "// Line_Reference 923: ",
        "// Line_Reference 924: \tif (sbinfo->free_blocks > -1) {",
        "// Line_Reference 925: \t\tspin_lock(&sbinfo->stat_lock);",
        "// Line_Reference 926: \t\tsbinfo->free_blocks += delta;",
        "// Line_Reference 927: \t\tspin_unlock(&sbinfo->stat_lock);",
        "// Line_Reference 928: \t}",
        "// Line_Reference 929: }",
        "// Line_Reference 930: "
    ]
}
