{
    "cve_id": "CVE-2020-28374",
    "cve_description": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.",
    "cve_publish_date": "2021-01-13",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "scsi: target: Fix XCOPY NAA identifier lookup\n\nWhen attempting to match EXTENDED COPY CSCD descriptors with corresponding\nse_devices, target_xcopy_locate_se_dev_e4() currently iterates over LIO's\nglobal devices list which includes all configured backstores.\n\nThis change ensures that only initiator-accessible backstores are\nconsidered during CSCD descriptor lookup, according to the session's\nse_node_acl LUN list.\n\nTo avoid LUN removal race conditions, device pinning is changed from being\nconfigfs based to instead using the se_node_acl lun_ref.\n\nReference: CVE-2020-28374\nFixes: cbf031f425fd (\"target: Add support for EXTENDED_COPY copy offload emulation\")\nReviewed-by: Lee Duncan <lduncan@suse.com>\nSigned-off-by: David Disseldorp <ddiss@suse.de>\nSigned-off-by: Mike Christie <michael.christie@oracle.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "target_core_xcopy.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "70",
    "number_of_lines_deleted_vulnerable_to_cve": "49",
    "vulnerable_lines": [
        "// Line_Reference 49: struct xcopy_dev_search_info {",
        "// Line_Reference 50: \tconst unsigned char *dev_wwn;",
        "// Line_Reference 51: \tstruct se_device *found_dev;",
        "// Line_Reference 52: };",
        "// Line_Reference 53: ",
        "// Line_Reference 55: \t\t\t\t\t      void *data)",
        "// Line_Reference 57: \tstruct xcopy_dev_search_info *info = data;",
        "// Line_Reference 61: \tif (!se_dev->dev_attrib.emulate_3pc)",
        "// Line_Reference 67: \trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);",
        "// Line_Reference 68: \tif (rc != 0)",
        "// Line_Reference 69: \t\treturn 0;",
        "// Line_Reference 70: ",
        "// Line_Reference 71: \tinfo->found_dev = se_dev;",
        "// Line_Reference 72: \tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);",
        "// Line_Reference 73: ",
        "// Line_Reference 74: \trc = target_depend_item(&se_dev->dev_group.cg_item);",
        "// Line_Reference 76: \t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",",
        "// Line_Reference 77: \t\t       rc, se_dev);",
        "// Line_Reference 78: \t\treturn rc;",
        "// Line_Reference 81: \tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",",
        "// Line_Reference 82: \t\t se_dev, &se_dev->dev_group);",
        "// Line_Reference 86: static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,",
        "// Line_Reference 87: \t\t\t\t\tstruct se_device **found_dev)",
        "// Line_Reference 89: \tstruct xcopy_dev_search_info info;",
        "// Line_Reference 90: \tint ret;",
        "// Line_Reference 91: ",
        "// Line_Reference 92: \tmemset(&info, 0, sizeof(info));",
        "// Line_Reference 93: \tinfo.dev_wwn = dev_wwn;",
        "// Line_Reference 94: ",
        "// Line_Reference 95: \tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);",
        "// Line_Reference 96: \tif (ret == 1) {",
        "// Line_Reference 97: \t\t*found_dev = info.found_dev;",
        "// Line_Reference 98: \t\treturn 0;",
        "// Line_Reference 99: \t} else {",
        "// Line_Reference 100: \t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");",
        "// Line_Reference 101: \t\treturn -EINVAL;",
        "// Line_Reference 249: \t\trc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn,",
        "// Line_Reference 250: \t\t\t\t\t\t&xop->dst_dev);",
        "// Line_Reference 253: \t\trc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn,",
        "// Line_Reference 254: \t\t\t\t\t\t&xop->src_dev);",
        "// Line_Reference 394: \tstruct se_device *remote_dev;",
        "// Line_Reference 395: ",
        "// Line_Reference 397: \t\tremote_dev = xop->dst_dev;",
        "// Line_Reference 399: \t\tremote_dev = xop->src_dev;",
        "// Line_Reference 400: ",
        "// Line_Reference 401: \tpr_debug(\"Calling configfs_undepend_item for\"",
        "// Line_Reference 402: \t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",",
        "// Line_Reference 403: \t\t  remote_dev, &remote_dev->dev_group.cg_item);",
        "// Line_Reference 405: \ttarget_undepend_item(&remote_dev->dev_group.cg_item);"
    ]
}
