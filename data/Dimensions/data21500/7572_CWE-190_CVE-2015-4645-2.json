{
    "cve_id": "CVE-2015-4645",
    "cve_description": "Integer overflow in the read_fragment_table_4 function in unsquash-4.c in Squashfs and sasquatch allows remote attackers to cause a denial of service (application crash) via a crafted input, which triggers a stack-based buffer overflow.",
    "cve_publish_date": "2017-03-17",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "unsquashfs-4: Add more sanity checks + fix CVE-2015-4645/6\n\nAdd more filesystem table sanity checks to Unsquashfs-4 and\nalso properly fix CVE-2015-4645 and CVE-2015-4646.\n\nThe CVEs were raised due to Unsquashfs having variable\noveflow and stack overflow in a number of vulnerable\nfunctions.\n\nThe suggested patch only \"fixed\" one such function and fixed\nit badly, and so it was buggy and introduced extra bugs!\n\nThe suggested patch was not only buggy, but, it used the\nessentially wrong approach too.  It was \"fixing\" the\nsymptom but not the cause.  The symptom is wrong values\ncausing overflow, the cause is filesystem corruption.\nThis corruption should be detected and the filesystem\nrejected *before* trying to allocate memory.\n\nThis patch applies the following fixes:\n\n1. The filesystem super-block tables are checked, and the values\n   must match across the filesystem.\n\n   This will trap corrupted filesystems created by Mksquashfs.\n\n2. The maximum (theorectical) size the filesystem tables could grow\n   to, were analysed, and some variables were increased from int to\n   long long.\n\n   This analysis has been added as comments.\n\n3. Stack allocation was removed, and a shared buffer (which is\n   checked and increased as necessary) is used to read the\n   table indexes.\n\nSigned-off-by: Phillip Lougher <phillip@squashfs.org.uk>",
    "type_of_change": "Modification",
    "filename_of_changes": "unsquash-4.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "195",
    "number_of_lines_deleted_vulnerable_to_cve": "39",
    "vulnerable_lines": [
        "// Line_Reference 32: static int read_fragment_table(long long *directory_table_end)",
        "// Line_Reference 35: \tint bytes = SQUASHFS_FRAGMENT_BYTES(sBlk.s.fragments);",
        "// Line_Reference 36: \tint  indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk.s.fragments);",
        "// Line_Reference 37: \tlong long fragment_table_index[indexes];",
        "// Line_Reference 43: \tif(sBlk.s.fragments == 0) {",
        "// Line_Reference 44: \t\t*directory_table_end = sBlk.s.fragment_table_start;",
        "// Line_Reference 45: \t\treturn TRUE;",
        "// Line_Reference 46: \t}",
        "// Line_Reference 47: ",
        "// Line_Reference 53: \tres = read_fs_bytes(fd, sBlk.s.fragment_table_start,",
        "// Line_Reference 54: \t\tSQUASHFS_FRAGMENT_INDEX_BYTES(sBlk.s.fragments),",
        "// Line_Reference 55: \t\tfragment_table_index);",
        "// Line_Reference 81: \t*directory_table_end = fragment_table_index[0];",
        "// Line_Reference 359: static int read_uids_guids(long long *table_start)",
        "// Line_Reference 364: \tlong long id_index_table[indexes];",
        "// Line_Reference 366: \tTRACE(\"read_uids_guids: no_ids %d\\n\", sBlk.s.no_ids);",
        "// Line_Reference 370: \t\tERROR(\"read_uids_guids: failed to allocate id table\\n\");",
        "// Line_Reference 374: \tres = read_fs_bytes(fd, sBlk.s.id_table_start,",
        "// Line_Reference 375: \t\tSQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);",
        "// Line_Reference 377: \t\tERROR(\"read_uids_guids: failed to read id index table\\n\");",
        "// Line_Reference 396: \t\t\tERROR(\"read_uids_guids: failed to read id table block\"",
        "// Line_Reference 411: \tint indexes = SQUASHFS_LOOKUP_BLOCKS(sBlk.s.inodes);",
        "// Line_Reference 412: \tlong long export_index_table[indexes];",
        "// Line_Reference 414: \tres = read_fs_bytes(fd, sBlk.s.lookup_table_start,",
        "// Line_Reference 415: \t\tSQUASHFS_LOOKUP_BLOCK_BYTES(sBlk.s.inodes), export_index_table);",
        "// Line_Reference 435: \tlong long directory_table_end, table_start;",
        "// Line_Reference 437: \tif(read_xattrs_from_disk(fd, &sBlk.s, no_xattrs, &table_start) == 0)",
        "// Line_Reference 438: \t\treturn FALSE;",
        "// Line_Reference 440: \tif(read_uids_guids(&table_start) == FALSE)",
        "// Line_Reference 441: \t\treturn FALSE;",
        "// Line_Reference 443: \tif(parse_exports_table(&table_start) == FALSE)",
        "// Line_Reference 444: \t\treturn FALSE;",
        "// Line_Reference 446: \tif(read_fragment_table(&directory_table_end) == FALSE)",
        "// Line_Reference 447: \t\treturn FALSE;",
        "// Line_Reference 449: \tif(read_inode_table(sBlk.s.inode_table_start,",
        "// Line_Reference 450: \t\t\t\tsBlk.s.directory_table_start) == FALSE)",
        "// Line_Reference 451: \t\treturn FALSE;",
        "// Line_Reference 454: \t\t\t\tdirectory_table_end) == FALSE)",
        "// Line_Reference 455: \t\treturn FALSE;"
    ]
}
