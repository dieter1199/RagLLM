{
    "cve_id": "CVE-2013-1773",
    "cve_description": "Buffer overflow in the VFAT filesystem implementation in the Linux kernel before 3.3 allows local users to gain privileges or cause a denial of service (system crash) via a VFAT write operation on a filesystem with the utf8 mount option, which is not properly handled during UTF-8 to UTF-16 conversion.",
    "cve_publish_date": "2013-02-28",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "NLS: improve UTF8 -> UTF16 string conversion routine\n\nThe utf8s_to_utf16s conversion routine needs to be improved.  Unlike\nits utf16s_to_utf8s sibling, it doesn't accept arguments specifying\nthe maximum length of the output buffer or the endianness of its\n16-bit output.\n\nThis patch (as1501) adds the two missing arguments, and adjusts the\nonly two places in the kernel where the function is called.  A\nfollow-on patch will add a third caller that does utilize the new\ncapabilities.\n\nThe two conversion routines are still annoyingly inconsistent in the\nway they handle invalid byte combinations.  But that's a subject for a\ndifferent patch.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nCC: Clemens Ladisch <clemens@ladisch.de>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>",
    "type_of_change": "Modification",
    "filename_of_changes": "nls_base.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "33",
    "number_of_lines_deleted_vulnerable_to_cve": "10",
    "vulnerable_lines": [
        "// Line_Reference 117: int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)",
        "// Line_Reference 124: \twhile (*s && len > 0) {",
        "// Line_Reference 132: \t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |",
        "// Line_Reference 133: \t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));",
        "// Line_Reference 134: \t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |",
        "// Line_Reference 136: \t\t\t\t\t\t(u & SURROGATE_BITS));",
        "// Line_Reference 138: \t\t\t\t*op++ = (wchar_t) u;",
        "// Line_Reference 140: \t\t\ts += size;",
        "// Line_Reference 141: \t\t\tlen -= size;",
        "// Line_Reference 143: \t\t\t*op++ = *s++;"
    ]
}
