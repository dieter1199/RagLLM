{
    "cve_id": "CVE-2013-0281",
    "cve_description": "Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking).",
    "cve_publish_date": "2013-11-23",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "High: core: Internal tls api improvements for reuse with future LRMD tls backend.",
    "type_of_change": "Modification",
    "filename_of_changes": "cib_remote.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "139",
    "number_of_lines_deleted_vulnerable_to_cve": "151",
    "vulnerable_lines": [
        "// Line_Reference 41: extern gnutls_anon_client_credentials anon_cred_c;",
        "// Line_Reference 42: extern gnutls_session *create_tls_session(int csock, int type);",
        "// Line_Reference 79: int cib_remote_dispatch(gpointer user_data);",
        "// Line_Reference 161:     shutdown(private->command.socket, SHUT_RDWR);       /* no more receptions */",
        "// Line_Reference 162:     shutdown(private->callback.socket, SHUT_RDWR);      /* no more receptions */",
        "// Line_Reference 163:     close(private->command.socket);",
        "// Line_Reference 164:     close(private->callback.socket);",
        "// Line_Reference 165: ",
        "// Line_Reference 168:         gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);",
        "// Line_Reference 169:         gnutls_deinit(*(private->command.session));",
        "// Line_Reference 170:         gnutls_free(private->command.session);",
        "// Line_Reference 171: ",
        "// Line_Reference 172:         gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);",
        "// Line_Reference 173:         gnutls_deinit(*(private->callback.session));",
        "// Line_Reference 174:         gnutls_free(private->callback.session);",
        "// Line_Reference 176:         gnutls_anon_free_client_credentials(anon_cred_c);",
        "// Line_Reference 177:         gnutls_global_deinit();",
        "// Line_Reference 184: cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)",
        "// Line_Reference 188:     struct sockaddr_in addr;",
        "// Line_Reference 190:     char *server = private->server;",
        "// Line_Reference 191: ",
        "// Line_Reference 192:     int ret_ga;",
        "// Line_Reference 193:     struct addrinfo *res;",
        "// Line_Reference 194:     struct addrinfo hints;",
        "// Line_Reference 199:     static struct mainloop_fd_callbacks cib_fd_callbacks =",
        "// Line_Reference 200:         {",
        "// Line_Reference 201:             .dispatch = cib_remote_dispatch,",
        "// Line_Reference 202:             .destroy = cib_remote_connection_destroy,",
        "// Line_Reference 203:         };",
        "// Line_Reference 208:     /* create socket */",
        "// Line_Reference 209:     sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);",
        "// Line_Reference 210:     if (sock == -1) {",
        "// Line_Reference 211:         crm_perror(LOG_ERR, \"Socket creation failed\");",
        "// Line_Reference 212:         return -1;",
        "// Line_Reference 213:     }",
        "// Line_Reference 214: ",
        "// Line_Reference 215:     /* getaddrinfo */",
        "// Line_Reference 216:     bzero(&hints, sizeof(struct addrinfo));",
        "// Line_Reference 217:     hints.ai_flags = AI_CANONNAME;",
        "// Line_Reference 218:     hints.ai_family = AF_INET;",
        "// Line_Reference 219:     hints.ai_socktype = SOCK_RAW;",
        "// Line_Reference 220: ",
        "// Line_Reference 221:     if (hints.ai_family == AF_INET6) {",
        "// Line_Reference 222:         hints.ai_protocol = IPPROTO_ICMPV6;",
        "// Line_Reference 223:     } else {",
        "// Line_Reference 224:         hints.ai_protocol = IPPROTO_ICMP;",
        "// Line_Reference 225:     }",
        "// Line_Reference 226: ",
        "// Line_Reference 227:     crm_debug(\"Looking up %s\", server);",
        "// Line_Reference 228:     ret_ga = getaddrinfo(server, NULL, &hints, &res);",
        "// Line_Reference 229:     if (ret_ga) {",
        "// Line_Reference 230:         crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));",
        "// Line_Reference 231:         close(sock);",
        "// Line_Reference 232:         return -1;",
        "// Line_Reference 233:     }",
        "// Line_Reference 234: ",
        "// Line_Reference 235:     if (res->ai_canonname) {",
        "// Line_Reference 236:         server = res->ai_canonname;",
        "// Line_Reference 237:     }",
        "// Line_Reference 238: ",
        "// Line_Reference 239:     crm_debug(\"Got address %s for %s\", server, private->server);",
        "// Line_Reference 240: ",
        "// Line_Reference 241:     if (!res->ai_addr) {",
        "// Line_Reference 242:         fprintf(stderr, \"getaddrinfo failed\");",
        "// Line_Reference 243:         crm_exit(1);",
        "// Line_Reference 244:     }",
        "// Line_Reference 245: #if 1",
        "// Line_Reference 246:     memcpy(&addr, res->ai_addr, res->ai_addrlen);",
        "// Line_Reference 247: #else",
        "// Line_Reference 248:     /* connect to server */",
        "// Line_Reference 249:     memset(&addr, 0, sizeof(addr));",
        "// Line_Reference 250:     addr.sin_family = AF_INET;",
        "// Line_Reference 251:     addr.sin_addr.s_addr = inet_addr(server);",
        "// Line_Reference 252: #endif",
        "// Line_Reference 253:     addr.sin_port = htons(private->port);",
        "// Line_Reference 254: ",
        "// Line_Reference 255:     if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {",
        "// Line_Reference 256:         crm_perror(LOG_ERR, \"Connection to %s:%d failed\", server, private->port);",
        "// Line_Reference 257:         close(sock);",
        "// Line_Reference 258:         return -1;",
        "// Line_Reference 264:         gnutls_global_init();",
        "// Line_Reference 265:         gnutls_anon_allocate_client_credentials(&anon_cred_c);",
        "// Line_Reference 268:         connection->session = create_tls_session(sock, GNUTLS_CLIENT);",
        "// Line_Reference 269:         if (connection->session == NULL) {",
        "// Line_Reference 270:             crm_perror(LOG_ERR, \"Session creation for %s:%d failed\", server, private->port);",
        "// Line_Reference 271:             close(sock);",
        "// Line_Reference 292:     answer = crm_recv_remote_msg(connection->session, connection->encrypted);",
        "// Line_Reference 318:     connection->socket = sock;",
        "// Line_Reference 334: cib_remote_dispatch(gpointer user_data)",
        "// Line_Reference 340:     const char *type = NULL;",
        "// Line_Reference 343:     msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);",
        "// Line_Reference 345:     type = crm_element_value(msg, F_TYPE);",
        "// Line_Reference 346:     crm_trace(\"Activating %s callbacks...\", type);",
        "// Line_Reference 348:     if (safe_str_eq(type, T_CIB)) {",
        "// Line_Reference 349:         cib_native_callback(cib, msg, 0, 0);",
        "// Line_Reference 351:     } else if (safe_str_eq(type, T_CIB_NOTIFY)) {",
        "// Line_Reference 352:         g_list_foreach(cib->notify_list, cib_native_notify, msg);",
        "// Line_Reference 354:     } else {",
        "// Line_Reference 355:         crm_err(\"Unknown message type: %s\", type);",
        "// Line_Reference 356:     }",
        "// Line_Reference 358:     if (msg != NULL) {",
        "// Line_Reference 360:         return 0;",
        "// Line_Reference 362:     return -1;",
        "// Line_Reference 397:         rc = cib_tls_signon(cib, &(private->command));",
        "// Line_Reference 401:         rc = cib_tls_signon(cib, &(private->callback));",
        "// Line_Reference 466: static gboolean timer_expired = FALSE;",
        "// Line_Reference 467: static struct timer_rec_s *sync_timer = NULL;",
        "// Line_Reference 468: static gboolean",
        "// Line_Reference 469: cib_timeout_handler(gpointer data)",
        "// Line_Reference 470: {",
        "// Line_Reference 471:     struct timer_rec_s *timer = data;",
        "// Line_Reference 472: ",
        "// Line_Reference 473:     timer_expired = TRUE;",
        "// Line_Reference 474:     crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);",
        "// Line_Reference 475: ",
        "// Line_Reference 476:     /* Always return TRUE, never remove the handler",
        "// Line_Reference 477:      * We do that after the while-loop in cib_native_perform_op()",
        "// Line_Reference 478:      */",
        "// Line_Reference 479:     return TRUE;",
        "// Line_Reference 480: }",
        "// Line_Reference 481: ",
        "// Line_Reference 493:     if (sync_timer == NULL) {",
        "// Line_Reference 494:         sync_timer = calloc(1, sizeof(struct timer_rec_s));",
        "// Line_Reference 495:     }",
        "// Line_Reference 496: ",
        "// Line_Reference 527:     crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);",
        "// Line_Reference 540:     if (cib->call_timeout > 0) {",
        "// Line_Reference 541:         /* We need this, even with msgfromIPC_timeout(), because we might",
        "// Line_Reference 542:          * get other/older replies that don't match the active request",
        "// Line_Reference 543:          */",
        "// Line_Reference 544:         timer_expired = FALSE;",
        "// Line_Reference 545:         sync_timer->call_id = cib->call_id;",
        "// Line_Reference 546:         sync_timer->timeout = cib->call_timeout * 1000;",
        "// Line_Reference 547:         sync_timer->ref = g_timeout_add(sync_timer->timeout, cib_timeout_handler, sync_timer);",
        "// Line_Reference 548:     }",
        "// Line_Reference 550:     while (timer_expired == FALSE) {",
        "// Line_Reference 554:         op_reply = crm_recv_remote_msg(private->command.session, private->command.encrypted);",
        "// Line_Reference 555:         if (op_reply == NULL) {",
        "// Line_Reference 560:         CRM_CHECK(reply_id > 0, free_xml(op_reply);",
        "// Line_Reference 561:                   if (sync_timer->ref > 0) {",
        "// Line_Reference 562:                   g_source_remove(sync_timer->ref); sync_timer->ref = 0;}",
        "// Line_Reference 563:                   return -ENOMSG) ;",
        "// Line_Reference 582:     }",
        "// Line_Reference 583: ",
        "// Line_Reference 584:     if (sync_timer->ref > 0) {",
        "// Line_Reference 585:         g_source_remove(sync_timer->ref);",
        "// Line_Reference 586:         sync_timer->ref = 0;",
        "// Line_Reference 587:     }",
        "// Line_Reference 589:     if (timer_expired) {",
        "// Line_Reference 590:         return -ETIME;",
        "// Line_Reference 599:     if (op_reply == NULL) {"
    ]
}
