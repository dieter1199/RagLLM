{
    "cve_id": "CVE-2014-9710",
    "cve_description": "The Btrfs implementation in the Linux kernel before 3.19 does not ensure that the visible xattr state is consistent with a requested replacement, which allows local users to bypass intended ACL settings and gain privileges via standard filesystem operations (1) during an xattr-replacement time window, related to a race condition, or (2) after an xattr-replacement attempt that fails because the data does not fit.",
    "cve_publish_date": "2015-05-27",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "Btrfs: make xattr replace operations atomic\n\nReplacing a xattr consists of doing a lookup for its existing value, delete\nthe current value from the respective leaf, release the search path and then\nfinally insert the new value. This leaves a time window where readers (getxattr,\nlistxattrs) won't see any value for the xattr. Xattrs are used to store ACLs,\nso this has security implications.\n\nThis change also fixes 2 other existing issues which were:\n\n*) Deleting the old xattr value without verifying first if the new xattr will\n   fit in the existing leaf item (in case multiple xattrs are packed in the\n   same item due to name hash collision);\n\n*) Returning -EEXIST when the flag XATTR_CREATE is given and the xattr doesn't\n   exist but we have have an existing item that packs muliple xattrs with\n   the same name hash as the input xattr. In this case we should return ENOSPC.\n\nA test case for xfstests follows soon.\n\nThanks to Alexandre Oliva for reporting the non-atomicity of the xattr replace\nimplementation.\n\nReported-by: Alexandre Oliva <oliva@gnu.org>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "xattr.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "93",
    "number_of_lines_deleted_vulnerable_to_cve": "57",
    "vulnerable_lines": [
        "// Line_Reference 94: \tstruct btrfs_dir_item *di;",
        "// Line_Reference 108: \t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode), name,",
        "// Line_Reference 109: \t\t\t\t\tname_len, -1);",
        "// Line_Reference 110: \t\tif (IS_ERR(di)) {",
        "// Line_Reference 111: \t\t\tret = PTR_ERR(di);",
        "// Line_Reference 112: \t\t\tgoto out;",
        "// Line_Reference 113: \t\t} else if (!di) {",
        "// Line_Reference 117: \t\tret = btrfs_delete_one_dir_name(trans, root, path, di);",
        "// Line_Reference 118: \t\tif (ret)",
        "// Line_Reference 119: \t\t\tgoto out;",
        "// Line_Reference 123: \t\t * remove the attribute",
        "// Line_Reference 125: \t\tif (!value)",
        "// Line_Reference 126: \t\t\tgoto out;",
        "// Line_Reference 127: \t} else {",
        "// Line_Reference 128: \t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),",
        "// Line_Reference 129: \t\t\t\t\tname, name_len, 0);",
        "// Line_Reference 130: \t\tif (IS_ERR(di)) {",
        "// Line_Reference 131: \t\t\tret = PTR_ERR(di);",
        "// Line_Reference 134: \t\tif (!di && !value)",
        "// Line_Reference 135: \t\t\tgoto out;",
        "// Line_Reference 136: \t\tbtrfs_release_path(path);",
        "// Line_Reference 139: again:",
        "// Line_Reference 140: \tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),",
        "// Line_Reference 141: \t\t\t\t      name, name_len, value, size);",
        "// Line_Reference 142: \t/*",
        "// Line_Reference 143: \t * If we're setting an xattr to a new value but the new value is say",
        "// Line_Reference 144: \t * exactly BTRFS_MAX_XATTR_SIZE, we could end up with EOVERFLOW getting",
        "// Line_Reference 145: \t * back from split_leaf.  This is because it thinks we'll be extending",
        "// Line_Reference 146: \t * the existing item size, but we're asking for enough space to add the",
        "// Line_Reference 147: \t * item itself.  So if we get EOVERFLOW just set ret to EEXIST and let",
        "// Line_Reference 148: \t * the rest of the function figure it out.",
        "// Line_Reference 149: \t */",
        "// Line_Reference 150: \tif (ret == -EOVERFLOW)",
        "// Line_Reference 153: \tif (ret == -EEXIST) {",
        "// Line_Reference 154: \t\tif (flags & XATTR_CREATE)",
        "// Line_Reference 155: \t\t\tgoto out;",
        "// Line_Reference 157: \t\t * We can't use the path we already have since we won't have the",
        "// Line_Reference 158: \t\t * proper locking for a delete, so release the path and",
        "// Line_Reference 159: \t\t * re-lookup to delete the thing.",
        "// Line_Reference 161: \t\tbtrfs_release_path(path);",
        "// Line_Reference 162: \t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),",
        "// Line_Reference 163: \t\t\t\t\tname, name_len, -1);",
        "// Line_Reference 164: \t\tif (IS_ERR(di)) {",
        "// Line_Reference 165: \t\t\tret = PTR_ERR(di);",
        "// Line_Reference 166: \t\t\tgoto out;",
        "// Line_Reference 167: \t\t} else if (!di) {",
        "// Line_Reference 168: \t\t\t/* Shouldn't happen but just in case... */",
        "// Line_Reference 169: \t\t\tbtrfs_release_path(path);",
        "// Line_Reference 170: \t\t\tgoto again;",
        "// Line_Reference 173: \t\tret = btrfs_delete_one_dir_name(trans, root, path, di);",
        "// Line_Reference 174: \t\tif (ret)",
        "// Line_Reference 175: \t\t\tgoto out;",
        "// Line_Reference 178: \t\t * We have a value to set, so go back and try to insert it now.",
        "// Line_Reference 180: \t\tif (value) {",
        "// Line_Reference 181: \t\t\tbtrfs_release_path(path);",
        "// Line_Reference 182: \t\t\tgoto again;",
        "// Line_Reference 183: \t\t}"
    ]
}
