{
    "cve_id": "CVE-2016-6911",
    "cve_description": "The dynamicGetbuf function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TIFF image.",
    "cve_publish_date": "2017-01-26",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Fix invalid read in gdImageCreateFromTiffPtr()\n\ntiff_invalid_read.tiff is corrupt, and causes an invalid read in\ngdImageCreateFromTiffPtr(), but not in gdImageCreateFromTiff(). The culprit\nis dynamicGetbuf(), which doesn't check for out-of-bound reads. In this case,\ndynamicGetbuf() is called with a negative dp->pos, but also positive buffer\noverflows have to be handled, in which case 0 has to be returned (cf. commit\n75e29a9).\n\nFixing dynamicGetbuf() exhibits that the corrupt TIFF would still create\nthe image, because the return value of TIFFReadRGBAImage() is not checked.\nWe do that, and let createFromTiffRgba() fail if TIFFReadRGBAImage() fails.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6911",
    "type_of_change": "Modification",
    "filename_of_changes": "gd_tiff.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "16",
    "number_of_lines_deleted_vulnerable_to_cve": "13",
    "vulnerable_lines": [
        "// Line_Reference 774: \tTIFFReadRGBAImage(tif, width, height, buffer, 0);",
        "// Line_Reference 775: ",
        "// Line_Reference 776: \tfor(y = 0; y < height; y++) {",
        "// Line_Reference 777: \t\tfor(x = 0; x < width; x++) {",
        "// Line_Reference 778: \t\t\t/* if it doesn't already exist, allocate a new colour,",
        "// Line_Reference 779: \t\t\t * else use existing one */",
        "// Line_Reference 780: \t\t\trgba = buffer[(y * width + x)];",
        "// Line_Reference 781: \t\t\ta = (0xff - TIFFGetA(rgba)) / 2;",
        "// Line_Reference 782: \t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);",
        "// Line_Reference 783: ",
        "// Line_Reference 784: \t\t\t/* set pixel colour to this colour */",
        "// Line_Reference 785: \t\t\tgdImageSetPixel(im, x, height - y - 1, color);",
        "// Line_Reference 793: \treturn GD_SUCCESS;"
    ]
}
