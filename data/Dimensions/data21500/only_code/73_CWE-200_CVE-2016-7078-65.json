user = FactoryGirl.create(:user, :organizations => [@org, org2])
test ".taxable_ids can work with empty array returning nil" do
dummy_class = @dummy.class
assert_nil dummy_class.taxable_ids([], [])
end
test ".taxable_ids (and .inner_select) can work with array of taxonomies" do
loc1 = FactoryGirl.create(:location)
loc2 = FactoryGirl.create(:location, :parent_id => loc1.id)
loc3 = FactoryGirl.create(:location, :parent_id => loc2.id)
loc4 = FactoryGirl.create(:location)
org = FactoryGirl.create(:organization)
env1 = FactoryGirl.create(:environment, :organizations => [org], :locations => [loc2])
env2 = FactoryGirl.create(:environment, :organizations => [org])
env3 = FactoryGirl.create(:environment, :locations => [loc2])
env4 = FactoryGirl.create(:environment, :locations => [loc4])
env5 = FactoryGirl.create(:environment, :locations => [loc1])
env6 = FactoryGirl.create(:environment, :locations => [loc3])
taxable_ids = Environment.taxable_ids([loc2, loc4], org, :subtree_ids)
visible = [ env1 ]
invisible = [ env2, env3, env4, env5, env6 ]
visible.each { |env| assert_includes taxable_ids, env.id }
invisible.each { |env| refute_includes taxable_ids, env.id }
taxable_ids = Environment.taxable_ids([], org, :subtree_ids)
visible = [ env1, env2 ]
invisible = [ env3, env4, env5, env6 ]
visible.each { |env| assert_includes taxable_ids, env.id }
invisible.each { |env| refute_includes taxable_ids, env.id }
taxable_ids = Environment.taxable_ids(loc2, [], :subtree_ids)
visible = [ env1, env3, env5, env6 ]
invisible = [ env2, env4 ]
visible.each { |env| assert_includes taxable_ids, env.id }
invisible.each { |env| refute_includes taxable_ids, env.id }
taxable_ids = Environment.taxable_ids([loc2, loc4], [], :subtree_ids)
visible = [ env1, env3, env4, env5, env6 ]
invisible = [ env2 ]
visible.each { |env| assert_includes taxable_ids, env.id }
invisible.each { |env| refute_includes taxable_ids, env.id }
used_organizations = user.used_organization_ids
assert_empty used_organizations
assert_equal used_organizations.count, 0
