* Format the fractonal part of a time, with the specified precision)
void
return;
* and was truncated.  Nothing more to do.
return;
buf += decimal_point_len;
buflen -= decimal_point_len;
num_ptr = uint_to_str_back_len(num_end,
nsecs / 100000000, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 10000000, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 1000000, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 100000, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 10000, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 1000, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 100, precision);
num_ptr = uint_to_str_back_len(num_end,
nsecs / 10, precision);
num_ptr = uint_to_str_back_len(num_end, nsecs,
precision);
*    the size of the buffer, minus 1 for the terminating
*      '\0'.
num_len = MIN((size_t)(num_end - num_ptr), buflen - 1);
return;
memcpy(buf, num_ptr, num_len);
*(buf + num_len) = '\0';
size_t buf_remaining;
int num_chars;
buf_remaining = buflen;
num_chars = snprintf(ptr, buf_remaining,
if (num_chars < 0) {
if ((unsigned int)num_chars >= buf_remaining) {
* Either that got an error (num_chars < 0) or it
* filled up or would have overflowed the buffer
* (num_chars >= buf_remaining).
ptr += num_chars;
buf_remaining -= num_chars;
if (precision == 0) {
* Seconds precision, so no nanosecond.
return;
/*
* Append the fractional part.
*/
format_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);
