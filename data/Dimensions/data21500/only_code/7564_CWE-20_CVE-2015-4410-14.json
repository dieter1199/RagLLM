@cluster = Cluster.new(seeds)
#   session[:people].     john, mary = session[:people].find.one # => { :name => "John" }
session.cluster.reconnect
# @private
def current_database
return @current_database if defined? @current_database
if database = options[:database]
set_current_database(database)
else
raise "No database set for session. Call #use or #with before accessing the database"
end
end
# @private
def simple_query(query)
query.limit = -1
query(query).documents.first
end
# @private
def query(query)
if options[:consistency] == :eventual
query.flags |= [:slave_ok] if query.respond_to? :flags
mode = :read
else
mode = :write
end
reply = socket_for(mode).execute(query)
reply.tap do |reply|
if reply.flags.include?(:query_failure)
raise Errors::QueryFailure.new(query, reply.documents.first)
end
end
end
# @private
def execute(op)
mode = options[:consistency] == :eventual ? :read : :write
socket = socket_for(mode)
if safe?
last_error = Protocol::Command.new(
"admin", { getlasterror: 1 }.merge(safety)
)
socket.execute(op, last_error).documents.first.tap do |result|
raise Errors::OperationFailure.new(
op, result
) if result["err"] || result["errmsg"]
end
else
socket.execute(op)
end
end
private
def socket_for(mode)
if options[:retain_socket]
@socket ||= cluster.socket_for(mode)
cluster.socket_for(mode)
def dup
session = super
session.instance_variable_set :@options, options.dup
session.send(:remove_instance_variable, :@current_database)
session
