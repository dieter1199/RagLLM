{
    "cve_id": "CVE-2024-35178",
    "cve_description": "The Jupyter Server provides the backend for Jupyter web applications. Jupyter Server on Windows has a vulnerability that lets unauthenticated attackers leak the NTLMv2 password hash of the Windows user running the Jupyter server. An attacker can crack this password to gain access to the Windows machine hosting the Jupyter server, or access other network-accessible machines or 3rd party services using that credential. Or an attacker perform an NTLM relay attack without cracking the credential to gain access to other network-accessible machines. This vulnerability is fixed in 2.14.1.",
    "cve_publish_date": "2024-06-06",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Merge pull request from GHSA-hrw6-wg82-cm62\n\n* filefind: avoid handling absolute paths\n\nwe don't need or want absolute path support,\nwhich we inherited from generic ipython_genutils\n\nonly supporting relative paths lets us avoid attempting to accessing files we know we won't accept\n\n* Apply suggestions from code review\n\nCo-authored-by: M Bussonnier <bussonniermatthias@gmail.com>\n\n* filefind: only accept Sequence[str]\n\nwe only call it one place, might as well be simple about it\n\n* version_info gate for is_relative_to\n\n* clarify docstring\n\nCo-authored-by: Carol Willing <carolcode@willingconsulting.com>\n\n---------\n\nCo-authored-by: M Bussonnier <bussonniermatthias@gmail.com>\nCo-authored-by: Carol Willing <carolcode@willingconsulting.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "utils.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "42",
    "number_of_lines_deleted_vulnerable_to_cve": "57",
    "vulnerable_lines": [
        "// Line_Reference 341: def filefind(filename: str, path_dirs: Sequence[str] | str | None = None) -> str:",
        "// Line_Reference 343:     This iterates through a sequence of paths looking for a file and returns",
        "// Line_Reference 344:     the full, absolute path of the first occurrence of the file.  If no set of",
        "// Line_Reference 345:     path dirs is given, the filename is tested as is, after running through",
        "// Line_Reference 346:     :func:`expandvars` and :func:`expanduser`.  Thus a simple call::",
        "// Line_Reference 348:         filefind(\"myfile.txt\")",
        "// Line_Reference 350:     will find the file in the current working dir, but::",
        "// Line_Reference 352:         filefind(\"~/myfile.txt\")",
        "// Line_Reference 354:     Will find the file in the users home directory.  This function does not",
        "// Line_Reference 355:     automatically try any paths, such as the cwd or the user's home directory.",
        "// Line_Reference 360:         The filename to look for.",
        "// Line_Reference 361:     path_dirs : str, None or sequence of str",
        "// Line_Reference 362:         The sequence of paths to look for the file in.  If None, the filename",
        "// Line_Reference 363:         need to be absolute or be in the cwd.  If a string, the string is",
        "// Line_Reference 364:         put into a sequence and the searched.  If a sequence, walk through",
        "// Line_Reference 365:         each element and join with ``filename``, calling :func:`expandvars`",
        "// Line_Reference 366:         and :func:`expanduser` before testing for existence.",
        "// Line_Reference 370:     Raises :exc:`IOError` or returns absolute path to file.",
        "// Line_Reference 372: ",
        "// Line_Reference 373:     # If paths are quoted, abspath gets confused, strip them...",
        "// Line_Reference 374:     filename = filename.strip('\"').strip(\"'\")",
        "// Line_Reference 375:     # If the input is an absolute path, just check it exists",
        "// Line_Reference 376:     if os.path.isabs(filename) and os.path.isfile(filename):",
        "// Line_Reference 377:         return filename",
        "// Line_Reference 378: ",
        "// Line_Reference 379:     if path_dirs is None:",
        "// Line_Reference 380:         path_dirs = (\"\",)",
        "// Line_Reference 381:     elif isinstance(path_dirs, str):",
        "// Line_Reference 382:         path_dirs = (path_dirs,)",
        "// Line_Reference 383: ",
        "// Line_Reference 384:     for path in path_dirs:",
        "// Line_Reference 385:         if path == \".\":",
        "// Line_Reference 386:             path = os.getcwd()  # noqa: PLW2901",
        "// Line_Reference 387:         testname = expand_path(os.path.join(path, filename))",
        "// Line_Reference 388:         if os.path.isfile(testname):",
        "// Line_Reference 389:             return os.path.abspath(testname)",
        "// Line_Reference 395: def expand_path(s: str) -> str:",
        "// Line_Reference 396:     \"\"\"Expand $VARS and ~names in a string, like a shell",
        "// Line_Reference 397: ",
        "// Line_Reference 398:     :Examples:",
        "// Line_Reference 399:        In [2]: os.environ['FOO']='test'",
        "// Line_Reference 400:        In [3]: expand_path('variable FOO is $FOO')",
        "// Line_Reference 401:        Out[3]: 'variable FOO is test'",
        "// Line_Reference 402:     \"\"\"",
        "// Line_Reference 403:     # This is a pretty subtle hack. When expand user is given a UNC path",
        "// Line_Reference 404:     # on Windows (\\\\server\\share$\\%username%), os.path.expandvars, removes",
        "// Line_Reference 405:     # the $ to get (\\\\server\\share\\%username%). I think it considered $",
        "// Line_Reference 406:     # alone an empty var. But, we need the $ to remains there (it indicates",
        "// Line_Reference 407:     # a hidden share).",
        "// Line_Reference 408:     if os.name == \"nt\":",
        "// Line_Reference 409:         s = s.replace(\"$\\\\\", \"IPYTHON_TEMP\")",
        "// Line_Reference 410:     s = os.path.expandvars(os.path.expanduser(s))",
        "// Line_Reference 411:     if os.name == \"nt\":",
        "// Line_Reference 412:         s = s.replace(\"IPYTHON_TEMP\", \"$\\\\\")",
        "// Line_Reference 413:     return s",
        "// Line_Reference 414: ",
        "// Line_Reference 415: "
    ]
}
