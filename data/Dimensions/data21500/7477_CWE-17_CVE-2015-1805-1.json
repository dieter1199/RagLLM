{
    "cve_id": "CVE-2015-1805",
    "cve_description": "The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an \"I/O vector array overrun.\"",
    "cve_publish_date": "2015-08-08",
    "cwe_id": "CWE-17",
    "cwe_name": "DEPRECATED: Code",
    "cwe_description": "This entry has been deprecated.  It was originally used for organizing the Development View (CWE-699) and some other views, but it introduced unnecessary complexity and depth to the resulting tree.",
    "commit_message": "switch pipe_read() to copy_page_to_iter()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "type_of_change": "Modification",
    "filename_of_changes": "pipe.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "8",
    "number_of_lines_deleted_vulnerable_to_cve": "71",
    "vulnerable_lines": [
        "// Line_Reference 145: static int",
        "// Line_Reference 146: pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,",
        "// Line_Reference 147: \t\t      int atomic)",
        "// Line_Reference 148: {",
        "// Line_Reference 149: \tunsigned long copy;",
        "// Line_Reference 150: ",
        "// Line_Reference 151: \twhile (len > 0) {",
        "// Line_Reference 152: \t\twhile (!iov->iov_len)",
        "// Line_Reference 153: \t\t\tiov++;",
        "// Line_Reference 154: \t\tcopy = min_t(unsigned long, len, iov->iov_len);",
        "// Line_Reference 155: ",
        "// Line_Reference 156: \t\tif (atomic) {",
        "// Line_Reference 157: \t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))",
        "// Line_Reference 158: \t\t\t\treturn -EFAULT;",
        "// Line_Reference 159: \t\t} else {",
        "// Line_Reference 160: \t\t\tif (copy_to_user(iov->iov_base, from, copy))",
        "// Line_Reference 161: \t\t\t\treturn -EFAULT;",
        "// Line_Reference 162: \t\t}",
        "// Line_Reference 163: \t\tfrom += copy;",
        "// Line_Reference 164: \t\tlen -= copy;",
        "// Line_Reference 165: \t\tiov->iov_base += copy;",
        "// Line_Reference 166: \t\tiov->iov_len -= copy;",
        "// Line_Reference 167: \t}",
        "// Line_Reference 168: \treturn 0;",
        "// Line_Reference 169: }",
        "// Line_Reference 170: ",
        "// Line_Reference 171: /*",
        "// Line_Reference 172:  * Attempt to pre-fault in the user memory, so we can use atomic copies.",
        "// Line_Reference 173:  * Returns the number of bytes not faulted in.",
        "// Line_Reference 174:  */",
        "// Line_Reference 175: static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)",
        "// Line_Reference 176: {",
        "// Line_Reference 177: \twhile (!iov->iov_len)",
        "// Line_Reference 178: \t\tiov++;",
        "// Line_Reference 179: ",
        "// Line_Reference 180: \twhile (len > 0) {",
        "// Line_Reference 181: \t\tunsigned long this_len;",
        "// Line_Reference 182: ",
        "// Line_Reference 183: \t\tthis_len = min_t(unsigned long, len, iov->iov_len);",
        "// Line_Reference 184: \t\tif (fault_in_pages_writeable(iov->iov_base, this_len))",
        "// Line_Reference 185: \t\t\tbreak;",
        "// Line_Reference 186: ",
        "// Line_Reference 187: \t\tlen -= this_len;",
        "// Line_Reference 188: \t\tiov++;",
        "// Line_Reference 189: \t}",
        "// Line_Reference 190: ",
        "// Line_Reference 191: \treturn len;",
        "// Line_Reference 192: }",
        "// Line_Reference 193: ",
        "// Line_Reference 347: \t\t\tvoid *addr;",
        "// Line_Reference 349: \t\t\tint error, atomic;",
        "// Line_Reference 361: \t\t\tatomic = !iov_fault_in_pages_write(iov, chars);",
        "// Line_Reference 362: redo:",
        "// Line_Reference 363: \t\t\tif (atomic)",
        "// Line_Reference 364: \t\t\t\taddr = kmap_atomic(buf->page);",
        "// Line_Reference 365: \t\t\telse",
        "// Line_Reference 366: \t\t\t\taddr = kmap(buf->page);",
        "// Line_Reference 367: \t\t\terror = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);",
        "// Line_Reference 368: \t\t\tif (atomic)",
        "// Line_Reference 369: \t\t\t\tkunmap_atomic(addr);",
        "// Line_Reference 370: \t\t\telse",
        "// Line_Reference 371: \t\t\t\tkunmap(buf->page);",
        "// Line_Reference 372: \t\t\tif (unlikely(error)) {",
        "// Line_Reference 373: \t\t\t\t/*",
        "// Line_Reference 374: \t\t\t\t * Just retry with the slow path if we failed.",
        "// Line_Reference 375: \t\t\t\t */",
        "// Line_Reference 376: \t\t\t\tif (atomic) {",
        "// Line_Reference 377: \t\t\t\t\tatomic = 0;",
        "// Line_Reference 378: \t\t\t\t\tgoto redo;",
        "// Line_Reference 379: \t\t\t\t}",
        "// Line_Reference 381: \t\t\t\t\tret = error;"
    ]
}
