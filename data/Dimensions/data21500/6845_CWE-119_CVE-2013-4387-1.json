{
    "cve_id": "CVE-2013-4387",
    "cve_description": "net/ipv6/ip6_output.c in the Linux kernel through 3.11.4 does not properly determine the need for UDP Fragmentation Offload (UFO) processing of small packets after the UFO queueing of a large packet, which allows remote attackers to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact via network traffic that triggers a large response packet.",
    "cve_publish_date": "2013-10-10",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "ipv6: udp packets following an UFO enqueued packet need also be handled by UFO\n\nIn the following scenario the socket is corked:\nIf the first UDP packet is larger then the mtu we try to append it to the\nwrite queue via ip6_ufo_append_data. A following packet, which is smaller\nthan the mtu would be appended to the already queued up gso-skb via\nplain ip6_append_data. This causes random memory corruptions.\n\nIn ip6_ufo_append_data we also have to be careful to not queue up the\nsame skb multiple times. So setup the gso frame only when no first skb\nis available.\n\nThis also fixes a shortcoming where we add the current packet's length to\ncork->length but return early because of a packet > mtu with dontfrag set\n(instead of sutracting it again).\n\nFound with trinity.\n\nCc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "ip6_output.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "22",
    "number_of_lines_deleted_vulnerable_to_cve": "31",
    "vulnerable_lines": [
        "// Line_Reference 1039: \t}",
        "// Line_Reference 1040: ",
        "// Line_Reference 1041: \terr = skb_append_datato_frags(sk,skb, getfrag, from,",
        "// Line_Reference 1042: \t\t\t\t      (length - transhdrlen));",
        "// Line_Reference 1043: \tif (!err) {",
        "// Line_Reference 1044: \t\tstruct frag_hdr fhdr;",
        "// Line_Reference 1055: ",
        "// Line_Reference 1056: \t\treturn 0;",
        "// Line_Reference 1058: \t/* There is not enough support do UPD LSO,",
        "// Line_Reference 1059: \t * so follow normal path",
        "// Line_Reference 1060: \t */",
        "// Line_Reference 1061: \tkfree_skb(skb);",
        "// Line_Reference 1063: \treturn err;",
        "// Line_Reference 1230: \tcork->length += length;",
        "// Line_Reference 1231: \tif (length > mtu) {",
        "// Line_Reference 1232: \t\tint proto = sk->sk_protocol;",
        "// Line_Reference 1233: \t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){",
        "// Line_Reference 1234: \t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);",
        "// Line_Reference 1235: \t\t\treturn -EMSGSIZE;",
        "// Line_Reference 1236: \t\t}",
        "// Line_Reference 1237: ",
        "// Line_Reference 1238: \t\tif (proto == IPPROTO_UDP &&",
        "// Line_Reference 1239: \t\t    (rt->dst.dev->features & NETIF_F_UFO)) {",
        "// Line_Reference 1241: \t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,",
        "// Line_Reference 1242: \t\t\t\t\t\t  hh_len, fragheaderlen,",
        "// Line_Reference 1243: \t\t\t\t\t\t  transhdrlen, mtu, flags, rt);",
        "// Line_Reference 1244: \t\t\tif (err)",
        "// Line_Reference 1245: \t\t\t\tgoto error;",
        "// Line_Reference 1246: \t\t\treturn 0;",
        "// Line_Reference 1247: \t\t}",
        "// Line_Reference 1250: \tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)"
    ]
}
