{
    "cve_id": "CVE-2015-3905",
    "cve_description": "Buffer overflow in the set_cs_start function in t1disasm.c in t1utils before 1.39 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file.",
    "cve_publish_date": "2015-06-08",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "Security fixes.\n\n- Don't overflow the small cs_start buffer (reported by Niels\n  Thykier via the debian tracker (Jakub Wilk), found with a\n  fuzzer (\"American fuzzy lop\")).\n\n- Cast arguments to <ctype.h> functions to unsigned char.",
    "type_of_change": "Modification",
    "filename_of_changes": "t1asm.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "13",
    "number_of_lines_deleted_vulnerable_to_cve": "27",
    "vulnerable_lines": [
        "// Line_Reference 93: /* lenIV and charstring start command */",
        "// Line_Reference 94: static int lenIV = 4;",
        "// Line_Reference 95: static char cs_start[10];",
        "// Line_Reference 96: ",
        "// Line_Reference 276:   while (isspace(*p))",
        "// Line_Reference 362:   if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {",
        "// Line_Reference 363:     while (*++string && isdigit(*string))",
        "// Line_Reference 629:   char *p, *q, *r;",
        "// Line_Reference 743:       if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace(line[17])) {",
        "// Line_Reference 747: \tfor (p = line + 18; isspace(*p); p++)",
        "// Line_Reference 752: \tlenIV = atoi(line + 6);",
        "// Line_Reference 753:       } else if ((p = strstr(line, \"string currentfile\"))",
        "// Line_Reference 754: \t\t && strstr(line, \"readstring\")) { /* enforce `readstring' */",
        "// Line_Reference 755: \t/* locate the name of the charstring start command */",
        "// Line_Reference 756: \t*p = '\\0';                                  /* damage line[] */",
        "// Line_Reference 757: \tq = strrchr(line, '/');",
        "// Line_Reference 758: \tif (q) {",
        "// Line_Reference 759: \t  r = cs_start;",
        "// Line_Reference 760: \t  ++q;",
        "// Line_Reference 761: \t  while (!isspace(*q) && *q != '{')",
        "// Line_Reference 762: \t    *r++ = *q++;",
        "// Line_Reference 763: \t  *r = '\\0';",
        "// Line_Reference 764: \t}",
        "// Line_Reference 765: \t*p = 's';                                   /* repair line[] */",
        "// Line_Reference 770:       if ((p = strstr(line, \"/Subrs\")) && isdigit(p[7]))",
        "// Line_Reference 772:       else if ((p = strstr(line, \"/CharStrings\")) && isdigit(p[13]))",
        "// Line_Reference 781:       for (q = p; isspace(*q) && *q != '\\n'; q++)"
    ]
}
