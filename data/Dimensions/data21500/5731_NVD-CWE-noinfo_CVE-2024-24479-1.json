{
    "cve_id": "CVE-2024-24479",
    "cve_description": "A Buffer Overflow in Wireshark before 4.2.0 allows a remote attacker to cause a denial of service via the wsutil/to_str.c, and format_fractional_part_nsecs components. NOTE: this is disputed by the vendor because neither release 4.2.0 nor any other release was affected.",
    "cve_publish_date": "2024-02-21",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Various enhancements and fixes to format_fractional_part_nsecs().\n\nHave format_fractional_part_nsecs() return the number of bytes\nformatted.  This matches what snprintf() and strlcpy() do, for the\nbenefit of routines constructing a string in a fixed-length buffer with\nmultiple calls, one of which is format_fractional_part_nsecs().\n\nHave format_fractional_part_nsecs() check for a count of nanoseconds\ngreatre than or equal to 1 billion, and report that specially.\n\nFix places wher it used the bufer pointer and size of the buffer, rather\nthan the current position in the buffer and the remaining space in the\nbuffer, to append to the buffer and make sure doing so doesn't overrun\nthe buffer.\n\nRename some variable names (rename buf_remaining to just remaining,\nrename num_chars to num_bytes as it counts bytes).\n\nFix some comments.",
    "type_of_change": "Modification",
    "filename_of_changes": "to_str.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "76",
    "number_of_lines_deleted_vulnerable_to_cve": "50",
    "vulnerable_lines": [
        "// Line_Reference 656:  * Format the fractonal part of a time, with the specified precision)",
        "// Line_Reference 658: void",
        "// Line_Reference 674: \t\treturn;",
        "// Line_Reference 684: \t\t * and was truncated.  Nothing more to do.",
        "// Line_Reference 686: \t\treturn;",
        "// Line_Reference 688: \tbuf += decimal_point_len;",
        "// Line_Reference 689: \tbuflen -= decimal_point_len;",
        "// Line_Reference 712: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 713: \t\t    nsecs / 100000000, precision);",
        "// Line_Reference 720: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 721: \t\t    nsecs / 10000000, precision);",
        "// Line_Reference 728: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 729: \t\t    nsecs / 1000000, precision);",
        "// Line_Reference 736: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 737: \t\t    nsecs / 100000, precision);",
        "// Line_Reference 744: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 745: \t\t    nsecs / 10000, precision);",
        "// Line_Reference 752: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 753: \t\t    nsecs / 1000, precision);",
        "// Line_Reference 760: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 761: \t\t    nsecs / 100, precision);",
        "// Line_Reference 768: \t\tnum_ptr = uint_to_str_back_len(num_end,",
        "// Line_Reference 769: \t\t    nsecs / 10, precision);",
        "// Line_Reference 776: \t\tnum_ptr = uint_to_str_back_len(num_end, nsecs,",
        "// Line_Reference 777: \t\t    precision);",
        "// Line_Reference 790: \t *    the size of the buffer, minus 1 for the terminating",
        "// Line_Reference 791: \t *      '\\0'.",
        "// Line_Reference 793: \tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);",
        "// Line_Reference 798: \t\treturn;",
        "// Line_Reference 804: \tmemcpy(buf, num_ptr, num_len);",
        "// Line_Reference 809: \t*(buf + num_len) = '\\0';",
        "// Line_Reference 895: \tsize_t buf_remaining;",
        "// Line_Reference 896: \tint num_chars;",
        "// Line_Reference 907: \tbuf_remaining = buflen;",
        "// Line_Reference 908: \tnum_chars = snprintf(ptr, buf_remaining,",
        "// Line_Reference 916: \tif (num_chars < 0) {",
        "// Line_Reference 923: \tif ((unsigned int)num_chars >= buf_remaining) {",
        "// Line_Reference 925: \t\t * Either that got an error (num_chars < 0) or it",
        "// Line_Reference 926: \t\t * filled up or would have overflowed the buffer",
        "// Line_Reference 927: \t\t * (num_chars >= buf_remaining).",
        "// Line_Reference 932: \tptr += num_chars;",
        "// Line_Reference 933: \tbuf_remaining -= num_chars;",
        "// Line_Reference 935: \tif (precision == 0) {",
        "// Line_Reference 937: \t\t * Seconds precision, so no nanosecond.",
        "// Line_Reference 939: \t\treturn;",
        "// Line_Reference 941: ",
        "// Line_Reference 942: \t/*",
        "// Line_Reference 943: \t * Append the fractional part.",
        "// Line_Reference 944: \t */",
        "// Line_Reference 945: \tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);"
    ]
}
