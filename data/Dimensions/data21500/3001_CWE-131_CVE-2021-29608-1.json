{
    "cve_id": "CVE-2021-29608",
    "cve_description": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
    "cve_publish_date": "2021-05-14",
    "cwe_id": "CWE-131",
    "cwe_name": "Incorrect Calculation of Buffer Size",
    "cwe_description": "The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",
    "commit_message": "Fix heap OOB / undefined behavior in `RaggedTensorToTensor`\n\nPiperOrigin-RevId: 373244623\nChange-Id: I2d6cbbc8c67b238a8815bf58097f7586d87c54f2",
    "type_of_change": "Modification",
    "filename_of_changes": "ragged_tensor_to_tensor_op.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "35",
    "number_of_lines_deleted_vulnerable_to_cve": "20",
    "vulnerable_lines": [
        "// Line_Reference 210:   void CalculateOutputIndexRowSplit(",
        "// Line_Reference 211:       OpKernelContext* context, const RowPartitionTensor& row_split,",
        "// Line_Reference 235:     if (row_split_size > 0) {",
        "// Line_Reference 236:       OP_REQUIRES(context, result->size() == row_split(row_split_size - 1),",
        "// Line_Reference 237:                   errors::InvalidArgument(\"Invalid row split size.\"));",
        "// Line_Reference 262:   void CalculateOutputIndexValueRowID(",
        "// Line_Reference 263:       OpKernelContext* context, const RowPartitionTensor& value_rowids,",
        "// Line_Reference 270:       return;",
        "// Line_Reference 275:     DCHECK_LT(current_value_rowid, parent_output_index.size());",
        "// Line_Reference 292:         DCHECK_LT(next_value_rowid, parent_output_index.size());",
        "// Line_Reference 297:     OP_REQUIRES(context, result->size() == value_rowids.size(),",
        "// Line_Reference 298:                 errors::InvalidArgument(\"Invalid row ids.\"));",
        "// Line_Reference 311:         CalculateOutputIndexValueRowID(",
        "// Line_Reference 312:             context, row_partition_tensor, parent_output_index,",
        "// Line_Reference 313:             output_index_multiplier, output_size, result);",
        "// Line_Reference 314:         return tensorflow::Status::OK();",
        "// Line_Reference 322:         CalculateOutputIndexRowSplit(",
        "// Line_Reference 323:             context, row_partition_tensor, parent_output_index,",
        "// Line_Reference 324:             output_index_multiplier, output_size, result);",
        "// Line_Reference 325:         return tensorflow::Status::OK();"
    ]
}
