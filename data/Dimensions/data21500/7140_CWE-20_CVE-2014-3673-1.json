{
    "cve_id": "CVE-2014-3673",
    "cve_description": "The SCTP implementation in the Linux kernel through 3.17.2 allows remote attackers to cause a denial of service (system crash) via a malformed ASCONF chunk, related to net/sctp/sm_make_chunk.c and net/sctp/sm_statefuns.c.",
    "cve_publish_date": "2014-11-10",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "net: sctp: fix skb_over_panic when receiving malformed ASCONF chunks\n\nCommit 6f4c618ddb0 (\"SCTP : Add paramters validity check for\nASCONF chunk\") added basic verification of ASCONF chunks, however,\nit is still possible to remotely crash a server by sending a\nspecial crafted ASCONF chunk, even up to pre 2.6.12 kernels:\n\nskb_over_panic: text:ffffffffa01ea1c3 len:31056 put:30768\n head:ffff88011bd81800 data:ffff88011bd81800 tail:0x7950\n end:0x440 dev:<NULL>\n ------------[ cut here ]------------\nkernel BUG at net/core/skbuff.c:129!\n[...]\nCall Trace:\n <IRQ>\n [<ffffffff8144fb1c>] skb_put+0x5c/0x70\n [<ffffffffa01ea1c3>] sctp_addto_chunk+0x63/0xd0 [sctp]\n [<ffffffffa01eadaf>] sctp_process_asconf+0x1af/0x540 [sctp]\n [<ffffffff8152d025>] ? _read_unlock_bh+0x15/0x20\n [<ffffffffa01e0038>] sctp_sf_do_asconf+0x168/0x240 [sctp]\n [<ffffffffa01e3751>] sctp_do_sm+0x71/0x1210 [sctp]\n [<ffffffff8147645d>] ? fib_rules_lookup+0xad/0xf0\n [<ffffffffa01e6b22>] ? sctp_cmp_addr_exact+0x32/0x40 [sctp]\n [<ffffffffa01e8393>] sctp_assoc_bh_rcv+0xd3/0x180 [sctp]\n [<ffffffffa01ee986>] sctp_inq_push+0x56/0x80 [sctp]\n [<ffffffffa01fcc42>] sctp_rcv+0x982/0xa10 [sctp]\n [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23/0x28 [iptable_filter]\n [<ffffffff8148bdc9>] ? nf_iterate+0x69/0xb0\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0\n [<ffffffff8148bf86>] ? nf_hook_slow+0x76/0x120\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0\n [<ffffffff81496ded>] ip_local_deliver_finish+0xdd/0x2d0\n [<ffffffff81497078>] ip_local_deliver+0x98/0xa0\n [<ffffffff8149653d>] ip_rcv_finish+0x12d/0x440\n [<ffffffff81496ac5>] ip_rcv+0x275/0x350\n [<ffffffff8145c88b>] __netif_receive_skb+0x4ab/0x750\n [<ffffffff81460588>] netif_receive_skb+0x58/0x60\n\nThis can be triggered e.g., through a simple scripted nmap\nconnection scan injecting the chunk after the handshake, for\nexample, ...\n\n  -------------- INIT[ASCONF; ASCONF_ACK] ------------->\n  <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n  ------------------ ASCONF; UNKNOWN ------------------>\n\n... where ASCONF chunk of length 280 contains 2 parameters ...\n\n  1) Add IP address parameter (param length: 16)\n  2) Add/del IP address parameter (param length: 255)\n\n... followed by an UNKNOWN chunk of e.g. 4 bytes. Here, the\nAddress Parameter in the ASCONF chunk is even missing, too.\nThis is just an example and similarly-crafted ASCONF chunks\ncould be used just as well.\n\nThe ASCONF chunk passes through sctp_verify_asconf() as all\nparameters passed sanity checks, and after walking, we ended\nup successfully at the chunk end boundary, and thus may invoke\nsctp_process_asconf(). Parameter walking is done with\nWORD_ROUND() to take padding into account.\n\nIn sctp_process_asconf()'s TLV processing, we may fail in\nsctp_process_asconf_param() e.g., due to removal of the IP\naddress that is also the source address of the packet containing\nthe ASCONF chunk, and thus we need to add all TLVs after the\nfailure to our ASCONF response to remote via helper function\nsctp_add_asconf_response(), which basically invokes a\nsctp_addto_chunk() adding the error parameters to the given\nskb.\n\nWhen walking to the next parameter this time, we proceed\nwith ...\n\n  length = ntohs(asconf_param->param_hdr.length);\n  asconf_param = (void *)asconf_param + length;\n\n... instead of the WORD_ROUND()'ed length, thus resulting here\nin an off-by-one that leads to reading the follow-up garbage\nparameter length of 12336, and thus throwing an skb_over_panic\nfor the reply when trying to sctp_addto_chunk() next time,\nwhich implicitly calls the skb_put() with that length.\n\nFix it by using sctp_walk_params() [ which is also used in\nINIT parameter processing ] macro in the verification *and*\nin ASCONF processing: it will make sure we don't spill over,\nthat we walk parameters WORD_ROUND()'ed. Moreover, we're being\nmore defensive and guard against unknown parameter types and\nmissized addresses.\n\nJoint work with Vlad Yasevich.\n\nFixes: b896b82be4ae (\"[SCTP] ADDIP: Support for processing incoming ASCONF_ACK chunks.\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "sm_make_chunk.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "55",
    "number_of_lines_deleted_vulnerable_to_cve": "44",
    "vulnerable_lines": [
        "// Line_Reference 3113: /* Verify the ASCONF packet before we process it.  */",
        "// Line_Reference 3114: int sctp_verify_asconf(const struct sctp_association *asoc,",
        "// Line_Reference 3115: \t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,",
        "// Line_Reference 3116: \t\t       struct sctp_paramhdr **errp) {",
        "// Line_Reference 3117: \tsctp_addip_param_t *asconf_param;",
        "// Line_Reference 3119: \tint length, plen;",
        "// Line_Reference 3120: ",
        "// Line_Reference 3121: \tparam.v = (sctp_paramhdr_t *) param_hdr;",
        "// Line_Reference 3122: \twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {",
        "// Line_Reference 3123: \t\tlength = ntohs(param.p->length);",
        "// Line_Reference 3124: \t\t*errp = param.p;",
        "// Line_Reference 3126: \t\tif (param.v > chunk_end - length ||",
        "// Line_Reference 3127: \t\t    length < sizeof(sctp_paramhdr_t))",
        "// Line_Reference 3128: \t\t\treturn 0;",
        "// Line_Reference 3134: \t\t\tasconf_param = (sctp_addip_param_t *)param.v;",
        "// Line_Reference 3135: \t\t\tplen = ntohs(asconf_param->param_hdr.length);",
        "// Line_Reference 3136: \t\t\tif (plen < sizeof(sctp_addip_param_t) +",
        "// Line_Reference 3137: \t\t\t    sizeof(sctp_paramhdr_t))",
        "// Line_Reference 3138: \t\t\t\treturn 0;",
        "// Line_Reference 3143: \t\t\t\treturn 0;",
        "// Line_Reference 3144: ",
        "// Line_Reference 3147: \t\t\tbreak;",
        "// Line_Reference 3149: ",
        "// Line_Reference 3150: \t\tparam.v += WORD_ROUND(length);",
        "// Line_Reference 3153: \tif (param.v != chunk_end)",
        "// Line_Reference 3154: \t\treturn 0;",
        "// Line_Reference 3156: \treturn 1;",
        "// Line_Reference 3169: ",
        "// Line_Reference 3174: \tint\tall_param_pass = 1;",
        "// Line_Reference 3202: \twhile (chunk_len > 0) {",
        "// Line_Reference 3204: \t\t\t\t\t\t     asconf_param);",
        "// Line_Reference 3212: \t\tif (SCTP_ERROR_NO_ERROR != err_code)",
        "// Line_Reference 3213: \t\t\tall_param_pass = 0;",
        "// Line_Reference 3214: ",
        "// Line_Reference 3216: \t\t\tsctp_add_asconf_response(asconf_ack,",
        "// Line_Reference 3217: \t\t\t\t\t\t asconf_param->crr_id, err_code,",
        "// Line_Reference 3218: \t\t\t\t\t\t asconf_param);",
        "// Line_Reference 3225: \t\tif (SCTP_ERROR_RSRC_LOW == err_code)",
        "// Line_Reference 3227: ",
        "// Line_Reference 3228: \t\t/* Move to the next ASCONF param. */",
        "// Line_Reference 3229: \t\tlength = ntohs(asconf_param->param_hdr.length);",
        "// Line_Reference 3230: \t\tasconf_param = (void *)asconf_param + length;",
        "// Line_Reference 3231: \t\tchunk_len -= length;",
        "// Line_Reference 3233: "
    ]
}
