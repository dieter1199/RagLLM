{
    "cve_id": "CVE-2023-6039",
    "cve_description": "A use-after-free flaw was found in lan78xx_disconnect in drivers/net/usb/lan78xx.c in the network sub-component, net/usb/lan78xx in the Linux Kernel. This flaw allows a local attacker to crash the system when the LAN78XX USB device detaches.",
    "cve_publish_date": "2023-11-09",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "net: usb: lan78xx: reorder cleanup operations to avoid UAF bugs\n\nThe timer dev->stat_monitor can schedule the delayed work dev->wq and\nthe delayed work dev->wq can also arm the dev->stat_monitor timer.\n\nWhen the device is detaching, the net_device will be deallocated. but\nthe net_device private data could still be dereferenced in delayed work\nor timer handler. As a result, the UAF bugs will happen.\n\nOne racy situation is shown below:\n\n      (Thread 1)                 |      (Thread 2)\nlan78xx_stat_monitor()           |\n ...                             |  lan78xx_disconnect()\n lan78xx_defer_kevent()          |    ...\n  ...                            |    cancel_delayed_work_sync(&dev->wq);\n  schedule_delayed_work()        |    ...\n  (wait some time)               |    free_netdev(net); //free net_device\n  lan78xx_delayedwork()          |\n  //use net_device private data  |\n  dev-> //use                    |\n\nAlthough we use cancel_delayed_work_sync() to cancel the delayed work\nin lan78xx_disconnect(), it could still be scheduled in timer handler\nlan78xx_stat_monitor().\n\nAnother racy situation is shown below:\n\n      (Thread 1)                |      (Thread 2)\nlan78xx_delayedwork             |\n mod_timer()                    |  lan78xx_disconnect()\n                                |   cancel_delayed_work_sync()\n (wait some time)               |   if (timer_pending(&dev->stat_monitor))\n             \t                |       del_timer_sync(&dev->stat_monitor);\n lan78xx_stat_monitor()         |   ...\n  lan78xx_defer_kevent()        |   free_netdev(net); //free\n   //use net_device private data|\n   dev-> //use                  |\n\nAlthough we use del_timer_sync() to delete the timer, the function\ntimer_pending() returns 0 when the timer is activated. As a result,\nthe del_timer_sync() will not be executed and the timer could be\nre-armed.\n\nIn order to mitigate this bug, We use timer_shutdown_sync() to shutdown\nthe timer and then use cancel_delayed_work_sync() to cancel the delayed\nwork. As a result, the net_device could be deallocated safely.\n\nWhat's more, the dev->flags is set to EVENT_DEV_DISCONNECT in\nlan78xx_disconnect(). But it could still be set to EVENT_STAT_UPDATE\nin lan78xx_stat_monitor(). So this patch put the set_bit() behind\ntimer_shutdown_sync().\n\nFixes: 77dfff5bb7e2 (\"lan78xx: Fix race condition in disconnect handling\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "lan78xx.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "5",
    "vulnerable_lines": [
        "// Line_Reference 4227: \tset_bit(EVENT_DEV_DISCONNECT, &dev->flags);",
        "// Line_Reference 4228: ",
        "// Line_Reference 4250: \tif (timer_pending(&dev->stat_monitor))",
        "// Line_Reference 4251: \t\tdel_timer_sync(&dev->stat_monitor);",
        "// Line_Reference 4252: "
    ]
}
