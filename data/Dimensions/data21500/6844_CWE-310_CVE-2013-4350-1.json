{
    "cve_id": "CVE-2013-4350",
    "cve_description": "The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network.",
    "cve_publish_date": "2013-09-25",
    "cwe_id": "CWE-310",
    "cwe_name": "Cryptographic Issues",
    "cwe_description": "Weaknesses in this category are related to the design and implementation of data confidentiality and integrity. Frequently these deal with the use of encoding techniques, encryption libraries, and hashing algorithms. The weaknesses in this category could lead to a degradation of the quality data if they are not addressed.",
    "commit_message": "net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit\n\nAlan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not\nbeing encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport\ndoes not seem to have the desired effect:\n\nSCTP + IPv4:\n\n  22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)\n    192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72\n  22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)\n    192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):\n\nSCTP + IPv6:\n\n  22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)\n    fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp\n    1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]\n\nMoreover, Alan says:\n\n  This problem was seen with both Racoon and Racoon2. Other people have seen\n  this with OpenSwan. When IPsec is configured to encrypt all upper layer\n  protocols the SCTP connection does not initialize. After using Wireshark to\n  follow packets, this is because the SCTP packet leaves Box A unencrypted and\n  Box B believes all upper layer protocols are to be encrypted so it drops\n  this packet, causing the SCTP connection to fail to initialize. When IPsec\n  is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.\n\nIn fact, using `socat sctp6-listen:3333 -` on one end and transferring \"plaintext\"\nstring on the other end, results in cleartext on the wire where SCTP eventually\ndoes not report any errors, thus in the latter case that Alan reports, the\nnon-paranoid user might think he's communicating over an encrypted transport on\nSCTP although he's not (tcpdump ... -X):\n\n  ...\n  0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....\n  0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...\n\nOnly in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the\nreceiver side. Initial follow-up analysis from Alan's bug report was done by\nAlexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.\n\nSCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit().\nThis has the implication that it probably never really got updated along with\nchanges in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.\n\nSCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since\na call to inet6_csk_xmit() would solve this problem, but result in unecessary\nroute lookups, let us just use the cached flowi6 instead that we got through\nsctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(),\nwe do the route lookup / flow caching in sctp_transport_route(), hold it in\ntp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in\nsctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect\nof not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst()\ninstead to get the correct source routed dst entry, which we assign to the skb.\n\nAlso source address routing example from 625034113 (\"sctp: fix sctp to work with\nipv6 source address routing\") still works with this patch! Nevertheless, in RFC5095\nit is actually 'recommended' to not use that anyway due to traffic amplification [1].\nSo it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if\nwe overwrite the flow destination here, the lower IPv6 layer will be unable to\nput the correct destination address into IP header, as routing header is added in\nipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside,\nresult of this patch is that we do not have any XfrmInTmplMismatch increase plus on\nthe wire with this patch it now looks like:\n\nSCTP + IPv6:\n\n  08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:\n    AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72\n  08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:\n    AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296\n\nThis fixes Kernel Bugzilla 24412. This security issue seems to be present since\n2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have\nits fun with that. lksctp-tools IPv6 regression test suite passes as well with\nthis patch.\n\n [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf\n\nReported-by: Alan Chester <alan.chester@tekelec.com>\nReported-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nCc: Hannes Frederic Sowa <hannes@stressinduktion.org>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "ipv6.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "13",
    "number_of_lines_deleted_vulnerable_to_cve": "29",
    "vulnerable_lines": [
        "// Line_Reference 207: /* Based on tcp_v6_xmit() in tcp_ipv6.c. */",
        "// Line_Reference 212: \tstruct flowi6 fl6;",
        "// Line_Reference 213: ",
        "// Line_Reference 214: \tmemset(&fl6, 0, sizeof(fl6));",
        "// Line_Reference 215: ",
        "// Line_Reference 216: \tfl6.flowi6_proto = sk->sk_protocol;",
        "// Line_Reference 217: ",
        "// Line_Reference 218: \t/* Fill in the dest address from the route entry passed with the skb",
        "// Line_Reference 219: \t * and the source address from the transport.",
        "// Line_Reference 220: \t */",
        "// Line_Reference 221: \tfl6.daddr = transport->ipaddr.v6.sin6_addr;",
        "// Line_Reference 222: \tfl6.saddr = transport->saddr.v6.sin6_addr;",
        "// Line_Reference 223: ",
        "// Line_Reference 224: \tfl6.flowlabel = np->flow_label;",
        "// Line_Reference 225: \tIP6_ECN_flow_xmit(sk, fl6.flowlabel);",
        "// Line_Reference 226: \tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)",
        "// Line_Reference 227: \t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;",
        "// Line_Reference 228: \telse",
        "// Line_Reference 229: \t\tfl6.flowi6_oif = sk->sk_bound_dev_if;",
        "// Line_Reference 230: ",
        "// Line_Reference 231: \tif (np->opt && np->opt->srcrt) {",
        "// Line_Reference 232: \t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;",
        "// Line_Reference 233: \t\tfl6.daddr = *rt0->addr;",
        "// Line_Reference 234: \t}",
        "// Line_Reference 237: \t\t skb->len, &fl6.saddr, &fl6.daddr);",
        "// Line_Reference 239: \tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);",
        "// Line_Reference 244: \treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);",
        "// Line_Reference 284: \tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);",
        "// Line_Reference 339: \t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);"
    ]
}
