{
    "cve_id": "CVE-2019-18609",
    "cve_description": "An issue was discovered in amqp_handle_input in amqp_connection.c in rabbitmq-c 0.9.0. There is an integer overflow that leads to heap memory corruption in the handling of CONNECTION_STATE_HEADER. A rogue server could return a malicious frame header that leads to a smaller target_size value than needed. This condition is then carried on to a memcpy function that copies too much data into a heap buffer.",
    "cve_publish_date": "2019-12-01",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "lib: check frame_size is >= INT32_MAX\n\nWhen parsing a frame header, validate that the frame_size is less than\nor equal to INT32_MAX. Given frame_max is limited between 0 and\nINT32_MAX in amqp_login and friends, this does not change the API.\n\nThis prevents a potential buffer overflow when a malicious client sends\na frame_size that is close to UINT32_MAX, in which causes an overflow\nwhen computing state->target_size resulting in a small value there. A\nbuffer is then allocated with the small amount, then memcopy copies the\nframe_size writing to memory beyond the end of the buffer.",
    "type_of_change": "Modification",
    "filename_of_changes": "amqp_connection.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "12",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 290:       /* frame length is 3 bytes in */",
        "// Line_Reference 293:       state->target_size =",
        "// Line_Reference 294:           amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;"
    ]
}
