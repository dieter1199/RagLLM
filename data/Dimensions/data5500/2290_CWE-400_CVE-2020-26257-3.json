{
    "cve_id": "CVE-2020-26257",
    "cve_description": "Matrix is an ecosystem for open federated Instant Messaging and VoIP. Synapse is a reference \"homeserver\" implementation of Matrix. A malicious or poorly-implemented homeserver can inject malformed events into a room by specifying a different room id in the path of a `/send_join`, `/send_leave`, `/invite` or `/exchange_third_party_invite` request. This can lead to a denial of service in which future events will not be correctly sent to other servers over federation. This affects any server which accepts federation requests from untrusted servers. The Matrix Synapse reference implementation before version 1.23.1 the implementation is vulnerable to this injection attack. Issue is fixed in version 1.23.1. As a workaround homeserver administrators could limit access to the federation API to trusted servers (for example via `federation_domain_whitelist`).",
    "cve_publish_date": "2020-12-09",
    "cwe_id": "CWE-400",
    "cwe_name": "Uncontrolled Resource Consumption",
    "cwe_description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "commit_message": "Consistently use room_id from federation request body (#8776)\n\n* Consistently use room_id from federation request body\r\n\r\nSome federation APIs have a redundant `room_id` path param (see\r\nhttps://github.com/matrix-org/matrix-doc/issues/2330). We should make sure we\r\nconsistently use either the path param or the body param, and the body param is\r\neasier.\r\n\r\n* Kill off some references to \"context\"\r\n\r\nOnce upon a time, \"rooms\" were known as \"contexts\". I think this kills of the\r\nlast references to \"contexts\".",
    "type_of_change": "Modification",
    "filename_of_changes": "server.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "33",
    "number_of_lines_deleted_vulnerable_to_cve": "35",
    "vulnerable_lines": [
        "// Line_Reference 443:     PATH = \"/state/(?P<context>[^/]*)/?\"",
        "// Line_Reference 445:     # This is when someone asks for all data for a given context.",
        "// Line_Reference 446:     async def on_GET(self, origin, content, query, context):",
        "// Line_Reference 447:         return await self.handler.on_context_state_request(",
        "// Line_Reference 449:             context,",
        "// Line_Reference 466:     PATH = \"/backfill/(?P<context>[^/]*)/?\"",
        "// Line_Reference 468:     async def on_GET(self, origin, content, query, context):",
        "// Line_Reference 475:         return await self.handler.on_backfill_request(origin, context, versions, limit)",
        "// Line_Reference 490:     PATH = \"/make_join/(?P<context>[^/]*)/(?P<user_id>[^/]*)\"",
        "// Line_Reference 492:     async def on_GET(self, origin, _content, query, context, user_id):",
        "// Line_Reference 514:             origin, context, user_id, supported_versions=supported_versions",
        "// Line_Reference 520:     PATH = \"/make_leave/(?P<context>[^/]*)/(?P<user_id>[^/]*)\"",
        "// Line_Reference 522:     async def on_GET(self, origin, content, query, context, user_id):",
        "// Line_Reference 523:         content = await self.handler.on_make_leave_request(origin, context, user_id)",
        "// Line_Reference 531:         content = await self.handler.on_send_leave_request(origin, content, room_id)",
        "// Line_Reference 541:         content = await self.handler.on_send_leave_request(origin, content, room_id)",
        "// Line_Reference 546:     PATH = \"/event_auth/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"",
        "// Line_Reference 548:     async def on_GET(self, origin, content, query, context, event_id):",
        "// Line_Reference 549:         return await self.handler.on_event_auth(origin, context, event_id)",
        "// Line_Reference 553:     PATH = \"/send_join/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"",
        "// Line_Reference 555:     async def on_PUT(self, origin, content, query, context, event_id):",
        "// Line_Reference 556:         # TODO(paul): assert that context/event_id parsed from path actually",
        "// Line_Reference 558:         content = await self.handler.on_send_join_request(origin, content, context)",
        "// Line_Reference 563:     PATH = \"/send_join/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"",
        "// Line_Reference 567:     async def on_PUT(self, origin, content, query, context, event_id):",
        "// Line_Reference 568:         # TODO(paul): assert that context/event_id parsed from path actually",
        "// Line_Reference 570:         content = await self.handler.on_send_join_request(origin, content, context)",
        "// Line_Reference 575:     PATH = \"/invite/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"",
        "// Line_Reference 577:     async def on_PUT(self, origin, content, query, context, event_id):",
        "// Line_Reference 592:     PATH = \"/invite/(?P<context>[^/]*)/(?P<event_id>[^/]*)\"",
        "// Line_Reference 596:     async def on_PUT(self, origin, content, query, context, event_id):",
        "// Line_Reference 597:         # TODO(paul): assert that context/event_id parsed from path actually",
        "// Line_Reference 619:         content = await self.handler.on_exchange_third_party_invite_request(",
        "// Line_Reference 620:             room_id, content",
        "// Line_Reference 621:         )"
    ]
}
