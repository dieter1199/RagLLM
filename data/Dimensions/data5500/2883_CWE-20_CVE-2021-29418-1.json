{
    "cve_id": "CVE-2021-29418",
    "cve_description": "The netmask package before 2.0.1 for Node.js mishandles certain unexpected characters in an IP address string, such as an octal digit of 9. This (in some situations) allows attackers to bypass access control that is based on IP addresses. NOTE: this issue exists because of an incomplete fix for CVE-2021-28918.",
    "cve_publish_date": "2021-03-30",
    "cwe_id": "CWE-20",
    "cwe_name": "Improper Input Validation",
    "cwe_description": "The product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.",
    "commit_message": "Rewrite byte parsing in full JS without depending on parseInt\n\nThe parseInt function is full of surprises. Instead of trying to find\nall its pitfalls, let's parse bytes manually.",
    "type_of_change": "Modification",
    "filename_of_changes": "netmask.coffee",
    "code_language": "CoffeeScript",
    "number_of_lines_added_for_mitigation": "47",
    "number_of_lines_deleted_vulnerable_to_cve": "17",
    "vulnerable_lines": [
        "// Line_Reference 9:     b = (ip + '').split('.');",
        "// Line_Reference 10:     if b.length is 0 or b.length > 4 then throw new Error('Invalid IP')",
        "// Line_Reference 11:     for byte, i in b",
        "// Line_Reference 12:         if byte and byte[0] == '0'",
        "// Line_Reference 13:             if byte.length > 2 and (byte[1] == 'x' or byte[1] == 'x')",
        "// Line_Reference 14:                 # make sure 0x prefixed bytes are parsed as hex",
        "// Line_Reference 15:                 byte = parseInt(byte, 16)",
        "// Line_Reference 16:             else",
        "// Line_Reference 17:                 # make sure 0 prefixed bytes are parsed as octal",
        "// Line_Reference 18:                 byte = parseInt(byte, 8)",
        "// Line_Reference 19:         else if byte and (byte[0] == ' ' or byte[byte.length-1] == ' ')",
        "// Line_Reference 20:             throw new Error('Invalid IP')",
        "// Line_Reference 21:         else",
        "// Line_Reference 22:             byte = parseInt(byte, 10)",
        "// Line_Reference 23:         if isNaN(byte) then throw new Error(\"Invalid byte: #{byte}\")",
        "// Line_Reference 24:         if byte < 0 or byte > 255 then throw new Error(\"Invalid byte: #{byte}\")",
        "// Line_Reference 25:         b[i] = byte"
    ]
}
