{
    "cve_id": "CVE-2020-26269",
    "cve_description": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
    "cve_publish_date": "2020-12-10",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Completely rewrite `GetMatchingPaths`.\n\nThe current parallel implementation is too complex (lambda inside lambda, two levels of parallelism) and has a read outside of bounds issue.\n\nThe new implementation cleans up artifacts from the previous implementations that were left in the code as it evolves. We add multiple helper functions, and document invariants and preconditions as well as every major step. This way, we fix the security issue and a potential new one which was not caught before\n\nPiperOrigin-RevId: 346146220\nChange-Id: Iec0f44673f43349797bf9944dffe9b2f779137d8",
    "type_of_change": "Modification",
    "filename_of_changes": "file_system_helper.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "185",
    "number_of_lines_deleted_vulnerable_to_cve": "83",
    "vulnerable_lines": [
        "// Line_Reference 64:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
        "// Line_Reference 65:   string eval_pattern = pattern;",
        "// Line_Reference 66:   string dir(io::Dirname(fixed_prefix));",
        "// Line_Reference 67:   // If dir is empty then we need to fix up fixed_prefix and eval_pattern to",
        "// Line_Reference 68:   // include . as the top level directory.",
        "// Line_Reference 69:   if (dir.empty()) {",
        "// Line_Reference 70:     dir = \".\";",
        "// Line_Reference 71:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
        "// Line_Reference 72:     eval_pattern = io::JoinPath(dir, eval_pattern);",
        "// Line_Reference 73:   }",
        "// Line_Reference 74:   bool is_directory = pattern[pattern.size() - 1] == '/';",
        "// Line_Reference 75: #ifdef PLATFORM_WINDOWS",
        "// Line_Reference 76:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
        "// Line_Reference 77: #endif",
        "// Line_Reference 78:   std::vector<string> dirs;",
        "// Line_Reference 79:   if (!is_directory) {",
        "// Line_Reference 80:     dirs.emplace_back(eval_pattern);",
        "// Line_Reference 81:   }",
        "// Line_Reference 82:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
        "// Line_Reference 83:   while (tmp_dir.size() > dir.size()) {",
        "// Line_Reference 84:     dirs.emplace_back(string(tmp_dir));",
        "// Line_Reference 85:     tmp_dir = io::Dirname(tmp_dir);",
        "// Line_Reference 87:   dirs.emplace_back(dir);",
        "// Line_Reference 88:   std::reverse(dirs.begin(), dirs.end());",
        "// Line_Reference 89:   // Setup a parallel BFS to explore everything under dir.",
        "// Line_Reference 90:   std::deque<std::pair<string, int>> dir_q;",
        "// Line_Reference 91:   std::deque<std::pair<string, int>> next_dir_q;",
        "// Line_Reference 92:   dir_q.emplace_back(std::make_pair(dirs[0], 0));",
        "// Line_Reference 93:   Status ret;  // Status to return.",
        "// Line_Reference 94:   mutex results_mutex;",
        "// Line_Reference 95:   condition_variable results_cond;",
        "// Line_Reference 96:   mutex next_que_mutex;",
        "// Line_Reference 97:   condition_variable next_que_cond;",
        "// Line_Reference 98:   while (!dir_q.empty()) {",
        "// Line_Reference 99:     next_dir_q.clear();",
        "// Line_Reference 100:     std::vector<Status> new_rets(dir_q.size());",
        "// Line_Reference 101:     auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,",
        "// Line_Reference 102:                          &is_directory, &dirs, &results_mutex, &results_cond,",
        "// Line_Reference 103:                          &next_que_mutex, &next_que_cond](int i) {",
        "// Line_Reference 104:       string current_dir = dir_q.at(i).first;",
        "// Line_Reference 105:       int dir_index = dir_q.at(i).second;",
        "// Line_Reference 106:       dir_index++;",
        "// Line_Reference 107:       std::vector<string> children;",
        "// Line_Reference 108:       Status s = fs->GetChildren(current_dir, &children);",
        "// Line_Reference 109:       // In case PERMISSION_DENIED is encountered, we bail here.",
        "// Line_Reference 113:       new_rets[i] = s;",
        "// Line_Reference 114:       if (children.empty()) return;",
        "// Line_Reference 115: ",
        "// Line_Reference 116:       // children_dir_status holds is_dir status for children. It can have three",
        "// Line_Reference 117:       // possible values: OK for true; FAILED_PRECONDITION for false; CANCELLED",
        "// Line_Reference 118:       // if we don't calculate IsDirectory (we might do that because there isn't",
        "// Line_Reference 119:       // any point in exploring that child path).",
        "// Line_Reference 120:       std::vector<Status> children_dir_status;",
        "// Line_Reference 121: ",
        "// Line_Reference 122:       // This IsDirectory call can be expensive for some FS. Parallelizing it.",
        "// Line_Reference 123:       children_dir_status.resize(children.size());",
        "// Line_Reference 124:       auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,",
        "// Line_Reference 125:                               is_directory, &children_dir_status](int j) {",
        "// Line_Reference 126:         const string child_path = io::JoinPath(current_dir, children[j]);",
        "// Line_Reference 127:         if (!fs->Match(child_path, dirs[dir_index])) {",
        "// Line_Reference 128:           children_dir_status[j] =",
        "// Line_Reference 130:         } else if (dir_index != dirs.size() - 1) {",
        "// Line_Reference 131:           children_dir_status[j] = fs->IsDirectory(child_path);",
        "// Line_Reference 133:           children_dir_status[j] =",
        "// Line_Reference 134:               is_directory ? fs->IsDirectory(child_path) : Status::OK();",
        "// Line_Reference 139:       for (size_t j = 0; j < children.size(); ++j) {",
        "// Line_Reference 140:         const string child_path = io::JoinPath(current_dir, children[j]);",
        "// Line_Reference 141:         // If the IsDirectory call was cancelled we bail.",
        "// Line_Reference 142:         if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {",
        "// Line_Reference 145:         if (children_dir_status[j].ok()) {",
        "// Line_Reference 146:           if (dir_index != dirs.size() - 1) {",
        "// Line_Reference 147:             mutex_lock lk(next_que_mutex);",
        "// Line_Reference 148:             next_dir_q.emplace_back(std::make_pair(child_path, dir_index));",
        "// Line_Reference 149:             next_que_cond.notify_one();",
        "// Line_Reference 150:           } else {",
        "// Line_Reference 151:             mutex_lock lk(results_mutex);",
        "// Line_Reference 152:             results->emplace_back(child_path);",
        "// Line_Reference 153:             results_cond.notify_one();",
        "// Line_Reference 154:           }",
        "// Line_Reference 158:     ForEach(0, dir_q.size(), handle_level);",
        "// Line_Reference 160:     ret.Update(new_rets[dir_q.size() - 1]);",
        "// Line_Reference 161:     std::swap(dir_q, next_dir_q);",
        "// Line_Reference 163:   return ret;"
    ]
}
