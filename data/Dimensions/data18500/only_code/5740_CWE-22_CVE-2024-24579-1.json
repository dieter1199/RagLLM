// UntarToDirectory writes the contents of the given tar reader to the given destination
visitor := func(entry TarFileEntry) error {
target := filepath.Join(dst, entry.Header.Name)
switch entry.Header.Typeflag {
case tar.TypeDir:
if _, err := os.Stat(target); err != nil {
if err := os.MkdirAll(target, 0755); err != nil {
return err
}
}
case tar.TypeReg:
f, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))
if err != nil {
// limit the reader on each file read to prevent decompression bomb attacks
numBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))
if numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {
return fmt.Errorf("zip read limit hit (potential decompression bomb attack)")
}
if err != nil {
return fmt.Errorf("unable to copy file: %w", err)
}
if err = f.Close(); err != nil {
log.Errorf("failed to close file during untar of path=%q: %w", f.Name(), err)
}
return nil
}
return IterateTar(reader, visitor)
