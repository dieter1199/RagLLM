// GetIDByEpochAndNodeID gets an ATX ID for a given epoch and node ID.
func GetIDByEpochAndNodeID(db sql.Executor, epoch types.EpochID, nodeID types.NodeID) (id types.ATXID, err error) {
stmt.BindInt64(1, int64(epoch))
stmt.BindBytes(2, nodeID.Bytes())
where epoch = ?1 and pubkey = ?2
return types.ATXID{}, fmt.Errorf("exec nodeID %v: %w", nodeID, err)
return types.ATXID{}, fmt.Errorf("exec nodeID %s: %w", nodeID, sql.ErrNotFound)
// IterateIDsByEpoch invokes the specified callback for each ATX ID in a given epoch.
// It stops if the callback returns an error.
func IterateIDsByEpoch(
db sql.Executor,
epoch types.EpochID,
callback func(total int, id types.ATXID) error,
) error {
if sql.IsCached(db) {
// If the slices are cached, let's not do more SELECTs
ids, err := GetIDsByEpoch(context.Background(), db, epoch)
if err != nil {
return err
}
for _, id := range ids {
if err := callback(len(ids), id); err != nil {
return err
}
}
return nil
}
var callbackErr error
var id types.ATXID
total := stmt.ColumnInt(0)
stmt.ColumnBytes(1, id[:])
if callbackErr = callback(total, id); callbackErr != nil {
return false
}
// Get total count in the same select statement to avoid the need for transaction
if _, err := db.Exec(
"select (select count(*) from atxs where epoch = ?1) as total, id from atxs where epoch = ?1;",
enc, dec,
); err != nil {
return fmt.Errorf("exec epoch %v: %w", epoch, err)
return callbackErr
return nil, err
