import { stringToRegex } from "#lib/utils";
import { UnderscoreID, zodId } from "#lib/mongo";
import { bufferToJSON, DocJSON, htmlToJSON, jsonToBuffer } from "#lib/processing";
import { isAuthenticated } from "#lib/middleware";
import { procedure, router } from "#lib/trpc";
FullContentPieceWithAdditionalData,
getContentPiecesCollection
} from "#database/content-pieces";
import { Tag, getTagsCollection, tag } from "#database/tags";
import * as errors from "#lib/errors";
import { getContentsCollection } from "#database/contents";
import { runWebhooks } from "#lib/webhooks";
import { createEventPublisher, createEventSubscription } from "#lib/pub-sub";
import { runGitSyncHook } from "#lib";
type ContentPieceEvent =
| { action: "delete"; userId: string; data: { id: string } }
| { action: "create"; userId: string; data: FullContentPieceWithAdditionalData }
| {
action: "update";
userId: string;
variantId?: string;
data: Partial<FullContentPieceWithAdditionalData> & { id: string };
}
| {
action: "move";
userId: string;
data: {
contentPiece: FullContentPieceWithAdditionalData;
nextReferenceId?: string;
previousReferenceId?: string;
};
};
const publishEvent = createEventPublisher<ContentPieceEvent>((contentGroupId) => {
return `contentPieces:${contentGroupId}`;
});
variantIdOrName?: string
): Promise<{ variantId: ObjectId | null; variantName: string | null }> => {
if (!variantIdOrName) return { variantId: null, variantName: null };
const isId = ObjectId.isValid(variantIdOrName);
...(isId && { _id: new ObjectId(variantIdOrName) }),
...(!isId && { name: variantIdOrName })
return { variantId: variant._id || null, variantName: variant.name || null };
const { variantId, variantName } = await getVariantDetails(ctx.db, input.variant);
{ slug: contentPiece.slug, variant: variantName }
const { variantId, variantName } = await getVariantDetails(ctx.db, input.variant);
{ slug: contentPiece.slug, variant: variantName }
publishEvent(ctx, `${contentPiece.contentGroupId}`, {
const { variantId, variantName } = await getVariantDetails(ctx.db, variant);
contentPieceUpdates.slug = convertToSlug(update.slug || update.title || contentPiece.title);
publishEvent(ctx, `${newContentPiece.contentGroupId}`, {
{ slug: newContentPiece.slug, variant: variantName }
publishEvent(ctx, `${contentPiece.contentGroupId}`, {
publishEvent(
return createEventSubscription<ContentPieceEvent>(
ctx,
`contentPieces:${input.contentGroupId}`
);
export type { ContentPieceEvent };
