<configOption name="transport">
<synopsis>Match against a transport type.</synopsis>
<description>
<para>When using the ip or transport identifier, this option
can be used to match the transport type <literal>(udp or tcp)
</literal> as well.</para>
<para>When omitted, or left empty, which is the default, it
won't match against the transport type.</para>
</description>
</configOption>
/*! The name of the transport type */
AST_STRING_FIELD(transport);
/*! \brief Structure for a socket address with transport */
struct ast_sockaddr_with_tp {
struct ast_sockaddr addr;
char tp[128];
};
struct ast_sockaddr_with_tp *addr_with_tp = arg;
struct ast_sockaddr address = addr_with_tp->addr;
sense = ast_apply_ha(identify->matches, &address);
ast_debug(3, "Address %s matches identify '%s'\n",
ast_sockaddr_stringify(&address),
ast_sorcery_object_get_id(identify));
if (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {
ast_debug(3, "Transport %s matches identify '%s'\n",
addr_with_tp->tp,
ast_sorcery_object_get_id(identify));
return CMP_MATCH;
} else {
ast_debug(3, "Transport %s match not matched identify '%s'\n",
addr_with_tp->tp,
return 0;
}
ast_debug(3, "Address %s does not match identify '%s'\n",
ast_sockaddr_stringify(&address),
struct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };
pj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));
ast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);
ast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);
return common_identify(ip_identify_match_check, &addr_with_tp);
}
static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)
{
char buffer[PJ_INET6_ADDRSTRLEN];
pj_status_t status;
struct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };
union pj_sockaddr sock = rdata->tp_info.transport->local_addr;
pj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));
if (sock.addr.sa_family == PJ_AF_INET6) {
status = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);
if (status == PJ_SUCCESS && !strcmp(buffer, "::")) {
ast_log(LOG_WARNING, "Matching against '::' may be unpredictable.\n");
}
} else {
status = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);
if (status == PJ_SUCCESS && !strcmp(buffer, "0.0.0.0")) {
ast_log(LOG_WARNING, "Matching against '0.0.0.0' may be unpredictable.\n");
}
}
if (status == PJ_SUCCESS) {
ast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);
ast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);
return common_identify(ip_identify_match_check, &addr_with_tp);
} else {
return NULL;
}
static struct ast_sip_endpoint_identifier transport_identifier = {
.identify_endpoint = transport_identify,
};
if (!ast_strlen_zero(identify->transport)) {
if (ast_string_field_set(identify, transport, identify->transport)) {
return -1;
}
}
if (!ast_strlen_zero(ident->transport)) {
ast_str_append(&context->output_buffer, 0, "%*s: %s\n",
indent,
"Transport",
ident->transport);
}
ast_sorcery_object_field_register(ast_sip_get_sorcery(), "identify", "transport", "", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, transport));
ast_sip_register_endpoint_identifier_with_name(&transport_identifier, "transport");
ast_sip_unregister_endpoint_identifier(&transport_identifier);
