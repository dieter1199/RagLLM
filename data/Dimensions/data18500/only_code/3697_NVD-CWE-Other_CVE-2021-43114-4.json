/* Array list to get deltas from notification file */
DEFINE_ARRAY_LIST_STRUCT(deltas_parsed, struct delta_head *);
DEFINE_ARRAY_LIST_FUNCTIONS(deltas_parsed, struct delta_head *, static)
/* Context while reading an update notification */
struct rdr_notification_ctx {
/* Data being parsed */
struct update_notification *notification;
/* Unordered list of deltas */
struct deltas_parsed deltas;
};
if (attr == NULL)
else
if (xml_value == NULL)
return pr_val_err("RRDP file: Couldn't find %s from '%s'",
(attr == NULL ? "string content" : "xml attribute"),
xmlTextReaderConstLocalName(reader));
static int
rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)
{
deltas_parsed_init(&ctx->deltas);
return 0;
}
static void
__delta_head_destroy(struct delta_head **delta_head)
{
delta_head_destroy(*delta_head);
}
static void
rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)
{
if (ctx->deltas.array != NULL)
deltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);
}
struct rdr_notification_ctx *ctx)
struct delta_head *tmp;
unsigned long serial;
error = delta_head_create(&tmp);
error = parse_long(reader, RRDP_ATTR_SERIAL, &serial);
goto delta_destroy;
tmp->serial = serial;
error = parse_doc_data(reader, true, true, &tmp->doc_data);
if (error)
goto delta_destroy;
error = deltas_parsed_add(&ctx->deltas, &tmp);
goto delta_destroy;
return 0;
delta_destroy:
delta_head_destroy(tmp);
static int
order_notification_deltas(struct rdr_notification_ctx *ctx)
{
struct delta_head **ptr;
array_index i;
int error;
error = deltas_head_set_size(ctx->notification->deltas_list,
ctx->deltas.len);
if (error)
return error;
ARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {
error = deltas_head_add(ctx->notification->deltas_list,
ctx->notification->global_data.serial,
(*ptr)->serial,
(*ptr)->doc_data.uri,
(*ptr)->doc_data.hash,
(*ptr)->doc_data.hash_len);
if (!error)
continue;
if (error == -EINVAL)
return pr_val_err("Serial '%lu' at delta elements isn't part of a contiguous list of serials.",
(*ptr)->serial);
if (error == -EEXIST)
return pr_val_err("Duplicated serial '%lu' at delta elements.",
(*ptr)->serial);
return error;
}
/*
* "If delta elements are included, they MUST form a contiguous
* sequence of serial numbers starting at a revision determined by
* the Repository Server, up to the serial number mentioned in the
* notification element."
*
* If all expected elements are set, everything is ok.
*/
if (!deltas_head_values_set(ctx->notification->deltas_list))
return pr_val_err("Deltas listed don't have a contiguous sequence of serial numbers");
return 0;
}
struct rdr_notification_ctx *ctx = arg;
xmlReaderTypes type;
int error;
error = 0;
type = xmlTextReaderNodeType(reader);
switch (type) {
error = parse_notification_delta(reader, ctx);
error = parse_doc_data(reader, true, true,
&ctx->notification->snapshot);
error = parse_global_data(reader,
&ctx->notification->global_data, NULL, 0);
/* Init context for deltas and snapshot */
rdr_notification_ctx_init(ctx);
} else {
return pr_val_err("Unexpected '%s' element", name);
break;
if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {
error = order_notification_deltas(ctx);
rdr_notification_ctx_cleanup(ctx);
return error; /* Error 0 is ok */
}
default:
return 0;
}
if (error) {
rdr_notification_ctx_cleanup(ctx);
return error;
struct rdr_notification_ctx ctx;
struct update_notification *tmp;
char *dup;
dup = strdup(uri_get_global(uri));
if (dup == NULL)
error = update_notification_create(&tmp);
if (error)
return error;
tmp->uri = dup;
ctx.notification = tmp;
&ctx);
update_notification_destroy(tmp);
*file = tmp;
/* Error 0 is ok */
return deltas_head_for_each(parent->deltas_list,
