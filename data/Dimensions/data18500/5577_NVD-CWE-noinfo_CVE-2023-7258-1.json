{
    "cve_id": "CVE-2023-7258",
    "cve_description": "A denial of service exists in Gvisor Sandbox where a bug in reference counting code in mount point tracking could lead to a panic, making it possible for an attacker running as root and with permission to mount volumes to kill the sandbox. We recommend upgrading past commitÂ 6a112c60a257dadac59962e0bc9e9b5aee70b5b6",
    "cve_publish_date": "2024-05-15",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Check for mounts marked as unmounted before propagating.\n\nIf the namespace were set to nil during umount (such as in Linux), checks\nfor mnt.neverConnected() would cover this case. We keep mnt.ns as non-nil,\nso we need to also check umounted in some cases.\n\nPiperOrigin-RevId: 586747189",
    "type_of_change": "Modification",
    "filename_of_changes": "mount.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "70",
    "number_of_lines_deleted_vulnerable_to_cve": "34",
    "vulnerable_lines": [
        "// Line_Reference 36: const MountMax = 10000",
        "// Line_Reference 256: // attachTreeLocked attaches the mount tree at mnt to vd and propagates the",
        "// Line_Reference 257: // mount to vd.mount's peers and followers. This method consumes the reference",
        "// Line_Reference 258: // on vd. It is analogous to fs/namespace.c:attach_recursive_mnt() in Linux.",
        "// Line_Reference 261: func (vfs *VirtualFilesystem) attachTreeLocked(ctx context.Context, mnt *Mount, vd VirtualDentry) error {",
        "// Line_Reference 262: \tmp, err := vfs.lockMountpoint(vd)",
        "// Line_Reference 263: \tif err != nil {",
        "// Line_Reference 264: \t\treturn err",
        "// Line_Reference 265: \t}",
        "// Line_Reference 269: \t\tmp.DecRef(ctx)",
        "// Line_Reference 282: \tvar propMnts map[*Mount]struct{}",
        "// Line_Reference 328: \treturn vfs.attachTreeLocked(ctx, mnt, vd)",
        "// Line_Reference 510: \t\tvfs.delayDecRef(targetVd)",
        "// Line_Reference 514: \tif err := vfs.attachTreeLocked(ctx, clone, targetVd); err != nil {",
        "// Line_Reference 531: \tif mntns := MountNamespaceFromContext(ctx); mntns != nil {",
        "// Line_Reference 532: \t\tvfs.delayDecRef(mntns)",
        "// Line_Reference 533: \t\tif mntns != mnt.ns {",
        "// Line_Reference 534: \t\t\treturn linuxerr.EINVAL",
        "// Line_Reference 535: \t\t}",
        "// Line_Reference 579: \tif mntns := MountNamespaceFromContext(ctx); mntns != nil {",
        "// Line_Reference 580: \t\tvfs.delayDecRef(mntns)",
        "// Line_Reference 581: \t\tif mntns != vd.mount.ns {",
        "// Line_Reference 582: \t\t\treturn linuxerr.EINVAL",
        "// Line_Reference 583: \t\t}",
        "// Line_Reference 584: ",
        "// Line_Reference 585: \t\tif vd.mount == vd.mount.ns.root {",
        "// Line_Reference 586: \t\t\treturn linuxerr.EINVAL",
        "// Line_Reference 587: \t\t}",
        "// Line_Reference 902: \treturn false",
        "// Line_Reference 1102: \tns := MountNamespaceFromContext(ctx)",
        "// Line_Reference 1103: \tvfs.delayDecRef(ns)",
        "// Line_Reference 1104: \tif oldRoot.mount.ns != ns || newRoot.mount.ns != ns {",
        "// Line_Reference 1128: \tvfs.connectLocked(oldRoot.mount, putOld, ns)",
        "// Line_Reference 1132: \tvfs.connectLocked(newRoot.mount, rootMp, ns)"
    ]
}
