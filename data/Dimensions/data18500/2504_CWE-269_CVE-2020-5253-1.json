{
    "cve_id": "CVE-2020-5253",
    "cve_description": "NetHack before version 3.6.0 allowed malicious use of escaping of characters in the configuration file (usually .nethackrc) which could be exploited. This bug is patched in NetHack 3.6.0.",
    "cve_publish_date": "2020-03-10",
    "cwe_id": "CWE-269",
    "cwe_name": "Improper Privilege Management",
    "cwe_description": "The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.",
    "commit_message": "escapes() revamp\n\n     Partial rewrite of escapes(), mostly changing its if-then-else\nlogic so that end-of-string can be checked once instead for each case.\nThe previous version had a bug if the input string ended with backslash\nand one decimal digit (due to being lumped together with the handling\nfor trailing \\X or \\O).",
    "type_of_change": "Modification",
    "filename_of_changes": "options.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "48",
    "number_of_lines_deleted_vulnerable_to_cve": "34",
    "vulnerable_lines": [
        "// Line_Reference 756:  * For 3.4.3 and earlier, ending with \"\\M\", backslash, or caret prior",
        "// Line_Reference 757:  * to terminating '\\0' would pull that '\\0' into the output and then",
        "// Line_Reference 758:  * keep processing past it.  Now, a trailing escape will be handled",
        "// Line_Reference 759:  * as if it was preceded with its own backslash and be kept as is,",
        "// Line_Reference 760:  * with end of string terminator always honored as end of input.",
        "// Line_Reference 768: \tint\tcval = 0, meta = 0;",
        "// Line_Reference 769: ",
        "// Line_Reference 770: \tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {",
        "// Line_Reference 771: \t\tmeta = 1;",
        "// Line_Reference 772: \t\tcp += 2;",
        "// Line_Reference 773: \t}",
        "// Line_Reference 774: \tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {",
        "// Line_Reference 775: \t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";",
        "// Line_Reference 776: \t    const char *dp;",
        "// Line_Reference 777: \t    int dcount = 0;",
        "// Line_Reference 778: ",
        "// Line_Reference 779: \t    cp++;",
        "// Line_Reference 780: \t    if (*cp == 'x' || *cp == 'X')",
        "// Line_Reference 781: \t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)",
        "// Line_Reference 782: \t\t    cval = (cval * 16) + ((int)(dp - hex) / 2);",
        "// Line_Reference 783: \t    else if (*cp == 'o' || *cp == 'O')",
        "// Line_Reference 784: \t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)",
        "// Line_Reference 785: \t\t    cval = (cval * 8) + (*cp - '0');",
        "// Line_Reference 786: \t    else",
        "// Line_Reference 787: \t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)",
        "// Line_Reference 788: \t\t    cval = (cval * 10) + (*cp - '0');",
        "// Line_Reference 789: \t} else if (*cp == '\\\\' && cp[1]) {\t/* C-style character escapes */",
        "// Line_Reference 798: \t    cp++;",
        "// Line_Reference 799: \t} else if (*cp == '^' && cp[1]) { /* expand control-character syntax */",
        "// Line_Reference 800: \t    cval = (*++cp & 0x1f);",
        "// Line_Reference 801: \t    cp++;",
        "// Line_Reference 802: \t} else",
        "// Line_Reference 803: \t    cval = *cp++;",
        "// Line_Reference 807: \t*tp++ = cval;"
    ]
}
