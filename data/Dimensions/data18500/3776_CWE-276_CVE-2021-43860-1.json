{
    "cve_id": "CVE-2021-43860",
    "cve_description": "Flatpak is a Linux application sandboxing and distribution framework. Prior to versions 1.12.3 and 1.10.6, Flatpak doesn't properly validate that the permissions displayed to the user for an app at install time match the actual permissions granted to the app at runtime, in the case that there's a null byte in the metadata file of an app. Therefore apps can grant themselves permissions without the consent of the user. Flatpak shows permissions to the user during install by reading them from the \"xa.metadata\" key in the commit metadata. This cannot contain a null terminator, because it is an untrusted GVariant. Flatpak compares these permissions to the *actual* metadata, from the \"metadata\" file to ensure it wasn't lied to. However, the actual metadata contents are loaded in several places where they are read as simple C-style strings. That means that, if the metadata file includes a null terminator, only the content of the file from *before* the terminator gets compared to xa.metadata. Thus, any permissions that appear in the metadata file after a null terminator are applied at runtime but not shown to the user. So maliciously crafted apps can give themselves hidden permissions. Users who have Flatpaks installed from untrusted sources are at risk in case the Flatpak has a maliciously crafted metadata file, either initially or in an update. This issue is patched in versions 1.12.3 and 1.10.6. As a workaround, users can manually check the permissions of installed apps by checking the metadata file or the xa.metadata key on the commit metadata.",
    "cve_publish_date": "2022-01-12",
    "cwe_id": "CWE-276",
    "cwe_name": "Incorrect Default Permissions",
    "cwe_description": "During installation, installed file permissions are set to allow anyone to modify those files.",
    "commit_message": "Transaction: Fail the resolve if xa.metadata invalid or missing\n\nIf we fail to parse xa.metadata from the summary cache or the commit\nxa.metadata we fail the resolve.\n\nIf xa.metadata is missing in the commit we fail the resolve (it is\nalways set in the summary cache, because summary update converts\nmissing xa.metadata to \"\", so we either get that, or cache miss which\nleads to resolving from the commit.\n\nThis means that op->resolved_metadata is always set during install and\nupdates, which means we will show the app permissions. The transaction\nwill also always make sure that this data actually matches what gets\ndeployed.\n\nBefore this change an invalid metadata in the summary cache could lead\nto a NULL resolved_metadata, which means we wouldn't print the app\npermissions, yet we would still deploy some metadata file that could\nhave permissions. (NOTE: It would fail to deploy unless the\nxa.metadata in the commit matched the metadata file, but in this\ncorner case we would't compare the summary and commit metadata, so\nthey may differ.)",
    "type_of_change": "Modification",
    "filename_of_changes": "flatpak-transaction.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "55",
    "number_of_lines_deleted_vulnerable_to_cve": "29",
    "vulnerable_lines": [
        "// Line_Reference 2973: static void",
        "// Line_Reference 2978:                   GBytes                      *old_metadata)",
        "// Line_Reference 3000:       if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))",
        "// Line_Reference 3001:         {",
        "// Line_Reference 3002:           op->resolved_metadata = g_bytes_ref (metadata);",
        "// Line_Reference 3003:           op->resolved_metakey = g_steal_pointer (&metakey);",
        "// Line_Reference 3004:         }",
        "// Line_Reference 3005:       else",
        "// Line_Reference 3006:         g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));",
        "// Line_Reference 3017:         g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));",
        "// Line_Reference 3021: static void",
        "// Line_Reference 3026:                 GBytes *metadata_bytes)",
        "// Line_Reference 3031:   mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);",
        "// Line_Reference 3036: static void",
        "// Line_Reference 3041:                         GVariant *commit_data)",
        "// Line_Reference 3052:     g_message (\"Warning: No xa.metadata in local commit %s ref %s\", checksum, flatpak_decomposed_get_ref (op->ref));",
        "// Line_Reference 3053:   else",
        "// Line_Reference 3054:     metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));",
        "// Line_Reference 3064:   resolve_op_end (self, op, checksum, sideload_path, metadata_bytes);",
        "// Line_Reference 3072:                               FlatpakRemoteState *state)",
        "// Line_Reference 3112:   resolve_op_end (self, op, checksum, sideload_path, metadata_bytes);",
        "// Line_Reference 3113:   return TRUE;",
        "// Line_Reference 3156:           mark_op_resolved (op, op->resolved_commit, NULL, NULL, NULL);",
        "// Line_Reference 3170:           mark_op_resolved (op, checksum, NULL, metadata_bytes, NULL);",
        "// Line_Reference 3177:           mark_op_resolved (op, op->commit, NULL, op->external_metadata, NULL);",
        "// Line_Reference 3208:           resolve_op_from_commit (self, op, checksum, NULL, commit_data);",
        "// Line_Reference 3267:           if (!try_resolve_op_from_metadata (self, op, checksum, sideload_path, state))",
        "// Line_Reference 3269:               /* Else try to load the commit object.",
        "// Line_Reference 3305:               resolve_op_from_commit (self, op, checksum, sideload_path, commit_data);"
    ]
}
