{
    "cve_id": "CVE-2022-24788",
    "cve_description": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.",
    "cve_publish_date": "2022-04-13",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "Merge pull request from GHSA-j2x6-9323-fp7h\n\nThis commit addresses two issues in validating returndata, both related\nto the inferred type of the external call return.\n\nFirst, it addresses an issue with interfaces imported from JSON. The\nJSON_ABI encoding type was added in 0.3.0 as part of the calling\nconvention refactor to mimic the old code's behavior when the signature\nof a function had `is_from_json` toggled to True. However, both\nimplementations were a workaround for the fact that in\nFunctionSignatures from JSON with Bytes return types, length is set to 1\nas a hack to ensure they always typecheck - almost always resulting in a\nruntime revert.\n\nThis commit removes the JSON_ABI encoding type, so that dynamic\nreturndata from an interface defined with .json ABI file cannot result\nin a buffer overrun(!). To avoid the issue with always runtime\nreverting, codegen uses the uses the inferred ContractFunction type of\nthe Call.func member (which is both more accurate than the inferred type\nof the Call expression, and the return type on the FunctionSignature!)\nto calculate the length of the external Bytes array.\n\nSecond, this commit addresses an issue with validating call returns in\ncomplex expressions. In the following examples, the type of the call\nreturn is either inferred incorrectly or it takes a path through codegen\nwhich avoids generating runtime clamps:\n\n```\ninterface Foo:\n    def returns_int128() -> int128: view\n    def returns_Bytes3() -> Bytes[3]: view\n\nfoo: Foo\n...\nx: uint256 = convert(self.foo.returns_int128(), uint256)\ny: Bytes[32] = concat(self.foo.returns_Bytes3(), b\"\")\n```\n\nTo address this issue, if the type of returndata needs validation, this\ncommit decodes the returndata \"strictly\" into a newly allocated buffer\nat the time of the call, to avoid unvalidated data accidentally getting\ninto the runtime. This does result in extra memory traffic which is a\nperformance hit, but the performance issue can be addressed at a later\ndate with a zero-copy buffering scheme (parent Expr allocates the\nbuffer).\n\nAdditional minor fixes and cleanup:\n- fix compiler panic in new_type_to_old_type for Tuples\n- remove `_should_decode` helper function as it duplicates `needs_clamp`\n- minor optimization in returndatasize check - assert ge uses one fewer\n  instruction than assert gt.",
    "type_of_change": "Modification",
    "filename_of_changes": "external_function.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "5",
    "number_of_lines_deleted_vulnerable_to_cve": "26",
    "vulnerable_lines": [
        "// Line_Reference 7: from vyper.codegen.core import get_element_ptr, getpos, make_setter",
        "// Line_Reference 12: from vyper.codegen.types.types import (",
        "// Line_Reference 13:     BaseType,",
        "// Line_Reference 14:     ByteArrayLike,",
        "// Line_Reference 15:     DArrayType,",
        "// Line_Reference 16:     SArrayType,",
        "// Line_Reference 17:     TupleLike,",
        "// Line_Reference 18:     TupleType,",
        "// Line_Reference 19: )",
        "// Line_Reference 20: from vyper.exceptions import CompilerPanic",
        "// Line_Reference 21: ",
        "// Line_Reference 22: ",
        "// Line_Reference 23: def _should_decode(typ):",
        "// Line_Reference 24:     # either a basetype which needs to be clamped",
        "// Line_Reference 25:     # or a complex type which contains something that",
        "// Line_Reference 26:     # needs to be clamped.",
        "// Line_Reference 27:     if isinstance(typ, BaseType):",
        "// Line_Reference 28:         return typ.typ not in (\"int256\", \"uint256\", \"bytes32\")",
        "// Line_Reference 29:     if isinstance(typ, (ByteArrayLike, DArrayType)):",
        "// Line_Reference 30:         return True",
        "// Line_Reference 31:     if isinstance(typ, SArrayType):",
        "// Line_Reference 32:         return _should_decode(typ.subtype)",
        "// Line_Reference 33:     if isinstance(typ, TupleLike):",
        "// Line_Reference 34:         return any(_should_decode(t) for t in typ.tuple_members())",
        "// Line_Reference 35:     raise CompilerPanic(f\"_should_decode({typ})\")  # pragma: notest",
        "// Line_Reference 56:         if _should_decode(arg.typ):"
    ]
}
