{
    "cve_id": "CVE-2012-2373",
    "cve_description": "The Linux kernel before 3.4.5 on the x86 platform, when Physical Address Extension (PAE) is enabled, does not properly use the Page Middle Directory (PMD), which allows local users to cause a denial of service (panic) via a crafted application that triggers a race condition.",
    "cve_publish_date": "2012-08-09",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "mm: pmd_read_atomic: fix 32bit PAE pmd walk vs pmd_populate SMP race condition\n\nWhen holding the mmap_sem for reading, pmd_offset_map_lock should only\nrun on a pmd_t that has been read atomically from the pmdp pointer,\notherwise we may read only half of it leading to this crash.\n\nPID: 11679  TASK: f06e8000  CPU: 3   COMMAND: \"do_race_2_panic\"\n #0 [f06a9dd8] crash_kexec at c049b5ec\n #1 [f06a9e2c] oops_end at c083d1c2\n #2 [f06a9e40] no_context at c0433ded\n #3 [f06a9e64] bad_area_nosemaphore at c043401a\n #4 [f06a9e6c] __do_page_fault at c0434493\n #5 [f06a9eec] do_page_fault at c083eb45\n #6 [f06a9f04] error_code (via page_fault) at c083c5d5\n    EAX: 01fb470c EBX: fff35000 ECX: 00000003 EDX: 00000100 EBP:\n    00000000\n    DS:  007b     ESI: 9e201000 ES:  007b     EDI: 01fb4700 GS:  00e0\n    CS:  0060     EIP: c083bc14 ERR: ffffffff EFLAGS: 00010246\n #7 [f06a9f38] _spin_lock at c083bc14\n #8 [f06a9f44] sys_mincore at c0507b7d\n #9 [f06a9fb0] system_call at c083becd\n                         start           len\n    EAX: ffffffda  EBX: 9e200000  ECX: 00001000  EDX: 6228537f\n    DS:  007b      ESI: 00000000  ES:  007b      EDI: 003d0f00\n    SS:  007b      ESP: 62285354  EBP: 62285388  GS:  0033\n    CS:  0073      EIP: 00291416  ERR: 000000da  EFLAGS: 00000286\n\nThis should be a longstanding bug affecting x86 32bit PAE without THP.\nOnly archs with 64bit large pmd_t and 32bit unsigned long should be\naffected.\n\nWith THP enabled the barrier() in pmd_none_or_trans_huge_or_clear_bad()\nwould partly hide the bug when the pmd transition from none to stable,\nby forcing a re-read of the *pmd in pmd_offset_map_lock, but when THP is\nenabled a new set of problem arises by the fact could then transition\nfreely in any of the none, pmd_trans_huge or pmd_trans_stable states.\nSo making the barrier in pmd_none_or_trans_huge_or_clear_bad()\nunconditional isn't good idea and it would be a flakey solution.\n\nThis should be fully fixed by introducing a pmd_read_atomic that reads\nthe pmd in order with THP disabled, or by reading the pmd atomically\nwith cmpxchg8b with THP enabled.\n\nLuckily this new race condition only triggers in the places that must\nalready be covered by pmd_none_or_trans_huge_or_clear_bad() so the fix\nis localized there but this bug is not related to THP.\n\nNOTE: this can trigger on x86 32bit systems with PAE enabled with more\nthan 4G of ram, otherwise the high part of the pmd will never risk to be\ntruncated because it would be zero at all times, in turn so hiding the\nSMP race.\n\nThis bug was discovered and fully debugged by Ulrich, quote:\n\n----\n[..]\npmd_none_or_trans_huge_or_clear_bad() loads the content of edx and\neax.\n\n    496 static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t\n    *pmd)\n    497 {\n    498         /* depend on compiler for an atomic pmd read */\n    499         pmd_t pmdval = *pmd;\n\n                                // edi = pmd pointer\n0xc0507a74 <sys_mincore+548>:   mov    0x8(%esp),%edi\n...\n                                // edx = PTE page table high address\n0xc0507a84 <sys_mincore+564>:   mov    0x4(%edi),%edx\n...\n                                // eax = PTE page table low address\n0xc0507a8e <sys_mincore+574>:   mov    (%edi),%eax\n\n[..]\n\nPlease note that the PMD is not read atomically. These are two \"mov\"\ninstructions where the high order bits of the PMD entry are fetched\nfirst. Hence, the above machine code is prone to the following race.\n\n-  The PMD entry {high|low} is 0x0000000000000000.\n   The \"mov\" at 0xc0507a84 loads 0x00000000 into edx.\n\n-  A page fault (on another CPU) sneaks in between the two \"mov\"\n   instructions and instantiates the PMD.\n\n-  The PMD entry {high|low} is now 0x00000003fda38067.\n   The \"mov\" at 0xc0507a8e loads 0xfda38067 into eax.\n----\n\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Larry Woodman <lwoodman@redhat.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "pgtable.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "20",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 464: \t/* depend on compiler for an atomic pmd read */",
        "// Line_Reference 465: \tpmd_t pmdval = *pmd;"
    ]
}
