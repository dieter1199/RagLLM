{
    "cve_id": "CVE-2016-3134",
    "cve_description": "The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
    "cve_publish_date": "2016-04-27",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "netfilter: x_tables: fix unconditional helper\n\nBen Hawkes says:\n\n In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it\n is possible for a user-supplied ipt_entry structure to have a large\n next_offset field. This field is not bounds checked prior to writing a\n counter value at the supplied offset.\n\nProblem is that mark_source_chains should not have been called --\nthe rule doesn't have a next entry, so its supposed to return\nan absolute verdict of either ACCEPT or DROP.\n\nHowever, the function conditional() doesn't work as the name implies.\nIt only checks that the rule is using wildcard address matching.\n\nHowever, an unconditional rule must also not be using any matches\n(no -m args).\n\nThe underflow validator only checked the addresses, therefore\npassing the 'unconditional absolute verdict' test, while\nmark_source_chains also tested for presence of matches, and thus\nproceeeded to the next (not-existent) rule.\n\nUnify this so that all the callers have same idea of 'unconditional rule'.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "ip_tables.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "12",
    "vulnerable_lines": [
        "// Line_Reference 171: static inline bool unconditional(const struct ipt_ip *ip)",
        "// Line_Reference 175: \treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;",
        "// Line_Reference 232: \t\tif (s->target_offset == sizeof(struct ipt_entry) &&",
        "// Line_Reference 235: \t\t   t->verdict < 0 &&",
        "// Line_Reference 236: \t\t   unconditional(&s->ip)) {",
        "// Line_Reference 479: \t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&",
        "// Line_Reference 482: \t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||",
        "// Line_Reference 483: \t\t\t    visited) {",
        "// Line_Reference 718: \tif (!unconditional(&e->ip))",
        "// Line_Reference 766: \t\t\t\tpr_err(\"Underflows must be unconditional and \"",
        "// Line_Reference 767: \t\t\t\t       \"use the STANDARD target with \"",
        "// Line_Reference 768: \t\t\t\t       \"ACCEPT/DROP\\n\");"
    ]
}
