{
    "cve_id": "CVE-2016-2383",
    "cve_description": "The adjust_branches function in kernel/bpf/verifier.c in the Linux kernel before 4.5 does not consider the delta in the backward-jump case, which allows local users to obtain sensitive information from kernel memory by creating a packet filter and then loading crafted BPF instructions.",
    "cve_publish_date": "2016-04-27",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "bpf: fix branch offset adjustment on backjumps after patching ctx expansion\n\nWhen ctx access is used, the kernel often needs to expand/rewrite\ninstructions, so after that patching, branch offsets have to be\nadjusted for both forward and backward jumps in the new eBPF program,\nbut for backward jumps it fails to account the delta. Meaning, for\nexample, if the expansion happens exactly on the insn that sits at\nthe jump target, it doesn't fix up the back jump offset.\n\nAnalysis on what the check in adjust_branches() is currently doing:\n\n  /* adjust offset of jmps if necessary */\n  if (i < pos && i + insn->off + 1 > pos)\n    insn->off += delta;\n  else if (i > pos && i + insn->off + 1 < pos)\n    insn->off -= delta;\n\nFirst condition (forward jumps):\n\n  Before:                         After:\n\n  insns[0]                        insns[0]\n  insns[1] <--- i/insn            insns[1] <--- i/insn\n  insns[2] <--- pos               insns[P] <--- pos\n  insns[3]                        insns[P]  `------| delta\n  insns[4] <--- target_X          insns[P]   `-----|\n  insns[5]                        insns[3]\n                                  insns[4] <--- target_X\n                                  insns[5]\n\nFirst case is if we cross pos-boundary and the jump instruction was\nbefore pos. This is handeled correctly. I.e. if i == pos, then this\nwould mean our jump that we currently check was the patchlet itself\nthat we just injected. Since such patchlets are self-contained and\nhave no awareness of any insns before or after the patched one, the\ndelta is correctly not adjusted. Also, for the second condition in\ncase of i + insn->off + 1 == pos, means we jump to that newly patched\ninstruction, so no offset adjustment are needed. That part is correct.\n\nSecond condition (backward jumps):\n\n  Before:                         After:\n\n  insns[0]                        insns[0]\n  insns[1] <--- target_X          insns[1] <--- target_X\n  insns[2] <--- pos <-- target_Y  insns[P] <--- pos <-- target_Y\n  insns[3]                        insns[P]  `------| delta\n  insns[4] <--- i/insn            insns[P]   `-----|\n  insns[5]                        insns[3]\n                                  insns[4] <--- i/insn\n                                  insns[5]\n\nSecond interesting case is where we cross pos-boundary and the jump\ninstruction was after pos. Backward jump with i == pos would be\nimpossible and pose a bug somewhere in the patchlet, so the first\ncondition checking i > pos is okay only by itself. However, i +\ninsn->off + 1 < pos does not always work as intended to trigger the\nadjustment. It works when jump targets would be far off where the\ndelta wouldn't matter. But, for example, where the fixed insn->off\nbefore pointed to pos (target_Y), it now points to pos + delta, so\nthat additional room needs to be taken into account for the check.\nThis means that i) both tests here need to be adjusted into pos + delta,\nand ii) for the second condition, the test needs to be <= as pos\nitself can be a target in the backjump, too.\n\nFixes: 9bac3d6d548e (\"bpf: allow extended BPF programs access skb fields\")\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "verifier.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 2085: \t\telse if (i > pos && i + insn->off + 1 < pos)"
    ]
}
