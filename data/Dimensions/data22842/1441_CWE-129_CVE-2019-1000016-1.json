{
    "cve_id": "CVE-2019-1000016",
    "cve_description": "FFMPEG version 4.1 contains a CWE-129: Improper Validation of Array Index vulnerability in libavcodec/cbs_av1.c that can result in Denial of service. This attack appears to be exploitable via specially crafted AV1 file has to be provided as input. This vulnerability appears to have been fixed in after commit b97a4b658814b2de8b9f2a3bce491c002d34de31.",
    "cve_publish_date": "2019-02-04",
    "cwe_id": "CWE-129",
    "cwe_name": "Improper Validation of Array Index",
    "cwe_description": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "commit_message": "cbs_av1: Fix reading of overlong uvlc codes\n\nThe specification allows 2^32-1 to be encoded as any number of zeroes\ngreater than 31, followed by a one.  This previously failed because the\ntrace code would overflow the array containing the string representation\nof the bits if there were more than 63 zeroes.  Fix that by splitting the\ntrace output into batches, and at the same time move it out of the default\npath.\n\n(While this seems likely to be a specification error, libaom does support\nit so we probably should as well.)\n\nFrom a test case by keval shah <skeval65@gmail.com>.\n\nReviewed-by: Michael Niedermayer <michael@niedermayer.cc>",
    "type_of_change": "Modification",
    "filename_of_changes": "cbs_av1.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "40",
    "number_of_lines_deleted_vulnerable_to_cve": "18",
    "vulnerable_lines": [
        "// Line_Reference 32:     uint32_t value;",
        "// Line_Reference 33:     int position, zeroes, i, j;",
        "// Line_Reference 34:     char bits[65];",
        "// Line_Reference 39:     zeroes = i = 0;",
        "// Line_Reference 41:         if (get_bits_left(gbc) < zeroes + 1) {",
        "// Line_Reference 47:         if (get_bits1(gbc)) {",
        "// Line_Reference 48:             bits[i++] = '1';",
        "// Line_Reference 50:         } else {",
        "// Line_Reference 51:             bits[i++] = '0';",
        "// Line_Reference 52:             ++zeroes;",
        "// Line_Reference 53:         }",
        "// Line_Reference 59:         value = get_bits_long(gbc, zeroes);",
        "// Line_Reference 60: ",
        "// Line_Reference 61:         for (j = 0; j < zeroes; j++)",
        "// Line_Reference 62:             bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';",
        "// Line_Reference 64:         value += (1 << zeroes) - 1;",
        "// Line_Reference 69:         ff_cbs_trace_syntax_element(ctx, position, name, NULL,",
        "// Line_Reference 70:                                     bits, value);"
    ]
}
