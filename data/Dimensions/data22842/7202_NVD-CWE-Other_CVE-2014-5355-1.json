{
    "cve_id": "CVE-2014-5355",
    "cve_description": "MIT Kerberos 5 (aka krb5) through 1.13.1 incorrectly expects that a krb5_read_message data field is represented as a string ending with a '\\0' character, which allows remote attackers to (1) cause a denial of service (NULL pointer dereference) via a zero-byte version string or (2) cause a denial of service (out-of-bounds read) by omitting the '\\0' character, related to appl/user_user/server.c and lib/krb5/krb/recvauth.c.",
    "cve_publish_date": "2015-02-20",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "Fix krb5_read_message handling [CVE-2014-5355]\n\nIn recvauth_common, do not use strcmp against the data fields of\nkrb5_data objects populated by krb5_read_message(), as there is no\nguarantee that they are C strings.  Instead, create an expected\nkrb5_data value and use data_eq().\n\nIn the sample user-to-user server application, check that the received\nclient principal name is null-terminated before using it with printf\nand krb5_parse_name.\n\nCVE-2014-5355:\n\nIn MIT krb5, when a server process uses the krb5_recvauth function, an\nunauthenticated remote attacker can cause a NULL dereference by\nsending a zero-byte version string, or a read beyond the end of\nallocated storage by sending a non-null-terminated version string.\nThe example user-to-user server application (uuserver) is similarly\nvulnerable to a zero-length or non-null-terminated principal name\nstring.\n\nThe krb5_recvauth function reads two version strings from the client\nusing krb5_read_message(), which produces a krb5_data structure\ncontaining a length and a pointer to an octet sequence.  krb5_recvauth\nassumes that the data pointer is a valid C string and passes it to\nstrcmp() to verify the versions.  If the client sends an empty octet\nsequence, the data pointer will be NULL and strcmp() will dereference\na NULL pointer, causing the process to crash.  If the client sends a\nnon-null-terminated octet sequence, strcmp() will read beyond the end\nof the allocated storage, possibly causing the process to crash.\n\nuuserver similarly uses krb5_read_message() to read a client principal\nname, and then passes it to printf() and krb5_parse_name() without\nverifying that it is a valid C string.\n\nThe krb5_recvauth function is used by kpropd and the Kerberized\nversions of the BSD rlogin and rsh daemons.  These daemons are usually\nrun out of inetd or in a mode which forks before processing incoming\nconnections, so a process crash will generally not result in a\ncomplete denial of service.\n\nThanks to Tim Uglow for discovering this issue.\n\nCVSSv2: AV:N/AC:L/Au:N/C:N/I:N/A:P/E:POC/RL:OF/RC:C\n\n[tlyu@mit.edu: CVSS score]\n\nticket: 8050 (new)\ntarget_version: 1.13.1\ntags: pullup",
    "type_of_change": "Modification",
    "filename_of_changes": "recvauth.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "6",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 80:         if (strcmp(inbuf.data, sendauth_version)) {",
        "// Line_Reference 96:     if (appl_version && strcmp(inbuf.data, appl_version)) {",
        "// Line_Reference 97:         if (!problem) {"
    ]
}
