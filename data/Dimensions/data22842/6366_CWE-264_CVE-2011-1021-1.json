{
    "cve_id": "CVE-2011-1021",
    "cve_description": "drivers/acpi/debugfs.c in the Linux kernel before 3.0 allows local users to modify arbitrary kernel memory locations by leveraging root privileges to write to the /sys/kernel/debug/acpi/custom_method file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2010-4347.",
    "cve_publish_date": "2012-06-21",
    "cwe_id": "CWE-264",
    "cwe_name": "Permissions, Privileges, and Access Controls",
    "cwe_description": "Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",
    "commit_message": "ACPI: Split out custom_method functionality into an own driver\n\nWith /sys/kernel/debug/acpi/custom_method root can write\nto arbitrary memory and increase his priveleges, even if\nthese are restricted.\n\n-> Make this an own debug .config option and warn about the\nsecurity issue in the config description.\n\n-> Still keep acpi/debugfs.c which now only creates an empty\n   /sys/kernel/debug/acpi directory. There might be other\n   users of it later.\n\nSigned-off-by: Thomas Renninger <trenn@suse.de>\nAcked-by: Rafael J. Wysocki <rjw@sisk.pl>\nAcked-by: rui.zhang@intel.com\nSigned-off-by: Len Brown <len.brown@intel.com>",
    "type_of_change": "ModificationType.ADD",
    "filename_of_changes": "debugfs.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "79",
    "vulnerable_lines": [
        "// Line_Reference 6: #include <linux/module.h>",
        "// Line_Reference 7: #include <linux/kernel.h>",
        "// Line_Reference 8: #include <linux/uaccess.h>",
        "// Line_Reference 16: static struct dentry *cm_dentry;",
        "// Line_Reference 17: ",
        "// Line_Reference 18: /* /sys/kernel/debug/acpi/custom_method */",
        "// Line_Reference 19: ",
        "// Line_Reference 20: static ssize_t cm_write(struct file *file, const char __user * user_buf,",
        "// Line_Reference 21: \t\t\tsize_t count, loff_t *ppos)",
        "// Line_Reference 22: {",
        "// Line_Reference 23: \tstatic char *buf;",
        "// Line_Reference 24: \tstatic u32 max_size;",
        "// Line_Reference 25: \tstatic u32 uncopied_bytes;",
        "// Line_Reference 26: ",
        "// Line_Reference 27: \tstruct acpi_table_header table;",
        "// Line_Reference 28: \tacpi_status status;",
        "// Line_Reference 29: ",
        "// Line_Reference 30: \tif (!(*ppos)) {",
        "// Line_Reference 31: \t\t/* parse the table header to get the table length */",
        "// Line_Reference 32: \t\tif (count <= sizeof(struct acpi_table_header))",
        "// Line_Reference 33: \t\t\treturn -EINVAL;",
        "// Line_Reference 34: \t\tif (copy_from_user(&table, user_buf,",
        "// Line_Reference 35: \t\t\t\t   sizeof(struct acpi_table_header)))",
        "// Line_Reference 36: \t\t\treturn -EFAULT;",
        "// Line_Reference 37: \t\tuncopied_bytes = max_size = table.length;",
        "// Line_Reference 38: \t\tbuf = kzalloc(max_size, GFP_KERNEL);",
        "// Line_Reference 39: \t\tif (!buf)",
        "// Line_Reference 40: \t\t\treturn -ENOMEM;",
        "// Line_Reference 41: \t}",
        "// Line_Reference 42: ",
        "// Line_Reference 43: \tif (buf == NULL)",
        "// Line_Reference 44: \t\treturn -EINVAL;",
        "// Line_Reference 45: ",
        "// Line_Reference 46: \tif ((*ppos > max_size) ||",
        "// Line_Reference 47: \t    (*ppos + count > max_size) ||",
        "// Line_Reference 48: \t    (*ppos + count < count) ||",
        "// Line_Reference 49: \t    (count > uncopied_bytes))",
        "// Line_Reference 50: \t\treturn -EINVAL;",
        "// Line_Reference 51: ",
        "// Line_Reference 52: \tif (copy_from_user(buf + (*ppos), user_buf, count)) {",
        "// Line_Reference 53: \t\tkfree(buf);",
        "// Line_Reference 54: \t\tbuf = NULL;",
        "// Line_Reference 55: \t\treturn -EFAULT;",
        "// Line_Reference 56: \t}",
        "// Line_Reference 57: ",
        "// Line_Reference 58: \tuncopied_bytes -= count;",
        "// Line_Reference 59: \t*ppos += count;",
        "// Line_Reference 60: ",
        "// Line_Reference 61: \tif (!uncopied_bytes) {",
        "// Line_Reference 62: \t\tstatus = acpi_install_method(buf);",
        "// Line_Reference 63: \t\tkfree(buf);",
        "// Line_Reference 64: \t\tbuf = NULL;",
        "// Line_Reference 65: \t\tif (ACPI_FAILURE(status))",
        "// Line_Reference 66: \t\t\treturn -EINVAL;",
        "// Line_Reference 67: \t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);",
        "// Line_Reference 68: \t}",
        "// Line_Reference 69: ",
        "// Line_Reference 70: \treturn count;",
        "// Line_Reference 71: }",
        "// Line_Reference 72: ",
        "// Line_Reference 73: static const struct file_operations cm_fops = {",
        "// Line_Reference 74: \t.write = cm_write,",
        "// Line_Reference 75: \t.llseek = default_llseek,",
        "// Line_Reference 76: };",
        "// Line_Reference 77: ",
        "// Line_Reference 78: static int __init acpi_custom_method_init(void)",
        "// Line_Reference 79: {",
        "// Line_Reference 80: \tif (!acpi_debugfs_dir)",
        "// Line_Reference 81: \t\treturn -ENOENT;",
        "// Line_Reference 82: ",
        "// Line_Reference 83: \tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,",
        "// Line_Reference 84: \t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);",
        "// Line_Reference 85: \tif (!cm_dentry)",
        "// Line_Reference 86: \t\treturn -ENODEV;",
        "// Line_Reference 87: ",
        "// Line_Reference 88: \treturn 0;",
        "// Line_Reference 89: }",
        "// Line_Reference 94: ",
        "// Line_Reference 95: \tacpi_custom_method_init();"
    ]
}
