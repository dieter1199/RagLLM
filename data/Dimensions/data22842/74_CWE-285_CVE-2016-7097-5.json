{
    "cve_id": "CVE-2016-7097",
    "cve_description": "The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.",
    "cve_publish_date": "2016-10-16",
    "cwe_id": "CWE-285",
    "cwe_name": "Improper Authorization",
    "cwe_description": "The product does not perform or incorrectly performs an authorization check when an actor attempts to access a resource or perform an action.",
    "commit_message": "posix_acl: Clear SGID bit when setting file permissions\n\nWhen file permissions are modified via chmod(2) and the user is not in\nthe owning group or capable of CAP_FSETID, the setgid bit is cleared in\ninode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file\npermissions as well as the new ACL, but doesn't clear the setgid bit in\na similar way; this allows to bypass the check in chmod(2).  Fix that.\n\nReferences: CVE-2016-7097\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Andreas Gruenbacher <agruenba@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "acl.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "4",
    "number_of_lines_deleted_vulnerable_to_cve": "8",
    "vulnerable_lines": [
        "// Line_Reference 196: \t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);",
        "// Line_Reference 197: \t\t\tif (error < 0)",
        "// Line_Reference 199: \t\t\telse {",
        "// Line_Reference 200: \t\t\t\tinode->i_ctime = ext4_current_time(inode);",
        "// Line_Reference 201: \t\t\t\text4_mark_inode_dirty(handle, inode);",
        "// Line_Reference 202: \t\t\t\tif (error == 0)",
        "// Line_Reference 203: \t\t\t\t\tacl = NULL;",
        "// Line_Reference 204: \t\t\t}"
    ]
}
