{
    "cve_id": "CVE-2014-4654",
    "cve_description": "The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not check authorization for SNDRV_CTL_IOCTL_ELEM_REPLACE commands, which allows local users to remove kernel controls and cause a denial of service (use-after-free and system crash) by leveraging /dev/snd/controlCX access for an ioctl call.",
    "cve_publish_date": "2014-07-03",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "ALSA: control: Fix replacing user controls\n\nThere are two issues with the current implementation for replacing user\ncontrols. The first is that the code does not check if the control is actually a\nuser control and neither does it check if the control is owned by the process\nthat tries to remove it. That allows userspace applications to remove arbitrary\ncontrols, which can cause a user after free if a for example a driver does not\nexpect a control to be removed from under its feed.\n\nThe second issue is that on one hand when a control is replaced the\nuser_ctl_count limit is not checked and on the other hand the user_ctl_count is\nincreased (even though the number of user controls does not change). This allows\nuserspace, once the user_ctl_count limit as been reached, to repeatedly replace\na control until user_ctl_count overflows. Once that happens new controls can be\nadded effectively bypassing the user_ctl_count limit.\n\nBoth issues can be fixed by instead of open-coding the removal of the control\nthat is to be replaced to use snd_ctl_remove_user_ctl(). This function does\nproper permission checks as well as decrements user_ctl_count after the control\nhas been removed.\n\nNote that by using snd_ctl_remove_user_ctl() the check which returns -EBUSY at\nbeginning of the function if the control already exists is removed. This is not\na problem though since the check is quite useless, because the lock that is\nprotecting the control list is released between the check and before adding the\nnew control to the list, which means that it is possible that a different\ncontrol with the same settings is added to the list after the check. Luckily\nthere is another check that is done while holding the lock in snd_ctl_add(), so\nwe'll rely on that to make sure that the same control is not added twice.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "type_of_change": "Modification",
    "filename_of_changes": "control.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "9",
    "number_of_lines_deleted_vulnerable_to_cve": "16",
    "vulnerable_lines": [
        "// Line_Reference 1157: \tif (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)",
        "// Line_Reference 1158: \t\treturn -ENOMEM;",
        "// Line_Reference 1167: \tdown_write(&card->controls_rwsem);",
        "// Line_Reference 1168: \t_kctl = snd_ctl_find_id(card, &info->id);",
        "// Line_Reference 1169: \terr = 0;",
        "// Line_Reference 1170: \tif (_kctl) {",
        "// Line_Reference 1171: \t\tif (replace)",
        "// Line_Reference 1172: \t\t\terr = snd_ctl_remove(card, _kctl);",
        "// Line_Reference 1173: \t\telse",
        "// Line_Reference 1174: \t\t\terr = -EBUSY;",
        "// Line_Reference 1175: \t} else {",
        "// Line_Reference 1176: \t\tif (replace)",
        "// Line_Reference 1177: \t\t\terr = -ENOENT;",
        "// Line_Reference 1179: \tup_write(&card->controls_rwsem);",
        "// Line_Reference 1180: \tif (err < 0)",
        "// Line_Reference 1181: \t\treturn err;"
    ]
}
