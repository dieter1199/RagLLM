{
    "cve_id": "CVE-2015-1331",
    "cve_description": "lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.",
    "cve_publish_date": "2015-08-12",
    "cwe_id": "CWE-59",
    "cwe_name": "Improper Link Resolution Before File Access ('Link Following')",
    "cwe_description": "The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",
    "commit_message": "CVE-2015-1331: lxclock: use /run/lxc/lock rather than /run/lock/lxc\n\nThis prevents an unprivileged user to use LXC to create arbitrary file\non the filesystem.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nSigned-off-by: Tyler Hicks <tyhicks@canonical.com>\nAcked-by: St√©phane Graber <stgraber@ubuntu.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "lxclock.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "10",
    "number_of_lines_deleted_vulnerable_to_cve": "37",
    "vulnerable_lines": [
        "// Line_Reference 106: \t * \"/run\" + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if root",
        "// Line_Reference 108: \t * $XDG_RUNTIME_DIR + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root",
        "// Line_Reference 111: \t/* length of \"/lock/lxc/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */",
        "// Line_Reference 112: \tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;",
        "// Line_Reference 123: \tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);",
        "// Line_Reference 131: \t\t/* fall back to \"/tmp/\" + $(id -u) + \"/lxc\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0'",
        "// Line_Reference 132: \t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)",
        "// Line_Reference 133: \t\t * * lxcpath always starts with '/'",
        "// Line_Reference 134: \t\t */",
        "// Line_Reference 135: \t\tint l2 = 22 + strlen(n) + strlen(p);",
        "// Line_Reference 136: \t\tif (l2 > len) {",
        "// Line_Reference 137: \t\t\tchar *d;",
        "// Line_Reference 138: \t\t\td = realloc(dest, l2);",
        "// Line_Reference 139: \t\t\tif (!d) {",
        "// Line_Reference 140: \t\t\t\tfree(dest);",
        "// Line_Reference 141: \t\t\t\tfree(rundir);",
        "// Line_Reference 142: \t\t\t\treturn NULL;",
        "// Line_Reference 143: \t\t\t}",
        "// Line_Reference 144: \t\t\tlen = l2;",
        "// Line_Reference 145: \t\t\tdest = d;",
        "// Line_Reference 146: \t\t}",
        "// Line_Reference 147: \t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);",
        "// Line_Reference 148: \t\tif (ret < 0 || ret >= len) {",
        "// Line_Reference 149: \t\t\tfree(dest);",
        "// Line_Reference 150: \t\t\tfree(rundir);",
        "// Line_Reference 151: \t\t\treturn NULL;",
        "// Line_Reference 152: \t\t}",
        "// Line_Reference 153: \t\tret = mkdir_p(dest, 0755);",
        "// Line_Reference 154: \t\tif (ret < 0) {",
        "// Line_Reference 155: \t\t\tfree(dest);",
        "// Line_Reference 156: \t\t\tfree(rundir);",
        "// Line_Reference 157: \t\t\treturn NULL;",
        "// Line_Reference 158: \t\t}",
        "// Line_Reference 159: \t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);",
        "// Line_Reference 160: \t} else",
        "// Line_Reference 161: \t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);",
        "// Line_Reference 164: "
    ]
}
