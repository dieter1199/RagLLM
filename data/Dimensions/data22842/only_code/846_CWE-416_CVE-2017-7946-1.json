if (!parse_dylib(bin, off)){
bin->dyld_info = malloc (sizeof(struct dyld_info_command));
if (off + sizeof (struct dyld_info_command) > bin->size){
bprintf ("Cannot parse dyldinfo\n");
free (bin->dyld_info);
return false;
}
if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {
free (bin->dyld_info);
bin->dyld_info = NULL;
bprintf ("Error: read (LC_DYLD_INFO) at 0x%08"PFMT64x"\n", off);
} else {
bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);
bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);
bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);
bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);
bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);
bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);
bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);
bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);
bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);
bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);
bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);
bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);
if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)
bin->dyld_info->lazy_bind_off + lazy_size > bin->size)
if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)
if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))
if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)
if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))
if (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {
if (!bin->nlibs)
if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))
if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)
for (i = 0; i < bin->nsegs; ++i)
if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)
if (entry > bin->size || entry + sizeof (b) > bin->size)
