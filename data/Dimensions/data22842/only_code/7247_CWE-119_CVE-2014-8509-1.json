Copyright (c) 2008-2012, Arvid Norberg
#define TORRENT_FAIL_BDECODE(code) \
{ \
ec = make_error_code(code); \
while (!stack.empty()) { \
top = stack.back(); \
if (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t) top->pop(); \
stack.pop_back(); \
} \
if (error_pos) *error_pos = start - orig_start; \
return -1; \
bool is_digit(char c) { return c >= '0' && c <= '9'; }
bool is_print(char c) { return c >= 32 && c < 127; }
char const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)
if (!is_digit(*start)) { return 0; }
val += *start - '0';
while (start < end)
if (!is_digit(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);
start = parse_int(start, end, ':', len);
if (start == 0 || start + len + 3 > end || *start != ':')
TORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);
if (!is_digit(t))
start = parse_int(start, end, ':', len);
if (start == 0 || start + len + 1 > end || *start != ':')
TORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);
parse_int(negative?m_data.start+1:m_data.start, m_data.start + m_size, 'e', val);
using namespace std;
if (is_print((unsigned char)str[i])) continue;
ret += e.string_value();
for (int i = 0; i < e.string_length(); ++i)
char tmp[5];
snprintf(tmp, sizeof(tmp), "%02x", (unsigned char)str[i]);
ret += tmp;