done := make(chan struct{})
reverseExpandQuery.Execute(ctx, &ReverseExpandRequest{
done <- struct{}{}
require.NoError(t, res.Err)
case <-done:
t.Log("OK!")
return
require.FailNow(t, "timed out")
done := make(chan struct{})
reverseExpandQuery.Execute(timeoutCtx, &ReverseExpandRequest{
done <- struct{}{}
case res, open := <-resultChan:
if open {
require.Error(t, res.Err)
} else {
require.Nil(t, res)
<-done
case <-done:
// OK!
done := make(chan struct{})
reverseExpandQuery.Execute(ctx, &ReverseExpandRequest{
done <- struct{}{}
go func() {
<-resultChan
// We want to read resultChan twice because Next() will fail after first read
<-resultChan
cancelFunc()
}()
select {
case <-done:
return
case <-time.After(30 * time.Millisecond):
require.FailNow(t, "timed out")
