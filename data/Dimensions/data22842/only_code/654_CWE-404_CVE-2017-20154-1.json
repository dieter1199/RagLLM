bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
bool* pfMissingInputs)
{
if(nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY))
return error("CTxMemPool::accept() : not enough fees");
if (nFees < MIN_RELAY_TX_FEE)
{
static CCriticalSection cs;
{
LOCK(cs);
// Use an exponentially decaying ~10-minute window:
dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));
nLastTime = nNow;
// -limitfreerelay unit is thousand-bytes-per-minute
// At default rate it would take over a month to fill 1GB
if (dFreeCount > GetArg("-limitfreerelay", 15)*10*1000 && !IsFromMe(tx))
return error("CTxMemPool::accept() : free transaction rejected by rate limiter");
if (fDebug)
printf("Rate limit dFreeCount: %g => %g\n", dFreeCount, dFreeCount+nTxSize);
dFreeCount += nTxSize;
}
bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)
{
return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);
bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {
return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));
tx.AcceptToMemoryPool(txdb, fCheckInputs);
return AcceptToMemoryPool(txdb, fCheckInputs);
tx.AcceptToMemoryPool(txdb, false);
if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))
{
if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))
{
else if (!fMissingInputs2)
{
// invalid orphan
printf("   removed invalid orphan tx %s\n", inv.hash.ToString().substr(0,10).c_str());