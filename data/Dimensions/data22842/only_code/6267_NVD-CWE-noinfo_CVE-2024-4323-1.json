static struct flb_input_instance *find_input(struct flb_hs *hs, const char *name)
if (strcmp(name, in->name) == 0) {
static int enable_trace_input(struct flb_hs *hs, const char *name, const char *prefix, const char *output_name, struct mk_list *props)
in = find_input(hs, name);
return (in->chunk_trace_ctxt == NULL ? 503 : 0);
static int disable_trace_input(struct flb_hs *hs, const char *name)
in = find_input(hs, name);
if (request->real_path.len < strlen(base)) {
return flb_sds_create_len(&request->real_path.data[strlen(base)],
request->real_path.len - strlen(base));
static int http_disable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)
toggled_on = disable_trace_input(hs, input_name);
msgpack_pack_str_with_body(mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(mp_pck, "ok", strlen("ok"));
static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *result, const char *input_name)
if (result->data.type == MSGPACK_OBJECT_MAP) {
toggled_on = enable_trace_input(hs, input_name, prefix, output_name, props);
static int http_enable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)
ret = enable_trace_input(hs, input_name, "trace.", "stdout", NULL);
msgpack_pack_str_with_body(mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(mp_pck, "ok", strlen("ok"));
flb_error("unable to enable tracing for %s", input_name);
flb_error("unable to unpack msgpack parameters for %s", input_name);
ret = enable_trace_input(hs, input_name, prefix, output_name, props);
input_instance = find_input(hs, input_name);
msgpack_pack_str_with_body(mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(mp_pck, "ok", strlen("ok"));
response = http_enable_trace(request, data, input_name, &mp_pck);
response = http_disable_trace(request, data, input_name, &mp_pck);
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "not found", strlen("not found"));
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
flb_sds_t input_name;
if (result.data.via.map.ptr[i].key.via.str.size < strlen("inputs")) {
if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, "inputs", strlen("inputs"))) {
msgpack_pack_str_with_body(&mp_pck, "inputs", strlen("inputs"));
input_name = flb_sds_create_len(inputs->ptr[i].via.str.ptr, inputs->ptr[i].via.str.size);
msgpack_pack_str_with_body(&mp_pck, input_name, flb_sds_len(input_name));
if (inputs->ptr[i].type != MSGPACK_OBJECT_STR) {
msgpack_pack_map(&mp_pck, 1);
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
else {
if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {
ret = msgpack_params_enable_trace((struct flb_hs *)data, &result, input_name);
if (ret != 0) {
msgpack_pack_map(&mp_pck, 2);
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
msgpack_pack_str_with_body(&mp_pck, "returncode", strlen("returncode"));
msgpack_pack_int64(&mp_pck, ret);
}
else {
msgpack_pack_map(&mp_pck, 1);
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "ok", strlen("ok"));
}
}
else if (request->method == MK_METHOD_DELETE) {
disable_trace_input((struct flb_hs *)data, input_name);
msgpack_pack_map(&mp_pck, 2);
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
msgpack_pack_str_with_body(&mp_pck, "message", strlen("message"));
msgpack_pack_str_with_body(&mp_pck, "method not allowed", strlen("method not allowed"));
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "not found", strlen("not found"));
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "error", strlen("error"));
msgpack_pack_str_with_body(&mp_pck, "message", strlen("message"));
msgpack_pack_str_with_body(&mp_pck, "unknown error", strlen("unknown error"));
msgpack_pack_str_with_body(&mp_pck, "status", strlen("status"));
msgpack_pack_str_with_body(&mp_pck, "ok", strlen("ok"));
mk_vhost_handler(hs->ctx, hs->vid, "/api/v1/traces/", cb_traces, hs);
mk_vhost_handler(hs->ctx, hs->vid, "/api/v1/trace/*", cb_trace, hs);
