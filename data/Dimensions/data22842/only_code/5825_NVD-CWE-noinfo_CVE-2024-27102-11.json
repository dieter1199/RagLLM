"syscall"
"github.com/karrick/godirwalk"
// Update the last time that a disk space lookup was performed.
// Returns the maximum amount of disk space that this Filesystem instance is allowed to use.
return atomic.LoadInt64(&fs.diskLimit)
// Sets the disk space limit for this Filesystem instance.
atomic.SwapInt64(&fs.diskLimit, i)
log.WithField("root", fs.root).WithField("error", err).Warn("failed to determine root fs directory size")
return atomic.LoadInt64(&fs.diskUsed)
log.WithField("root", fs.root).WithField("error", err).Warn("failed to update fs disk usage from within routine")
return atomic.LoadInt64(&fs.diskUsed), nil
atomic.StoreInt64(&fs.diskUsed, size)
// Determines the directory size of a given location by running parallel tasks to iterate
// through all of the folders. Returns the size in bytes. This can be a fairly taxing operation
// on locations with tons of files, so it is recommended that you cache the output.
func (fs *Filesystem) DirectorySize(dir string) (int64, error) {
d, err := fs.SafePath(dir)
var size int64
var st syscall.Stat_t
err = godirwalk.Walk(d, &godirwalk.Options{
Unsorted: true,
Callback: func(p string, e *godirwalk.Dirent) error {
// If this is a symlink then resolve the final destination of it before trying to continue walking
// over its contents. If it resolves outside the server data directory just skip everything else for
// it. Otherwise, allow it to continue.
if e.IsSymlink() {
if _, err := fs.SafePath(p); err != nil {
if IsErrorCode(err, ErrCodePathResolution) {
return godirwalk.SkipThis
}
return err
}
}
if !e.IsDir() {
_ = syscall.Lstat(p, &st)
atomic.AddInt64(&size, st.Size)
}
},
})
return size, errors.WrapIf(err, "server/filesystem: directorysize: failed to walk directory")
// Helper function to determine if a server has space available for a file of a given size.
// If space is available, no error will be returned, otherwise an ErrNotEnoughSpace error
// will be raised.
if fs.MaxDisk() == 0 {
return nil
}
s, err := fs.DiskUsage(true)
if err != nil {
return err
}
if (s + size) > fs.MaxDisk() {
size := atomic.LoadInt64(&fs.diskUsed)
// Sorry go gods. This is ugly but the best approach I can come up with for right
// now without completely re-evaluating the logic we use for determining disk space.
//
// Normally I would just be using the atomic load right below, but I'm not sure about
// the scenarios where it is 0 because nothing has run that would trigger a disk size
// calculation?
//
// Perhaps that isn't even a concern for the sake of this?
if !fs.isTest {
size, _ = fs.DiskUsage(true)
}
// If we're dropping below 0 somehow just cap it to 0.
if (size + i) < 0 {
return atomic.SwapInt64(&fs.diskUsed, 0)
}
return atomic.AddInt64(&fs.diskUsed, i)
