#define sem_unlock(sma)		ipc_unlock(&(sma)->sem_perm)
static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)
spin_lock(&ipcp->lock);
spin_unlock(&ipcp->lock);
static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
int id)
{
struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
if (IS_ERR(ipcp))
return ERR_CAST(ipcp);
return container_of(ipcp, struct sem_array, sem_perm);
}
ipc_lock_by_ptr(&sma->sem_perm);
ipc_rcu_getref(sma);
ipc_unlock(&(sma)->sem_perm);
ipc_lock_by_ptr(&sma->sem_perm);
ipc_rcu_putref(sma);
ipc_unlock(&(sma)->sem_perm);
spin_lock(&(sma)->sem_perm.lock);
ipc_rcu_getref(sma);
ipc_unlock(&(sma)->sem_perm);
for (i = 0; i < nsems; i++)
sem_unlock(sma);
sem_unlock(sma);
int nsems;
sma = sem_lock_check(ns, semid);
if (IS_ERR(sma))
return PTR_ERR(sma);
nsems = sma->sem_nsems;
err = -EACCES;
if (ipcperms(ns, &sma->sem_perm, S_IWUGO))
goto out_unlock;
if (err)
goto out_unlock;
err = -EINVAL;
if(semnum < 0 || semnum >= nsems)
goto out_unlock;
err = -ERANGE;
if (val > SEMVMX || val < 0)
goto out_unlock;
err = 0;
out_unlock:
sem_unlock(sma);
return err;
sem_unlock(sma);
}
spin_lock(&sma->sem_perm.lock);
sem_unlock(sma);
ipc_rcu_getref(sma);
sem_unlock(sma);
spin_lock(&sma->sem_perm.lock);
sem_unlock(sma);
ipc_lock_object(&sma->sem_perm);
ipc_lock_object(&sma->sem_perm);
sem_unlock(sma);
int nsems;
int error;
ipc_rcu_getref(sma);
sem_unlock(sma);
sem_unlock(sma);
int undos = 0, alter = 0, max;
} else
INIT_LIST_HEAD(&tasks);
rcu_read_lock();
if (un)
rcu_read_unlock();
ipc_lock_object(&sma->sem_perm);
if (un) {
if (un->semid == -1) {
rcu_read_unlock();
goto out_unlock_free;
} else {
/*
* rcu lock can be released, "un" cannot disappear:
* - sem_lock is acquired, thus IPC_RMID is
*   impossible.
* - exit_sem is impossible, it always operates on
*   current (or a dead task).
*/
rcu_read_unlock();
}
}
sem_unlock(sma);
sma = sem_obtain_lock(ns, semid);
sem_unlock(sma);
int semid;
int i;
rcu_read_unlock();
if (semid == -1)
sma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);
if (IS_ERR(sma))
sem_unlock(sma);
sem_unlock(sma);
