"os"
"path/filepath"
// Parses a given configuration file and updates all of the values within as defined
// in the API response from the Panel.
func (f *ConfigurationFile) Parse(path string, internal bool) error {
log.WithField("path", path).WithField("parser", f.Parser.String()).Debug("parsing server configuration file")
err = f.parsePropertiesFile(path)
break
err = f.parseTextFile(path)
break
err = f.parseYamlFile(path)
break
err = f.parseJsonFile(path)
break
err = f.parseIniFile(path)
break
err = f.parseXmlFile(path)
break
if errors.Is(err, os.ErrNotExist) {
// File doesn't exist, we tried creating it, and same error is returned? Pretty
// sure this pathway is impossible, but if not, abort here.
if internal {
return nil
}
b := strings.TrimSuffix(path, filepath.Base(path))
if err := os.MkdirAll(b, 0o755); err != nil {
return errors.WithMessage(err, "failed to create base directory for missing configuration file")
} else {
if _, err := os.Create(path); err != nil {
return errors.WithMessage(err, "failed to create missing configuration file")
}
}
return f.Parse(path, true)
}
func (f *ConfigurationFile) parseXmlFile(path string) error {
file, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)
if err != nil {
return err
}
defer file.Close()
// If you don't truncate the file you'll end up duplicating the data in there (or just appending
// to the end of the file. We don't want to do that.
// Move the cursor to the start of the file to avoid weird spacing issues.
file.Seek(0, 0)
// Truncate the file before attempting to write the changes.
if err := os.Truncate(path, 0); err != nil {
// Write the XML to the file.
_, err = doc.WriteTo(file)
return err
func (f *ConfigurationFile) parseIniFile(path string) error {
// Ini package can't handle a non-existent file, so handle that automatically here
// by creating it if not exists. Then, immediately close the file since we will use
// other methods to write the new contents.
file, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0o644)
if err != nil {
return err
}
file.Close()
cfg, err := ini.Load(path)
return cfg.SaveTo(path)
func (f *ConfigurationFile) parseJsonFile(path string) error {
b, err := readFileBytes(path)
output := []byte(data.StringIndent("", "    "))
return os.WriteFile(path, output, 0o644)
func (f *ConfigurationFile) parseYamlFile(path string) error {
b, err := readFileBytes(path)
return os.WriteFile(path, marshaled, 0o644)
func (f *ConfigurationFile) parseTextFile(path string) error {
input, err := os.ReadFile(path)
if err != nil {
return err
}
lines := strings.Split(string(input), "\n")
for i, line := range lines {
if !strings.HasPrefix(line, replace.Match) {
lines[i] = replace.ReplaceWith.String()
if err := os.WriteFile(path, []byte(strings.Join(lines, "\n")), 0o644); err != nil {
func (f *ConfigurationFile) parsePropertiesFile(path string) error {
var s strings.Builder
// Open the file and attempt to load any comments that currenty exist at the start
// of the file. This is kind of a hack, but should work for a majority of users for
// the time being.
if fd, err := os.Open(path); err != nil {
return errors.Wrap(err, "parser: could not open file for reading")
} else {
scanner := bufio.NewScanner(fd)
// Scan until we hit a line that is not a comment that actually has content
// on it. Keep appending the comments until that time.
for scanner.Scan() {
text := scanner.Text()
if len(text) > 0 && text[0] != '#' {
break
}
s.WriteString(text + "\n")
}
_ = fd.Close()
if err := scanner.Err(); err != nil {
return errors.WithStackIf(err)
p, err := properties.LoadFile(path, properties.UTF8)
// Open the file for writing.
w, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)
if err != nil {
defer w.Close()
if _, err := w.Write([]byte(s.String())); err != nil {
