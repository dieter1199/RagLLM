for argument in self.arguments.into_iter() {
for argument in self.arguments.into_iter() {
let arguments = self.pop_arguments_llvm_log::<D, 2>(context)?;
let arguments = self.pop_arguments_llvm_log::<D, 3>(context)?;
let arguments = self.pop_arguments_llvm_log::<D, 4>(context)?;
let arguments = self.pop_arguments_llvm_log::<D, 5>(context)?;
let arguments = self.pop_arguments_llvm_log::<D, 6>(context)?;
for expression in self.arguments.drain(0..N) {
for expression in self.arguments.drain(0..N) {
Ok(arguments.try_into().expect("Always successful"))
}
///
/// Pops the specified number of arguments, converted into their LLVM values.
///
/// This function inverts the order of event topics, taking into account its behavior in EVM.
///
fn pop_arguments_llvm_log<'ctx, D, const N: usize>(
&mut self,
context: &mut compiler_llvm_context::Context<'ctx, D>,
) -> anyhow::Result<[inkwell::values::BasicValueEnum<'ctx>; N]>
where
D: compiler_llvm_context::Dependency,
{
self.arguments[2..].reverse();
let mut arguments = Vec::with_capacity(N);
for expression in self.arguments.drain(0..N) {
arguments.push(expression.into_llvm(context)?.expect("Always exists").value);
}
arguments[2..].reverse();
