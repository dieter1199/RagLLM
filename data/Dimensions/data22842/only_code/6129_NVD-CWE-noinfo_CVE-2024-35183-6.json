"errors"
"github.com/wolfi-dev/wolfictl/pkg/git/submodules"
Auth:              wgit.GetGitAuth(),
// if mapping data has a strip prefix, add it back in to the version for when updating git modules
latestVersionWithPrefix := newVersion.Version
ghm := o.PackageConfigs[packageName].Config.Update.GitHubMonitor
if ghm != nil {
if ghm.StripPrefix != "" {
latestVersionWithPrefix = ghm.StripPrefix + latestVersionWithPrefix
}
}
// some repos could use git submodules, let's check if a submodule file exists and bump any matching packages
err = o.updateGitModules(root, packageName, latestVersionWithPrefix, worktree)
if err != nil {
return fmt.Sprintf("failed to update git modules: %s", err.Error()), nil
}
// some melange config repos use submodules to pull in git repositories into the source dir before the melange pipelines run
// this function is a noop if no git submodules exist
func (o *Options) updateGitModules(dir, packageName, version string, wt *git.Worktree) error {
// if no gitmodules file exist this in a noop
if _, err := os.Stat(filepath.Join(dir, ".gitmodules")); errors.Is(err, os.ErrNotExist) {
return nil
}
ghm := o.PackageConfigs[packageName].Config.Update.GitHubMonitor
if ghm == nil {
o.Logger.Printf("package %s  is not a github repo in mapping data, not attempting to bump gitmodules", packageName)
return nil
}
if ghm.Identifier == "" {
o.Logger.Printf("no identifier found in mapping data for package %s, not attempting to bump gitmodules", packageName)
return nil
}
parts := strings.Split(ghm.Identifier, "/")
if len(parts) != 2 {
o.Logger.Printf("identifier doesn't look like a github owner/repo in mapping data for package %s, not attempting to bump gitmodules", packageName)
return nil
}
return submodules.Update(dir, parts[0], parts[1], version, wt)
}
Auth:       wgit.GetGitAuth(),
Progress:   os.Stdout, // todo remove if this doesn't help: extra logging to help debug intermittent "object not found" when pushing
