pts := strings.Split(vector, "/")
if len(pts) != 6 && len(pts) != 9 && len(pts) != 14 {
Base: Base{},
Temporal: Temporal{
Exploitability:   "ND",
RemediationLevel: "ND",
ReportConfidence: "ND",
Environmental: Environmental{
CollateralDamagePotential:  "ND",
TargetDistribution:         "ND",
ConfidentialityRequirement: "ND",
IntegrityRequirement:       "ND",
AvailabilityRequirement:    "ND",
// Parse metrics in order
slcs := [][]string{
{"AV", "AC", "Au", "C", "I", "A"}, // Base metrics
{"E", "RL", "RC"},                 // Temporal metrics
{"CDP", "TD", "CR", "IR", "AR"},   // Environmental metrics
}
currSlc := slcs[slci]
if abv != currSlc[i] {
if i == len(currSlc) {
currSlc = slcs[slci]
s := ""
s += "AV:" + cvss20.AccessVector
s += "/AC:" + cvss20.AccessComplexity
s += "/Au:" + cvss20.Authentication
s += "/C:" + cvss20.ConfidentialityImpact
s += "/I:" + cvss20.IntegrityImpact
s += "/A:" + cvss20.AvailabilityImpact
// Temporal, if any is defined
if cvss20.Exploitability != "ND" || cvss20.RemediationLevel != "ND" || cvss20.ReportConfidence != "ND" {
s += "/E:" + cvss20.Exploitability
s += "/RL:" + cvss20.RemediationLevel
s += "/RC:" + cvss20.ReportConfidence
// Environmental, if any is defined
if cvss20.CollateralDamagePotential != "ND" || cvss20.TargetDistribution != "ND" || cvss20.ConfidentialityRequirement != "ND" || cvss20.IntegrityRequirement != "ND" || cvss20.AvailabilityRequirement != "ND" {
s += "/CDP:" + cvss20.CollateralDamagePotential
s += "/TD:" + cvss20.TargetDistribution
s += "/CR:" + cvss20.ConfidentialityRequirement
s += "/IR:" + cvss20.IntegrityRequirement
s += "/AR:" + cvss20.AvailabilityRequirement
return s
Base
Temporal
Environmental
// Base is the group of metrics defined with such name by the
type Base struct {
AccessVector string
AccessComplexity string
Authentication string
ConfidentialityImpact string
IntegrityImpact string
AvailabilityImpact string
// Temporal is the group of metrics defined with such name by the
type Temporal struct {
Exploitability string
RemediationLevel string
ReportConfidence string
// Environmental is the group of metrics defined with such name by the
type Environmental struct {
CollateralDamagePotential string
TargetDistribution string
ConfidentialityRequirement string
IntegrityRequirement       string
AvailabilityRequirement    string
return cvss20.AccessVector, nil
return cvss20.AccessComplexity, nil
return cvss20.Authentication, nil
return cvss20.ConfidentialityImpact, nil
return cvss20.IntegrityImpact, nil
return cvss20.AvailabilityImpact, nil
return cvss20.Exploitability, nil
return cvss20.RemediationLevel, nil
return cvss20.ReportConfidence, nil
return cvss20.CollateralDamagePotential, nil
return cvss20.TargetDistribution, nil
return cvss20.ConfidentialityRequirement, nil
return cvss20.IntegrityRequirement, nil
return cvss20.AvailabilityRequirement, nil
cvss20.AccessVector = value
cvss20.AccessComplexity = value
cvss20.Authentication = value
cvss20.ConfidentialityImpact = value
cvss20.IntegrityImpact = value
cvss20.AvailabilityImpact = value
cvss20.Exploitability = value
cvss20.RemediationLevel = value
cvss20.ReportConfidence = value
cvss20.CollateralDamagePotential = value
cvss20.TargetDistribution = value
cvss20.ConfidentialityRequirement = value
cvss20.IntegrityRequirement = value
cvss20.AvailabilityRequirement = value
impact := 10.41 * (1 - (1-cia(cvss20.ConfidentialityImpact))*(1-cia(cvss20.IntegrityImpact))*(1-cia(cvss20.AvailabilityImpact)))
exploitability := 20 * accessVector(cvss20.AccessVector) * accessComplexity(cvss20.AccessComplexity) * authentication(cvss20.Authentication)
return roundTo1Decimal(cvss20.BaseScore() * exploitability(cvss20.Exploitability) * remediationLevel(cvss20.RemediationLevel) * reportConfidence(cvss20.ReportConfidence))
adjustedImpact := math.Min(10, 10.41*(1-(1-cia(cvss20.ConfidentialityImpact)*ciar(cvss20.ConfidentialityRequirement))*(1-cia(cvss20.IntegrityImpact)*ciar(cvss20.IntegrityRequirement))*(1-cia(cvss20.AvailabilityImpact)*ciar(cvss20.AvailabilityRequirement))))
expltBase := 20 * accessVector(cvss20.AccessVector) * accessComplexity(cvss20.AccessComplexity) * authentication(cvss20.Authentication)
adjustedTemporal := roundTo1Decimal(recBase * exploitability(cvss20.Exploitability) * remediationLevel(cvss20.RemediationLevel) * reportConfidence(cvss20.ReportConfidence))
return roundTo1Decimal((adjustedTemporal + (10-adjustedTemporal)*collateralDamagePotential(cvss20.CollateralDamagePotential)) * targetDistribution(cvss20.TargetDistribution))