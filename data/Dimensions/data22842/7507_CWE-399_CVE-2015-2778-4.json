{
    "cve_id": "CVE-2015-2778",
    "cve_description": "Quassel before 0.12-rc1 uses an incorrect data-type size when splitting a message, which allows remote attackers to cause a denial of service (crash) via a long CTCP query containing only multibyte characters.",
    "cve_publish_date": "2015-04-10",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.",
    "type_of_change": "Modification",
    "filename_of_changes": "coreuserinputhandler.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "23",
    "number_of_lines_deleted_vulnerable_to_cve": "49",
    "vulnerable_lines": [
        "// Line_Reference 476:     QByteArray encMsg = userEncode(target, msg.section(' ', 1));",
        "// Line_Reference 479:     putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));",
        "// Line_Reference 481:     putPrivmsg(serverEncode(target), encMsg);",
        "// Line_Reference 597:     QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);",
        "// Line_Reference 599:     putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));",
        "// Line_Reference 601:     putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);",
        "// Line_Reference 766: void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)",
        "// Line_Reference 768:     // Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,",
        "// Line_Reference 769:     // so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted",
        "// Line_Reference 770:     // version is short enough...",
        "// Line_Reference 771:     // TODO: check out how the various possible encryption methods behave length-wise and make",
        "// Line_Reference 772:     //       this clean by predicting the length of the crypted msg.",
        "// Line_Reference 773:     //       For example, blowfish-ebc seems to create 8-char chunks.",
        "// Line_Reference 775:     static const char *cmd = \"PRIVMSG\";",
        "// Line_Reference 776:     static const char *splitter = \" .,-!?\";",
        "// Line_Reference 778:     int maxSplitPos = message.count();",
        "// Line_Reference 779:     int splitPos = maxSplitPos;",
        "// Line_Reference 780:     forever {",
        "// Line_Reference 781:         QByteArray crypted = message.left(splitPos);",
        "// Line_Reference 782:         bool isEncrypted = false;",
        "// Line_Reference 784:         if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {",
        "// Line_Reference 785:             isEncrypted = cipher->encrypt(crypted);",
        "// Line_Reference 788:         int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);",
        "// Line_Reference 789:         if (overrun) {",
        "// Line_Reference 790:             // In case this is not an encrypted msg, we can just cut off at the end",
        "// Line_Reference 791:             if (!isEncrypted)",
        "// Line_Reference 792:                 maxSplitPos = message.count() - overrun;",
        "// Line_Reference 793: ",
        "// Line_Reference 794:             splitPos = -1;",
        "// Line_Reference 795:             for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {",
        "// Line_Reference 796:                 splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); // keep split char on old line",
        "// Line_Reference 797:             }",
        "// Line_Reference 798:             if (splitPos <= 0 || splitPos > maxSplitPos)",
        "// Line_Reference 799:                 splitPos = maxSplitPos;",
        "// Line_Reference 800: ",
        "// Line_Reference 801:             maxSplitPos = splitPos - 1;",
        "// Line_Reference 802:             if (maxSplitPos <= 0) { // this should never happen, but who knows...",
        "// Line_Reference 803:                 qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());",
        "// Line_Reference 804:                 return;",
        "// Line_Reference 805:             }",
        "// Line_Reference 806:             continue; // we never come back here for !encrypted!",
        "// Line_Reference 807:         }",
        "// Line_Reference 808: ",
        "// Line_Reference 809:         // now we have found a valid splitpos (or didn't need to split to begin with)",
        "// Line_Reference 810:         putCmd(cmd, QList<QByteArray>() << target << crypted);",
        "// Line_Reference 811:         if (splitPos < message.count())",
        "// Line_Reference 812:             putPrivmsg(target, message.mid(splitPos), cipher);",
        "// Line_Reference 814:         return;",
        "// Line_Reference 815:     }"
    ]
}
