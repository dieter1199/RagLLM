{
    "cve_id": "CVE-2017-7495",
    "cve_description": "fs/ext4/inode.c in the Linux kernel before 4.6.2, when ext4 data=ordered mode is used, mishandles a needs-flushing-before-commit list, which allows local users to obtain sensitive information from other users' files in opportunistic circumstances by waiting for a hardware reset, creating a new file, making write system calls, and reading this file.",
    "cve_publish_date": "2017-05-15",
    "cwe_id": "CWE-200",
    "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
    "cwe_description": "The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.",
    "commit_message": "ext4: fix data exposure after a crash\n\nHuang has reported that in his powerfail testing he is seeing stale\nblock contents in some of recently allocated blocks although he mounts\next4 in data=ordered mode. After some investigation I have found out\nthat indeed when delayed allocation is used, we don't add inode to\ntransaction's list of inodes needing flushing before commit. Originally\nwe were doing that but commit f3b59291a69d removed the logic with a\nflawed argument that it is not needed.\n\nThe problem is that although for delayed allocated blocks we write their\ncontents immediately after allocating them, there is no guarantee that\nthe IO scheduler or device doesn't reorder things and thus transaction\nallocating blocks and attaching them to inode can reach stable storage\nbefore actual block contents. Actually whenever we attach freshly\nallocated blocks to inode using a written extent, we should add inode to\ntransaction's ordered inode list to make sure we properly wait for block\ncontents to be written before committing the transaction. So that is\nwhat we do in this patch. This also handles other cases where stale data\nexposure was possible - like filling hole via mmap in\ndata=ordered,nodelalloc mode.\n\nThe only exception to the above rule are extending direct IO writes where\nblkdev_direct_IO() waits for IO to complete before increasing i_size and\nthus stale data exposure is not possible. For now we don't complicate\nthe code with optimizing this special case since the overhead is pretty\nlow. In case this is observed to be a performance problem we can always\nhandle it using a special flag to ext4_map_blocks().\n\nCC: stable@vger.kernel.org\nFixes: f3b59291a69d0b734be1fc8be489fef2dd846d3d\nReported-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nTested-by: \"HUANG Weller (CM/ESW12-CN)\" <Weller.Huang@cn.bosch.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
    "type_of_change": "Modification",
    "filename_of_changes": "inode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "15",
    "number_of_lines_deleted_vulnerable_to_cve": "9",
    "vulnerable_lines": [
        "// Line_Reference 1292: \tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {",
        "// Line_Reference 1293: \t\tret = ext4_jbd2_file_inode(handle, inode);",
        "// Line_Reference 1294: \t\tif (ret) {",
        "// Line_Reference 1295: \t\t\tunlock_page(page);",
        "// Line_Reference 1296: \t\t\tput_page(page);",
        "// Line_Reference 1297: \t\t\tgoto errout;",
        "// Line_Reference 1298: \t\t}",
        "// Line_Reference 1299: \t}",
        "// Line_Reference 1300: "
    ]
}
