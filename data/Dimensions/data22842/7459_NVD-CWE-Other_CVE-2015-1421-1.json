{
    "cve_id": "CVE-2015-1421",
    "cve_description": "Use-after-free vulnerability in the sctp_assoc_update function in net/sctp/associola.c in the Linux kernel before 3.18.8 allows remote attackers to cause a denial of service (slab corruption and panic) or possibly have unspecified other impact by triggering an INIT collision that leads to improper handling of shared-key data.",
    "cve_publish_date": "2015-03-16",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "net: sctp: fix slab corruption from use after free on INIT collisions\n\nWhen hitting an INIT collision case during the 4WHS with AUTH enabled, as\nalready described in detail in commit 1be9a950c646 (\"net: sctp: inherit\nauth_capable on INIT collisions\"), it can happen that we occasionally\nstill remotely trigger the following panic on server side which seems to\nhave been uncovered after the fix from commit 1be9a950c646 ...\n\n[  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff\n[  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230\n[  533.940559] PGD 5030f2067 PUD 0\n[  533.957104] Oops: 0000 [#1] SMP\n[  533.974283] Modules linked in: sctp mlx4_en [...]\n[  534.939704] Call Trace:\n[  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0\n[  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0\n[  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170\n[  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0\n[  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50\n[  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]\n[  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0\n[  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b\n\n... or depending on the the application, for example this one:\n\n[ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff\n[ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0\n[ 1370.054568] PGD 633c94067 PUD 0\n[ 1370.070446] Oops: 0000 [#1] SMP\n[ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]\n[ 1370.963431] Call Trace:\n[ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960\n[ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960\n[ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170\n[ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130\n[ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b\n\nWith slab debugging enabled, we can see that the poison has been overwritten:\n\n[  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten\n[  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b\n[  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494\n[  669.826424]  __slab_alloc+0x4bf/0x566\n[  669.826433]  __kmalloc+0x280/0x310\n[  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]\n[  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]\n[  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]\n[  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]\n[  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494\n[  669.826635]  __slab_free+0x39/0x2a8\n[  669.826643]  kfree+0x1d6/0x230\n[  669.826650]  kzfree+0x31/0x40\n[  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]\n[  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]\n[  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]\n\nSince this only triggers in some collision-cases with AUTH, the problem at\nheart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice\nwhen having refcnt 1, once directly in sctp_assoc_update() and yet again\nfrom within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on\nthe already kzfree'd memory, which is also consistent with the observation\nof the poison decrease from 0x6b to 0x6a (note: the overwrite is detected\nat a later point in time when poison is checked on new allocation).\n\nReference counting of auth keys revisited:\n\nShared keys for AUTH chunks are being stored in endpoints and associations\nin endpoint_shared_keys list. On endpoint creation, a null key is being\nadded; on association creation, all endpoint shared keys are being cached\nand thus cloned over to the association. struct sctp_shared_key only holds\na pointer to the actual key bytes, that is, struct sctp_auth_bytes which\nkeeps track of users internally through refcounting. Naturally, on assoc\nor enpoint destruction, sctp_shared_key are being destroyed directly and\nthe reference on sctp_auth_bytes dropped.\n\nUser space can add keys to either list via setsockopt(2) through struct\nsctp_authkey and by passing that to sctp_auth_set_key() which replaces or\nadds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes\nwith refcount 1 and in case of replacement drops the reference on the old\nsctp_auth_bytes. A key can be set active from user space through setsockopt()\non the id via sctp_auth_set_active_key(), which iterates through either\nendpoint_shared_keys and in case of an assoc, invokes (one of various places)\nsctp_auth_asoc_init_active_key().\n\nsctp_auth_asoc_init_active_key() computes the actual secret from local's\nand peer's random, hmac and shared key parameters and returns a new key\ndirectly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops\nthe reference if there was a previous one. The secret, which where we\neventually double drop the ref comes from sctp_auth_asoc_set_secret() with\nintitial refcount of 1, which also stays unchanged eventually in\nsctp_assoc_update(). This key is later being used for crypto layer to\nset the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().\n\nTo close the loop: asoc->asoc_shared_key is freshly allocated secret\nmaterial and independant of the sctp_shared_key management keeping track\nof only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76\n(\"net: sctp: fix memory leak in auth key management\") is independant of\nthis bug here since it concerns a different layer (though same structures\nbeing used eventually). asoc->asoc_shared_key is reference dropped correctly\non assoc destruction in sctp_association_free() and when active keys are\nbeing replaced in sctp_auth_asoc_init_active_key(), it always has a refcount\nof 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is\nto remove that sctp_auth_key_put() from there which fixes these panics.\n\nFixes: 730fc3d05cd4 (\"[SCTP]: Implete SCTP-AUTH parameter processing\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "associola.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 1185: \tsctp_auth_key_put(asoc->asoc_shared_key);"
    ]
}
