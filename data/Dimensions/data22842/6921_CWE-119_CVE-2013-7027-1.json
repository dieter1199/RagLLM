{
    "cve_id": "CVE-2013-7027",
    "cve_description": "The ieee80211_radiotap_iterator_init function in net/wireless/radiotap.c in the Linux kernel before 3.11.7 does not check whether a frame contains any data outside of the header, which might allow attackers to cause a denial of service (buffer over-read) via a crafted header.",
    "cve_publish_date": "2013-12-09",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "wireless: radiotap: fix parsing buffer overrun\n\nWhen parsing an invalid radiotap header, the parser can overrun\nthe buffer that is passed in because it doesn't correctly check\n 1) the minimum radiotap header size\n 2) the space for extended bitmaps\n\nThe first issue doesn't affect any in-kernel user as they all\ncheck the minimum size before calling the radiotap function.\nThe second issue could potentially affect the kernel if an skb\nis passed in that consists only of the radiotap header with a\nlot of extended bitmaps that extend past the SKB. In that case\na read-only buffer overrun by at most 4 bytes is possible.\n\nFix this by adding the appropriate checks to the parser.\n\nCc: stable@vger.kernel.org\nReported-by: Evan Huus <eapache@gmail.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "radiotap.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "6",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 134: \t\t\t    (unsigned long)iterator->_rtheader >"
    ]
}
