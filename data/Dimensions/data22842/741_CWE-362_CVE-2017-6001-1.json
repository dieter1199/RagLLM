{
    "cve_id": "CVE-2017-6001",
    "cve_description": "Race condition in kernel/events/core.c in the Linux kernel before 4.9.7 allows local users to gain privileges via a crafted application that makes concurrent perf_event_open system calls for moving a software group into a hardware context.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-6786.",
    "cve_publish_date": "2017-02-18",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "perf/core: Fix concurrent sys_perf_event_open() vs. 'move_group' race\n\nDi Shen reported a race between two concurrent sys_perf_event_open()\ncalls where both try and move the same pre-existing software group\ninto a hardware context.\n\nThe problem is exactly that described in commit:\n\n  f63a8daa5812 (\"perf: Fix event->ctx locking\")\n\n... where, while we wait for a ctx->mutex acquisition, the event->ctx\nrelation can have changed under us.\n\nThat very same commit failed to recognise sys_perf_event_context() as an\nexternal access vector to the events and thereby didn't apply the\nestablished locking rules correctly.\n\nSo while one sys_perf_event_open() call is stuck waiting on\nmutex_lock_double(), the other (which owns said locks) moves the group\nabout. So by the time the former sys_perf_event_open() acquires the\nlocks, the context we've acquired is stale (and possibly dead).\n\nApply the established locking rules as per perf_event_ctx_lock_nested()\nto the mutex_lock_double() for the 'move_group' case. This obviously means\nwe need to validate state after we acquire the locks.\n\nReported-by: Di Shen (Keen Lab)\nTested-by: John Dias <joaodias@google.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Kees Cook <keescook@chromium.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Min Chong <mchong@google.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nFixes: f63a8daa5812 (\"perf: Fix event->ctx locking\")\nLink: http://lkml.kernel.org/r/20170106131444.GZ3174@twins.programming.kicks-ass.net\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "core.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "54",
    "number_of_lines_deleted_vulnerable_to_cve": "4",
    "vulnerable_lines": [
        "// Line_Reference 9775: \t\tgctx = group_leader->ctx;",
        "// Line_Reference 9776: \t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);",
        "// Line_Reference 9882: \t\tmutex_unlock(&gctx->mutex);",
        "// Line_Reference 9908: \t\tmutex_unlock(&gctx->mutex);"
    ]
}
