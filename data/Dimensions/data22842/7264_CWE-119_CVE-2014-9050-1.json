{
    "cve_id": "CVE-2014-9050",
    "cve_description": "Heap-based buffer overflow in the cli_scanpe function in libclamav/pe.c in ClamAV before 0.98.5 allows remote attackers to cause a denial of service (crash) via a crafted y0da Crypter PE file.",
    "cve_publish_date": "2014-12-01",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "Merge fix from security/bb11155 branch",
    "type_of_change": "Modification",
    "filename_of_changes": "pe.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "47",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 740: \tunsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;",
        "// Line_Reference 747: \tuint32_t valign, falign, hdr_size, j;",
        "// Line_Reference 1242: \tstrncpy(sname, (char *) section_hdr[i].Name, 8);",
        "// Line_Reference 1243: \tsname[8] = 0;",
        "// Line_Reference 1244: \texe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
        "// Line_Reference 1245: \texe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
        "// Line_Reference 1246: \texe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
        "// Line_Reference 1247: \texe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
        "// Line_Reference 1248: \texe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
        "// Line_Reference 1249: \texe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */",
        "// Line_Reference 1250: \texe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
        "// Line_Reference 1251: \texe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
        "// Line_Reference 1252: \texe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
        "// Line_Reference 1307: \t    if (exe_sections[i].raw >= fsize) { /* really broken */",
        "// Line_Reference 1308: \t      cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
        "// Line_Reference 1309: \t      cli_dbgmsg(\"------------------------------------\\n\");",
        "// Line_Reference 1310: \t\tfree(section_hdr);",
        "// Line_Reference 1311: \t\tfree(exe_sections);",
        "// Line_Reference 1312: \t\tif(DETECT_BROKEN_PE) {",
        "// Line_Reference 1313: \t\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
        "// Line_Reference 1314: \t\t    return CL_VIRUS;",
        "// Line_Reference 1315: \t\t}",
        "// Line_Reference 1316: \t\treturn CL_CLEAN; /* no ninjas to see here! move along! */",
        "// Line_Reference 1317: \t    }",
        "// Line_Reference 1318: "
    ]
}
