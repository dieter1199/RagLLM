{
    "cve_id": "CVE-2015-0274",
    "cve_description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
    "cve_publish_date": "2015-03-16",
    "cwe_id": "CWE-19",
    "cwe_name": "Data Processing Errors",
    "cwe_description": "Weaknesses in this category are typically found in functionality that processes data. Data processing is the manipulation of input to retrieve or save information.",
    "commit_message": "xfs: remote attribute overwrite causes transaction overrun\n\nCommit e461fcb (\"xfs: remote attribute lookups require the value\nlength\") passes the remote attribute length in the xfs_da_args\nstructure on lookup so that CRC calculations and validity checking\ncan be performed correctly by related code. This, unfortunately has\nthe side effect of changing the args->valuelen parameter in cases\nwhere it shouldn't.\n\nThat is, when we replace a remote attribute, the incoming\nreplacement stores the value and length in args->value and\nargs->valuelen, but then the lookup which finds the existing remote\nattribute overwrites args->valuelen with the length of the remote\nattribute being replaced. Hence when we go to create the new\nattribute, we create it of the size of the existing remote\nattribute, not the size it is supposed to be. When the new attribute\nis much smaller than the old attribute, this results in a\ntransaction overrun and an ASSERT() failure on a debug kernel:\n\nXFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331\n\nFix this by keeping the remote attribute value length separate to\nthe attribute value length in the xfs_da_args structure. The enables\nus to pass the length of the remote attribute to be removed without\noverwriting the new attribute's length.\n\nAlso, ensure that when we save remote block contexts for a later\nrename we zero the original state variables so that we don't confuse\nthe state of the attribute to be removes with the state of the new\nattribute that we just added. [Spotted by Brain Foster.]\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Brian Foster <bfoster@redhat.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "xfs_attr_leaf.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "10",
    "vulnerable_lines": [
        "// Line_Reference 2170: \t\t\targs->valuelen = be32_to_cpu(name_rmt->valuelen);",
        "// Line_Reference 2174: \t\t\t\t\t\t\targs->valuelen);",
        "// Line_Reference 2223: \t\tvaluelen = be32_to_cpu(name_rmt->valuelen);",
        "// Line_Reference 2226: \t\t\t\t\t\t       valuelen);",
        "// Line_Reference 2228: \t\t\targs->valuelen = valuelen;",
        "// Line_Reference 2231: \t\tif (args->valuelen < valuelen) {",
        "// Line_Reference 2232: \t\t\targs->valuelen = valuelen;",
        "// Line_Reference 2235: \t\targs->valuelen = valuelen;",
        "// Line_Reference 2522: \t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);",
        "// Line_Reference 2680: \t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);"
    ]
}
