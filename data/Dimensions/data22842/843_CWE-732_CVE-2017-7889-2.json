{
    "cve_id": "CVE-2017-7889",
    "cve_description": "The mm subsystem in the Linux kernel through 3.2 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",
    "cve_publish_date": "2017-04-17",
    "cwe_id": "CWE-732",
    "cwe_name": "Incorrect Permission Assignment for Critical Resource",
    "cwe_description": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.",
    "commit_message": "mm: Tighten x86 /dev/mem with zeroing reads\n\nUnder CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is\ndisallowed. However, on x86, the first 1MB was always allowed for BIOS\nand similar things, regardless of it actually being System RAM. It was\npossible for heap to end up getting allocated in low 1MB RAM, and then\nread by things like x86info or dd, which would trip hardened usercopy:\n\nusercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)\n\nThis changes the x86 exception for the low 1MB by reading back zeros for\nSystem RAM areas instead of blindly allowing them. More work is needed to\nextend this to mmap, but currently mmap doesn't go through usercopy, so\nhardened usercopy won't Oops the kernel.\n\nReported-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nTested-by: Tommi Rantala <tommi.t.rantala@nokia.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "mem.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "52",
    "number_of_lines_deleted_vulnerable_to_cve": "30",
    "vulnerable_lines": [
        "// Line_Reference 128: \t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))",
        "// Line_Reference 131: \t\t/*",
        "// Line_Reference 132: \t\t * On ia64 if a page has been mapped somewhere as uncached, then",
        "// Line_Reference 133: \t\t * it must also be accessed uncached by the kernel or data",
        "// Line_Reference 134: \t\t * corruption may occur.",
        "// Line_Reference 135: \t\t */",
        "// Line_Reference 136: \t\tptr = xlate_dev_mem_ptr(p);",
        "// Line_Reference 137: \t\tif (!ptr)",
        "// Line_Reference 138: \t\t\treturn -EFAULT;",
        "// Line_Reference 140: \t\tremaining = copy_to_user(buf, ptr, sz);",
        "// Line_Reference 141: \t\tunxlate_dev_mem_ptr(p, ptr);",
        "// Line_Reference 186: \t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))",
        "// Line_Reference 189: \t\t/*",
        "// Line_Reference 190: \t\t * On ia64 if a page has been mapped somewhere as uncached, then",
        "// Line_Reference 191: \t\t * it must also be accessed uncached by the kernel or data",
        "// Line_Reference 192: \t\t * corruption may occur.",
        "// Line_Reference 193: \t\t */",
        "// Line_Reference 194: \t\tptr = xlate_dev_mem_ptr(p);",
        "// Line_Reference 195: \t\tif (!ptr) {",
        "// Line_Reference 196: \t\t\tif (written)",
        "// Line_Reference 197: \t\t\t\tbreak;",
        "// Line_Reference 198: \t\t\treturn -EFAULT;",
        "// Line_Reference 199: \t\t}",
        "// Line_Reference 201: \t\tcopied = copy_from_user(ptr, buf, sz);",
        "// Line_Reference 202: \t\tunxlate_dev_mem_ptr(p, ptr);",
        "// Line_Reference 203: \t\tif (copied) {",
        "// Line_Reference 204: \t\t\twritten += sz - copied;",
        "// Line_Reference 205: \t\t\tif (written)",
        "// Line_Reference 206: \t\t\t\tbreak;",
        "// Line_Reference 207: \t\t\treturn -EFAULT;"
    ]
}
