{
    "cve_id": "CVE-2012-6119",
    "cve_description": "Candlepin before 0.7.24, as used in Red Hat Subscription Asset Manager before 1.2.1, does not properly check manifest signatures, which allows local users to modify manifests.",
    "cve_publish_date": "2013-04-02",
    "cwe_id": "CWE-264",
    "cwe_name": "Permissions, Privileges, and Access Controls",
    "cwe_description": "Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",
    "commit_message": "835977: Re-enable manifest signature checking.\n\nThe production/stage public candlepin certificate is now packaged in the\nRPM. This is flagged as a config file but *without* noreplace, so any\ndeployment using their own upstream cert (we don't think there are any)\nwill have to restore it from the rpmsave file that results after a\ncandlepin rpm upgrade. This was done because we expect this to be the\ndesired behavior, there is no known usecase for using your own\nupstream cert at this time.",
    "type_of_change": "Modification",
    "filename_of_changes": "Importer.java",
    "code_language": "Java",
    "number_of_lines_added_for_mitigation": "31",
    "number_of_lines_deleted_vulnerable_to_cve": "32",
    "vulnerable_lines": [
        "// Line_Reference 214: //           only need this call when sig file is verified",
        "// Line_Reference 215: //            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));",
        "// Line_Reference 216: ",
        "// Line_Reference 217:             /*",
        "// Line_Reference 218:              * Disabling this once again for a little bit longer. Dependent projects",
        "// Line_Reference 219:              * are not yet ready for it, and we're having some difficulty with the actual",
        "// Line_Reference 220:              * upstream cert to use.",
        "// Line_Reference 221:              *",
        "// Line_Reference 222:              * When we bring this back, we should probably report this conflict",
        "// Line_Reference 223:              * immediately, rather than continuing to extract and trying to find any",
        "// Line_Reference 224:              * other conflicts to pass back.",
        "// Line_Reference 225:              */",
        "// Line_Reference 226: //            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(",
        "// Line_Reference 227: //                exportStream,",
        "// Line_Reference 228: //                loadSignature(new File(tmpDir, \"signature\")));",
        "// Line_Reference 229: //            if (!verifiedSignature) {",
        "// Line_Reference 230: //                log.warn(\"Manifest signature check failed.\");",
        "// Line_Reference 231: //                if (!forcedConflicts",
        "// Line_Reference 232: //                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {",
        "// Line_Reference 233: //                    conflicts.addConflict(",
        "// Line_Reference 234: //                        i18n.tr(\"Failed import file hash check.\"),",
        "// Line_Reference 235: //                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);",
        "// Line_Reference 236: //                }",
        "// Line_Reference 237: //                else {",
        "// Line_Reference 238: //                    log.warn(\"Ignoring signature check failure.\");",
        "// Line_Reference 239: //                }",
        "// Line_Reference 240: //            }",
        "// Line_Reference 241: ",
        "// Line_Reference 268: //        catch (CertificateException e) {",
        "// Line_Reference 269: //            log.error(\"Exception caught importing archive\", e);",
        "// Line_Reference 270: //            throw new ImportExtractionException(\"unable to extract export archive\", e);",
        "// Line_Reference 271: //        }"
    ]
}
