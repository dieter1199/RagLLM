{
    "cve_id": "CVE-2013-7446",
    "cve_description": "Use-after-free vulnerability in net/unix/af_unix.c in the Linux kernel before 4.3.3 allows local users to bypass intended AF_UNIX socket permissions or cause a denial of service (panic) via crafted epoll_ctl calls.",
    "cve_publish_date": "2015-12-28",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "unix: avoid use-after-free in ep_remove_wait_queue\n\nRainer Weikusat <rweikusat@mobileactivedefense.com> writes:\nAn AF_UNIX datagram socket being the client in an n:1 association with\nsome server socket is only allowed to send messages to the server if the\nreceive queue of this socket contains at most sk_max_ack_backlog\ndatagrams. This implies that prospective writers might be forced to go\nto sleep despite none of the message presently enqueued on the server\nreceive queue were sent by them. In order to ensure that these will be\nwoken up once space becomes again available, the present unix_dgram_poll\nroutine does a second sock_poll_wait call with the peer_wait wait queue\nof the server socket as queue argument (unix_dgram_recvmsg does a wake\nup on this queue after a datagram was received). This is inherently\nproblematic because the server socket is only guaranteed to remain alive\nfor as long as the client still holds a reference to it. In case the\nconnection is dissolved via connect or by the dead peer detection logic\nin unix_dgram_sendmsg, the server socket may be freed despite \"the\npolling mechanism\" (in particular, epoll) still has a pointer to the\ncorresponding peer_wait queue. There's no way to forcibly deregister a\nwait queue with epoll.\n\nBased on an idea by Jason Baron, the patch below changes the code such\nthat a wait_queue_t belonging to the client socket is enqueued on the\npeer_wait queue of the server whenever the peer receive queue full\ncondition is detected by either a sendmsg or a poll. A wake up on the\npeer queue is then relayed to the ordinary wait queue of the client\nsocket via wake function. The connection to the peer wait queue is again\ndissolved if either a wake up is about to be relayed or the client\nsocket reconnects or a dead peer is detected or the client socket is\nitself closed. This enables removing the second sock_poll_wait from\nunix_dgram_poll, thus avoiding the use-after-free, while still ensuring\nthat no blocked writer sleeps forever.\n\nSigned-off-by: Rainer Weikusat <rweikusat@mobileactivedefense.com>\nFixes: ec0d215f9420 (\"af_unix: fix 'poll for write'/connected DGRAM sockets\")\nReviewed-by: Jason Baron <jbaron@akamai.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "af_unix.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "164",
    "number_of_lines_deleted_vulnerable_to_cve": "19",
    "vulnerable_lines": [
        "// Line_Reference 1558: \tif (sock_flag(other, SOCK_DEAD)) {",
        "// Line_Reference 1567: \t\tunix_state_lock(sk);",
        "// Line_Reference 1595: \tif (unix_peer(other) != sk && unix_recvq_full(other)) {",
        "// Line_Reference 1596: \t\tif (!timeo) {",
        "// Line_Reference 1597: \t\t\terr = -EAGAIN;",
        "// Line_Reference 1598: \t\t\tgoto out_unlock;",
        "// Line_Reference 1601: \t\ttimeo = unix_wait_for_peer(other, timeo);",
        "// Line_Reference 1603: \t\terr = sock_intr_errno(timeo);",
        "// Line_Reference 1604: \t\tif (signal_pending(current))",
        "// Line_Reference 1605: \t\t\tgoto out_free;",
        "// Line_Reference 1607: \t\tgoto restart;",
        "// Line_Reference 2479: \tother = unix_peer_get(sk);",
        "// Line_Reference 2480: \tif (other) {",
        "// Line_Reference 2481: \t\tif (unix_peer(other) != sk) {",
        "// Line_Reference 2482: \t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);",
        "// Line_Reference 2483: \t\t\tif (unix_recvq_full(other))",
        "// Line_Reference 2484: \t\t\t\twritable = 0;",
        "// Line_Reference 2485: \t\t}",
        "// Line_Reference 2486: \t\tsock_put(other);"
    ]
}
