{
    "cve_id": "CVE-2017-7946",
    "cve_description": "The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.",
    "cve_publish_date": "2017-04-18",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "Fix null deref and uaf in mach0 parser",
    "type_of_change": "Modification",
    "filename_of_changes": "mach0.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "51",
    "number_of_lines_deleted_vulnerable_to_cve": "41",
    "vulnerable_lines": [
        "// Line_Reference 1122: \t\t\tif (!parse_dylib(bin, off)){",
        "// Line_Reference 1133: \t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));",
        "// Line_Reference 1134: ",
        "// Line_Reference 1135: \t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){",
        "// Line_Reference 1136: \t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");",
        "// Line_Reference 1137: \t\t\t\tfree (bin->dyld_info);",
        "// Line_Reference 1138: \t\t\t\treturn false;",
        "// Line_Reference 1139: \t\t\t}",
        "// Line_Reference 1140: \t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {",
        "// Line_Reference 1141: \t\t\t\tfree (bin->dyld_info);",
        "// Line_Reference 1142: \t\t\t\tbin->dyld_info = NULL;",
        "// Line_Reference 1143: \t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);",
        "// Line_Reference 1144: \t\t\t} else {",
        "// Line_Reference 1145: \t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);",
        "// Line_Reference 1146: \t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);",
        "// Line_Reference 1147: \t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);",
        "// Line_Reference 1148: \t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);",
        "// Line_Reference 1149: \t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);",
        "// Line_Reference 1150: \t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);",
        "// Line_Reference 1151: \t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);",
        "// Line_Reference 1152: \t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);",
        "// Line_Reference 1153: \t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);",
        "// Line_Reference 1154: \t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);",
        "// Line_Reference 1155: \t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);",
        "// Line_Reference 1156: \t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);",
        "// Line_Reference 1750: \t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)",
        "// Line_Reference 1753: \t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)",
        "// Line_Reference 1755: \t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)",
        "// Line_Reference 1758: \t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))",
        "// Line_Reference 1760: ",
        "// Line_Reference 1908: \t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)",
        "// Line_Reference 1910: \t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))",
        "// Line_Reference 1913: \t\t\tif (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {",
        "// Line_Reference 1957: ",
        "// Line_Reference 1965: \tif (!bin->nlibs)",
        "// Line_Reference 1967: \tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))",
        "// Line_Reference 1981: \tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)",
        "// Line_Reference 1983: ",
        "// Line_Reference 1984: \tfor (i = 0; i < bin->nsegs; ++i)",
        "// Line_Reference 1985: \t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)",
        "// Line_Reference 2312: \t\tif (entry > bin->size || entry + sizeof (b) > bin->size)"
    ]
}
