{
    "cve_id": "CVE-2022-2582",
    "cve_description": "The AWS S3 Crypto SDK sends an unencrypted hash of the plaintext alongside the ciphertext as a metadata field. This hash can be used to brute force the plaintext, if the hash is readable to the attacker. AWS now blocks this metadata field, but older SDK versions still send it.",
    "cve_publish_date": "2022-12-27",
    "cwe_id": "CWE-326",
    "cwe_name": "Inadequate Encryption Strength",
    "cwe_description": "The product stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.",
    "commit_message": "service/s3/s3crypto: V2 Client Release (#3403)",
    "type_of_change": "Modification",
    "filename_of_changes": "cipher_util.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "80",
    "vulnerable_lines": [
        "// Line_Reference 6: \t\"strings\"",
        "// Line_Reference 7: ",
        "// Line_Reference 8: \t\"github.com/aws/aws-sdk-go/aws\"",
        "// Line_Reference 9: \t\"github.com/aws/aws-sdk-go/aws/awserr\"",
        "// Line_Reference 12: func (client *DecryptionClient) contentCipherFromEnvelope(ctx aws.Context, env Envelope) (ContentCipher, error) {",
        "// Line_Reference 13: \twrap, err := client.wrapFromEnvelope(env)",
        "// Line_Reference 14: \tif err != nil {",
        "// Line_Reference 15: \t\treturn nil, err",
        "// Line_Reference 16: \t}",
        "// Line_Reference 17: ",
        "// Line_Reference 18: \treturn client.cekFromEnvelope(ctx, env, wrap)",
        "// Line_Reference 19: }",
        "// Line_Reference 20: ",
        "// Line_Reference 21: func (client *DecryptionClient) wrapFromEnvelope(env Envelope) (CipherDataDecrypter, error) {",
        "// Line_Reference 22: \tf, ok := client.WrapRegistry[env.WrapAlg]",
        "// Line_Reference 23: \tif !ok || f == nil {",
        "// Line_Reference 24: \t\treturn nil, awserr.New(",
        "// Line_Reference 25: \t\t\t\"InvalidWrapAlgorithmError\",",
        "// Line_Reference 26: \t\t\t\"wrap algorithm isn't supported, \"+env.WrapAlg,",
        "// Line_Reference 27: \t\t\tnil,",
        "// Line_Reference 28: \t\t)",
        "// Line_Reference 29: \t}",
        "// Line_Reference 30: \treturn f(env)",
        "// Line_Reference 31: }",
        "// Line_Reference 32: ",
        "// Line_Reference 40: func (client *DecryptionClient) cekFromEnvelope(ctx aws.Context, env Envelope, decrypter CipherDataDecrypter) (ContentCipher, error) {",
        "// Line_Reference 41: \tf, ok := client.CEKRegistry[env.CEKAlg]",
        "// Line_Reference 42: \tif !ok || f == nil {",
        "// Line_Reference 43: \t\treturn nil, awserr.New(",
        "// Line_Reference 44: \t\t\t\"InvalidCEKAlgorithmError\",",
        "// Line_Reference 45: \t\t\t\"cek algorithm isn't supported, \"+env.CEKAlg,",
        "// Line_Reference 46: \t\t\tnil,",
        "// Line_Reference 47: \t\t)",
        "// Line_Reference 48: \t}",
        "// Line_Reference 49: ",
        "// Line_Reference 50: \tkey, err := base64.StdEncoding.DecodeString(env.CipherKey)",
        "// Line_Reference 51: \tif err != nil {",
        "// Line_Reference 52: \t\treturn nil, err",
        "// Line_Reference 53: \t}",
        "// Line_Reference 54: ",
        "// Line_Reference 55: \tiv, err := base64.StdEncoding.DecodeString(env.IV)",
        "// Line_Reference 56: \tif err != nil {",
        "// Line_Reference 57: \t\treturn nil, err",
        "// Line_Reference 58: \t}",
        "// Line_Reference 59: ",
        "// Line_Reference 60: \tif d, ok := decrypter.(CipherDataDecrypterWithContext); ok {",
        "// Line_Reference 61: \t\tkey, err = d.DecryptKeyWithContext(ctx, key)",
        "// Line_Reference 62: \t} else {",
        "// Line_Reference 63: \t\tkey, err = decrypter.DecryptKey(key)",
        "// Line_Reference 64: \t}",
        "// Line_Reference 65: ",
        "// Line_Reference 66: \tif err != nil {",
        "// Line_Reference 67: \t\treturn nil, err",
        "// Line_Reference 68: \t}",
        "// Line_Reference 69: ",
        "// Line_Reference 70: \tcd := CipherData{",
        "// Line_Reference 71: \t\tKey:          key,",
        "// Line_Reference 72: \t\tIV:           iv,",
        "// Line_Reference 73: \t\tCEKAlgorithm: env.CEKAlg,",
        "// Line_Reference 74: \t\tPadder:       client.getPadder(env.CEKAlg),",
        "// Line_Reference 75: \t}",
        "// Line_Reference 76: \treturn f(cd)",
        "// Line_Reference 77: }",
        "// Line_Reference 78: ",
        "// Line_Reference 79: // getPadder will return an unpadder with checking the cek algorithm specific padder.",
        "// Line_Reference 80: // If there wasn't a cek algorithm specific padder, we check the padder itself.",
        "// Line_Reference 81: // We return a no unpadder, if no unpadder was found. This means any customization",
        "// Line_Reference 82: // either contained padding within the cipher implementation, and to maintain",
        "// Line_Reference 83: // backwards compatility we will simply not unpad anything.",
        "// Line_Reference 84: func (client *DecryptionClient) getPadder(cekAlg string) Padder {",
        "// Line_Reference 85: \tpadder, ok := client.PadderRegistry[cekAlg]",
        "// Line_Reference 86: \tif !ok {",
        "// Line_Reference 87: \t\tpadder, ok = client.PadderRegistry[cekAlg[strings.LastIndex(cekAlg, \"/\")+1:]]",
        "// Line_Reference 88: \t\tif !ok {",
        "// Line_Reference 89: \t\t\treturn NoPadder",
        "// Line_Reference 90: \t\t}",
        "// Line_Reference 91: \t}",
        "// Line_Reference 92: \treturn padder",
        "// Line_Reference 93: }",
        "// Line_Reference 94: "
    ]
}
