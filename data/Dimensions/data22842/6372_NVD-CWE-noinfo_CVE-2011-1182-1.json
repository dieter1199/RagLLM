{
    "cve_id": "CVE-2011-1182",
    "cve_description": "kernel/signal.c in the Linux kernel before 2.6.39 allows local users to spoof the uid and pid of a signal sender via a sigqueueinfo system call.",
    "cve_publish_date": "2013-03-01",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Prevent rt_sigqueueinfo and rt_tgsigqueueinfo from spoofing the signal code\n\nUserland should be able to trust the pid and uid of the sender of a\nsignal if the si_code is SI_TKILL.\n\nUnfortunately, the kernel has historically allowed sigqueueinfo() to\nsend any si_code at all (as long as it was negative - to distinguish it\nfrom kernel-generated signals like SIGILL etc), so it could spoof a\nSI_TKILL with incorrect siginfo values.\n\nHappily, it looks like glibc has always set si_code to the appropriate\nSI_QUEUE, so there are probably no actual user code that ever uses\nanything but the appropriate SI_QUEUE flag.\n\nSo just tighten the check for si_code (we used to allow any negative\nvalue), and add a (one-time) warning in case there are binaries out\nthere that might depend on using other si_code values.\n\nSigned-off-by: Julien Tinnes <jln@google.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "signal.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "12",
    "number_of_lines_deleted_vulnerable_to_cve": "4",
    "vulnerable_lines": [
        "// Line_Reference 2424: \t   Nor can they impersonate a kill(), which adds source info.  */",
        "// Line_Reference 2425: \tif (info.si_code >= 0)",
        "// Line_Reference 2440: \t   Nor can they impersonate a kill(), which adds source info.  */",
        "// Line_Reference 2441: \tif (info->si_code >= 0)"
    ]
}
