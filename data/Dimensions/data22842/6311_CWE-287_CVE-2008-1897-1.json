{
    "cve_id": "CVE-2008-1897",
    "cve_description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
    "cve_publish_date": "2008-04-23",
    "cwe_id": "CWE-287",
    "cwe_name": "Improper Authentication",
    "cwe_description": "When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",
    "commit_message": "When we receive a full frame that is supposed to contain our call number,\nensure that it has the correct one.\n(closes issue #10078)\n(AST-2008-006)",
    "type_of_change": "Modification",
    "filename_of_changes": "chan_iax2.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "38",
    "number_of_lines_deleted_vulnerable_to_cve": "22",
    "vulnerable_lines": [
        "// Line_Reference 1242: static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur)",
        "// Line_Reference 1247: \t\tif ((cur->peercallno == callno) ||",
        "// Line_Reference 1248: \t\t\t((dcallno == cur->callno) && !cur->peercallno)) {",
        "// Line_Reference 1339: static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
        "// Line_Reference 1352: \t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
        "// Line_Reference 1362: \t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
        "// Line_Reference 1378: \t\tgettimeofday(&now, NULL);",
        "// Line_Reference 1379: \t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
        "// Line_Reference 1382: \t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
        "// Line_Reference 1386: \t\tif (x >= TRUNK_CALL_START) {",
        "// Line_Reference 1423: static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
        "// Line_Reference 1425: \treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);",
        "// Line_Reference 1428: static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
        "// Line_Reference 1430: \treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);",
        "// Line_Reference 6874: \t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd);",
        "// Line_Reference 6932: \t\t\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, &sin, NEW_PREVENT, fd);",
        "// Line_Reference 7018: \t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd);",
        "// Line_Reference 8513: \t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);",
        "// Line_Reference 8574: \tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);",
        "// Line_Reference 8715: \tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);",
        "// Line_Reference 8795: \tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);",
        "// Line_Reference 10109: \tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
    ]
}
