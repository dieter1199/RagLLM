{
    "cve_id": "CVE-2016-4804",
    "cve_description": "The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function.",
    "cve_publish_date": "2016-06-03",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "read_boot(): Handle excessive FAT size specifications\n\nThe variable used for storing the FAT size (in bytes) was an unsigned\nint. Since the size in sectors read from the BPB was not sufficiently\nchecked, this could end up being zero after multiplying it with the\nsector size while some offsets still stayed excessive. Ultimately it\nwould cause segfaults when accessing FAT entries for which no memory\nwas allocated.\n\nMake it more robust by changing the types used to store FAT size to\noff_t and abort if there is no room for data clusters. Additionally\ncheck that FAT size is not specified as zero.\n\nFixes #25 and fixes #26.\n\nReported-by: Hanno BÃ¶ck\nSigned-off-by: Andreas Bombe <aeb@debian.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "fsck.fat.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 155:     unsigned int fat_size;\t/* unit is bytes */"
    ]
}
