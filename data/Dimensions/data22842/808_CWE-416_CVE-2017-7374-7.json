{
    "cve_id": "CVE-2017-7374",
    "cve_description": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.",
    "cve_publish_date": "2017-03-31",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "fscrypt: remove broken support for detecting keyring key revocation\n\nFilesystem encryption ostensibly supported revoking a keyring key that\nhad been used to \"unlock\" encrypted files, causing those files to become\n\"locked\" again.  This was, however, buggy for several reasons, the most\nsevere of which was that when key revocation happened to be detected for\nan inode, its fscrypt_info was immediately freed, even while other\nthreads could be using it for encryption or decryption concurrently.\nThis could be exploited to crash the kernel or worse.\n\nThis patch fixes the use-after-free by removing the code which detects\nthe keyring key having been revoked, invalidated, or expired.  Instead,\nan encrypted inode that is \"unlocked\" now simply remains unlocked until\nit is evicted from memory.  Note that this is no worse than the case for\nblock device-level encryption, e.g. dm-crypt, and it still remains\npossible for a privileged user to evict unused pages, inodes, and\ndentries by running 'sync; echo 3 > /proc/sys/vm/drop_caches', or by\nsimply unmounting the filesystem.  In fact, one of those actions was\nalready needed anyway for key revocation to work even somewhat sanely.\nThis change is not expected to break any applications.\n\nIn the future I'd like to implement a real API for fscrypt key\nrevocation that interacts sanely with ongoing filesystem operations ---\nwaiting for existing operations to complete and blocking new operations,\nand invalidating and sanitizing key material and plaintext from the VFS\ncaches.  But this is a hard problem, and for now this bug must be fixed.\n\nThis bug affected almost all versions of ext4, f2fs, and ubifs\nencryption, and it was potentially reachable in any kernel configured\nwith encryption support (CONFIG_EXT4_ENCRYPTION=y,\nCONFIG_EXT4_FS_ENCRYPTION=y, CONFIG_F2FS_FS_ENCRYPTION=y, or\nCONFIG_UBIFS_FS_ENCRYPTION=y).  Note that older kernels did not use the\nshared fs/crypto/ code, but due to the potential security implications\nof this bug, it may still be worthwhile to backport this fix to them.\n\nFixes: b7236e21d55f (\"ext4 crypto: reorganize how we store keys in the inode\")\nCc: stable@vger.kernel.org # v4.2+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nAcked-by: Michael Halcrow <mhalcrow@google.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "keyinfo.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "9",
    "number_of_lines_deleted_vulnerable_to_cve": "43",
    "vulnerable_lines": [
        "// Line_Reference 105: \tdown_read(&keyring_key->sem);",
        "// Line_Reference 109: \t\tup_read(&keyring_key->sem);",
        "// Line_Reference 120: \t\tup_read(&keyring_key->sem);",
        "// Line_Reference 124: \tup_read(&keyring_key->sem);",
        "// Line_Reference 125: \tif (res)",
        "// Line_Reference 126: \t\tgoto out;",
        "// Line_Reference 127: ",
        "// Line_Reference 128: \tcrypt_info->ci_keyring_key = keyring_key;",
        "// Line_Reference 129: \treturn 0;",
        "// Line_Reference 172: \tkey_put(ci->ci_keyring_key);",
        "// Line_Reference 177: int fscrypt_get_crypt_info(struct inode *inode)",
        "// Line_Reference 193: retry:",
        "// Line_Reference 194: \tcrypt_info = ACCESS_ONCE(inode->i_crypt_info);",
        "// Line_Reference 195: \tif (crypt_info) {",
        "// Line_Reference 196: \t\tif (!crypt_info->ci_keyring_key ||",
        "// Line_Reference 197: \t\t\t\tkey_validate(crypt_info->ci_keyring_key) == 0)",
        "// Line_Reference 198: \t\t\treturn 0;",
        "// Line_Reference 199: \t\tfscrypt_put_encryption_info(inode, crypt_info);",
        "// Line_Reference 200: \t\tgoto retry;",
        "// Line_Reference 201: \t}",
        "// Line_Reference 232: \tcrypt_info->ci_keyring_key = NULL;",
        "// Line_Reference 276: \tkzfree(raw_key);",
        "// Line_Reference 277: \traw_key = NULL;",
        "// Line_Reference 278: \tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {",
        "// Line_Reference 279: \t\tput_crypt_info(crypt_info);",
        "// Line_Reference 280: \t\tgoto retry;",
        "// Line_Reference 281: \t}",
        "// Line_Reference 282: \treturn 0;",
        "// Line_Reference 283: ",
        "// Line_Reference 308: ",
        "// Line_Reference 309: int fscrypt_get_encryption_info(struct inode *inode)",
        "// Line_Reference 310: {",
        "// Line_Reference 311: \tstruct fscrypt_info *ci = inode->i_crypt_info;",
        "// Line_Reference 312: ",
        "// Line_Reference 313: \tif (!ci ||",
        "// Line_Reference 314: \t\t(ci->ci_keyring_key &&",
        "// Line_Reference 315: \t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |",
        "// Line_Reference 316: \t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |",
        "// Line_Reference 317: \t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))",
        "// Line_Reference 318: \t\treturn fscrypt_get_crypt_info(inode);",
        "// Line_Reference 319: \treturn 0;",
        "// Line_Reference 320: }",
        "// Line_Reference 321: EXPORT_SYMBOL(fscrypt_get_encryption_info);"
    ]
}
