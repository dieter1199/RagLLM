{
    "cve_id": "CVE-2014-0205",
    "cve_description": "The futex_wait function in kernel/futex.c in the Linux kernel before 2.6.37 does not properly maintain a certain reference count during requeue operations, which allows local users to cause a denial of service (use-after-free and system crash) or possibly gain privileges via a crafted application that triggers a zero count.",
    "cve_publish_date": "2014-09-28",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "futex: Fix errors in nested key ref-counting\n\nfutex_wait() is leaking key references due to futex_wait_setup()\nacquiring an additional reference via the queue_lock() routine. The\nnested key ref-counting has been masking bugs and complicating code\nanalysis. queue_lock() is only called with a previously ref-counted\nkey, so remove the additional ref-counting from the queue_(un)lock()\nfunctions.\n\nAlso futex_wait_requeue_pi() drops one key reference too many in\nunqueue_me_pi(). Remove the key reference handling from\nunqueue_me_pi(). This was paired with a queue_lock() in\nfutex_lock_pi(), so the count remains unchanged.\n\nDocument remaining nested key ref-counting sites.\n\nSigned-off-by: Darren Hart <dvhart@linux.intel.com>\nReported-and-tested-by: Matthieu Fertr√©<matthieu.fertre@kerlabs.com>\nReported-by: Louis Rilling<louis.rilling@kerlabs.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Eric Dumazet <eric.dumazet@gmail.com>\nCc: John Kacur <jkacur@redhat.com>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nLKML-Reference: <4CBB17A8.70401@linux.intel.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@kernel.org",
    "type_of_change": "Modification",
    "filename_of_changes": "futex.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "16",
    "number_of_lines_deleted_vulnerable_to_cve": "15",
    "vulnerable_lines": [
        "// Line_Reference 1366: \tget_futex_key_refs(&q->key);",
        "// Line_Reference 1378: \tdrop_futex_key_refs(&q->key);",
        "// Line_Reference 1483: ",
        "// Line_Reference 1484: \tdrop_futex_key_refs(&q->key);",
        "// Line_Reference 1815: \t/* Prepare to wait on uaddr. */",
        "// Line_Reference 1826: \t\tgoto out_put_key;",
        "// Line_Reference 1829: \t\tgoto out_put_key;",
        "// Line_Reference 1835: \tif (!signal_pending(current)) {",
        "// Line_Reference 1836: \t\tput_futex_key(fshared, &q.key);",
        "// Line_Reference 1838: \t}",
        "// Line_Reference 1842: \t\tgoto out_put_key;",
        "// Line_Reference 1859: out_put_key:",
        "// Line_Reference 1860: \tput_futex_key(fshared, &q.key);",
        "// Line_Reference 2239: \t/* Prepare to wait on uaddr. */",
        "// Line_Reference 2257: \t * race with the atomic proxy lock acquition by the requeue code."
    ]
}
