{
    "cve_id": "CVE-2021-43795",
    "cve_description": "Armeria is an open source microservice framework. In affected versions an attacker can access an Armeria server's local file system beyond its restricted directory by sending an HTTP request whose path contains `%2F` (encoded `/`), such as `/files/..%2Fsecrets.txt`, bypassing Armeria's path validation logic. Armeria 1.13.4 or above contains the hardened path validation logic that handles `%2F` properly. This vulnerability can be worked around by inserting a decorator that performs an additional validation on the request path.",
    "cve_publish_date": "2021-12-02",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "Merge pull request from GHSA-8fp4-rp6c-5gcv\n\nMotivation:\n\n- We changed how `PathAndQuery` handles `%2F` (/) in 1.12.0 via #3855.\n  This change introduces an unexpected hole in its double-dot detection\n  logic.\n- Since we decided not to decode `%2F`, we should not decode it\n  whereever possible.\n\nModifications:\n\n- Hardened the double-dot detection logic in `PathAndQuery`.\n- `Bytes.data` now always store the bytes in their decoded form. We keep\n  whether the byte has to be encoded in a separate `BitSet`.\n- Split `ArmeriaHttpUtil.decodePath()` into `decodePath()` and\n  `decodePathParam()`.\n  - We don't decode `%2F` in `decodePath()` but we do in\n    `decodePathParam()`.\n  - `RoutingResultBuilder.rawParam()` now uses `decodePathParam()`\n    because `decodePath()` doesn't decode `%2F` anymore.\n\nResult:\n\n- A path that contains double dots with `%2F`, such as\n  `/files/..%2Fsecrets.txt`, are now rejected correctly.",
    "type_of_change": "Modification",
    "filename_of_changes": "PathAndQuery.java",
    "code_language": "Java",
    "number_of_lines_added_for_mitigation": "184",
    "number_of_lines_deleted_vulnerable_to_cve": "125",
    "vulnerable_lines": [
        "// Line_Reference 50:     private static final int PERCENT_ENCODING_MARKER = 0xFF;",
        "// Line_Reference 52:     private static final byte[] RAW_CHAR_TO_MARKER = new byte[256];",
        "// Line_Reference 53:     private static final String[] MARKER_TO_PERCENT_ENCODED_CHAR = new String[256];",
        "// Line_Reference 68:         for (final ReservedChar reservedChar : ReservedChar.values()) {",
        "// Line_Reference 69:             RAW_CHAR_TO_MARKER[reservedChar.rawChar] = reservedChar.marker;",
        "// Line_Reference 70:             MARKER_TO_PERCENT_ENCODED_CHAR[reservedChar.marker] = reservedChar.percentEncodedChar;",
        "// Line_Reference 185:         return path + \"?\" + query;",
        "// Line_Reference 216:         if (path.data[0] != '/') {",
        "// Line_Reference 222:         if (pathContainsDoubleDots(path)) {",
        "// Line_Reference 226:         return new PathAndQuery(encodeToPercents(path, true),",
        "// Line_Reference 227:                                 query != null ? encodeToPercents(query, false) : null);",
        "// Line_Reference 264: ",
        "// Line_Reference 265:                         // Insert a special mark so we can distinguish a raw character ('/') and",
        "// Line_Reference 266:                         // percent-encoded character ('%2F') in a path string.",
        "// Line_Reference 267:                         // We will encode this mark back into a percent-encoded character later.",
        "// Line_Reference 268:                         final byte marker = RAW_CHAR_TO_MARKER['/'];",
        "// Line_Reference 269:                         buf.ensure(2);",
        "// Line_Reference 270:                         buf.add((byte) PERCENT_ENCODING_MARKER);",
        "// Line_Reference 271:                         buf.add(marker);",
        "// Line_Reference 282:                     final byte marker = RAW_CHAR_TO_MARKER[decoded];",
        "// Line_Reference 283:                     if (marker != 0) {",
        "// Line_Reference 284:                         // Insert a special mark so we can distinguish a raw character and percent-encoded",
        "// Line_Reference 285:                         // character in a query string, such as '&' and '%26'.",
        "// Line_Reference 286:                         // We will encode this mark back into a percent-encoded character later.",
        "// Line_Reference 287:                         buf.ensure(2);",
        "// Line_Reference 288:                         buf.add((byte) PERCENT_ENCODING_MARKER);",
        "// Line_Reference 289:                         buf.add(marker);",
        "// Line_Reference 304:                 buf.add((byte) ' ');",
        "// Line_Reference 319:                 buf.add((byte) ((cp >>> 6) | 0b110_00000));",
        "// Line_Reference 320:                 buf.add((byte) (cp & 0b111111 | 0b10_000000));",
        "// Line_Reference 323:                 buf.add((byte) ((cp >>> 12) | 0b1110_0000));",
        "// Line_Reference 324:                 buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));",
        "// Line_Reference 325:                 buf.add((byte) ((cp & 0b111111) | 0b10_000000));",
        "// Line_Reference 328:                 buf.add((byte) ((cp >>> 18) | 0b11110_000));",
        "// Line_Reference 329:                 buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));",
        "// Line_Reference 330:                 buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));",
        "// Line_Reference 331:                 buf.add((byte) ((cp & 0b111111) | 0b10_000000));",
        "// Line_Reference 336:                 buf.add((byte) ((cp >>> 24) | 0b111110_00));",
        "// Line_Reference 337:                 buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));",
        "// Line_Reference 338:                 buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));",
        "// Line_Reference 339:                 buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));",
        "// Line_Reference 340:                 buf.add((byte) ((cp & 0b111111) | 0b10_000000));",
        "// Line_Reference 345:                 buf.add((byte) ((cp >>> 30) | 0b1111110_0));",
        "// Line_Reference 346:                 buf.add((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));",
        "// Line_Reference 347:                 buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));",
        "// Line_Reference 348:                 buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));",
        "// Line_Reference 349:                 buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));",
        "// Line_Reference 350:                 buf.add((byte) ((cp & 0b111111) | 0b10_000000));",
        "// Line_Reference 384:             buf.add((byte) cp);",
        "// Line_Reference 397:             if (b3 == '/' && b2 == '.' && b1 == '.' && b0 == '/') {",
        "// Line_Reference 405:         return b0 == '/' && b1 == '.' && b2 == '.';",
        "// Line_Reference 408:     private static String encodeToPercents(Bytes value, boolean isPath) {",
        "// Line_Reference 409:         final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;",
        "// Line_Reference 410:         final int length = value.length;",
        "// Line_Reference 411:         boolean needsEncoding = false;",
        "// Line_Reference 413:             if (!allowedChars.get(value.data[i] & 0xFF)) {",
        "// Line_Reference 414:                 needsEncoding = true;",
        "// Line_Reference 415:                 break;",
        "// Line_Reference 419:         if (!needsEncoding) {",
        "// Line_Reference 422:             return new String(value.data, 0, 0, length);",
        "// Line_Reference 425:         final StringBuilder buf = new StringBuilder(length);",
        "// Line_Reference 429:             if (b == PERCENT_ENCODING_MARKER && (i + 1) < length) {",
        "// Line_Reference 430:                 final int marker = value.data[i + 1] & 0xFF;",
        "// Line_Reference 431:                 final String percentEncodedChar = MARKER_TO_PERCENT_ENCODED_CHAR[marker];",
        "// Line_Reference 432:                 if (percentEncodedChar != null) {",
        "// Line_Reference 433:                     buf.append(percentEncodedChar);",
        "// Line_Reference 434:                     i++;",
        "// Line_Reference 435:                     continue;",
        "// Line_Reference 436:                 }",
        "// Line_Reference 439:             if (allowedChars.get(b)) {",
        "// Line_Reference 440:                 buf.append((char) b);",
        "// Line_Reference 441:             } else if (b == ' ') {",
        "// Line_Reference 442:                 if (isPath) {",
        "// Line_Reference 443:                     buf.append(\"%20\");",
        "// Line_Reference 444:                 } else {",
        "// Line_Reference 445:                     buf.append('+');",
        "// Line_Reference 446:                 }",
        "// Line_Reference 447:             } else {",
        "// Line_Reference 448:                 buf.append('%');",
        "// Line_Reference 449:                 appendHexNibble(buf, b >>> 4);",
        "// Line_Reference 450:                 appendHexNibble(buf, b & 0xF);",
        "// Line_Reference 451:             }",
        "// Line_Reference 457:     private static void appendHexNibble(StringBuilder buf, int nibble) {",
        "// Line_Reference 458:         if (nibble < 10) {",
        "// Line_Reference 459:             buf.append((char) ('0' + nibble));",
        "// Line_Reference 460:         } else {",
        "// Line_Reference 461:             buf.append((char) ('A' + nibble - 10));",
        "// Line_Reference 534: ",
        "// Line_Reference 535:     /**",
        "// Line_Reference 536:      * Reserved characters which require percent-encoding. These values are only used for constructing",
        "// Line_Reference 537:      * {@link #RAW_CHAR_TO_MARKER} and {@link #MARKER_TO_PERCENT_ENCODED_CHAR} mapping tables.",
        "// Line_Reference 538:      *",
        "// Line_Reference 539:      * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\">RFC 3986, section 2.2</a>",
        "// Line_Reference 540:      */",
        "// Line_Reference 541:     private enum ReservedChar {",
        "// Line_Reference 542:         GEN_DELIM_01(':', \"%3A\", (byte) 0x01),",
        "// Line_Reference 543:         GEN_DELIM_02('/', \"%2F\", (byte) 0x02),",
        "// Line_Reference 544:         GEN_DELIM_03('?', \"%3F\", (byte) 0x03),",
        "// Line_Reference 545:         GEN_DELIM_04('#', \"%23\", (byte) 0x04),",
        "// Line_Reference 546:         GEN_DELIM_05('[', \"%5B\", (byte) 0x05),",
        "// Line_Reference 547:         GEN_DELIM_06(']', \"%5D\", (byte) 0x06),",
        "// Line_Reference 548:         GEN_DELIM_07('@', \"%40\", (byte) 0x07),",
        "// Line_Reference 549: ",
        "// Line_Reference 550:         SUB_DELIM_01('!', \"%21\", (byte) 0x11),",
        "// Line_Reference 551:         SUB_DELIM_02('$', \"%24\", (byte) 0x12),",
        "// Line_Reference 552:         SUB_DELIM_03('&', \"%26\", (byte) 0x13),",
        "// Line_Reference 553:         SUB_DELIM_04('\\'', \"%27\", (byte) 0x14),",
        "// Line_Reference 554:         SUB_DELIM_05('(', \"%28\", (byte) 0x15),",
        "// Line_Reference 555:         SUB_DELIM_06(')', \"%29\", (byte) 0x16),",
        "// Line_Reference 556:         SUB_DELIM_07('*', \"%2A\", (byte) 0x17),",
        "// Line_Reference 557:         SUB_DELIM_08('+', \"%2B\", (byte) 0x18),",
        "// Line_Reference 558:         SUB_DELIM_09(',', \"%2C\", (byte) 0x19),",
        "// Line_Reference 559:         SUB_DELIM_10(';', \"%3B\", (byte) 0x1A),",
        "// Line_Reference 560:         SUB_DELIM_11('=', \"%3D\", (byte) 0x1B);",
        "// Line_Reference 561: ",
        "// Line_Reference 562:         private final int rawChar;",
        "// Line_Reference 563:         private final String percentEncodedChar;",
        "// Line_Reference 564:         private final byte marker;",
        "// Line_Reference 565: ",
        "// Line_Reference 566:         ReservedChar(int rawChar, String percentEncodedChar, byte marker) {",
        "// Line_Reference 567:             this.rawChar = rawChar;",
        "// Line_Reference 568:             this.percentEncodedChar = percentEncodedChar;",
        "// Line_Reference 569:             this.marker = marker;",
        "// Line_Reference 570:         }",
        "// Line_Reference 571:     }"
    ]
}
