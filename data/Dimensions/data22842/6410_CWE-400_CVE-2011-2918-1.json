{
    "cve_id": "CVE-2011-2918",
    "cve_description": "The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application.",
    "cve_publish_date": "2012-05-24",
    "cwe_id": "CWE-400",
    "cwe_name": "Uncontrolled Resource Consumption",
    "cwe_description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "commit_message": "perf: Remove the nmi parameter from the swevent and overflow interface\n\nThe nmi parameter indicated if we could do wakeups from the current\ncontext, if not, we would set some state and self-IPI and let the\nresulting interrupt do the wakeup.\n\nFor the various event classes:\n\n  - hardware: nmi=0; PMI is in fact an NMI or we run irq_work_run from\n    the PMI-tail (ARM etc.)\n  - tracepoint: nmi=0; since tracepoint could be from NMI context.\n  - software: nmi=[0,1]; some, like the schedule thing cannot\n    perform wakeups, and hence need 0.\n\nAs one can see, there is very little nmi=1 usage, and the down-side of\nnot using it is that on some platforms some software events can have a\njiffy delay in wakeup (when arch_irq_work_raise isn't implemented).\n\nThe up-side however is that we can remove the nmi parameter and save a\nbunch of conditionals in fast paths.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: Michael Cree <mcree@orcon.net.nz>\nCc: Will Deacon <will.deacon@arm.com>\nCc: Deng-Cheng Zhu <dengcheng.zhu@gmail.com>\nCc: Anton Blanchard <anton@samba.org>\nCc: Eric B Munson <emunson@mgebm.net>\nCc: Heiko Carstens <heiko.carstens@de.ibm.com>\nCc: Paul Mundt <lethal@linux-sh.org>\nCc: David S. Miller <davem@davemloft.net>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Jason Wessel <jason.wessel@windriver.com>\nCc: Don Zickus <dzickus@redhat.com>\nLink: http://lkml.kernel.org/n/tip-agjev8eu666tvknpb3iaj0fg@git.kernel.org\nSigned-off-by: Ingo Molnar <mingo@elte.hu>",
    "type_of_change": "Modification",
    "filename_of_changes": "core.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "28",
    "number_of_lines_deleted_vulnerable_to_cve": "35",
    "vulnerable_lines": [
        "// Line_Reference 3975: static void perf_event_output(struct perf_event *event, int nmi,",
        "// Line_Reference 3987: \tif (perf_output_begin(&handle, event, header.size, nmi, 1))",
        "// Line_Reference 4027: \tret = perf_output_begin(&handle, event, read_event.header.size, 0, 0);",
        "// Line_Reference 4070: \t\t\t\ttask_event->event_id.header.size, 0, 0);",
        "// Line_Reference 4207: \t\t\t\tcomm_event->event_id.header.size, 0, 0);",
        "// Line_Reference 4354: \t\t\t\tmmap_event->event_id.header.size, 0, 0);",
        "// Line_Reference 4549: \t\t\t\tthrottle_event.header.size, 1, 0);",
        "// Line_Reference 4562: static int __perf_event_overflow(struct perf_event *event, int nmi,",
        "// Line_Reference 4605: \t\tif (nmi) {",
        "// Line_Reference 4606: \t\t\tevent->pending_disable = 1;",
        "// Line_Reference 4607: \t\t\tirq_work_queue(&event->pending);",
        "// Line_Reference 4608: \t\t} else",
        "// Line_Reference 4609: \t\t\tperf_event_disable(event);",
        "// Line_Reference 4613: \t\tevent->overflow_handler(event, nmi, data, regs);",
        "// Line_Reference 4615: \t\tperf_event_output(event, nmi, data, regs);",
        "// Line_Reference 4618: \t\tif (nmi) {",
        "// Line_Reference 4619: \t\t\tevent->pending_wakeup = 1;",
        "// Line_Reference 4620: \t\t\tirq_work_queue(&event->pending);",
        "// Line_Reference 4621: \t\t} else",
        "// Line_Reference 4622: \t\t\tperf_event_wakeup(event);",
        "// Line_Reference 4628: int perf_event_overflow(struct perf_event *event, int nmi,",
        "// Line_Reference 4632: \treturn __perf_event_overflow(event, nmi, 1, data, regs);",
        "// Line_Reference 4681: \t\t\t\t    int nmi, struct perf_sample_data *data,",
        "// Line_Reference 4695: \t\tif (__perf_event_overflow(event, nmi, throttle,",
        "// Line_Reference 4708: \t\t\t       int nmi, struct perf_sample_data *data,",
        "// Line_Reference 4722: \t\treturn perf_swevent_overflow(event, 1, nmi, data, regs);",
        "// Line_Reference 4727: \tperf_swevent_overflow(event, 0, nmi, data, regs);",
        "// Line_Reference 4815: \t\t\t\t    u64 nr, int nmi,",
        "// Line_Reference 4831: \t\t\tperf_swevent_event(event, nr, nmi, data, regs);",
        "// Line_Reference 4852: void __perf_sw_event(u32 event_id, u64 nr, int nmi,",
        "// Line_Reference 4853: \t\t\t    struct pt_regs *regs, u64 addr)",
        "// Line_Reference 4865: \tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);",
        "// Line_Reference 5113: \t\t\tperf_swevent_event(event, count, 1, &data, regs);",
        "// Line_Reference 5206: \t\tperf_swevent_event(bp, 1, 1, &sample, regs);",
        "// Line_Reference 5235: \t\t\tif (perf_event_overflow(event, 0, &data, regs))"
    ]
}
