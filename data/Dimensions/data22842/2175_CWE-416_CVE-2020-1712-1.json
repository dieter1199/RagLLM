{
    "cve_id": "CVE-2020-1712",
    "cve_description": "A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.",
    "cve_publish_date": "2020-03-31",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "polkit: when authorizing via PK let's re-resolve callback/userdata instead of caching it\n\nPreviously, when doing an async PK query we'd store the original\ncallback/userdata pair and call it again after the PK request is\ncomplete. This is problematic, since PK queries might be slow and in the\nmeantime the userdata might be released and re-acquired. Let's avoid\nthis by always traversing through the message handlers so that we always\nre-resolve the callback and userdata pair and thus can be sure it's\nup-to-date and properly valid.",
    "type_of_change": "Modification",
    "filename_of_changes": "bus-polkit.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "50",
    "number_of_lines_deleted_vulnerable_to_cve": "26",
    "vulnerable_lines": [
        "// Line_Reference 162:         sd_bus_message_handler_t callback;",
        "// Line_Reference 163:         void *userdata;",
        "// Line_Reference 169: ",
        "// Line_Reference 199:         if (r < 0) {",
        "// Line_Reference 200:                 r = sd_bus_reply_method_errno(q->request, r, NULL);",
        "// Line_Reference 201:                 goto finish;",
        "// Line_Reference 202:         }",
        "// Line_Reference 204:         r = q->callback(q->request, q->userdata, &error_buffer);",
        "// Line_Reference 205:         r = bus_maybe_reply_error(q->request, r, &error_buffer);",
        "// Line_Reference 207: finish:",
        "// Line_Reference 209: ",
        "// Line_Reference 228:         const char *sender;",
        "// Line_Reference 229:         sd_bus_message_handler_t callback;",
        "// Line_Reference 230:         void *userdata;",
        "// Line_Reference 296: #if ENABLE_POLKIT",
        "// Line_Reference 297:         if (sd_bus_get_current_message(call->bus) != call)",
        "// Line_Reference 298:                 return -EINVAL;",
        "// Line_Reference 299: ",
        "// Line_Reference 300:         callback = sd_bus_get_current_handler(call->bus);",
        "// Line_Reference 301:         if (!callback)",
        "// Line_Reference 302:                 return -EINVAL;",
        "// Line_Reference 303: ",
        "// Line_Reference 304:         userdata = sd_bus_get_current_userdata(call->bus);",
        "// Line_Reference 305: ",
        "// Line_Reference 352:                 .callback = callback,",
        "// Line_Reference 353:                 .userdata = userdata,"
    ]
}
