{
    "cve_id": "CVE-2014-4608",
    "cve_description": "Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says \"the Linux kernel is *not* affected; media hype.",
    "cve_publish_date": "2014-07-03",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "lzo: properly check for overruns\n\nThe lzo decompressor can, if given some really crazy data, possibly\noverrun some variable types.  Modify the checking logic to properly\ndetect overruns before they happen.\n\nReported-by: \"Don A. Bailey\" <donb@securitymouse.com>\nTested-by: \"Don A. Bailey\" <donb@securitymouse.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "lzo1x_decompress_safe.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "41",
    "number_of_lines_deleted_vulnerable_to_cve": "21",
    "vulnerable_lines": [
        "// Line_Reference 22: #define HAVE_IP(x)      ((size_t)(ip_end - ip) >= (size_t)(x))",
        "// Line_Reference 23: #define HAVE_OP(x)      ((size_t)(op_end - op) >= (size_t)(x))",
        "// Line_Reference 24: #define NEED_IP(x)      if (!HAVE_IP(x)) goto input_overrun",
        "// Line_Reference 25: #define NEED_OP(x)      if (!HAVE_OP(x)) goto output_overrun",
        "// Line_Reference 26: #define TEST_LB(m_pos)  if ((m_pos) < out) goto lookbehind_overrun",
        "// Line_Reference 61: \t\t\t\t\t\tNEED_IP(1);",
        "// Line_Reference 68: \t\t\t\tif (likely(HAVE_IP(t + 15) && HAVE_OP(t + 15))) {",
        "// Line_Reference 84: \t\t\t\t\tNEED_OP(t);",
        "// Line_Reference 85: \t\t\t\t\tNEED_IP(t + 3);",
        "// Line_Reference 98: \t\t\t\tNEED_OP(2);",
        "// Line_Reference 122: \t\t\t\t\tNEED_IP(1);",
        "// Line_Reference 125: \t\t\t\tNEED_IP(2);",
        "// Line_Reference 140: \t\t\t\t\tNEED_IP(1);",
        "// Line_Reference 143: \t\t\t\tNEED_IP(2);",
        "// Line_Reference 157: \t\t\tif (likely(HAVE_OP(t + 15))) {",
        "// Line_Reference 167: \t\t\t\tif (HAVE_IP(6)) {",
        "// Line_Reference 175: \t\t\t\tNEED_OP(t);",
        "// Line_Reference 184: \t\t\tNEED_OP(t);",
        "// Line_Reference 197: \t\tif (likely(HAVE_IP(6) && HAVE_OP(4))) {",
        "// Line_Reference 204: \t\t\tNEED_IP(t + 3);",
        "// Line_Reference 205: \t\t\tNEED_OP(t);"
    ]
}
