{
    "cve_id": "CVE-2017-17807",
    "cve_description": "The KEYS subsystem in the Linux kernel before 4.14.6 omitted an access-control check when adding a key to the current task's \"default request-key keyring\" via the request_key() system call, allowing a local user to use a sequence of crafted system calls to add keys to a keyring with only Search permission (not Write permission) to that keyring, related to construct_get_dest_keyring() in security/keys/request_key.c.",
    "cve_publish_date": "2017-12-20",
    "cwe_id": "CWE-862",
    "cwe_name": "Missing Authorization",
    "cwe_description": "The product does not perform an authorization check when an actor attempts to access a resource or perform an action.",
    "commit_message": "KEYS: add missing permission check for request_key() destination\n\nWhen the request_key() syscall is not passed a destination keyring, it\nlinks the requested key (if constructed) into the \"default\" request-key\nkeyring.  This should require Write permission to the keyring.  However,\nthere is actually no permission check.\n\nThis can be abused to add keys to any keyring to which only Search\npermission is granted.  This is because Search permission allows joining\nthe keyring.  keyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_SESSION_KEYRING)\nthen will set the default request-key keyring to the session keyring.\nThen, request_key() can be used to add keys to the keyring.\n\nBoth negatively and positively instantiated keys can be added using this\nmethod.  Adding negative keys is trivial.  Adding a positive key is a\nbit trickier.  It requires that either /sbin/request-key positively\ninstantiates the key, or that another thread adds the key to the process\nkeyring at just the right time, such that request_key() misses it\ninitially but then finds it in construct_alloc_key().\n\nFix this bug by checking for Write permission to the keyring in\nconstruct_get_dest_keyring() when the default keyring is being used.\n\nWe don't do the permission check for non-default keyrings because that\nwas already done by the earlier call to lookup_user_key().  Also,\nrequest_key_and_link() is currently passed a 'struct key *' rather than\na key_ref_t, so the \"possessed\" bit is unavailable.\n\nWe also don't do the permission check for the \"requestor keyring\", to\ncontinue to support the use case described by commit 8bbf4976b59f\n(\"KEYS: Alter use of key instantiation link-to-keyring argument\") where\n/sbin/request-key recursively calls request_key() to add keys to the\noriginal requestor's destination keyring.  (I don't know of any users\nwho actually do that, though...)\n\nFixes: 3e30148c3d52 (\"[PATCH] Keys: Make request-key create an authorisation key\")\nCc: <stable@vger.kernel.org>\t# v2.6.13+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "request_key.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "37",
    "number_of_lines_deleted_vulnerable_to_cve": "9",
    "vulnerable_lines": [
        "// Line_Reference 254: static void construct_get_dest_keyring(struct key **_dest_keyring)",
        "// Line_Reference 281: \t\t\t\tif (dest_keyring)",
        "// Line_Reference 321: \treturn;",
        "// Line_Reference 447: \tuser = key_user_lookup(current_fsuid());",
        "// Line_Reference 448: \tif (!user)",
        "// Line_Reference 449: \t\treturn ERR_PTR(-ENOMEM);",
        "// Line_Reference 451: \tconstruct_get_dest_keyring(&dest_keyring);",
        "// Line_Reference 466: \t\tgoto couldnt_alloc_key;",
        "// Line_Reference 476: couldnt_alloc_key:"
    ]
}
