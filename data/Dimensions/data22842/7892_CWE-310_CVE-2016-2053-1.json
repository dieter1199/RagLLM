{
    "cve_id": "CVE-2016-2053",
    "cve_description": "The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c.",
    "cve_publish_date": "2016-05-02",
    "cwe_id": "CWE-310",
    "cwe_name": "Cryptographic Issues",
    "cwe_description": "Weaknesses in this category are related to the design and implementation of data confidentiality and integrity. Frequently these deal with the use of encoding techniques, encryption libraries, and hashing algorithms. The weaknesses in this category could lead to a degradation of the quality data if they are not addressed.",
    "commit_message": "ASN.1: Fix non-match detection failure on data overrun\n\nIf the ASN.1 decoder is asked to parse a sequence of objects, non-optional\nmatches get skipped if there's no more data to be had rather than a\ndata-overrun error being reported.\n\nThis is due to the code segment that decides whether to skip optional\nmatches (ie. matches that could get ignored because an element is marked\nOPTIONAL in the grammar) due to a lack of data also skips non-optional\nelements if the data pointer has reached the end of the buffer.\n\nThis can be tested with the data decoder for the new RSA akcipher algorithm\nthat takes three non-optional integers.  Currently, it skips the last\ninteger if there is insufficient data.\n\nWithout the fix, #defining DEBUG in asn1_decoder.c will show something\nlike:\n\n\tnext_op: pc=0/13 dp=0/270 C=0 J=0\n\t- match? 30 30 00\n\t- TAG: 30 266 CONS\n\tnext_op: pc=2/13 dp=4/270 C=1 J=0\n\t- match? 02 02 00\n\t- TAG: 02 257\n\t- LEAF: 257\n\tnext_op: pc=5/13 dp=265/270 C=1 J=0\n\t- match? 02 02 00\n\t- TAG: 02 3\n\t- LEAF: 3\n\tnext_op: pc=8/13 dp=270/270 C=1 J=0\n\tnext_op: pc=11/13 dp=270/270 C=1 J=0\n\t- end cons t=4 dp=270 l=270/270\n\nThe next_op line for pc=8/13 should be followed by a match line.\n\nThis is not exploitable for X.509 certificates by means of shortening the\nmessage and fixing up the ASN.1 CONS tags because:\n\n (1) The relevant records being built up are cleared before use.\n\n (2) If the message is shortened sufficiently to remove the public key, the\n     ASN.1 parse of the RSA key will fail quickly due to a lack of data.\n\n (3) Extracted signature data is either turned into MPIs (which cope with a\n     0 length) or is simpler integers specifying algoritms and suchlike\n     (which can validly be 0); and\n\n (4) The AKID and SKID extensions are optional and their removal is handled\n     without risking passing a NULL to asymmetric_key_generate_id().\n\n (5) If the certificate is truncated sufficiently to remove the subject,\n     issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons\n     stack underflow' return.\n\nThis is not exploitable for PKCS#7 messages by means of removal of elements\nfrom such a message from the tail end of a sequence:\n\n (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable\n     as detailed above.\n\n (2) The message digest content isn't used if it shows a NULL pointer,\n     similarly, the authattrs aren't used if that shows a NULL pointer.\n\n (3) A missing signature results in a NULL MPI - which the MPI routines deal\n     with.\n\n (4) If data is NULL, it is expected that the message has detached content and\n     that is handled appropriately.\n\n (5) If the serialNumber is excised, the unconditional action associated\n     with it will pick up the containing SEQUENCE instead, so no NULL\n     pointer will be seen here.\n\n     If both the issuer and the serialNumber are excised, the ASN.1 decode\n     will fail with an 'Unexpected tag' return.\n\n     In either case, there's no way to get to asymmetric_key_generate_id()\n     with a NULL pointer.\n\n (6) Other fields are decoded to simple integers.  Shortening the message\n     to omit an algorithm ID field will cause checks on this to fail early\n     in the verification process.\n\n\nThis can also be tested by snipping objects off of the end of the ASN.1 stream\nsuch that mandatory tags are removed - or even from the end of internal\nSEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be\nproduced.  Without this patch ERANGE or ENOPKG might be produced or the parse\nmay apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced\nlater, depending on what gets snipped.\n\nJust snipping off the final BIT_STRING or OCTET_STRING from either sample\nshould be a start since both are mandatory and neither will cause an EBADMSG\nwithout the patches\n\nReported-by: Marcel Holtmann <marcel@holtmann.org>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Marcel Holtmann <marcel@holtmann.org>\nReviewed-by: David Woodhouse <David.Woodhouse@intel.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "asn1_decoder.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "2",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 213: \t\tif ((op & ASN1_OP_MATCH__COND &&",
        "// Line_Reference 214: \t\t     flags & FLAG_MATCHED) ||",
        "// Line_Reference 215: \t\t    dp == datalen) {"
    ]
}
