{
    "cve_id": "CVE-2016-4581",
    "cve_description": "fs/pnode.c in the Linux kernel before 4.5.4 does not properly traverse a mount propagation tree in a certain case involving a slave mount, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted series of mount system calls.",
    "cve_publish_date": "2016-05-23",
    "cwe_id": "NVD-CWE-Other",
    "cwe_name": "Other",
    "cwe_description": "NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",
    "commit_message": "propogate_mnt: Handle the first propogated copy being a slave\n\nWhen the first propgated copy was a slave the following oops would result:\n> BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n> IP: [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> PGD bacd4067 PUD bac66067 PMD 0\n> Oops: 0000 [#1] SMP\n> Modules linked in:\n> CPU: 1 PID: 824 Comm: mount Not tainted 4.6.0-rc5userns+ #1523\n> Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007\n> task: ffff8800bb0a8000 ti: ffff8800bac3c000 task.ti: ffff8800bac3c000\n> RIP: 0010:[<ffffffff811fba4e>]  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n> RSP: 0018:ffff8800bac3fd38  EFLAGS: 00010283\n> RAX: 0000000000000000 RBX: ffff8800bb77ec00 RCX: 0000000000000010\n> RDX: 0000000000000000 RSI: ffff8800bb58c000 RDI: ffff8800bb58c480\n> RBP: ffff8800bac3fd48 R08: 0000000000000001 R09: 0000000000000000\n> R10: 0000000000001ca1 R11: 0000000000001c9d R12: 0000000000000000\n> R13: ffff8800ba713800 R14: ffff8800bac3fda0 R15: ffff8800bb77ec00\n> FS:  00007f3c0cd9b7e0(0000) GS:ffff8800bfb00000(0000) knlGS:0000000000000000\n> CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n> CR2: 0000000000000010 CR3: 00000000bb79d000 CR4: 00000000000006e0\n> Stack:\n>  ffff8800bb77ec00 0000000000000000 ffff8800bac3fd88 ffffffff811fbf85\n>  ffff8800bac3fd98 ffff8800bb77f080 ffff8800ba713800 ffff8800bb262b40\n>  0000000000000000 0000000000000000 ffff8800bac3fdd8 ffffffff811f1da0\n> Call Trace:\n>  [<ffffffff811fbf85>] propagate_mnt+0x105/0x140\n>  [<ffffffff811f1da0>] attach_recursive_mnt+0x120/0x1e0\n>  [<ffffffff811f1ec3>] graft_tree+0x63/0x70\n>  [<ffffffff811f1f6b>] do_add_mount+0x9b/0x100\n>  [<ffffffff811f2c1a>] do_mount+0x2aa/0xdf0\n>  [<ffffffff8117efbe>] ? strndup_user+0x4e/0x70\n>  [<ffffffff811f3a45>] SyS_mount+0x75/0xc0\n>  [<ffffffff8100242b>] do_syscall_64+0x4b/0xa0\n>  [<ffffffff81988f3c>] entry_SYSCALL64_slow_path+0x25/0x25\n> Code: 00 00 75 ec 48 89 0d 02 22 22 01 8b 89 10 01 00 00 48 89 05 fd 21 22 01 39 8e 10 01 00 00 0f 84 e0 00 00 00 48 8b 80 d8 00 00 00 <48> 8b 50 10 48 89 05 df 21 22 01 48 89 15 d0 21 22 01 8b 53 30\n> RIP  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0\n>  RSP <ffff8800bac3fd38>\n> CR2: 0000000000000010\n> ---[ end trace 2725ecd95164f217 ]---\n\nThis oops happens with the namespace_sem held and can be triggered by\nnon-root users.  An all around not pleasant experience.\n\nTo avoid this scenario when finding the appropriate source mount to\ncopy stop the walk up the mnt_master chain when the first source mount\nis encountered.\n\nFurther rewrite the walk up the last_source mnt_master chain so that\nit is clear what is going on.\n\nThe reason why the first source mount is special is that it it's\nmnt_parent is not a mount in the dest_mnt propagation tree, and as\nsuch termination conditions based up on the dest_mnt mount propgation\ntree do not make sense.\n\nTo avoid other kinds of confusion last_dest is not changed when\ncomputing last_source.  last_dest is only used once in propagate_one\nand that is above the point of the code being modified, so changing\nthe global variable is meaningless and confusing.\n\nCc: stable@vger.kernel.org\nfixes: f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68 (\"smarter propagate_mnt()\")\nReported-by: Tycho Andersen <tycho.andersen@canonical.com>\nReviewed-by: Seth Forshee <seth.forshee@canonical.com>\nTested-by: Seth Forshee <seth.forshee@canonical.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "pnode.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "14",
    "number_of_lines_deleted_vulnerable_to_cve": "11",
    "vulnerable_lines": [
        "// Line_Reference 201: static struct mount *last_dest, *last_source, *dest_master;",
        "// Line_Reference 226: \t\t\tif (p == dest_master || IS_MNT_MARKED(p)) {",
        "// Line_Reference 227: \t\t\t\twhile (last_dest->mnt_master != p) {",
        "// Line_Reference 228: \t\t\t\t\tlast_source = last_source->mnt_master;",
        "// Line_Reference 229: \t\t\t\t\tlast_dest = last_source->mnt_parent;",
        "// Line_Reference 230: \t\t\t\t}",
        "// Line_Reference 231: \t\t\t\tif (!peers(n, last_dest)) {",
        "// Line_Reference 232: \t\t\t\t\tlast_source = last_source->mnt_master;",
        "// Line_Reference 233: \t\t\t\t\tlast_dest = last_source->mnt_parent;",
        "// Line_Reference 234: \t\t\t\t}",
        "// Line_Reference 236: \t\t\t}"
    ]
}
