{
    "cve_id": "CVE-2024-27102",
    "cve_description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-13",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "server(filesystem): rebuild everything imaginable\n\nThis wonderfully large commit replaces basically everything under the\n`server/filesystem` package, re-implementing essentially everything.\n\nThis is related to\nhttps://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9\n\nIf any vulnerabilities related to symlinks persist after this commit, I\nwill be very upset.\n\nSigned-off-by: Matthew Penner <me@matthewp.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "compress.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "77",
    "number_of_lines_deleted_vulnerable_to_cve": "81",
    "vulnerable_lines": [
        "// Line_Reference 8: \t\"os\"",
        "// Line_Reference 28: func (fs *Filesystem) CompressFiles(dir string, paths []string) (os.FileInfo, error) {",
        "// Line_Reference 29: \tcleanedRootDir, err := fs.SafePath(dir)",
        "// Line_Reference 33: ",
        "// Line_Reference 34: \t// Take all the paths passed in and merge them together with the root directory we've gotten.",
        "// Line_Reference 35: \tfor i, p := range paths {",
        "// Line_Reference 36: \t\tpaths[i] = filepath.Join(cleanedRootDir, p)",
        "// Line_Reference 39: \tcleaned, err := fs.ParallelSafePath(paths)",
        "// Line_Reference 44: \ta := &Archive{BasePath: cleanedRootDir, Files: cleaned}",
        "// Line_Reference 45: \td := path.Join(",
        "// Line_Reference 46: \t\tcleanedRootDir,",
        "// Line_Reference 47: \t\tfmt.Sprintf(\"archive-%s.tar.gz\", strings.ReplaceAll(time.Now().Format(time.RFC3339), \":\", \"\")),",
        "// Line_Reference 48: \t)",
        "// Line_Reference 49: ",
        "// Line_Reference 50: \tif err := a.Create(context.Background(), d); err != nil {",
        "// Line_Reference 54: \tf, err := os.Stat(d)",
        "// Line_Reference 55: \tif err != nil {",
        "// Line_Reference 56: \t\t_ = os.Remove(d)",
        "// Line_Reference 60: \tif err := fs.HasSpaceFor(f.Size()); err != nil {",
        "// Line_Reference 61: \t\t_ = os.Remove(d)",
        "// Line_Reference 65: \tfs.addDisk(f.Size())",
        "// Line_Reference 67: \treturn f, nil",
        "// Line_Reference 79: \tsource, err := fs.SafePath(filepath.Join(dir, file))",
        "// Line_Reference 80: \tif err != nil {",
        "// Line_Reference 81: \t\treturn err",
        "// Line_Reference 82: \t}",
        "// Line_Reference 83: ",
        "// Line_Reference 84: \t// Get the cached size in a parallel process so that if it is not cached we are not",
        "// Line_Reference 85: \t// waiting an unnecessary amount of time on this call.",
        "// Line_Reference 86: \tdirSize, err := fs.DiskUsage(false)",
        "// Line_Reference 87: ",
        "// Line_Reference 88: \tfsys, err := archiver.FileSystem(ctx, source)",
        "// Line_Reference 96: \tvar size int64",
        "// Line_Reference 111: \t\t\tif atomic.AddInt64(&size, info.Size())+dirSize > fs.MaxDisk() {",
        "// Line_Reference 125: \tsource, err := fs.SafePath(filepath.Join(dir, file))",
        "// Line_Reference 126: \tif err != nil {",
        "// Line_Reference 127: \t\treturn err",
        "// Line_Reference 128: \t}",
        "// Line_Reference 129: \treturn fs.DecompressFileUnsafe(ctx, dir, source)",
        "// Line_Reference 130: }",
        "// Line_Reference 131: ",
        "// Line_Reference 132: // DecompressFileUnsafe will decompress any file on the local disk without checking",
        "// Line_Reference 133: // if it is owned by the server.  The file will be SAFELY decompressed and extracted",
        "// Line_Reference 134: // into the server's directory.",
        "// Line_Reference 135: func (fs *Filesystem) DecompressFileUnsafe(ctx context.Context, dir string, file string) error {",
        "// Line_Reference 136: \t// Ensure that the archive actually exists on the system.",
        "// Line_Reference 137: \tif _, err := os.Stat(file); err != nil {",
        "// Line_Reference 138: \t\treturn errors.WithStack(err)",
        "// Line_Reference 139: \t}",
        "// Line_Reference 140: ",
        "// Line_Reference 141: \tf, err := os.Open(file)",
        "// Line_Reference 172: ",
        "// Line_Reference 193: \tif ex, ok := opts.Format.(archiver.Extractor); ok {",
        "// Line_Reference 194: \t\treturn ex.Extract(ctx, opts.Reader, nil, func(ctx context.Context, f archiver.File) error {",
        "// Line_Reference 195: \t\t\tif f.IsDir() {",
        "// Line_Reference 196: \t\t\t\treturn nil",
        "// Line_Reference 197: \t\t\t}",
        "// Line_Reference 198: \t\t\tp := filepath.Join(opts.Directory, f.NameInArchive)",
        "// Line_Reference 199: \t\t\t// If it is ignored, just don't do anything with the file and skip over it.",
        "// Line_Reference 200: \t\t\tif err := fs.IsIgnored(p); err != nil {",
        "// Line_Reference 201: \t\t\t\treturn nil",
        "// Line_Reference 202: \t\t\t}",
        "// Line_Reference 203: \t\t\tr, err := f.Open()",
        "// Line_Reference 204: \t\t\tif err != nil {",
        "// Line_Reference 205: \t\t\t\treturn err",
        "// Line_Reference 206: \t\t\t}",
        "// Line_Reference 207: \t\t\tdefer r.Close()",
        "// Line_Reference 208: \t\t\tif err := fs.Writefile(p, r); err != nil {",
        "// Line_Reference 209: \t\t\t\treturn wrapError(err, opts.FileName)",
        "// Line_Reference 210: \t\t\t}",
        "// Line_Reference 211: \t\t\t// Update the file permissions to the one set in the archive.",
        "// Line_Reference 212: \t\t\tif err := fs.Chmod(p, f.Mode()); err != nil {",
        "// Line_Reference 213: \t\t\t\treturn wrapError(err, opts.FileName)",
        "// Line_Reference 214: \t\t\t}",
        "// Line_Reference 215: \t\t\t// Update the file modification time to the one set in the archive.",
        "// Line_Reference 216: \t\t\tif err := fs.Chtimes(p, f.ModTime(), f.ModTime()); err != nil {",
        "// Line_Reference 217: \t\t\t\treturn wrapError(err, opts.FileName)",
        "// Line_Reference 218: \t\t\t}",
        "// Line_Reference 219: \t\t\treturn nil",
        "// Line_Reference 220: \t\t})",
        "// Line_Reference 222: \treturn nil"
    ]
}
