{
    "cve_id": "CVE-2022-46153",
    "cve_description": "Traefik is an open source HTTP reverse proxy and load balancer. In affected versions there is a potential vulnerability in Traefik managing TLS connections. A router configured with a not well-formatted TLSOption is exposed with an empty TLSOption. For instance, a route secured using an mTLS connection set with a wrong CA file is exposed without verifying the client certificates. Users are advised to upgrade to version 2.9.6. Users unable to upgrade should check their logs to detect the error messages and fix your TLS options.",
    "cve_publish_date": "2022-12-08",
    "cwe_id": "CWE-295",
    "cwe_name": "Improper Certificate Validation",
    "cwe_description": "The product does not validate, or incorrectly validates, a certificate.",
    "commit_message": "Handle broken TLS conf better\n\nCo-authored-by: Jean-Baptiste Doumenjou <925513+jbdoumenjou@users.noreply.github.com>\nCo-authored-by: Romain <rtribotte@users.noreply.github.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "manager.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "94",
    "number_of_lines_deleted_vulnerable_to_cve": "48",
    "vulnerable_lines": [
        "// Line_Reference 111: \t// Keyed by domain. The source of truth for doing SNI checking, and for what TLS",
        "// Line_Reference 112: \t// options will actually be used for the connection.",
        "// Line_Reference 145: \t\t\t// Extra Host(*) rule, for HTTPS routers with no Host rule, and for requests for",
        "// Line_Reference 146: \t\t\t// which the SNI does not match _any_ of the other existing routers Host. This is",
        "// Line_Reference 147: \t\t\t// only about choosing the TLS configuration. The actual routing will be done",
        "// Line_Reference 148: \t\t\t// further on by the HTTPS handler. See examples below.",
        "// Line_Reference 151: \t\t\t// The server name (from a Host(SNI) rule) is the only parameter (available in",
        "// Line_Reference 152: \t\t\t// HTTP routing rules) on which we can map a TLS config, because it is the only one",
        "// Line_Reference 153: \t\t\t// accessible before decryption (we obtain it during the ClientHello). Therefore,",
        "// Line_Reference 154: \t\t\t// when a router has no Host rule, it does not make any sense to specify some TLS",
        "// Line_Reference 155: \t\t\t// options. Consequently, when it comes to deciding what TLS config will be used,",
        "// Line_Reference 156: \t\t\t// for a request that will match an HTTPS router with no Host rule, the result will",
        "// Line_Reference 157: \t\t\t// depend on the _others_ existing routers (their Host rule, to be precise), and",
        "// Line_Reference 158: \t\t\t// the TLS options associated with them, even though they don't match the incoming",
        "// Line_Reference 159: \t\t\t// request. Consider the following examples:",
        "// Line_Reference 173: \t\t\t//\t# When a request for \"/foo\" comes, even though it won't be routed by",
        "// Line_Reference 174: \t\t\t//\thttpRouter2, if its SNI is set to foo.com, myTLSOptions will be used for the TLS",
        "// Line_Reference 175: \t\t\t//\tconnection. Otherwise, it will fallback to the default TLS config.",
        "// Line_Reference 179: \t\ttlsConf, err := m.tlsManager.Get(traefiktls.DefaultTLSStoreName, tlsOptionsName)",
        "// Line_Reference 180: \t\tif err != nil {",
        "// Line_Reference 181: \t\t\trouterHTTPConfig.AddError(err, true)",
        "// Line_Reference 182: \t\t\tlogger.Error(err)",
        "// Line_Reference 183: \t\t\tcontinue",
        "// Line_Reference 220: \t\t\tlogger.Debugf(\"Adding route for %s with TLS options %s\", hostSNI, optionsName)",
        "// Line_Reference 223: \t\t} else {",
        "// Line_Reference 224: \t\t\trouters := make([]string, 0, len(tlsConfigs))",
        "// Line_Reference 225: \t\t\tfor _, v := range tlsConfigs {",
        "// Line_Reference 226: \t\t\t\tconfigsHTTP[v.routerName].AddError(fmt.Errorf(\"found different TLS options for routers on the same host %v, so using the default TLS options instead\", hostSNI), false)",
        "// Line_Reference 227: \t\t\t\trouters = append(routers, v.routerName)",
        "// Line_Reference 228: \t\t\t}",
        "// Line_Reference 230: \t\t\tlogger.Warnf(\"Found different TLS options for routers on the same host %v, so using the default TLS options instead for these routers: %#v\", hostSNI, routers)",
        "// Line_Reference 232: \t\t\trouter.AddHTTPTLSConfig(hostSNI, defaultTLSConf)",
        "// Line_Reference 254: \t\thandler, err := m.buildTCPHandler(ctxRouter, routerConfig)",
        "// Line_Reference 255: \t\tif err != nil {",
        "// Line_Reference 256: \t\t\trouterConfig.AddError(err, true)",
        "// Line_Reference 257: \t\t\tlogger.Error(err)",
        "// Line_Reference 258: \t\t\tcontinue",
        "// Line_Reference 259: \t\t}",
        "// Line_Reference 260: ",
        "// Line_Reference 288: \t\t\tif err := router.AddRouteTLS(routerConfig.Rule, routerConfig.Priority, handler, nil); err != nil {",
        "// Line_Reference 330: \t\t// This is only applicable if the muxer can decide about the routing _before_",
        "// Line_Reference 331: \t\t// telling the client about the tlsConf (i.e. before the TLS HandShake). This seems",
        "// Line_Reference 332: \t\t// to be the case so far with the existing matchers (HostSNI, and ClientIP), so",
        "// Line_Reference 333: \t\t// it's all good. Otherwise, we would have to do as for HTTPS, i.e. disallow",
        "// Line_Reference 334: \t\t// different TLS configs for the same HostSNIs.",
        "// Line_Reference 337: \t\tif err := router.AddRouteTLS(routerConfig.Rule, routerConfig.Priority, handler, tlsConf); err != nil {",
        "// Line_Reference 342: ",
        "// Line_Reference 343: \treturn router, nil"
    ]
}
