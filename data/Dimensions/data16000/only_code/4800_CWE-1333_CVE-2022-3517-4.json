var path = { sep: '/' }
try {
path = require('path')
} catch (er) {}
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')
var plTypes = {
var qmark = '[^/]'
var star = qmark + '*?'
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
var reSpecials = charSet('().*{}+?[]^$\\!')
var slashSplit = /\/+/
var t = {}
Object.keys(b).forEach(function (k) {
t[k] = b[k]
})
if (!def || !Object.keys(def).length) return minimatch
var orig = minimatch
var m = function minimatch (p, pattern, options) {
return orig.minimatch(p, pattern, ext(def, options))
if (!def || !Object.keys(def).length) return Minimatch
if (typeof pattern !== 'string') {
throw new TypeError('glob pattern string required')
}
if (typeof pattern !== 'string') {
throw new TypeError('glob pattern string required')
}
if (typeof pattern === 'undefined') {
throw new TypeError('undefined pattern')
}
if (options.nobrace ||
!pattern.match(/\{.*\}/)) {
var SUBPARSE = {}
if (pattern.length > 1024 * 64) {
throw new TypeError('pattern is too long')
}
var hasMagic = !!options.nocase
case '/':
} catch (er) {
} catch (ex) {
var mm = new Minimatch(pattern, options)
} else if (pi === pl) {
var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
return emptyFileEnd