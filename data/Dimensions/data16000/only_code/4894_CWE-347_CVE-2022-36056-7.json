"encoding/base64"
"encoding/hex"
"github.com/transparency-dev/merkle/rfc6962"
var (
lea = models.LogEntryAnon{
Attestation:    &models.LogEntryAnonAttestation{},
Body:           base64.StdEncoding.EncodeToString([]byte("asdf")),
IntegratedTime: new(int64),
LogID:          new(string),
LogIndex:       new(int64),
Verification: &models.LogEntryAnonVerification{
InclusionProof: &models.InclusionProof{
RootHash: new(string),
TreeSize: new(int64),
LogIndex: new(int64),
},
},
}
data = models.LogEntry{
uuid(lea): lea,
}
)
// uuid generates the UUID for the given LogEntry.
// This is effectively a reimplementation of
// pkg/cosign/tlog.go -> verifyUUID / ComputeLeafHash, but separated
// to avoid a circular dependency.
// TODO?: Perhaps we should refactor the tlog libraries into a separate
// package?
func uuid(e models.LogEntryAnon) string {
entryBytes, err := base64.StdEncoding.DecodeString(e.Body.(string))
if err != nil {
panic(err)
}
return hex.EncodeToString(rfc6962.DefaultHasher.HashLeaf(entryBytes))
}
// mClient.entries = &EntriesClient{}
Entries models.LogEntry
return &entries.CreateLogEntryCreated{
ETag:     "",
Location: "",
Payload:  data,
}, nil
return &entries.GetLogEntryByIndexOK{
Payload: data,
}, nil
return &entries.GetLogEntryByUUIDOK{
Payload: data,
}, nil
Payload: []models.LogEntry{data},
