{
    "cve_id": "CVE-2018-25020",
    "cve_description": "The BPF subsystem in the Linux kernel before 4.17 mishandles situations with a long jump over an instruction sequence where inner instructions require substantial expansions into multiple BPF instructions, leading to an overflow. This affects kernel/bpf/core.c and net/core/filter.c.",
    "cve_publish_date": "2021-12-08",
    "cwe_id": "CWE-120",
    "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
    "cwe_description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
    "commit_message": "bpf: fix truncated jump targets on heavy expansions\n\nRecently during testing, I ran into the following panic:\n\n  [  207.892422] Internal error: Accessing user space memory outside uaccess.h routines: 96000004 [#1] SMP\n  [  207.901637] Modules linked in: binfmt_misc [...]\n  [  207.966530] CPU: 45 PID: 2256 Comm: test_verifier Tainted: G        W         4.17.0-rc3+ #7\n  [  207.974956] Hardware name: FOXCONN R2-1221R-A4/C2U4N_MB, BIOS G31FB18A 03/31/2017\n  [  207.982428] pstate: 60400005 (nZCv daif +PAN -UAO)\n  [  207.987214] pc : bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  207.992603] lr : 0xffff000000bdb754\n  [  207.996080] sp : ffff000013703ca0\n  [  207.999384] x29: ffff000013703ca0 x28: 0000000000000001\n  [  208.004688] x27: 0000000000000001 x26: 0000000000000000\n  [  208.009992] x25: ffff000013703ce0 x24: ffff800fb4afcb00\n  [  208.015295] x23: ffff00007d2f5038 x22: ffff00007d2f5000\n  [  208.020599] x21: fffffffffeff2a6f x20: 000000000000000a\n  [  208.025903] x19: ffff000009578000 x18: 0000000000000a03\n  [  208.031206] x17: 0000000000000000 x16: 0000000000000000\n  [  208.036510] x15: 0000ffff9de83000 x14: 0000000000000000\n  [  208.041813] x13: 0000000000000000 x12: 0000000000000000\n  [  208.047116] x11: 0000000000000001 x10: ffff0000089e7f18\n  [  208.052419] x9 : fffffffffeff2a6f x8 : 0000000000000000\n  [  208.057723] x7 : 000000000000000a x6 : 00280c6160000000\n  [  208.063026] x5 : 0000000000000018 x4 : 0000000000007db6\n  [  208.068329] x3 : 000000000008647a x2 : 19868179b1484500\n  [  208.073632] x1 : 0000000000000000 x0 : ffff000009578c08\n  [  208.078938] Process test_verifier (pid: 2256, stack limit = 0x0000000049ca7974)\n  [  208.086235] Call trace:\n  [  208.088672]  bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  208.093713]  0xffff000000bdb754\n  [  208.096845]  bpf_test_run+0x78/0xf8\n  [  208.100324]  bpf_prog_test_run_skb+0x148/0x230\n  [  208.104758]  sys_bpf+0x314/0x1198\n  [  208.108064]  el0_svc_naked+0x30/0x34\n  [  208.111632] Code: 91302260 f9400001 f9001fa1 d2800001 (29500680)\n  [  208.117717] ---[ end trace 263cb8a59b5bf29f ]---\n\nThe program itself which caused this had a long jump over the whole\ninstruction sequence where all of the inner instructions required\nheavy expansions into multiple BPF instructions. Additionally, I also\nhad BPF hardening enabled which requires once more rewrites of all\nconstant values in order to blind them. Each time we rewrite insns,\nbpf_adj_branches() would need to potentially adjust branch targets\nwhich cross the patchlet boundary to accommodate for the additional\ndelta. Eventually that lead to the case where the target offset could\nnot fit into insn->off's upper 0x7fff limit anymore where then offset\nwraps around becoming negative (in s16 universe), or vice versa\ndepending on the jump direction.\n\nTherefore it becomes necessary to detect and reject any such occasions\nin a generic way for native eBPF and cBPF to eBPF migrations. For\nthe latter we can simply check bounds in the bpf_convert_filter()'s\nBPF_EMIT_JMP helper macro and bail out once we surpass limits. The\nbpf_patch_insn_single() for native eBPF (and cBPF to eBPF in case\nof subsequent hardening) is a bit more complex in that we need to\ndetect such truncations before hitting the bpf_prog_realloc(). Thus\nthe latter is split into an extra pass to probe problematic offsets\non the original program in order to fail early. With that in place\nand carefully tested I no longer hit the panic and the rewrites are\nrejected properly. The above example panic I've seen on bpf-next,\nthough the issue itself is generic in that a guard against this issue\nin bpf seems more appropriate in this case.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "core.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "75",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 221: static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)",
        "// Line_Reference 224: \tu32 i, insn_cnt = prog->len;",
        "// Line_Reference 225: \tbool pseudo_call;",
        "// Line_Reference 226: \tu8 code;",
        "// Line_Reference 227: \tint off;",
        "// Line_Reference 231: \t\tif (BPF_CLASS(code) != BPF_JMP)",
        "// Line_Reference 232: \t\t\tcontinue;",
        "// Line_Reference 233: \t\tif (BPF_OP(code) == BPF_EXIT)",
        "// Line_Reference 236: \t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)",
        "// Line_Reference 237: \t\t\t\tpseudo_call = true;",
        "// Line_Reference 238: \t\t\telse",
        "// Line_Reference 241: \t\t\tpseudo_call = false;",
        "// Line_Reference 243: \t\toff = pseudo_call ? insn->imm : insn->off;",
        "// Line_Reference 244: ",
        "// Line_Reference 245: \t\t/* Adjust offset of jmps if we cross boundaries. */",
        "// Line_Reference 246: \t\tif (i < pos && i + off + 1 > pos)",
        "// Line_Reference 247: \t\t\toff += delta;",
        "// Line_Reference 248: \t\telse if (i > pos + delta && i + off + 1 <= pos + delta)",
        "// Line_Reference 249: \t\t\toff -= delta;",
        "// Line_Reference 250: ",
        "// Line_Reference 251: \t\tif (pseudo_call)",
        "// Line_Reference 252: \t\t\tinsn->imm = off;",
        "// Line_Reference 253: \t\telse",
        "// Line_Reference 254: \t\t\tinsn->off = off;",
        "// Line_Reference 297: \tbpf_adj_branches(prog_adj, off, insn_delta);"
    ]
}
