{
    "cve_id": "CVE-2018-25032",
    "cve_description": "zlib before 1.2.12 allows memory corruption when deflating (i.e., when compressing) if the input has many distant matches.",
    "cve_publish_date": "2022-03-25",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "Fix a bug that can crash deflate on some input when using Z_FIXED.\n\nThis bug was reported by Danilo Ramos of Eideticom, Inc. It has\nlain in wait 13 years before being found! The bug was introduced\nin zlib 1.2.2.2, with the addition of the Z_FIXED option. That\noption forces the use of fixed Huffman codes. For rare inputs with\na large number of distant matches, the pending buffer into which\nthe compressed data is written can overwrite the distance symbol\ntable which it overlays. That results in corrupted output due to\ninvalid distances, and can result in out-of-bound accesses,\ncrashing the application.\n\nThe fix here combines the distance buffer and literal/length\nbuffers into a single symbol buffer. Now three bytes of pending\nbuffer space are opened up for each literal or length/distance\npair consumed, instead of the previous two bytes. This assures\nthat the pending buffer cannot overwrite the symbol table, since\nthe maximum fixed code compressed length/distance is 31 bits, and\nsince there are four bytes of pending space for every three bytes\nof symbol space.",
    "type_of_change": "Modification",
    "filename_of_changes": "deflate.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "14",
    "vulnerable_lines": [
        "// Line_Reference 220:     uchf *l_buf;          /* buffer for literals or lengths */",
        "// Line_Reference 242:     uInt last_lit;      /* running index in l_buf */",
        "// Line_Reference 243: ",
        "// Line_Reference 244:     ushf *d_buf;",
        "// Line_Reference 245:     /* Buffer for distances. To simplify the code, d_buf and l_buf have",
        "// Line_Reference 246:      * the same number of elements. To use different lengths, an extra flag",
        "// Line_Reference 247:      * array would be necessary.",
        "// Line_Reference 248:      */",
        "// Line_Reference 328:     s->d_buf[s->last_lit] = 0; \\",
        "// Line_Reference 329:     s->l_buf[s->last_lit++] = cc; \\",
        "// Line_Reference 331:     flush = (s->last_lit == s->lit_bufsize-1); \\",
        "// Line_Reference 336:     s->d_buf[s->last_lit] = dist; \\",
        "// Line_Reference 337:     s->l_buf[s->last_lit++] = len; \\",
        "// Line_Reference 341:     flush = (s->last_lit == s->lit_bufsize-1); \\"
    ]
}
