{
    "cve_id": "CVE-2017-12193",
    "cve_description": "The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.13.11 mishandles node splitting, which allows local users to cause a denial of service (NULL pointer dereference and panic) via a crafted application, as demonstrated by the keyring key type, and key addition and link creation operations.",
    "cve_publish_date": "2017-11-22",
    "cwe_id": "CWE-476",
    "cwe_name": "NULL Pointer Dereference",
    "cwe_description": "The product dereferences a pointer that it expects to be valid but is NULL.",
    "commit_message": "assoc_array: Fix a buggy node-splitting case\n\nThis fixes CVE-2017-12193.\n\nFix a case in the assoc_array implementation in which a new leaf is\nadded that needs to go into a node that happens to be full, where the\nexisting leaves in that node cluster together at that level to the\nexclusion of new leaf.\n\nWhat needs to happen is that the existing leaves get moved out to a new\nnode, N1, at level + 1 and the existing node needs replacing with one,\nN0, that has pointers to the new leaf and to N1.\n\nThe code that tries to do this gets this wrong in two ways:\n\n (1) The pointer that should've pointed from N0 to N1 is set to point\n     recursively to N0 instead.\n\n (2) The backpointer from N0 needs to be set correctly in the case N0 is\n     either the root node or reached through a shortcut.\n\nFix this by removing this path and using the split_node path instead,\nwhich achieves the same end, but in a more general way (thanks to Eric\nBiggers for spotting the redundancy).\n\nThe problem manifests itself as:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n  IP: assoc_array_apply_edit+0x59/0xe5\n\nFixes: 3cb989501c26 (\"Add a generic associative array implementation.\")\nReported-and-tested-by: WU Fan <u3536072@connect.hku.hk>\nSigned-off-by: David Howells <dhowells@redhat.com>\nCc: stable@vger.kernel.org [v3.13-rc1+]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "assoc_array.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "17",
    "number_of_lines_deleted_vulnerable_to_cve": "34",
    "vulnerable_lines": [
        "// Line_Reference 601: \t\t/* Otherwise we can just insert a new node ahead of the old",
        "// Line_Reference 602: \t\t * one.",
        "// Line_Reference 604: \t\tgoto present_leaves_cluster_but_not_new_leaf;",
        "// Line_Reference 610: \t/* We need to split the current node; we know that the node doesn't",
        "// Line_Reference 611: \t * simply contain a full set of leaves that cluster together (it",
        "// Line_Reference 612: \t * contains meta pointers and/or non-clustering leaves).",
        "// Line_Reference 615: \t * leaves in the node and the new leaf.",
        "// Line_Reference 720: present_leaves_cluster_but_not_new_leaf:",
        "// Line_Reference 721: \t/* All the old leaves cluster in the same slot, but the new leaf wants",
        "// Line_Reference 722: \t * to go into a different slot, so we create a new node to hold the new",
        "// Line_Reference 723: \t * leaf and a pointer to a new node holding all the old leaves.",
        "// Line_Reference 724: \t */",
        "// Line_Reference 725: \tpr_devel(\"present leaves cluster but not new leaf\\n\");",
        "// Line_Reference 726: ",
        "// Line_Reference 727: \tnew_n0->back_pointer = node->back_pointer;",
        "// Line_Reference 728: \tnew_n0->parent_slot = node->parent_slot;",
        "// Line_Reference 729: \tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;",
        "// Line_Reference 730: \tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);",
        "// Line_Reference 731: \tnew_n1->parent_slot = edit->segment_cache[0];",
        "// Line_Reference 732: \tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;",
        "// Line_Reference 733: \tedit->adjust_count_on = new_n0;",
        "// Line_Reference 734: ",
        "// Line_Reference 735: \tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)",
        "// Line_Reference 736: \t\tnew_n1->slots[i] = node->slots[i];",
        "// Line_Reference 737: ",
        "// Line_Reference 738: \tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);",
        "// Line_Reference 739: \tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];",
        "// Line_Reference 740: ",
        "// Line_Reference 741: \tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];",
        "// Line_Reference 742: \tedit->set[0].to = assoc_array_node_to_ptr(new_n0);",
        "// Line_Reference 743: \tedit->excised_meta[0] = assoc_array_node_to_ptr(node);",
        "// Line_Reference 744: \tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);",
        "// Line_Reference 745: \treturn true;",
        "// Line_Reference 746: "
    ]
}
