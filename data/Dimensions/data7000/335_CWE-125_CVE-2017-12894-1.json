{
    "cve_id": "CVE-2017-12894",
    "cve_description": "Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in addrtoname.c:lookup_bytestring().",
    "cve_publish_date": "2017-09-14",
    "cwe_id": "CWE-125",
    "cwe_name": "Out-of-bounds Read",
    "cwe_description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "CVE-2017-12894/In lookup_bytestring(), take the length of the byte string into account.\n\nOtherwise, if, in our search of the hash table, we come across a byte\nstring that's shorter than the string we're looking for, we'll search\npast the end of the string in the hash table.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti LevomÃ¤ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
    "type_of_change": "Modification",
    "filename_of_changes": "addrtoname.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "43",
    "number_of_lines_deleted_vulnerable_to_cve": "29",
    "vulnerable_lines": [
        "// Line_Reference 159: static struct enamemem bytestringtable[HASHNAMESIZE];",
        "// Line_Reference 383: static inline struct enamemem *",
        "// Line_Reference 387: \tstruct enamemem *tp;",
        "// Line_Reference 402: \twhile (tp->e_nxt)",
        "// Line_Reference 403: \t\tif (tp->e_addr0 == i &&",
        "// Line_Reference 404: \t\t    tp->e_addr1 == j &&",
        "// Line_Reference 405: \t\t    tp->e_addr2 == k &&",
        "// Line_Reference 406: \t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)",
        "// Line_Reference 409: \t\t\ttp = tp->e_nxt;",
        "// Line_Reference 411: \ttp->e_addr0 = i;",
        "// Line_Reference 412: \ttp->e_addr1 = j;",
        "// Line_Reference 413: \ttp->e_addr2 = k;",
        "// Line_Reference 415: \ttp->e_bs = (u_char *) calloc(1, nlen + 1);",
        "// Line_Reference 416: \tif (tp->e_bs == NULL)",
        "// Line_Reference 419: \tmemcpy(tp->e_bs, bs, nlen);",
        "// Line_Reference 420: \ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));",
        "// Line_Reference 421: \tif (tp->e_nxt == NULL)",
        "// Line_Reference 552: \tregister struct enamemem *tp;",
        "// Line_Reference 556: \tif (tp->e_name)",
        "// Line_Reference 557: \t\treturn (tp->e_name);",
        "// Line_Reference 569: \ttp->e_name = strdup(buf);",
        "// Line_Reference 570: \tif (tp->e_name == NULL)",
        "// Line_Reference 573: \treturn (tp->e_name);",
        "// Line_Reference 582: \tregister struct enamemem *tp;",
        "// Line_Reference 594: \tif (tp->e_name)",
        "// Line_Reference 595: \t\treturn (tp->e_name);",
        "// Line_Reference 597: \ttp->e_name = cp = (char *)malloc(len*3);",
        "// Line_Reference 598: \tif (tp->e_name == NULL)",
        "// Line_Reference 608: \treturn (tp->e_name);"
    ]
}
