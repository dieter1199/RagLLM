return path.split(sep)
obj[k] = obj[k] ||
(this.useArray && isIndex(a[0]) ? [] : {})
if (!this.override &&
isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {
if (i === (keys.length - 1)) {
obj = obj.filter(function (n) { return n !== undefined })
ret = ret[keys[0]].filter(function (v) { return v !== undefined })
DotObject.prototype.transfer = function (source, target, obj1, obj2, mods, merge) {
this.set(target,
_process(
this.pick(source, obj1, true),
mods
), obj2, merge)
this.set(target,
JSON.parse(
JSON.stringify(
this.pick(source, obj1, false)
)
),
), obj2, merge)
if (i === (keys.length - 1)) {
*    "some": {
*      "thing": "else"
*    }
*    "some.thing": "name"
Object.keys(recipe).forEach(function (key) {
this.set(recipe[key], this.pick(key, obj), tgt)
}.bind(this))
Object.keys(obj).forEach(function (key) {
var index = isArray && this.useBrackets ? '[' + key + ']' : key
if (
(
(
(isObject(obj[key]) && !isEmptyObject(obj[key])) ||
(Array.isArray(obj[key]) && (!this.keepArray && (obj[key].length !== 0)))
)
)
) {
if (isArray && this.useBrackets) {
var previousKey = path[path.length - 1] || ''
return this.dot(obj[key], tgt, path.slice(0, -1).concat(previousKey + index))
} else {
return this.dot(obj[key], tgt, path.concat(index))
}
} else {
if (isArray && this.useBrackets) {
tgt[path.join(this.separator).concat('[' + key + ']')] = obj[key]
tgt[path.concat(index).join(this.separator)] = obj[key]
}
}.bind(this))
DotObject.dot = wrap('dot')
;['override', 'overwrite'].forEach(function (prop) {
})
;['useArray', 'keepArray', 'useBrackets'].forEach(function (prop) {
