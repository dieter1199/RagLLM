static int rm_rf_children_inner(
const struct stat *root_dev) {
_cleanup_close_ int subdir_fd = -1;
/* if root_dev is set, remove subdirectories only if device is same */
subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);
q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);
_cleanup_closedir_ DIR *d = NULL;
assert(fd >= 0);
/* This returns the first error we run into, but nevertheless tries to go on. This closes the passed
* fd, in all cases, including on failure. */
d = fdopendir(fd);
if (!d) {
safe_close(fd);
return -errno;
}
if (!(flags & REMOVE_PHYSICAL)) {
struct statfs sfs;
if (fstatfs(dirfd(d), &sfs) < 0)
return -errno;
if (is_physical_fs(&sfs)) {
/* We refuse to clean physical file systems with this call, unless explicitly
* requested. This is extra paranoia just to be sure we never ever remove non-state
* data. */
_cleanup_free_ char *path = NULL;
(void) fd_get_path(fd, &path);
return log_error_errno(SYNTHETIC_ERRNO(EPERM),
"Attempted to remove disk file system under \"%s\", and we can't allow that.",
strna(path));
}
}
FOREACH_DIRENT_ALL(de, d, return -errno) {
int is_dir;
if (dot_or_dot_dot(de->d_name))
continue;
is_dir =
de->d_type == DT_UNKNOWN ? -1 :
de->d_type == DT_DIR;
r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);
if (r < 0 && r != -ENOENT && ret == 0)
ret = r;
}
if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)
ret = -errno;
return rm_rf_children_inner(fd, name, -1, flags, NULL);
