{
    "cve_id": "CVE-2024-2083",
    "cve_description": "A directory traversal vulnerability exists in the zenml-io/zenml repository, specifically within the /api/v1/steps endpoint. Attackers can exploit this vulnerability by manipulating the 'logs' URI path in the request to fetch arbitrary file content, bypassing intended access restrictions. The vulnerability arises due to the lack of validation for directory traversal patterns, allowing attackers to access files outside of the restricted directory.",
    "cve_publish_date": "2024-04-16",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Improve Artifact Store isolation (#2490)\n\n* dir traversal issue\r\n\r\n* Auto-update of Starter template\r\n\r\n* Auto-update of NLP template\r\n\r\n* reroute artifacts and logs via AS\r\n\r\n* reroute materializers via AS\r\n\r\n* simplify to one deco\r\n\r\n* fix materializer tests\r\n\r\n* allow local download\r\n\r\n* Auto-update of E2E template\r\n\r\n* fix test issues\r\n\r\n* rework based on comments\r\n\r\n* fix bugs\r\n\r\n* lint\r\n\r\n* Candidate (#2493)\r\n\r\nCo-authored-by: Stefan Nica <stefan@zenml.io>\r\n\r\n* darglint\r\n\r\n---------\r\n\r\nCo-authored-by: GitHub Actions <actions@github.com>\r\nCo-authored-by: Stefan Nica <stefan@zenml.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "base_artifact_store.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "113",
    "number_of_lines_deleted_vulnerable_to_cve": "54",
    "vulnerable_lines": [
        "// Line_Reference 47: def _sanitize_potential_path(potential_path: Any) -> Any:",
        "// Line_Reference 48:     \"\"\"Sanitizes the input if it is a path.",
        "// Line_Reference 50:     If the input is a **remote** path, this function replaces backslash path",
        "// Line_Reference 51:     separators by forward slashes.",
        "// Line_Reference 54:         potential_path: Value that potentially refers to a (remote) path.",
        "// Line_Reference 57:         The original input or a sanitized version of it in case of a remote",
        "// Line_Reference 58:         path.",
        "// Line_Reference 60:     if isinstance(potential_path, bytes):",
        "// Line_Reference 61:         path = fileio.convert_to_str(potential_path)",
        "// Line_Reference 62:     elif isinstance(potential_path, str):",
        "// Line_Reference 63:         path = potential_path",
        "// Line_Reference 64:     else:",
        "// Line_Reference 65:         # Neither string nor bytes, this is not a path",
        "// Line_Reference 66:         return potential_path",
        "// Line_Reference 68:     if io_utils.is_remote(path):",
        "// Line_Reference 69:         # If we have a remote path, replace windows path separators with",
        "// Line_Reference 70:         # slashes",
        "// Line_Reference 71:         import ntpath",
        "// Line_Reference 72:         import posixpath",
        "// Line_Reference 74:         path = path.replace(ntpath.sep, posixpath.sep)",
        "// Line_Reference 76:     return path",
        "// Line_Reference 79: def _sanitize_paths(_func: Callable[..., Any]) -> Callable[..., Any]:",
        "// Line_Reference 80:     \"\"\"Sanitizes path inputs before calling the original function.",
        "// Line_Reference 82:     Args:",
        "// Line_Reference 83:         _func: The function for which to sanitize the inputs.",
        "// Line_Reference 85:     Returns:",
        "// Line_Reference 86:         Function that calls the input function with sanitized path inputs.",
        "// Line_Reference 87:     \"\"\"",
        "// Line_Reference 89:     def inner_function(*args: Any, **kwargs: Any) -> Any:",
        "// Line_Reference 90:         \"\"\"Inner function.",
        "// Line_Reference 99:         args = tuple(_sanitize_potential_path(arg) for arg in args)",
        "// Line_Reference 101:             key: _sanitize_potential_path(value)",
        "// Line_Reference 105:         return _func(*args, **kwargs)",
        "// Line_Reference 106: ",
        "// Line_Reference 107:     return inner_function",
        "// Line_Reference 384:             self.__class__.__name__,",
        "// Line_Reference 385:             (BaseFilesystem,),",
        "// Line_Reference 386:             {",
        "// Line_Reference 387:                 \"SUPPORTED_SCHEMES\": self.config.SUPPORTED_SCHEMES,",
        "// Line_Reference 388:                 \"open\": staticmethod(_sanitize_paths(self.open)),",
        "// Line_Reference 389:                 \"copyfile\": staticmethod(_sanitize_paths(self.copyfile)),",
        "// Line_Reference 390:                 \"exists\": staticmethod(_sanitize_paths(self.exists)),",
        "// Line_Reference 391:                 \"glob\": staticmethod(_sanitize_paths(self.glob)),",
        "// Line_Reference 392:                 \"isdir\": staticmethod(_sanitize_paths(self.isdir)),",
        "// Line_Reference 393:                 \"listdir\": staticmethod(_sanitize_paths(self.listdir)),",
        "// Line_Reference 394:                 \"makedirs\": staticmethod(_sanitize_paths(self.makedirs)),",
        "// Line_Reference 395:                 \"mkdir\": staticmethod(_sanitize_paths(self.mkdir)),",
        "// Line_Reference 396:                 \"remove\": staticmethod(_sanitize_paths(self.remove)),",
        "// Line_Reference 397:                 \"rename\": staticmethod(_sanitize_paths(self.rename)),",
        "// Line_Reference 398:                 \"rmtree\": staticmethod(_sanitize_paths(self.rmtree)),",
        "// Line_Reference 399:                 \"size\": staticmethod(_sanitize_paths(self.size)),",
        "// Line_Reference 400:                 \"stat\": staticmethod(_sanitize_paths(self.stat)),",
        "// Line_Reference 401:                 \"walk\": staticmethod(_sanitize_paths(self.walk)),",
        "// Line_Reference 402:             },"
    ]
}
