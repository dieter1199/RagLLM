{
    "cve_id": "CVE-2024-31585",
    "cve_description": "FFmpeg version n5.1 to n6.1 was discovered to contain an Off-by-one Error vulnerability in libavfilter/avf_showspectrum.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted input.",
    "cve_publish_date": "2024-04-17",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "avfilter/avf_showspectrum: stop using AVAudioFifo to keep samples\n\nFixes limitation of input duration that showspectrumpic can process.",
    "type_of_change": "Modification",
    "filename_of_changes": "avf_showspectrum.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "106",
    "number_of_lines_deleted_vulnerable_to_cve": "81",
    "vulnerable_lines": [
        "// Line_Reference 33: #include \"libavutil/audio_fifo.h\"",
        "// Line_Reference 98:     AVAudioFifo *fifo;",
        "// Line_Reference 333:     av_audio_fifo_free(s->fifo);",
        "// Line_Reference 394:             s->fft_data[ch][n].re = p[n] * window_func_lut[n];",
        "// Line_Reference 461:             s->fft_in[ch][n].re = p[n] * window_func_lut[n];",
        "// Line_Reference 729: static int draw_legend(AVFilterContext *ctx, int samples)",
        "// Line_Reference 1242:     av_audio_fifo_free(s->fifo);",
        "// Line_Reference 1243:     s->fifo = av_audio_fifo_alloc(inlink->format, inlink->channels, s->win_size);",
        "// Line_Reference 1244:     if (!s->fifo)",
        "// Line_Reference 1442:         outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);",
        "// Line_Reference 1510:     int ret;",
        "// Line_Reference 1514:     if (av_audio_fifo_size(s->fifo) < s->win_size) {",
        "// Line_Reference 1515:         AVFrame *frame = NULL;",
        "// Line_Reference 1517:         ret = ff_inlink_consume_frame(inlink, &frame);",
        "// Line_Reference 1521:             s->pts = frame->pts;",
        "// Line_Reference 1522:             s->consumed = 0;",
        "// Line_Reference 1524:             av_audio_fifo_write(s->fifo, (void **)frame->extended_data, frame->nb_samples);",
        "// Line_Reference 1525:             av_frame_free(&frame);",
        "// Line_Reference 1526:         }",
        "// Line_Reference 1527:     }",
        "// Line_Reference 1529:     if (s->outpicref && (av_audio_fifo_size(s->fifo) >= s->win_size ||",
        "// Line_Reference 1530:         ff_outlink_get_status(inlink))) {",
        "// Line_Reference 1531:         AVFrame *fin = ff_get_audio_buffer(inlink, s->win_size);",
        "// Line_Reference 1532:         if (!fin)",
        "// Line_Reference 1533:             return AVERROR(ENOMEM);",
        "// Line_Reference 1535:         fin->pts = s->pts + s->consumed;",
        "// Line_Reference 1536:         s->consumed += s->hop_size;",
        "// Line_Reference 1537:         ret = av_audio_fifo_peek(s->fifo, (void **)fin->extended_data,",
        "// Line_Reference 1538:                                  FFMIN(s->win_size, av_audio_fifo_size(s->fifo)));",
        "// Line_Reference 1539:         if (ret < 0) {",
        "// Line_Reference 1541:             return ret;",
        "// Line_Reference 1543: ",
        "// Line_Reference 1544:         av_assert0(fin->nb_samples == s->win_size);",
        "// Line_Reference 1545: ",
        "// Line_Reference 1546:         ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);",
        "// Line_Reference 1547: ",
        "// Line_Reference 1548:         if (s->data == D_MAGNITUDE)",
        "// Line_Reference 1549:             ff_filter_execute(ctx, calc_channel_magnitudes, NULL, NULL, s->nb_display_channels);",
        "// Line_Reference 1550: ",
        "// Line_Reference 1551:         if (s->data == D_PHASE)",
        "// Line_Reference 1552:             ff_filter_execute(ctx, calc_channel_phases, NULL, NULL, s->nb_display_channels);",
        "// Line_Reference 1553: ",
        "// Line_Reference 1554:         if (s->data == D_UPHASE)",
        "// Line_Reference 1555:             ff_filter_execute(ctx, calc_channel_uphases, NULL, NULL, s->nb_display_channels);",
        "// Line_Reference 1556: ",
        "// Line_Reference 1557:         ret = plot_spectrum_column(inlink, fin);",
        "// Line_Reference 1558: ",
        "// Line_Reference 1559:         av_frame_free(&fin);",
        "// Line_Reference 1560:         av_audio_fifo_drain(s->fifo, s->hop_size);",
        "// Line_Reference 1561:         if (ret <= 0 && !ff_outlink_get_status(inlink))",
        "// Line_Reference 1562:             return ret;",
        "// Line_Reference 1568:         int64_t pts;",
        "// Line_Reference 1591:     FF_FILTER_FORWARD_STATUS(inlink, outlink);",
        "// Line_Reference 1592:     if (av_audio_fifo_size(s->fifo) >= s->win_size ||",
        "// Line_Reference 1593:         ff_inlink_queued_frames(inlink) > 0 ||",
        "// Line_Reference 1594:         ff_outlink_get_status(inlink) == AVERROR_EOF) {",
        "// Line_Reference 1599:     if (ff_outlink_frame_wanted(outlink) && av_audio_fifo_size(s->fifo) < s->win_size &&",
        "// Line_Reference 1600:         ff_inlink_queued_frames(inlink) == 0 &&",
        "// Line_Reference 1601:         ff_outlink_get_status(inlink) != AVERROR_EOF) {",
        "// Line_Reference 1694:     int ret, samples;",
        "// Line_Reference 1697:     samples = av_audio_fifo_size(s->fifo);",
        "// Line_Reference 1698:     if (ret == AVERROR_EOF && s->outpicref && samples > 0) {",
        "// Line_Reference 1704:         spf = s->win_size * (samples / ((s->win_size * sz) * ceil(samples / (float)(s->win_size * sz))));",
        "// Line_Reference 1707:         spb = (samples / (spf * sz)) * spf;",
        "// Line_Reference 1709:         fin = ff_get_audio_buffer(inlink, s->win_size);",
        "// Line_Reference 1714:             ret = av_audio_fifo_peek(s->fifo, (void **)fin->extended_data, s->win_size);",
        "// Line_Reference 1715:             if (ret < 0) {",
        "// Line_Reference 1716:                 av_frame_free(&fin);",
        "// Line_Reference 1717:                 return ret;",
        "// Line_Reference 1718:             }",
        "// Line_Reference 1719: ",
        "// Line_Reference 1720:             av_audio_fifo_drain(s->fifo, spf);",
        "// Line_Reference 1722:             if (ret < s->win_size) {",
        "// Line_Reference 1723:                 for (ch = 0; ch < s->nb_display_channels; ch++) {",
        "// Line_Reference 1724:                     memset(fin->extended_data[ch] + ret * sizeof(float), 0,",
        "// Line_Reference 1725:                            (s->win_size - ret) * sizeof(float));",
        "// Line_Reference 1749:             draw_legend(ctx, samples);",
        "// Line_Reference 1762:     int ret;",
        "// Line_Reference 1764:     ret = av_audio_fifo_write(s->fifo, (void **)insamples->extended_data, insamples->nb_samples);",
        "// Line_Reference 1765:     av_frame_free(&insamples);",
        "// Line_Reference 1766:     return ret;"
    ]
}
