{
    "cve_id": "CVE-2014-9322",
    "cve_description": "arch/x86/kernel/entry_64.S in the Linux kernel before 3.17.5 does not properly handle faults associated with the Stack Segment (SS) segment register, which allows local users to gain privileges by triggering an IRET instruction that leads to access to a GS Base address from the wrong space.",
    "cve_publish_date": "2014-12-17",
    "cwe_id": "CWE-269",
    "cwe_name": "Improper Privilege Management",
    "cwe_description": "The product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.",
    "commit_message": "x86_64, traps: Stop using IST for #SS\n\nOn a 32-bit kernel, this has no effect, since there are no IST stacks.\n\nOn a 64-bit kernel, #SS can only happen in user code, on a failed iret\nto user space, a canonical violation on access via RSP or RBP, or a\ngenuine stack segment violation in 32-bit kernel code.  The first two\ncases don't need IST, and the latter two cases are unlikely fatal bugs,\nand promoting them to double faults would be fine.\n\nThis fixes a bug in which the espfix64 code mishandles a stack segment\nviolation.\n\nThis saves 4k of memory per CPU and a tiny bit of code.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "traps.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "17",
    "vulnerable_lines": [
        "// Line_Reference 236: #ifdef CONFIG_X86_32",
        "// Line_Reference 238: #endif",
        "// Line_Reference 243: dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)",
        "// Line_Reference 244: {",
        "// Line_Reference 245: \tenum ctx_state prev_state;",
        "// Line_Reference 246: ",
        "// Line_Reference 247: \tprev_state = exception_enter();",
        "// Line_Reference 248: \tif (notify_die(DIE_TRAP, \"stack segment\", regs, error_code,",
        "// Line_Reference 249: \t\t       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {",
        "// Line_Reference 250: \t\tpreempt_conditional_sti(regs);",
        "// Line_Reference 251: \t\tdo_trap(X86_TRAP_SS, SIGBUS, \"stack segment\", regs, error_code, NULL);",
        "// Line_Reference 252: \t\tpreempt_conditional_cli(regs);",
        "// Line_Reference 253: \t}",
        "// Line_Reference 254: \texception_exit(prev_state);",
        "// Line_Reference 255: }",
        "// Line_Reference 256: ",
        "// Line_Reference 805: \tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);"
    ]
}
