{
    "cve_id": "CVE-2022-23559",
    "cve_description": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in embedding lookup operations. Both `embedding_size` and `lookup_size` are products of values provided by the user. Hence, a malicious user could trigger overflows in the multiplication. In certain scenarios, this can then result in heap OOB read/write. Users are advised to upgrade to a patched version.",
    "cve_publish_date": "2022-02-04",
    "cwe_id": "CWE-190",
    "cwe_name": "Integer Overflow or Wraparound",
    "cwe_description": "The product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.",
    "commit_message": "[lite] Move MultiplyAndCheckOverflow to util to be able to share it.\n\nPiperOrigin-RevId: 416897229\nChange-Id: I5feb44881bdcbb6ed911da4f17c55bb978754059",
    "type_of_change": "Modification",
    "filename_of_changes": "subgraph.cc",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "21",
    "vulnerable_lines": [
        "// Line_Reference 693: namespace {",
        "// Line_Reference 694: // Multiply two sizes and return true if overflow occurred;",
        "// Line_Reference 695: // This is based off tensorflow/overflow.h but is simpler as we already",
        "// Line_Reference 696: // have unsigned numbers. It is also generalized to work where sizeof(size_t)",
        "// Line_Reference 697: // is not 8.",
        "// Line_Reference 698: TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {",
        "// Line_Reference 699:   // Multiplying a * b where a and b are size_t cannot result in overflow in a",
        "// Line_Reference 700:   // size_t accumulator if both numbers have no non-zero bits in their upper",
        "// Line_Reference 701:   // half.",
        "// Line_Reference 702:   constexpr size_t size_t_bits = 8 * sizeof(size_t);",
        "// Line_Reference 703:   constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;",
        "// Line_Reference 704:   *product = a * b;",
        "// Line_Reference 705:   // If neither integers have non-zero bits past 32 bits can't overflow.",
        "// Line_Reference 706:   // Otherwise check using slow devision.",
        "// Line_Reference 707:   if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {",
        "// Line_Reference 708:     if (a != 0 && *product / a != b) return kTfLiteError;",
        "// Line_Reference 709:   }",
        "// Line_Reference 710:   return kTfLiteOk;",
        "// Line_Reference 711: }",
        "// Line_Reference 712: }  // namespace",
        "// Line_Reference 713: "
    ]
}
