{
    "cve_id": "CVE-2020-12464",
    "cve_description": "usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925.",
    "cve_publish_date": "2020-04-29",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "USB: core: Fix free-while-in-use bug in the USB S-Glibrary\n\nFuzzUSB (a variant of syzkaller) found a free-while-still-in-use bug\nin the USB scatter-gather library:\n\nBUG: KASAN: use-after-free in atomic_read\ninclude/asm-generic/atomic-instrumented.h:26 [inline]\nBUG: KASAN: use-after-free in usb_hcd_unlink_urb+0x5f/0x170\ndrivers/usb/core/hcd.c:1607\nRead of size 4 at addr ffff888065379610 by task kworker/u4:1/27\n\nCPU: 1 PID: 27 Comm: kworker/u4:1 Not tainted 5.5.11 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.10.2-1ubuntu1 04/01/2014\nWorkqueue: scsi_tmf_2 scmd_eh_abort_handler\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374\n __kasan_report+0x153/0x1cb mm/kasan/report.c:506\n kasan_report+0x12/0x20 mm/kasan/common.c:639\n check_memory_region_inline mm/kasan/generic.c:185 [inline]\n check_memory_region+0x152/0x1b0 mm/kasan/generic.c:192\n __kasan_check_read+0x11/0x20 mm/kasan/common.c:95\n atomic_read include/asm-generic/atomic-instrumented.h:26 [inline]\n usb_hcd_unlink_urb+0x5f/0x170 drivers/usb/core/hcd.c:1607\n usb_unlink_urb+0x72/0xb0 drivers/usb/core/urb.c:657\n usb_sg_cancel+0x14e/0x290 drivers/usb/core/message.c:602\n usb_stor_stop_transport+0x5e/0xa0 drivers/usb/storage/transport.c:937\n\nThis bug occurs when cancellation of the S-G transfer races with\ntransfer completion.  When that happens, usb_sg_cancel() may continue\nto access the transfer's URBs after usb_sg_wait() has freed them.\n\nThe bug is caused by the fact that usb_sg_cancel() does not take any\nsort of reference to the transfer, and so there is nothing to prevent\nthe URBs from being deallocated while the routine is trying to use\nthem.  The fix is to take such a reference by incrementing the\ntransfer's io->count field while the cancellation is in progres and\ndecrementing it afterward.  The transfer's URBs are not deallocated\nuntil io->complete is triggered, which happens when io->count reaches\nzero.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nReported-and-tested-by: Kyungtae Kim <kt0755@gmail.com>\nCC: <stable@vger.kernel.org>\n\nLink: https://lore.kernel.org/r/Pine.LNX.4.44L0.2003281615140.14837-100000@netrider.rowland.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "message.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "8",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 592: \tif (io->status) {"
    ]
}
