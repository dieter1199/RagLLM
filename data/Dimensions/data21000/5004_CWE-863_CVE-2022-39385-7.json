{
    "cve_id": "CVE-2022-39385",
    "cve_description": "Discourse is the an open source discussion platform. In some rare cases users redeeming an invitation can be added as a participant to several private message topics that they should not be added to. They are not notified of this, it happens transparently in the background. This issue has been resolved in commit `a414520742` and will be included in future releases. Users are advised to upgrade. Users are also advised to set `SiteSetting.max_invites_per_day` to 0 until the patch is installed.",
    "cve_publish_date": "2022-11-14",
    "cwe_id": "CWE-863",
    "cwe_name": "Incorrect Authorization",
    "cwe_description": "The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",
    "commit_message": "SECURITY: Prevent email from being nil in InviteRedeemer (#19004)\n\nThis commit adds some protections in InviteRedeemer to ensure that email\r\ncan never be nil, which could cause issues with inviting the invited\r\nperson to private topics since there was an incorrect inner join.\r\n\r\nIf the email is nil and the invite is scoped to an email, we just use\r\nthat invite.email unconditionally.  If a redeeming_user (an existing\r\nuser) is passed in when redeeming an email, we use their email to\r\noverride the passed in email.  Otherwise we just use the passed in\r\nemail.  We now raise an error after all this if the email is still nil.\r\nThis commit also adds some tests to catch the private topic fix, and\r\nsome general improvements and comments around the invite code.\r\n\r\nThis commit also includes a migration to delete TopicAllowedUser records\r\nfor users who were mistakenly added to topics as part of the invite\r\nredemption process.",
    "type_of_change": "ModificationType.ADD",
    "filename_of_changes": "invites_controller_spec.rb",
    "code_language": "Ruby",
    "number_of_lines_added_for_mitigation": "127",
    "number_of_lines_deleted_vulnerable_to_cve": "59",
    "vulnerable_lines": [
        "// Line_Reference 915:       fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }",
        "// Line_Reference 916:       fab!(:user) { Fabricate(:user, email: 'test@example.com') }",
        "// Line_Reference 917:       fab!(:group) { Fabricate(:group) }",
        "// Line_Reference 918: ",
        "// Line_Reference 921:       it 'redeems the invitation and creates the invite accepted notification' do",
        "// Line_Reference 922:         put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }",
        "// Line_Reference 923:         expect(response.status).to eq(200)",
        "// Line_Reference 924:         expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))",
        "// Line_Reference 925:         invite.reload",
        "// Line_Reference 926:         expect(invite.invited_users.first.user).to eq(user)",
        "// Line_Reference 927:         expect(invite.redeemed?).to be_truthy",
        "// Line_Reference 928:         expect(",
        "// Line_Reference 929:           Notification.exists?(",
        "// Line_Reference 930:             user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]",
        "// Line_Reference 931:           )",
        "// Line_Reference 932:         ).to eq(true)",
        "// Line_Reference 933:       end",
        "// Line_Reference 935:       it 'redirects to the first topic the user was invited to and creates the topic notification' do",
        "// Line_Reference 936:         topic = Fabricate(:topic)",
        "// Line_Reference 937:         TopicInvite.create!(invite: invite, topic: topic)",
        "// Line_Reference 938:         put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }",
        "// Line_Reference 939:         expect(response.status).to eq(200)",
        "// Line_Reference 940:         expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)",
        "// Line_Reference 941:         expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)",
        "// Line_Reference 942:       end",
        "// Line_Reference 944:       it \"adds the user to the groups specified on the invite and allows them to access the secure topic\" do",
        "// Line_Reference 945:         group.add_owner(invite.invited_by)",
        "// Line_Reference 946:         secured_category = Fabricate(:category)",
        "// Line_Reference 947:         secured_category.permissions = { group.name => :full }",
        "// Line_Reference 948:         secured_category.save!",
        "// Line_Reference 950:         topic = Fabricate(:topic, category: secured_category)",
        "// Line_Reference 951:         TopicInvite.create!(invite: invite, topic: topic)",
        "// Line_Reference 952:         InvitedGroup.create!(invite: invite, group: group)",
        "// Line_Reference 954:         put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }",
        "// Line_Reference 955:         expect(response.status).to eq(200)",
        "// Line_Reference 956:         expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))",
        "// Line_Reference 957:         expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)",
        "// Line_Reference 958:         invite.reload",
        "// Line_Reference 959:         expect(invite.redeemed?).to be_truthy",
        "// Line_Reference 960:         expect(user.reload.groups).to include(group)",
        "// Line_Reference 961:         expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)",
        "// Line_Reference 962:       end",
        "// Line_Reference 964:       it \"does not try to log in the user automatically\" do",
        "// Line_Reference 965:         expect do",
        "// Line_Reference 967:         end.not_to change { UserAuthToken.count }",
        "// Line_Reference 968:         expect(response.status).to eq(200)",
        "// Line_Reference 969:         expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.existing_user_success\"))",
        "// Line_Reference 970:       end",
        "// Line_Reference 972:       it \"errors if the user's email doesn't match the invite email\" do",
        "// Line_Reference 973:         user.update!(email: \"blah@test.com\")",
        "// Line_Reference 974:         put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }",
        "// Line_Reference 975:         expect(response.status).to eq(412)",
        "// Line_Reference 976:         expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.not_matching_email\"))",
        "// Line_Reference 979:       it \"errors if the user's email domain doesn't match the invite domain\" do",
        "// Line_Reference 980:         user.update!(email: \"blah@test.com\")",
        "// Line_Reference 981:         invite.update!(email: nil, domain: \"example.com\")",
        "// Line_Reference 982:         put \"/invites/show/#{invite.invite_key}.json\", params: { id: invite.invite_key }",
        "// Line_Reference 983:         expect(response.status).to eq(412)",
        "// Line_Reference 984:         expect(response.parsed_body[\"message\"]).to eq(I18n.t(\"invite.domain_not_allowed\"))"
    ]
}
