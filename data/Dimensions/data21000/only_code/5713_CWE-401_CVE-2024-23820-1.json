reverseExpandQuery := reverseexpand.NewReverseExpandQuery(q.datastore, typesys,
reverseExpandQuery.Execute(cancelCtx, &reverseexpand.ReverseExpandRequest{
for res := range reverseExpandResultsChan {
if res.Err != nil {
err := res.Err
if errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {
err = serverErrors.AuthorizationModelResolutionTooComplex
resultsChan <- ListObjectsResult{Err: err}
break
}
if !(maxResults == 0) && objectsFound.Load() >= maxResults {
break
}
if res.ResultStatus == reverseexpand.NoFurtherEvalStatus {
noFurtherEvalRequiredCounter.Inc()
trySendObject(res.Object, &objectsFound, maxResults, resultsChan)
continue
}
furtherEvalRequiredCounter.Inc()
wg.Add(1)
go func(res *reverseexpand.ReverseExpandResult) {
defer func() {
<-concurrencyLimiterCh
wg.Done()
}()
concurrencyLimiterCh <- struct{}{}
resp, err := checkResolver.ResolveCheck(ctx, &graph.ResolveCheckRequest{
StoreID:              req.GetStoreId(),
AuthorizationModelID: req.GetAuthorizationModelId(),
TupleKey:             tuple.NewTupleKey(res.Object, req.GetRelation(), req.GetUser()),
ContextualTuples:     req.GetContextualTuples().GetTupleKeys(),
Context:              req.GetContext(),
ResolutionMetadata: &graph.ResolutionMetadata{
Depth: q.resolveNodeLimit,
},
})
if err != nil {
if errors.Is(err, graph.ErrResolutionDepthExceeded) || errors.Is(err, graph.ErrCycleDetected) {
resultsChan <- ListObjectsResult{Err: serverErrors.AuthorizationModelResolutionTooComplex}
resultsChan <- ListObjectsResult{Err: err}
return
}
atomic.AddUint32(resolutionMetadata.QueryCount, resp.GetResolutionMetadata().DatastoreQueryCount)
if resp.Allowed {
trySendObject(res.Object, &objectsFound, maxResults, resultsChan)
}(res)
for {
select {
case <-timeoutCtx.Done():
q.logger.WarnWithContext(
ctx, fmt.Sprintf("list objects timeout after %s", q.listObjectsDeadline.String()),
)
return &ListObjectsResponse{
Objects:            objects,
ResolutionMetadata: *resolutionMetadata,
}, nil
case result, channelOpen := <-resultsChan:
if result.Err != nil {
if errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {
return nil, result.Err
}
if errors.Is(result.Err, condition.ErrEvaluationFailed) {
errs = multierror.Append(errs, result.Err)
continue
}
if errors.Is(result.Err, context.Canceled) || errors.Is(result.Err, context.DeadlineExceeded) {
continue
}
return nil, serverErrors.HandleError("", result.Err)
if !channelOpen {
if len(objects) < int(maxResults) && errs.ErrorOrNil() != nil {
return nil, errs
}
return &ListObjectsResponse{
Objects:            objects,
ResolutionMetadata: *resolutionMetadata,
}, nil
objects = append(objects, result.ObjectID)
for {
select {
case <-timeoutCtx.Done():
q.logger.WarnWithContext(
ctx, fmt.Sprintf("list objects timeout after %s", q.listObjectsDeadline.String()),
)
return resolutionMetadata, nil
case result, channelOpen := <-resultsChan:
if !channelOpen {
// Channel closed! No more results.
return resolutionMetadata, nil
if result.Err != nil {
if errors.Is(result.Err, serverErrors.AuthorizationModelResolutionTooComplex) {
return nil, result.Err
}
if errors.Is(result.Err, condition.ErrEvaluationFailed) {
return nil, serverErrors.ValidationError(result.Err)
}
return nil, serverErrors.HandleError("", result.Err)
if err := srv.Send(&openfgav1.StreamedListObjectsResponse{
Object: result.ObjectID,
}); err != nil {
return nil, serverErrors.NewInternalError("", err)
}
