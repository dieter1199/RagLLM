__be32 saddr, __be32 daddr, struct ip_options *opt)
skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
if (opt && opt->optlen) {
iph->ihl += opt->optlen>>2;
ip_options_build(skb, opt, daddr, rt, 0);
struct ip_options *opt = inet->opt;
if(opt && opt->srr)
daddr = opt->faddr;
if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)
skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
if (opt && opt->optlen) {
iph->ihl += opt->optlen >> 2;
ip_options_build(skb, opt, inet->inet_daddr, rt, 0);
struct ip_options *opt;
memcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);
struct {
struct ip_options	opt;
char			data[40];
} replyopts;
if (ip_options_echo(&replyopts.opt, skb))
if (replyopts.opt.optlen) {
if (ipc.opt->srr)
daddr = replyopts.opt.faddr;