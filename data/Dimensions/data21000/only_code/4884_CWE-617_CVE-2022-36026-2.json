#include "tensorflow/core/kernels/quantize_and_dequantize_op.h"
typedef Eigen::ThreadPoolDevice CPUDevice;
typedef Eigen::GpuDevice GPUDevice;
errors::InvalidArgument("num_bits is out of range: ", num_bits_,
" with signed_input_ ", signed_input_));
errors::InvalidArgument("Round mode string must be "
"'HALF_UP' or "
"'HALF_TO_EVEN', is '" +
round_mode_string + "'"));
OP_REQUIRES(
ctx, axis_ >= -1,
errors::InvalidArgument("Axis must be at least -1. Found ", axis_));
OP_REQUIRES(
ctx, (axis_ == -1 || axis_ < input.shape().dims()),
errors::InvalidArgument("Shape must be at least rank ", axis_ + 1,
errors::InvalidArgument("Invalid range: input_min ",
min_val, " > input_max ", max_val));
OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,
errors::InvalidArgument(
"input_min_tensor has incorrect size, was ",
input_min_tensor.dim_size(0), " expected ", depth,
" to match dim ", axis_, " of the input ",
input_min_tensor.shape()));
OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,
errors::InvalidArgument(
"input_max_tensor has incorrect size, was ",
input_max_tensor.dim_size(0), " expected ", depth,
" to match dim ", axis_, " of the input ",
input_max_tensor.shape()));
OP_REQUIRES(
ctx, axis_ >= -1,
errors::InvalidArgument("Axis must be at least -1. Found ", axis_));
errors::InvalidArgument(
OP_REQUIRES(
ctx, input.IsSameSize(gradient),
errors::InvalidArgument("gradient and input must be the same size"));
errors::InvalidArgument(
errors::InvalidArgument(
OP_REQUIRES(
ctx, input_min_tensor.dim_size(0) == depth,
errors::InvalidArgument("min has incorrect size, expected ", depth,
OP_REQUIRES(
ctx, input_max_tensor.dim_size(0) == depth,
errors::InvalidArgument("max has incorrect size, expected ", depth,
OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),
errors::InvalidArgument(
"input_min must be a scalar if axis is unspecified"));
OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),
errors::InvalidArgument(
"input_max must be a scalar if axis is unspecified"));
errors::InvalidArgument(
Tensor num_bits_tensor;
num_bits_tensor = ctx->input(3);
int num_bits_val = num_bits_tensor.scalar<int32>()();
OP_REQUIRES(
ctx, num_bits_val > 0 && num_bits_val < (signed_input_ ? 62 : 63),
errors::InvalidArgument("num_bits is out of range: ", num_bits_val,
" with signed_input_ ", signed_input_));
auto min_val = input_min_tensor.scalar<T>()();
auto max_val = input_max_tensor.scalar<T>()();
errors::InvalidArgument("Invalid range: input_min ",
min_val, " > input_max ", max_val));
OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,
errors::InvalidArgument(
"input_min_tensor has incorrect size, was ",
input_min_tensor.dim_size(0), " expected ", depth,
" to match dim ", axis_, " of the input ",
input_min_tensor.shape()));
OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,
errors::InvalidArgument(
"input_max_tensor has incorrect size, was ",
input_max_tensor.dim_size(0), " expected ", depth,
" to match dim ", axis_, " of the input ",
input_max_tensor.shape()));
errors::InvalidArgument("num_bits is out of range: ", num_bits_,
" with signed_input_ ", signed_input_));
OP_REQUIRES(
ctx, input_min_ <= input_max_,
errors::InvalidArgument("Invalid range: input_min ", input_min_,
// Specializations for CPUDevice.
struct QuantizeAndDequantizeOneScaleFunctor<CPUDevice, T> {
void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,
QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(
struct QuantizeAndDequantizePerChannelFunctor<CPUDevice, T> {
void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,
QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(
struct QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice, T> {
void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,
QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(
struct QuantizeAndDequantizePerChannelGradientFunctor<CPUDevice, T> {
void operator()(const CPUDevice& d,
QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(
template struct functor::QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice,
CPUDevice, double>;
QuantizeAndDequantizeV2Op<CPUDevice, T>);            \
QuantizeAndDequantizeV3Op<CPUDevice, T>);            \
QuantizeAndDequantizeV2Op<CPUDevice, T>);            \
QuantizeAndDequantizeV4GradientOp<CPUDevice, T>);    \
QuantizeAndDequantizeOp<CPUDevice, T>);
QuantizeAndDequantizeV2Op<GPUDevice, T>);            \
QuantizeAndDequantizeV3Op<GPUDevice, T>);            \
QuantizeAndDequantizeV2Op<GPUDevice, T>);            \
QuantizeAndDequantizeV4GradientOp<GPUDevice, T>);    \
QuantizeAndDequantizeOp<GPUDevice, T>);
