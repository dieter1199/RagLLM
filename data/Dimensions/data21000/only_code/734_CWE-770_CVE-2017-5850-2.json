/*	$OpenBSD: server_file.c,v 1.63 2017/01/30 09:54:41 reyk Exp $	*/
* Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>
#define MAX_RANGES	4
struct range {
off_t	start;
off_t	end;
};
struct range	*parse_range(char *, size_t, int *);
int		 buffer_add_range(int, struct evbuffer *, struct range *);
struct evbuffer		*evb = NULL;
size_t			 content_length;
uint32_t		 boundary;
if ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {
if ((evb = evbuffer_new()) == NULL) {
errstr = "failed to allocate file buffer";
goto abort;
}
content_length = range->end - range->start + 1;
if (buffer_add_range(fd, evb, range) == 0)
goto abort;
content_length = 0;
boundary = arc4random();
/* Generate a multipart payload of byteranges */
while (nranges--) {
if ((i = evbuffer_add_printf(evb, "\r\n--%ud\r\n",
boundary)) == -1)
goto abort;
content_length += i;
if ((i = evbuffer_add_printf(evb,
"Content-Type: %s/%s\r\n",
media->media_type, media->media_subtype)) == -1)
goto abort;
content_length += i;
if ((i = evbuffer_add_printf(evb,
range->start, range->end, st->st_size)) == -1)
content_length += i;
if (buffer_add_range(fd, evb, range) == 0)
goto abort;
content_length += range->end - range->start + 1;
range++;
if ((i = evbuffer_add_printf(evb, "\r\n--%ud--\r\n",
boundary)) == -1)
content_length += i;
"byteranges; boundary=%ud", boundary);
close(fd);
fd = -1;
if (server_bufferevent_write_buffer(clt, evb) == -1)
bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
if (clt->clt_persist)
clt->clt_toread = TOREAD_HTTP_HEADER;
else
clt->clt_toread = TOREAD_HTTP_NONE;
clt->clt_done = 0;
evbuffer_free(evb);
if (evb != NULL)
evbuffer_free(evb);
struct range *
parse_range(char *str, size_t file_sz, int *nranges)
static struct range	 ranges[MAX_RANGES];
return (NULL);
return (NULL);
if (parse_range_spec(p, file_sz, &ranges[i]) == 0)
if (i == MAX_RANGES)
return (NULL);
if (parse_range_spec(p, file_sz, &ranges[i]) != 0)
*nranges = i;
return (i ? ranges : NULL);
int
buffer_add_range(int fd, struct evbuffer *evb, struct range *range)
{
char	buf[BUFSIZ];
size_t	n, range_sz;
ssize_t	nread;
if (lseek(fd, range->start, SEEK_SET) == -1)
return (0);
range_sz = range->end - range->start + 1;
while (range_sz) {
n = MINIMUM(range_sz, sizeof(buf));
if ((nread = read(fd, buf, n)) == -1)
return (0);
evbuffer_add(evb, buf, nread);
range_sz -= nread;
}
return (1);
}
