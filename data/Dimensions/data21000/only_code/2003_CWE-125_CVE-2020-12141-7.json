* Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>
*      An implementation of the Simple Network Management Protocol (RFC 3411-3418)
#include "snmp-oid.h"
int
snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)
uint32_t i;
for(i = 0; i < varbinds_length; i++) {
resource = snmp_mib_find(varbinds[i].oid);
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = i + 1;
(&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = 0;
resource->handler(&varbinds[i], resource->oid);
int
snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)
uint32_t i;
for(i = 0; i < varbinds_length; i++) {
resource = snmp_mib_find_next(varbinds[i].oid);
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = i + 1;
(&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = 0;
resource->handler(&varbinds[i], resource->oid);
int
snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *varbinds_length)
uint32_t i, j, original_varbinds_length;
uint32_t oid[SNMP_MAX_NR_VALUES][SNMP_MSG_OID_MAX_LEN];
original_varbinds_length = *varbinds_length;
for(i = 0; i < original_varbinds_length; i++) {
snmp_oid_copy(oid[i], varbinds[i].oid);
*varbinds_length = 0;
if(i >= header->error_status_non_repeaters.non_repeaters) {
resource = snmp_mib_find_next(oid[i]);
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = i + 1;
(&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = 0;
if(*varbinds_length < SNMP_MAX_NR_VALUES) {
resource->handler(&varbinds[*varbinds_length], resource->oid);
(*varbinds_length)++;
for(i = 0; i < header->error_index_max_repetitions.max_repetitions; i++) {
for(j = header->error_status_non_repeaters.non_repeaters; j < original_varbinds_length; j++) {
resource = snmp_mib_find_next(oid[j]);
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = *varbinds_length + 1;
if(*varbinds_length < SNMP_MAX_NR_VALUES) {
(&varbinds[*varbinds_length])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;
snmp_oid_copy((&varbinds[*varbinds_length])->oid, oid[j]);
(*varbinds_length)++;
header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
header->error_index_max_repetitions.error_index = 0;
if(*varbinds_length < SNMP_MAX_NR_VALUES) {
resource->handler(&varbinds[*varbinds_length], resource->oid);
(*varbinds_length)++;
snmp_oid_copy(oid[j], resource->oid);
unsigned char *
snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)
static snmp_header_t header;
static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];
static uint32_t varbind_length = SNMP_MAX_NR_VALUES;
buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);
if(buff == NULL) {
return NULL;
return NULL;
case SNMP_DATA_TYPE_PDU_GET_REQUEST:
if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {
return NULL;
case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:
if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {
return NULL;
case SNMP_DATA_TYPE_PDU_GET_BULK:
if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {
return NULL;
return NULL;
header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;
out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);
return ++out;