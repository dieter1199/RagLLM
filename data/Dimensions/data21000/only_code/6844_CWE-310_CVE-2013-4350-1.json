/* Based on tcp_v6_xmit() in tcp_ipv6.c. */
struct flowi6 fl6;
memset(&fl6, 0, sizeof(fl6));
fl6.flowi6_proto = sk->sk_protocol;
/* Fill in the dest address from the route entry passed with the skb
* and the source address from the transport.
*/
fl6.daddr = transport->ipaddr.v6.sin6_addr;
fl6.saddr = transport->saddr.v6.sin6_addr;
fl6.flowlabel = np->flow_label;
IP6_ECN_flow_xmit(sk, fl6.flowlabel);
if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
else
fl6.flowi6_oif = sk->sk_bound_dev_if;
if (np->opt && np->opt->srcrt) {
struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
fl6.daddr = *rt0->addr;
}
skb->len, &fl6.saddr, &fl6.daddr);
SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
