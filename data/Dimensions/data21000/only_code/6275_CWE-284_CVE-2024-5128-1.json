// Can be public route
datasets.get(
"/:identifier",
// checkAccess("datasets", "read"),
async (ctx: Context) => {
const { projectId } = ctx.state
const { identifier } = ctx.params
const isUUID = validateUUID(identifier)
if (isUUID) {
// For frontend
const datasetId = identifier
const dataset = await getDatasetById(datasetId, projectId)
ctx.body = dataset
return
} else {
// For SDK
const slug = identifier
const dataset = await getDatasetBySlug(slug, projectId)
ctx.body = dataset
return
}
},
)
// insert 1 prompt and 1 variation
const { id } = ctx.params
await sql`delete from dataset where id = ${id} and project_id = ${projectId}`
// Create prompt
// insert 1 variation
await sql`insert into dataset_prompt_variation
${sql({
promptId: prompt.id,
variables: {},
idealOutput: idealOutput ? lastMsg(idealOutput) : "",
})}
returning *
`
// return array of prompts and variations
select * from dataset_prompt where id = ${id} order by created_at asc
select * from dataset_prompt_variation where prompt_id = ${id} order by created_at asc
// add route ot to delete dataset_prompt and dataset_prompt_variation
const { id } = ctx.params
await sql`delete from dataset_prompt where id = ${id}`
await sql`delete from dataset_prompt_variation where prompt_id = ${id}`
// Update prompt
const { id } = ctx.params
await sql`delete from dataset_prompt_variation where id = ${id}`
// Update variation
// Create variation
${sql(
clearUndefined({
promptId,
variables,
idealOutput,
}),
)}
returning *
`