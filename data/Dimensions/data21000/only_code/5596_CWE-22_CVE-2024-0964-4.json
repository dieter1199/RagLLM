from gradio.utils import run_coro_in_background, safe_get_lock, set_task_name
self.message_queue = ThreadQueue()
def send_message(
self,
message_type: str,
data: dict | None = None,
final: bool = False,
):
data = {} if data is None else data
self.message_queue.put_nowait({"msg": message_type, **data})
if final:
self.message_queue.put_nowait(None)
async def get_data(self, timeout=5) -> bool:
self.send_message("send_data", {"event_id": self._id})
sleep_interval = 0.05
wait_time = 0
while wait_time < timeout and self.alive:
if self.data is not None:
break
await asyncio.sleep(sleep_interval)
wait_time += sleep_interval
return self.data is not None
def attach_data(self, body: PredictBody):
event_id = body.event_id
if event_id in self.awaiting_data_events:
event = self.awaiting_data_events[event_id]
event.data = body
else:
raise ValueError("Event not found", event_id)
event.send_message("progress", event.progress.model_dump())
event.send_message("log", log_message.model_dump())
def push(self, event: Event) -> int | None:
"""
Add event to queue, or return None if Queue is full
Parameters:
event: Event to add to Queue
Returns:
rank of submitted Event
"""
queue_len = len(self.event_queue)
if self.max_size is not None and queue_len >= self.max_size:
return None
self.event_queue.append(event)
return queue_len
async def clean_event(self, event: Event | str) -> None:
if isinstance(event, str):
for job_set in self.active_jobs:
if job_set:
for job in job_set:
if job._id == event:
event = job
break
if isinstance(event, str):
raise ValueError("Event not found", event)
event.alive = False
if event in self.event_queue:
event.send_message("estimation", estimation.model_dump())
if not event.data:
self.awaiting_data_events[event._id] = event
client_awake = await event.get_data()
del self.awaiting_data_events[event._id]
if not client_awake:
await self.clean_event(event)
continue
event.send_message("process_starts")
event.send_message(
final=True,
event.send_message(
event.send_message(
final=True,
event.send_message(
final=True,
