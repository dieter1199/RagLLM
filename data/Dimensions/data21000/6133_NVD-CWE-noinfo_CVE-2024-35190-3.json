{
    "cve_id": "CVE-2024-35190",
    "cve_description": "Asterisk is an open source private branch exchange and telephony toolkit. After upgrade to 18.23.0, ALL unauthorized SIP requests are identified as PJSIP Endpoint of local asterisk server. This vulnerability is fixed in 18.23.1, 20.8.1, and 21.3.1.\n",
    "cve_publish_date": "2024-05-17",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "Revert \"res_pjsip_endpoint_identifier_ip: Add endpoint identifier transport address.\"\n\nThis reverts PR #602\n\nResolves: #GHSA-qqxj-v78h-hrf9",
    "type_of_change": "Modification",
    "filename_of_changes": "res_pjsip_endpoint_identifier_ip.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "92",
    "vulnerable_lines": [
        "// Line_Reference 127: \t\t\t\t<configOption name=\"transport\">",
        "// Line_Reference 128: \t\t\t\t\t<synopsis>Match against a transport type.</synopsis>",
        "// Line_Reference 129: \t\t\t\t\t<description>",
        "// Line_Reference 130: \t\t\t\t\t\t<para>When using the ip or transport identifier, this option",
        "// Line_Reference 131: \t\t\t\t\t\tcan be used to match the transport type <literal>(udp or tcp)",
        "// Line_Reference 132: \t\t\t\t\t\t</literal> as well.</para>",
        "// Line_Reference 133: \t\t\t\t\t\t<para>When omitted, or left empty, which is the default, it",
        "// Line_Reference 134: \t\t\t\t\t\twon't match against the transport type.</para>",
        "// Line_Reference 135: \t\t\t\t\t</description>",
        "// Line_Reference 136: \t\t\t\t</configOption>",
        "// Line_Reference 164: \t\t/*! The name of the transport type */",
        "// Line_Reference 165: \t\tAST_STRING_FIELD(transport);",
        "// Line_Reference 183: /*! \\brief Structure for a socket address with transport */",
        "// Line_Reference 184: struct ast_sockaddr_with_tp {",
        "// Line_Reference 185: \tstruct ast_sockaddr addr;",
        "// Line_Reference 186: \tchar tp[128];",
        "// Line_Reference 187: };",
        "// Line_Reference 188: ",
        "// Line_Reference 324: \tstruct ast_sockaddr_with_tp *addr_with_tp = arg;",
        "// Line_Reference 325: \tstruct ast_sockaddr address = addr_with_tp->addr;",
        "// Line_Reference 328: \tsense = ast_apply_ha(identify->matches, &address);",
        "// Line_Reference 330: \t\tast_debug(3, \"Address %s matches identify '%s'\\n\",",
        "// Line_Reference 331: \t\t\t\tast_sockaddr_stringify(&address),",
        "// Line_Reference 332: \t\t\t\tast_sorcery_object_get_id(identify));",
        "// Line_Reference 333: \t\tif (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {",
        "// Line_Reference 334: \t\t\tast_debug(3, \"Transport %s matches identify '%s'\\n\",",
        "// Line_Reference 335: \t\t\t\taddr_with_tp->tp,",
        "// Line_Reference 336: \t\t\t\tast_sorcery_object_get_id(identify));",
        "// Line_Reference 337: \t\t\treturn CMP_MATCH;",
        "// Line_Reference 338: \t\t} else {",
        "// Line_Reference 339: \t\t\tast_debug(3, \"Transport %s match not matched identify '%s'\\n\",",
        "// Line_Reference 340: \t\t\t\taddr_with_tp->tp,",
        "// Line_Reference 342: \t\t\treturn 0;",
        "// Line_Reference 343: \t\t}",
        "// Line_Reference 345: \t\tast_debug(3, \"Address %s does not match identify '%s'\\n\",",
        "// Line_Reference 346: \t\t\t\tast_sockaddr_stringify(&address),",
        "// Line_Reference 387: \tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };",
        "// Line_Reference 388: \tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));",
        "// Line_Reference 389: ",
        "// Line_Reference 390: \tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);",
        "// Line_Reference 391: \tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);",
        "// Line_Reference 392: ",
        "// Line_Reference 393: \treturn common_identify(ip_identify_match_check, &addr_with_tp);",
        "// Line_Reference 394: }",
        "// Line_Reference 395: ",
        "// Line_Reference 396: static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)",
        "// Line_Reference 397: {",
        "// Line_Reference 398: \tchar buffer[PJ_INET6_ADDRSTRLEN];",
        "// Line_Reference 399: \tpj_status_t status;",
        "// Line_Reference 400: \tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };",
        "// Line_Reference 401: \tunion pj_sockaddr sock = rdata->tp_info.transport->local_addr;",
        "// Line_Reference 402: ",
        "// Line_Reference 403: \tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));",
        "// Line_Reference 404: ",
        "// Line_Reference 405: \tif (sock.addr.sa_family == PJ_AF_INET6) {",
        "// Line_Reference 406: \t\tstatus = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);",
        "// Line_Reference 407: \t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"::\")) {",
        "// Line_Reference 408: \t\t\tast_log(LOG_WARNING, \"Matching against '::' may be unpredictable.\\n\");",
        "// Line_Reference 409: \t\t}",
        "// Line_Reference 410: \t} else {",
        "// Line_Reference 411: \t\tstatus = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);",
        "// Line_Reference 412: \t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"0.0.0.0\")) {",
        "// Line_Reference 413: \t\t\tast_log(LOG_WARNING, \"Matching against '0.0.0.0' may be unpredictable.\\n\");",
        "// Line_Reference 414: \t\t}",
        "// Line_Reference 415: \t}",
        "// Line_Reference 417: \tif (status == PJ_SUCCESS) {",
        "// Line_Reference 418: \t\tast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);",
        "// Line_Reference 419: \t\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);",
        "// Line_Reference 421: \t\treturn common_identify(ip_identify_match_check, &addr_with_tp);",
        "// Line_Reference 422: \t} else {",
        "// Line_Reference 423: \t\treturn NULL;",
        "// Line_Reference 424: \t}",
        "// Line_Reference 431: static struct ast_sip_endpoint_identifier transport_identifier = {",
        "// Line_Reference 432: \t.identify_endpoint = transport_identify,",
        "// Line_Reference 433: };",
        "// Line_Reference 434: ",
        "// Line_Reference 598: \tif (!ast_strlen_zero(identify->transport)) {",
        "// Line_Reference 599: \t\tif (ast_string_field_set(identify, transport, identify->transport)) {",
        "// Line_Reference 600: \t\t\treturn -1;",
        "// Line_Reference 601: \t\t}",
        "// Line_Reference 602: \t}",
        "// Line_Reference 603: ",
        "// Line_Reference 953: \t\tif (!ast_strlen_zero(ident->transport)) {",
        "// Line_Reference 954: \t\t\tast_str_append(&context->output_buffer, 0, \"%*s: %s\\n\",",
        "// Line_Reference 955: \t\t\t\tindent,",
        "// Line_Reference 956: \t\t\t\t\"Transport\",",
        "// Line_Reference 957: \t\t\t\tident->transport);",
        "// Line_Reference 958: \t\t}",
        "// Line_Reference 959: ",
        "// Line_Reference 1035: \tast_sorcery_object_field_register(ast_sip_get_sorcery(), \"identify\", \"transport\", \"\", OPT_STRINGFIELD_T, 0, STRFLDSET(struct ip_identify_match, transport));",
        "// Line_Reference 1041: \tast_sip_register_endpoint_identifier_with_name(&transport_identifier, \"transport\");",
        "// Line_Reference 1078: \tast_sip_unregister_endpoint_identifier(&transport_identifier);"
    ]
}
