{
    "cve_id": "CVE-2012-2119",
    "cve_description": "Buffer overflow in the macvtap device driver in the Linux kernel before 3.4.5, when running in certain configurations, allows privileged KVM guest users to cause a denial of service (crash) via a long descriptor with a long vector length.",
    "cve_publish_date": "2013-01-22",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "macvtap: zerocopy: validate vectors before building skb\n\nThere're several reasons that the vectors need to be validated:\n\n- Return error when caller provides vectors whose num is greater than UIO_MAXIOV.\n- Linearize part of skb when userspace provides vectors grater than MAX_SKB_FRAGS.\n- Return error when userspace provides vectors whose total length may exceed\n- MAX_SKB_FRAGS * PAGE_SIZE.\n\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "macvtap.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "21",
    "number_of_lines_deleted_vulnerable_to_cve": "4",
    "vulnerable_lines": [
        "// Line_Reference 533: \t\tif ((num_pages != size) ||",
        "// Line_Reference 534: \t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {",
        "// Line_Reference 654: \tint copylen;",
        "// Line_Reference 691: \t\tcopylen = vnet_hdr.hdr_len;"
    ]
}
