{
    "cve_id": "CVE-2011-1479",
    "cve_description": "Double free vulnerability in the inotify subsystem in the Linux kernel before 2.6.39 allows local users to cause a denial of service (system crash) via vectors involving failed attempts to create files.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-4250.",
    "cve_publish_date": "2012-06-21",
    "cwe_id": "CWE-399",
    "cwe_name": "Resource Management Errors",
    "cwe_description": "Weaknesses in this category are related to improper management of system resources.",
    "commit_message": "inotify: fix double free/corruption of stuct user\n\nOn an error path in inotify_init1 a normal user can trigger a double\nfree of struct user.  This is a regression introduced by a2ae4cc9a16e\n(\"inotify: stop kernel memory leak on file creation failure\").\n\nWe fix this by making sure that if a group exists the user reference is\ndropped when the group is cleaned up.  We should not explictly drop the\nreference on error and also drop the reference when the group is cleaned\nup.\n\nThe new lifetime rules are that an inotify group lives from\ninotify_new_group to the last fsnotify_put_group.  Since the struct user\nand inotify_devs are directly tied to this lifetime they are only\nchanged/updated in those two locations.  We get rid of all special\ncasing of struct user or user->inotify_devs.\n\nSigned-off-by: Eric Paris <eparis@redhat.com>\nCc: stable@kernel.org (2.6.37 and up)\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "inotify_user.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "13",
    "number_of_lines_deleted_vulnerable_to_cve": "26",
    "vulnerable_lines": [
        "// Line_Reference 293: \tstruct user_struct *user = group->inotify_data.user;",
        "// Line_Reference 302: \tatomic_dec(&user->inotify_devs);",
        "// Line_Reference 303: ",
        "// Line_Reference 700: static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)",
        "// Line_Reference 713: \tgroup->inotify_data.user = user;",
        "// Line_Reference 724: \tstruct user_struct *user;",
        "// Line_Reference 734: \tuser = get_current_user();",
        "// Line_Reference 735: \tif (unlikely(atomic_read(&user->inotify_devs) >=",
        "// Line_Reference 736: \t\t\tinotify_max_user_instances)) {",
        "// Line_Reference 737: \t\tret = -EMFILE;",
        "// Line_Reference 738: \t\tgoto out_free_uid;",
        "// Line_Reference 739: \t}",
        "// Line_Reference 740: ",
        "// Line_Reference 742: \tgroup = inotify_new_group(user, inotify_max_queued_events);",
        "// Line_Reference 743: \tif (IS_ERR(group)) {",
        "// Line_Reference 744: \t\tret = PTR_ERR(group);",
        "// Line_Reference 745: \t\tgoto out_free_uid;",
        "// Line_Reference 746: \t}",
        "// Line_Reference 747: ",
        "// Line_Reference 748: \tatomic_inc(&user->inotify_devs);",
        "// Line_Reference 752: \tif (ret >= 0)",
        "// Line_Reference 753: \t\treturn ret;",
        "// Line_Reference 755: \tfsnotify_put_group(group);",
        "// Line_Reference 756: \tatomic_dec(&user->inotify_devs);",
        "// Line_Reference 757: out_free_uid:",
        "// Line_Reference 758: \tfree_uid(user);"
    ]
}
