{
    "cve_id": "CVE-2019-19010",
    "cve_description": "Eval injection in the Math plugin of Limnoria (before 2019.11.09) and Supybot (through 2018-05-09) allows remote unprivileged attackers to disclose information or possibly have unspecified other impact via the calc and icalc IRC commands.",
    "cve_publish_date": "2019-11-16",
    "cwe_id": "CWE-94",
    "cwe_name": "Improper Control of Generation of Code ('Code Injection')",
    "cwe_description": "The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",
    "commit_message": "Math: Rewrite calc functions with a proper evaluator.\n\nInstead of hacking around eval(), which everyone knows is a bad idea\neven with prior expression sanitizing.",
    "type_of_change": "ModificationType.ADD",
    "filename_of_changes": "plugin.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "12",
    "number_of_lines_deleted_vulnerable_to_cve": "105",
    "vulnerable_lines": [
        "// Line_Reference 100:     _mathEnv = {'__builtins__': types.ModuleType('__builtins__'), 'i': 1j}",
        "// Line_Reference 101:     _mathEnv.update(math.__dict__)",
        "// Line_Reference 102:     _mathEnv.update(cmath.__dict__)",
        "// Line_Reference 103:     def _sqrt(x):",
        "// Line_Reference 104:         if isinstance(x, complex) or x < 0:",
        "// Line_Reference 105:             return cmath.sqrt(x)",
        "// Line_Reference 106:         else:",
        "// Line_Reference 107:             return math.sqrt(x)",
        "// Line_Reference 108:     def _cbrt(x):",
        "// Line_Reference 109:         return math.pow(x, 1.0/3)",
        "// Line_Reference 110:     def _factorial(x):",
        "// Line_Reference 111:         if x<=10000:",
        "// Line_Reference 112:             return float(math.factorial(x))",
        "// Line_Reference 113:         else:",
        "// Line_Reference 114:             raise Exception('factorial argument too large')",
        "// Line_Reference 115:     _mathEnv['sqrt'] = _sqrt",
        "// Line_Reference 116:     _mathEnv['cbrt'] = _cbrt",
        "// Line_Reference 117:     _mathEnv['abs'] = abs",
        "// Line_Reference 118:     _mathEnv['max'] = max",
        "// Line_Reference 119:     _mathEnv['min'] = min",
        "// Line_Reference 120:     _mathEnv['round'] = lambda x, y=0: round(x, int(y))",
        "// Line_Reference 121:     _mathSafeEnv = dict([(x,y) for x,y in _mathEnv.items()])",
        "// Line_Reference 122:     _mathSafeEnv['factorial'] = _factorial",
        "// Line_Reference 123:     _mathRe = re.compile(r'((?:(?<![A-Fa-f\\d)])-)?'",
        "// Line_Reference 124:                          r'(?:0x[A-Fa-f\\d]+|'",
        "// Line_Reference 125:                          r'0[0-7]+|'",
        "// Line_Reference 126:                          r'\\d+\\.\\d+|'",
        "// Line_Reference 127:                          r'\\.\\d+|'",
        "// Line_Reference 128:                          r'\\d+\\.|'",
        "// Line_Reference 129:                          r'\\d+))')",
        "// Line_Reference 160:     _calc_match_forbidden_chars = re.compile('[_\\[\\]]')",
        "// Line_Reference 161:     _calc_remover = utils.str.MultipleRemover('_[] \\t')",
        "// Line_Reference 162:     ###",
        "// Line_Reference 163:     # So this is how the 'calc' command works:",
        "// Line_Reference 164:     # First, we make a nice little safe environment for evaluation; basically,",
        "// Line_Reference 165:     # the names in the 'math' and 'cmath' modules.  Then, we remove the ability",
        "// Line_Reference 166:     # of a random user to get ints evaluated: this means we have to turn all",
        "// Line_Reference 167:     # int literals (even octal numbers and hexadecimal numbers) into floats.",
        "// Line_Reference 168:     # Then we delete all square brackets, underscores, and whitespace, so no",
        "// Line_Reference 169:     # one can do list comprehensions or call __...__ functions.",
        "// Line_Reference 170:     ###",
        "// Line_Reference 181:         try:",
        "// Line_Reference 182:             text = str(text)",
        "// Line_Reference 183:         except UnicodeEncodeError:",
        "// Line_Reference 184:             irc.error(_(\"There's no reason you should have fancy non-ASCII \"",
        "// Line_Reference 185:                             \"characters in your mathematical expression. \"",
        "// Line_Reference 186:                             \"Please remove them.\"))",
        "// Line_Reference 187:             return",
        "// Line_Reference 188:         if self._calc_match_forbidden_chars.match(text):",
        "// Line_Reference 189:             # Note: this is important to keep this to forbid usage of",
        "// Line_Reference 190:             # __builtins__",
        "// Line_Reference 191:             irc.error(_('There\\'s really no reason why you should have '",
        "// Line_Reference 192:                            'underscores or brackets in your mathematical '",
        "// Line_Reference 193:                            'expression.  Please remove them.'))",
        "// Line_Reference 194:             return",
        "// Line_Reference 195:         text = self._calc_remover(text)",
        "// Line_Reference 196:         if 'lambda' in text:",
        "// Line_Reference 197:             irc.error(_('You can\\'t use lambda in this command.'))",
        "// Line_Reference 198:             return",
        "// Line_Reference 199:         text = text.lower()",
        "// Line_Reference 200:         def handleMatch(m):",
        "// Line_Reference 201:             s = m.group(1)",
        "// Line_Reference 202:             if s.startswith('0x'):",
        "// Line_Reference 203:                 i = int(s, 16)",
        "// Line_Reference 204:             elif s.startswith('0') and '.' not in s:",
        "// Line_Reference 205:                 try:",
        "// Line_Reference 206:                     i = int(s, 8)",
        "// Line_Reference 207:                 except ValueError:",
        "// Line_Reference 208:                     i = int(s)",
        "// Line_Reference 209:             else:",
        "// Line_Reference 210:                 i = float(s)",
        "// Line_Reference 211:             x = complex(i)",
        "// Line_Reference 212:             if x.imag == 0:",
        "// Line_Reference 213:                 x = x.real",
        "// Line_Reference 214:                 # Need to use string-formatting here instead of str() because",
        "// Line_Reference 215:                 # use of str() on large numbers loses information:",
        "// Line_Reference 216:                 # str(float(33333333333333)) => '3.33333333333e+13'",
        "// Line_Reference 217:                 # float('3.33333333333e+13') => 33333333333300.0",
        "// Line_Reference 218:                 return '%.16f' % x",
        "// Line_Reference 219:             return str(x)",
        "// Line_Reference 220:         text = self._mathRe.sub(handleMatch, text)",
        "// Line_Reference 223:             x = complex(eval(text, self._mathSafeEnv, self._mathSafeEnv))",
        "// Line_Reference 228:         except TypeError:",
        "// Line_Reference 229:             irc.error(_('Something in there wasn\\'t a valid number.'))",
        "// Line_Reference 231:             irc.error(_('%s is not a defined function.') % str(e).split()[1])",
        "// Line_Reference 244:         if self._calc_match_forbidden_chars.match(text):",
        "// Line_Reference 245:             # Note: this is important to keep this to forbid usage of",
        "// Line_Reference 246:             # __builtins__",
        "// Line_Reference 247:             irc.error(_('There\\'s really no reason why you should have '",
        "// Line_Reference 248:                            'underscores or brackets in your mathematical '",
        "// Line_Reference 249:                            'expression.  Please remove them.'))",
        "// Line_Reference 250:             return",
        "// Line_Reference 251:         # This removes spaces, too, but we'll leave the removal of _[] for",
        "// Line_Reference 252:         # safety's sake.",
        "// Line_Reference 253:         text = self._calc_remover(text)",
        "// Line_Reference 254:         if 'lambda' in text:",
        "// Line_Reference 255:             irc.error(_('You can\\'t use lambda in this command.'))",
        "// Line_Reference 256:             return",
        "// Line_Reference 257:         text = text.replace('lambda', '')",
        "// Line_Reference 260:             irc.reply(str(eval(text, self._mathEnv, self._mathEnv)))",
        "// Line_Reference 264:         except TypeError:",
        "// Line_Reference 265:             irc.error(_('Something in there wasn\\'t a valid number.'))",
        "// Line_Reference 289:                 if arg in self._mathSafeEnv:",
        "// Line_Reference 290:                     f = self._mathSafeEnv[arg]",
        "// Line_Reference 313:                         stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))"
    ]
}
