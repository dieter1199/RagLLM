{
    "cve_id": "CVE-2024-24746",
    "cve_description": "Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in Apache NimBLE.Â \n\nSpecially crafted GATT operation can cause infinite loop in GATT server leading to denial of service in Bluetooth stack or device.\n\nThis issue affects Apache NimBLE: through 1.6.0.\nUsers are recommended to upgrade to version 1.7.0, which fixes the issue.",
    "cve_publish_date": "2024-04-06",
    "cwe_id": "CWE-835",
    "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
    "cwe_description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
    "commit_message": "nimble/host: Fix disconnect on host connection timeout\n\nWe don't need to have double loop and lock-unlock host lock when\nissuing disconnect. ble_gap_terminate_with_conn() can be used\nto disconnect and it can be called with already provided conn object\nunder host lock.",
    "type_of_change": "Modification",
    "filename_of_changes": "ble_hs_conn.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "49",
    "number_of_lines_deleted_vulnerable_to_cve": "62",
    "vulnerable_lines": [
        "// Line_Reference 480:     ble_npl_time_t now;",
        "// Line_Reference 481:     int32_t next_exp_in;",
        "// Line_Reference 483:     uint16_t conn_handle;",
        "// Line_Reference 485:     for (;;) {",
        "// Line_Reference 486:         conn_handle = BLE_HS_CONN_HANDLE_NONE;",
        "// Line_Reference 487:         next_exp_in = BLE_HS_FOREVER;",
        "// Line_Reference 488:         now = ble_npl_time_get();",
        "// Line_Reference 490:         ble_hs_lock();",
        "// Line_Reference 491: ",
        "// Line_Reference 492:         /* This loop performs one of two tasks:",
        "// Line_Reference 493:          * 1. Determine if any connections need to be terminated due to timeout.",
        "// Line_Reference 494:          *    If so, break out of the loop and terminate the connection.  This",
        "// Line_Reference 495:          *    function will need to be executed again.",
        "// Line_Reference 496:          * 2. Otherwise, determine when the next timeout will occur.",
        "// Line_Reference 497:          */",
        "// Line_Reference 498:         SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {",
        "// Line_Reference 499:             if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {",
        "// Line_Reference 502:                 /* Check each connection's rx fragment timer.  If too much time",
        "// Line_Reference 503:                  * passes after a partial packet is received, the connection is",
        "// Line_Reference 504:                  * terminated.",
        "// Line_Reference 505:                  */",
        "// Line_Reference 506:                 if (conn->bhc_rx_chan != NULL) {",
        "// Line_Reference 507:                     time_diff = conn->bhc_rx_timeout - now;",
        "// Line_Reference 508: ",
        "// Line_Reference 509:                     if (time_diff <= 0) {",
        "// Line_Reference 510:                         /* ACL reassembly has timed out.  Remember the connection",
        "// Line_Reference 511:                          * handle so it can be terminated after the mutex is",
        "// Line_Reference 512:                          * unlocked.",
        "// Line_Reference 513:                          */",
        "// Line_Reference 514:                         conn_handle = conn->bhc_handle;",
        "// Line_Reference 515:                         break;",
        "// Line_Reference 516:                     }",
        "// Line_Reference 517: ",
        "// Line_Reference 518:                     /* Determine if this connection is the soonest to time out. */",
        "// Line_Reference 519:                     if (time_diff < next_exp_in) {",
        "// Line_Reference 520:                         next_exp_in = time_diff;",
        "// Line_Reference 521:                     }",
        "// Line_Reference 522:                 }",
        "// Line_Reference 523: #endif",
        "// Line_Reference 525: #if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO",
        "// Line_Reference 526:                 /* Check each connection's rx queued write timer.  If too much",
        "// Line_Reference 527:                  * time passes after a prep write is received, the queue is",
        "// Line_Reference 528:                  * cleared.",
        "// Line_Reference 529:                  */",
        "// Line_Reference 530:                 time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);",
        "// Line_Reference 532:                     /* ACL reassembly has timed out.  Remember the connection",
        "// Line_Reference 533:                      * handle so it can be terminated after the mutex is",
        "// Line_Reference 534:                      * unlocked.",
        "// Line_Reference 535:                      */",
        "// Line_Reference 536:                     conn_handle = conn->bhc_handle;",
        "// Line_Reference 537:                     break;",
        "// Line_Reference 542:                     next_exp_in = time_diff;",
        "// Line_Reference 546:         }",
        "// Line_Reference 548:         ble_hs_unlock();",
        "// Line_Reference 550:         /* If a connection has timed out, terminate it.  We need to repeatedly",
        "// Line_Reference 551:          * call this function again to determine when the next timeout is.",
        "// Line_Reference 552:          */",
        "// Line_Reference 553:         if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {",
        "// Line_Reference 554:             ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);",
        "// Line_Reference 555:             continue;",
        "// Line_Reference 557: ",
        "// Line_Reference 558:         return next_exp_in;"
    ]
}
