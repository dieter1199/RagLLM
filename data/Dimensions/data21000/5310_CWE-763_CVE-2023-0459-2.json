{
    "cve_id": "CVE-2023-0459",
    "cve_description": "Copy_from_user on 64-bit versions of the Linux kernel does not implement the __uaccess_begin_nospec allowing a user to bypass the \"access_ok\" check and pass a kernel pointer to copy_from_user(). This would allow an attacker to leak information. We recommend upgrading beyond commitÂ 74e19ef0ff8061ef55957c3abd71614ef0f42f47",
    "cve_publish_date": "2023-05-25",
    "cwe_id": "CWE-763",
    "cwe_name": "Release of Invalid Pointer or Reference",
    "cwe_description": "The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.",
    "commit_message": "uaccess: Add speculation barrier to copy_from_user()\n\nThe results of \"access_ok()\" can be mis-speculated.  The result is that\nyou can end speculatively:\n\n\tif (access_ok(from, size))\n\t\t// Right here\n\neven for bad from/size combinations.  On first glance, it would be ideal\nto just add a speculation barrier to \"access_ok()\" so that its results\ncan never be mis-speculated.\n\nBut there are lots of system calls just doing access_ok() via\n\"copy_to_user()\" and friends (example: fstat() and friends).  Those are\ngenerally not problematic because they do not _consume_ data from\nuserspace other than the pointer.  They are also very quick and common\nsystem calls that should not be needlessly slowed down.\n\n\"copy_from_user()\" on the other hand uses a user-controller pointer and\nis frequently followed up with code that might affect caches.  Take\nsomething like this:\n\n\tif (!copy_from_user(&kernelvar, uptr, size))\n\t\tdo_something_with(kernelvar);\n\nIf userspace passes in an evil 'uptr' that *actually* points to a kernel\naddresses, and then do_something_with() has cache (or other)\nside-effects, it could allow userspace to infer kernel data values.\n\nAdd a barrier to the common copy_from_user() code to prevent\nmis-speculated values which happen after the copy.\n\nAlso add a stub for architectures that do not define barrier_nospec().\nThis makes the macro usable in generic code.\n\nSince the barrier is now usable in generic code, the x86 #ifdef in the\nBPF code can also go away.\n\nReported-by: Jordy Zomer <jordyzomer@google.com>\nSuggested-by: Linus Torvalds <torvalds@linuxfoundation.org>\nSigned-off-by: Dave Hansen <dave.hansen@linux.intel.com>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>   # BPF bits\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "core.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "0",
    "number_of_lines_deleted_vulnerable_to_cve": "2",
    "vulnerable_lines": [
        "// Line_Reference 1913: #ifdef CONFIG_X86",
        "// Line_Reference 1915: #endif"
    ]
}
