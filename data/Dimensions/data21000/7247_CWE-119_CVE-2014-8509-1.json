{
    "cve_id": "CVE-2014-8509",
    "cve_description": "The lazy_bdecode function in BitTorrent bootstrap-dht (aka Bootstrap) allows remote attackers to execute arbitrary code via a crafted packet, which triggers an out-of-bounds read, related to \"Improper Indexing.\"",
    "cve_publish_date": "2014-10-31",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "update version of lazy_bdecode from libtorrent",
    "type_of_change": "Modification",
    "filename_of_changes": "lazy_bdecode.cpp",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "132",
    "number_of_lines_deleted_vulnerable_to_cve": "33",
    "vulnerable_lines": [
        "// Line_Reference 3: Copyright (c) 2008-2012, Arvid Norberg",
        "// Line_Reference 48: #define TORRENT_FAIL_BDECODE(code) \\",
        "// Line_Reference 49: \t{ \\",
        "// Line_Reference 50: \t\tec = make_error_code(code); \\",
        "// Line_Reference 51: \t\twhile (!stack.empty()) { \\",
        "// Line_Reference 52: \t\t\ttop = stack.back(); \\",
        "// Line_Reference 53: \t\t\tif (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t) top->pop(); \\",
        "// Line_Reference 54: \t\t\tstack.pop_back(); \\",
        "// Line_Reference 55: \t\t} \\",
        "// Line_Reference 56: \t\tif (error_pos) *error_pos = start - orig_start; \\",
        "// Line_Reference 57: \t\treturn -1; \\",
        "// Line_Reference 60: \tbool is_digit(char c) { return c >= '0' && c <= '9'; }",
        "// Line_Reference 62: \tbool is_print(char c) { return c >= 32 && c < 127; }",
        "// Line_Reference 68: \tchar const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)",
        "// Line_Reference 72: \t\t\tif (!is_digit(*start)) { return 0; }",
        "// Line_Reference 74: \t\t\tval += *start - '0';",
        "// Line_Reference 97: \t\twhile (start < end)",
        "// Line_Reference 119: \t\t\t\t\tif (!is_digit(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);",
        "// Line_Reference 121: \t\t\t\t\tstart = parse_int(start, end, ':', len);",
        "// Line_Reference 122: \t\t\t\t\tif (start == 0 || start + len + 3 > end || *start != ':')",
        "// Line_Reference 123: \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);",
        "// Line_Reference 176: \t\t\t\t\tif (!is_digit(t))",
        "// Line_Reference 180: \t\t\t\t\tstart = parse_int(start, end, ':', len);",
        "// Line_Reference 181: \t\t\t\t\tif (start == 0 || start + len + 1 > end || *start != ':')",
        "// Line_Reference 182: \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);",
        "// Line_Reference 201: \t\tparse_int(negative?m_data.start+1:m_data.start, m_data.start + m_size, 'e', val);",
        "// Line_Reference 495: \t\t\t\t\tusing namespace std;",
        "// Line_Reference 496: \t\t\t\t\tif (is_print((unsigned char)str[i])) continue;",
        "// Line_Reference 503: \t\t\t\t\tret += e.string_value();",
        "// Line_Reference 507: \t\t\t\tfor (int i = 0; i < e.string_length(); ++i)",
        "// Line_Reference 509: \t\t\t\t\tchar tmp[5];",
        "// Line_Reference 510: \t\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);",
        "// Line_Reference 511: \t\t\t\t\tret += tmp;"
    ]
}
