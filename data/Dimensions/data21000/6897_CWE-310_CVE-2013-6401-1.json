{
    "cve_id": "CVE-2013-6401",
    "cve_description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
    "cve_publish_date": "2014-03-21",
    "cwe_id": "CWE-310",
    "cwe_name": "Cryptographic Issues",
    "cwe_description": "Weaknesses in this category are related to the design and implementation of data confidentiality and integrity. Frequently these deal with the use of encoding techniques, encryption libraries, and hashing algorithms. The weaknesses in this category could lead to a degradation of the quality data if they are not addressed.",
    "commit_message": "CVE-2013-6401: Change hash function, randomize hashes\n\nThanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing\nand testing.",
    "type_of_change": "Modification",
    "filename_of_changes": "hashtable.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "26",
    "number_of_lines_deleted_vulnerable_to_cve": "41",
    "vulnerable_lines": [
        "// Line_Reference 18: #define list_to_pair(list_)  container_of(list_, pair_t, list)",
        "// Line_Reference 19: ",
        "// Line_Reference 20: /* From http://www.cse.yorku.ca/~oz/hash.html */",
        "// Line_Reference 21: static size_t hash_str(const void *ptr)",
        "// Line_Reference 22: {",
        "// Line_Reference 23:     const char *str = (const char *)ptr;",
        "// Line_Reference 24: ",
        "// Line_Reference 25:     size_t hash = 5381;",
        "// Line_Reference 26:     size_t c;",
        "// Line_Reference 28:     while((c = (size_t)*str))",
        "// Line_Reference 29:     {",
        "// Line_Reference 30:         hash = ((hash << 5) + hash) + c;",
        "// Line_Reference 31:         str++;",
        "// Line_Reference 32:     }",
        "// Line_Reference 34:     return hash;",
        "// Line_Reference 35: }",
        "// Line_Reference 77: static const size_t primes[] = {",
        "// Line_Reference 78:     5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,",
        "// Line_Reference 79:     49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,",
        "// Line_Reference 80:     12582917, 25165843, 50331653, 100663319, 201326611, 402653189,",
        "// Line_Reference 81:     805306457, 1610612741",
        "// Line_Reference 82: };",
        "// Line_Reference 83: ",
        "// Line_Reference 84: static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)",
        "// Line_Reference 85: {",
        "// Line_Reference 86:     return primes[hashtable->num_buckets];",
        "// Line_Reference 87: }",
        "// Line_Reference 88: ",
        "// Line_Reference 89: ",
        "// Line_Reference 123:     index = hash % num_buckets(hashtable);",
        "// Line_Reference 170:     hashtable->num_buckets++;",
        "// Line_Reference 171:     new_size = num_buckets(hashtable);",
        "// Line_Reference 177:     for(i = 0; i < num_buckets(hashtable); i++)",
        "// Line_Reference 202:     hashtable->num_buckets = 0;  /* index to primes[] */",
        "// Line_Reference 203:     hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));",
        "// Line_Reference 209:     for(i = 0; i < num_buckets(hashtable); i++)",
        "// Line_Reference 233:     if(hashtable->size >= num_buckets(hashtable))",
        "// Line_Reference 238:     index = hash % num_buckets(hashtable);",
        "// Line_Reference 276:     bucket = &hashtable->buckets[hash % num_buckets(hashtable)];",
        "// Line_Reference 297:     for(i = 0; i < num_buckets(hashtable); i++)",
        "// Line_Reference 319:     bucket = &hashtable->buckets[hash % num_buckets(hashtable)];"
    ]
}
