{
    "cve_id": "CVE-2012-3400",
    "cve_description": "Heap-based buffer overflow in the udf_load_logicalvol function in fs/udf/super.c in the Linux kernel before 3.4.5 allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted UDF filesystem.",
    "cve_publish_date": "2012-10-03",
    "cwe_id": "CWE-787",
    "cwe_name": "Out-of-bounds Write",
    "cwe_description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "commit_message": "udf: Fortify loading of sparing table\n\nAdd sanity checks when loading sparing table from disk to avoid accessing\nunallocated memory or writing to it.\n\nSigned-off-by: Jan Kara <jack@suse.cz>",
    "type_of_change": "Modification",
    "filename_of_changes": "super.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "53",
    "number_of_lines_deleted_vulnerable_to_cve": "33",
    "vulnerable_lines": [
        "// Line_Reference 1222: \tint i, j, offset;",
        "// Line_Reference 1284: \t\t\t\tuint32_t loc;",
        "// Line_Reference 1285: \t\t\t\tstruct sparingTable *st;",
        "// Line_Reference 1286: \t\t\t\tstruct sparablePartitionMap *spm =",
        "// Line_Reference 1287: \t\t\t\t\t(struct sparablePartitionMap *)gpm;",
        "// Line_Reference 1288: ",
        "// Line_Reference 1289: \t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;",
        "// Line_Reference 1290: \t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =",
        "// Line_Reference 1291: \t\t\t\t\t\tle16_to_cpu(spm->packetLength);",
        "// Line_Reference 1292: \t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {",
        "// Line_Reference 1293: \t\t\t\t\tstruct buffer_head *bh2;",
        "// Line_Reference 1294: ",
        "// Line_Reference 1295: \t\t\t\t\tloc = le32_to_cpu(",
        "// Line_Reference 1296: \t\t\t\t\t\tspm->locSparingTable[j]);",
        "// Line_Reference 1297: \t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,",
        "// Line_Reference 1298: \t\t\t\t\t\t\t     &ident);",
        "// Line_Reference 1299: \t\t\t\t\tmap->s_type_specific.s_sparing.",
        "// Line_Reference 1300: \t\t\t\t\t\t\ts_spar_map[j] = bh2;",
        "// Line_Reference 1301: ",
        "// Line_Reference 1302: \t\t\t\t\tif (bh2 == NULL)",
        "// Line_Reference 1303: \t\t\t\t\t\tcontinue;",
        "// Line_Reference 1304: ",
        "// Line_Reference 1305: \t\t\t\t\tst = (struct sparingTable *)bh2->b_data;",
        "// Line_Reference 1306: \t\t\t\t\tif (ident != 0 || strncmp(",
        "// Line_Reference 1307: \t\t\t\t\t\tst->sparingIdent.ident,",
        "// Line_Reference 1308: \t\t\t\t\t\tUDF_ID_SPARING,",
        "// Line_Reference 1309: \t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {",
        "// Line_Reference 1310: \t\t\t\t\t\tbrelse(bh2);",
        "// Line_Reference 1311: \t\t\t\t\t\tmap->s_type_specific.s_sparing.",
        "// Line_Reference 1312: \t\t\t\t\t\t\ts_spar_map[j] = NULL;",
        "// Line_Reference 1313: \t\t\t\t\t}",
        "// Line_Reference 1314: \t\t\t\t}",
        "// Line_Reference 1315: \t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;"
    ]
}
