{
    "cve_id": "CVE-2014-7822",
    "cve_description": "The implementation of certain splice_write file operations in the Linux kernel before 3.16 does not enforce a restriction on the maximum size of a single file, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted splice system call, as demonstrated by use of a file descriptor associated with an ext4 filesystem.",
    "cve_publish_date": "2015-03-16",
    "cwe_id": "CWE-264",
    "cwe_name": "Permissions, Privileges, and Access Controls",
    "cwe_description": "Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",
    "commit_message": "->splice_write() via ->write_iter()\n\niter_file_splice_write() - a ->splice_write() instance that gathers the\npipe buffers, builds a bio_vec-based iov_iter covering those and feeds\nit to ->write_iter().  A bunch of simple cases coverted to that...\n\n[AV: fixed the braino spotted by Cyrill]\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "type_of_change": "Modification",
    "filename_of_changes": "xfs_file.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "42",
    "vulnerable_lines": [
        "// Line_Reference 345: /*",
        "// Line_Reference 346:  * xfs_file_splice_write() does not use xfs_rw_ilock() because",
        "// Line_Reference 347:  * generic_file_splice_write() takes the i_mutex itself. This, in theory,",
        "// Line_Reference 348:  * couuld cause lock inversions between the aio_write path and the splice path",
        "// Line_Reference 349:  * if someone is doing concurrent splice(2) based writes and write(2) based",
        "// Line_Reference 350:  * writes to the same inode. The only real way to fix this is to re-implement",
        "// Line_Reference 351:  * the generic code here with correct locking orders.",
        "// Line_Reference 352:  */",
        "// Line_Reference 353: STATIC ssize_t",
        "// Line_Reference 354: xfs_file_splice_write(",
        "// Line_Reference 355: \tstruct pipe_inode_info\t*pipe,",
        "// Line_Reference 356: \tstruct file\t\t*outfilp,",
        "// Line_Reference 357: \tloff_t\t\t\t*ppos,",
        "// Line_Reference 358: \tsize_t\t\t\tcount,",
        "// Line_Reference 359: \tunsigned int\t\tflags)",
        "// Line_Reference 360: {",
        "// Line_Reference 361: \tstruct inode\t\t*inode = outfilp->f_mapping->host;",
        "// Line_Reference 362: \tstruct xfs_inode\t*ip = XFS_I(inode);",
        "// Line_Reference 363: \tint\t\t\tioflags = 0;",
        "// Line_Reference 364: \tssize_t\t\t\tret;",
        "// Line_Reference 365: ",
        "// Line_Reference 366: \tXFS_STATS_INC(xs_write_calls);",
        "// Line_Reference 367: ",
        "// Line_Reference 368: \tif (outfilp->f_mode & FMODE_NOCMTIME)",
        "// Line_Reference 369: \t\tioflags |= IO_INVIS;",
        "// Line_Reference 370: ",
        "// Line_Reference 371: \tif (XFS_FORCED_SHUTDOWN(ip->i_mount))",
        "// Line_Reference 372: \t\treturn -EIO;",
        "// Line_Reference 373: ",
        "// Line_Reference 374: \txfs_ilock(ip, XFS_IOLOCK_EXCL);",
        "// Line_Reference 375: ",
        "// Line_Reference 376: \ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);",
        "// Line_Reference 377: ",
        "// Line_Reference 378: \tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);",
        "// Line_Reference 379: \tif (ret > 0)",
        "// Line_Reference 380: \t\tXFS_STATS_ADD(xs_write_bytes, ret);",
        "// Line_Reference 381: ",
        "// Line_Reference 382: \txfs_iunlock(ip, XFS_IOLOCK_EXCL);",
        "// Line_Reference 383: \treturn ret;",
        "// Line_Reference 384: }",
        "// Line_Reference 385: ",
        "// Line_Reference 1445: \t.splice_write\t= xfs_file_splice_write,"
    ]
}
