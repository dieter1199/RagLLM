{
    "cve_id": "CVE-2017-16996",
    "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging register truncation mishandling.",
    "cve_publish_date": "2017-12-27",
    "cwe_id": "CWE-119",
    "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "cwe_description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "commit_message": "bpf: fix incorrect tracking of register size truncation\n\nProperly handle register truncation to a smaller size.\n\nThe old code first mirrors the clearing of the high 32 bits in the bitwise\ntristate representation, which is correct. But then, it computes the new\narithmetic bounds as the intersection between the old arithmetic bounds and\nthe bounds resulting from the bitwise tristate representation. Therefore,\nwhen coerce_reg_to_32() is called on a number with bounds\n[0xffff'fff8, 0x1'0000'0007], the verifier computes\n[0xffff'fff8, 0xffff'ffff] as bounds of the truncated number.\nThis is incorrect: The truncated number could also be in the range [0, 7],\nand no meaningful arithmetic bounds can be computed in that case apart from\nthe obvious [0, 0xffff'ffff].\n\nStarting with v4.14, this is exploitable by unprivileged users as long as\nthe unprivileged_bpf_disabled sysctl isn't set.\n\nDebian assigned CVE-2017-16996 for this issue.\n\nv2:\n - flip the mask during arithmetic bounds calculation (Ben Hutchings)\nv3:\n - add CVE number (Ben Hutchings)\n\nFixes: b03c9f9fdc37 (\"bpf/verifier: track signed and unsigned min/max values\")\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Edward Cree <ecree@solarflare.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "verifier.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "27",
    "number_of_lines_deleted_vulnerable_to_cve": "17",
    "vulnerable_lines": [
        "// Line_Reference 1203: \t\tregs[value_regno].var_off =",
        "// Line_Reference 1204: \t\t\ttnum_cast(regs[value_regno].var_off, size);",
        "// Line_Reference 1205: \t\t__update_reg_bounds(&regs[value_regno]);",
        "// Line_Reference 1775: static void coerce_reg_to_32(struct bpf_reg_state *reg)",
        "// Line_Reference 1776: {",
        "// Line_Reference 1777: \t/* clear high 32 bits */",
        "// Line_Reference 1778: \treg->var_off = tnum_cast(reg->var_off, 4);",
        "// Line_Reference 1779: \t/* Update bounds */",
        "// Line_Reference 1780: \t__update_reg_bounds(reg);",
        "// Line_Reference 1781: }",
        "// Line_Reference 1782: ",
        "// Line_Reference 2020: \t\tcoerce_reg_to_32(dst_reg);",
        "// Line_Reference 2021: \t\tcoerce_reg_to_32(&src_reg);",
        "// Line_Reference 2401: \t\t\t\t/* high 32 bits are known zero. */",
        "// Line_Reference 2402: \t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(",
        "// Line_Reference 2403: \t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);",
        "// Line_Reference 2404: \t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);"
    ]
}
