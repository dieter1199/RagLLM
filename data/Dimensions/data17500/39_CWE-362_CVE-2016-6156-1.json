{
    "cve_id": "CVE-2016-6156",
    "cve_description": "Race condition in the ec_device_ioctl_xcmd function in drivers/platform/chrome/cros_ec_dev.c in the Linux kernel before 4.7 allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a \"double fetch\" vulnerability.",
    "cve_publish_date": "2016-08-06",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "platform/chrome: cros_ec_dev - double fetch bug in ioctl\n\nWe verify \"u_cmd.outsize\" and \"u_cmd.insize\" but we need to make sure\nthat those values have not changed between the two copy_from_user()\ncalls.  Otherwise it could lead to a buffer overflow.\n\nAdditionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.\nWe should use the new smaller value so we don't copy too much data to\nthe user.\n\nReported-by: Pengfei Wang <wpengfeinudt@gmail.com>\nFixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Kees Cook <keescook@chromium.org>\nTested-by: Gwendal Grignou <gwendal@chromium.org>\nCc: <stable@vger.kernel.org> # v4.2+\nSigned-off-by: Olof Johansson <olof@lixom.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "cros_ec_dev.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "7",
    "number_of_lines_deleted_vulnerable_to_cve": "1",
    "vulnerable_lines": [
        "// Line_Reference 160: \tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))"
    ]
}
