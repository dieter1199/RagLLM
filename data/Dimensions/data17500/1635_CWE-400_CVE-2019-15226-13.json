{
    "cve_id": "CVE-2019-15226",
    "cve_description": "Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.",
    "cve_publish_date": "2019-10-09",
    "cwe_id": "CWE-400",
    "cwe_name": "Uncontrolled Resource Consumption",
    "cwe_description": "The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",
    "commit_message": "Track byteSize of HeaderMap internally.\n\nIntroduces a cached byte size updated internally in HeaderMap. The value\nis stored as an optional, and is cleared whenever a non-const pointer or\nreference to a HeaderEntry is accessed. The cached value can be set with\nrefreshByteSize() which performs an iteration over the HeaderMap to sum\nthe size of each key and value in the HeaderMap.\n\nSigned-off-by: Asra Ali <asraa@google.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "http_integration.h",
    "code_language": "C++",
    "number_of_lines_added_for_mitigation": "14",
    "number_of_lines_deleted_vulnerable_to_cve": "7",
    "vulnerable_lines": [
        "// Line_Reference 125:   IntegrationStreamDecoderPtr",
        "// Line_Reference 126:   sendRequestAndWaitForResponse(const Http::TestHeaderMapImpl& request_headers,",
        "// Line_Reference 127:                                 uint32_t request_body_size,",
        "// Line_Reference 128:                                 const Http::TestHeaderMapImpl& response_headers,",
        "// Line_Reference 129:                                 uint32_t response_body_size, int upstream_index = 0);",
        "// Line_Reference 135:   uint64_t waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices);",
        "// Line_Reference 136:   void waitForNextUpstreamRequest(uint64_t upstream_index = 0);"
    ]
}
