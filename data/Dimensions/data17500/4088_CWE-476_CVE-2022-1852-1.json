{
    "cve_id": "CVE-2022-1852",
    "cve_description": "A NULL pointer dereference flaw was found in the Linux kernelâ€™s KVM module, which can lead to a denial of service in the x86_emulate_insn in arch/x86/kvm/emulate.c. This flaw occurs while executing an illegal instruction in guest in the Intel CPU.",
    "cve_publish_date": "2022-06-30",
    "cwe_id": "CWE-476",
    "cwe_name": "NULL Pointer Dereference",
    "cwe_description": "The product dereferences a pointer that it expects to be valid but is NULL.",
    "commit_message": "KVM: x86: avoid calling x86 emulator without a decoded instruction\n\nWhenever x86_decode_emulated_instruction() detects a breakpoint, it\nreturns the value that kvm_vcpu_check_breakpoint() writes into its\npass-by-reference second argument.  Unfortunately this is completely\nbogus because the expected outcome of x86_decode_emulated_instruction\nis an EMULATION_* value.\n\nThen, if kvm_vcpu_check_breakpoint() does \"*r = 0\" (corresponding to\na KVM_EXIT_DEBUG userspace exit), it is misunderstood as EMULATION_OK\nand x86_emulate_instruction() is called without having decoded the\ninstruction.  This causes various havoc from running with a stale\nemulation context.\n\nThe fix is to move the call to kvm_vcpu_check_breakpoint() where it was\nbefore commit 4aa2691dcbd3 (\"KVM: x86: Factor out x86 instruction\nemulation with decoding\") introduced x86_decode_emulated_instruction().\nThe other caller of the function does not need breakpoint checks,\nbecause it is invoked as part of a vmexit and the processor has already\nchecked those before executing the instruction that #GP'd.\n\nThis fixes CVE-2022-1852.\n\nReported-by: Qiuhao Li <qiuhao@sysec.org>\nReported-by: Gaoning Pan <pgn@zju.edu.cn>\nReported-by: Yongkang Jia <kangel@zju.edu.cn>\nFixes: 4aa2691dcbd3 (\"KVM: x86: Factor out x86 instruction emulation with decoding\")\nCc: stable@vger.kernel.org\nSigned-off-by: Sean Christopherson <seanjc@google.com>\nMessage-Id: <20220311032801.3467418-2-seanjc@google.com>\n[Rewrote commit message according to Qiuhao's report, since a patch\n already existed to fix the bug. - Paolo]\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "x86.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "19",
    "number_of_lines_deleted_vulnerable_to_cve": "12",
    "vulnerable_lines": [
        "// Line_Reference 8299: static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)",
        "// Line_Reference 8368:  * Decode to be emulated instruction. Return EMULATION_OK if success.",
        "// Line_Reference 8373: \tint r = EMULATION_OK;",
        "// Line_Reference 8378: \t/*",
        "// Line_Reference 8379: \t * We will reenter on the same instruction since we do not set",
        "// Line_Reference 8380: \t * complete_userspace_io. This does not handle watchpoints yet,",
        "// Line_Reference 8381: \t * those would be handled in the emulate_ops.",
        "// Line_Reference 8382: \t */",
        "// Line_Reference 8383: \tif (!(emulation_type & EMULTYPE_SKIP) &&",
        "// Line_Reference 8384: \t    kvm_vcpu_check_breakpoint(vcpu, &r))",
        "// Line_Reference 8385: \t\treturn r;",
        "// Line_Reference 8386: "
    ]
}
