{
    "cve_id": "CVE-2022-35928",
    "cve_description": "AES Crypt is a file encryption software for multiple platforms. AES Crypt for Linux built using the source on GitHub and having the version number 3.11 has a vulnerability with respect to reading user-provided passwords and confirmations via command-line prompts. Passwords lengths were not checked before being read. This vulnerability may lead to buffer overruns. This does _not_ affect source code found on aescrypt.com, nor is the vulnerability present when providing a password or a key via the `-p` or `-k` command-line options. The problem was fixed via in commit 68761851b and will be included in release 3.16. Users are advised to upgrade. Users unable to upgrade should us the `-p` or `-k` options to provide a password or key.",
    "cve_publish_date": "2022-08-03",
    "cwe_id": "CWE-1284",
    "cwe_name": "Improper Validation of Specified Quantity in Input",
    "cwe_description": "The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.",
    "commit_message": "Fixed security issue with passwords entered via a prompt",
    "type_of_change": "Modification",
    "filename_of_changes": "aescrypt.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "109",
    "number_of_lines_deleted_vulnerable_to_cve": "86",
    "vulnerable_lines": [
        "// Line_Reference 3:  *  Copyright (C) 2007-2017",
        "// Line_Reference 87:     for (i=0; i<48; i+=16)",
        "// Line_Reference 91:         for(j=0; j<256; j++)",
        "// Line_Reference 103:         memcpy(iv_key+i, digest, 16);",
        "// Line_Reference 193:     sha256_starts(  &sha_ctx);",
        "// Line_Reference 195:     sha256_update(  &sha_ctx, (unsigned char *)&time, sizeof(current_time));",
        "// Line_Reference 197:     sha256_update(  &sha_ctx, (unsigned char *)&process_id, sizeof(process_id));",
        "// Line_Reference 207:         sha256_update(  &sha_ctx,",
        "// Line_Reference 208:                         buffer,",
        "// Line_Reference 209:                         32);",
        "// Line_Reference 212:     sha256_finish(  &sha_ctx, digest);",
        "// Line_Reference 225: ",
        "// Line_Reference 229:     for(i=0; i<8192; i++)",
        "// Line_Reference 231:         sha256_starts(  &sha_ctx);",
        "// Line_Reference 232:         sha256_update(  &sha_ctx, digest, 32);",
        "// Line_Reference 233:         sha256_update(  &sha_ctx,",
        "// Line_Reference 234:                         passwd,",
        "// Line_Reference 235:                         (unsigned long)passlen);",
        "// Line_Reference 236:         sha256_finish(  &sha_ctx,",
        "// Line_Reference 237:                         digest);",
        "// Line_Reference 251:     for(i=0; i<32; i++)",
        "// Line_Reference 264:     for(i=0; i<48; i+=16)",
        "// Line_Reference 276:         for(j=0; j<16; j++)",
        "// Line_Reference 283: ",
        "// Line_Reference 293: ",
        "// Line_Reference 312:      * key to now encrypt the datafile.  Also, reset the HMAC",
        "// Line_Reference 328:     for(i=0; i<32; i++)",
        "// Line_Reference 349:         for(i=0; i<16; i++)",
        "// Line_Reference 356: ",
        "// Line_Reference 366: ",
        "// Line_Reference 430: ",
        "// Line_Reference 437:             fprintf(stderr, \"Error: Input file is too short.\\n\");",
        "// Line_Reference 449:         fprintf(stderr, \"Error: Bad file header (not aescrypt file or is corrupted? [%x, %x, %x])\\n\", aeshdr.aes[0], aeshdr.aes[1], aeshdr.aes[2]);",
        "// Line_Reference 478:                     fprintf(stderr, \"Error: Input file is too short.\\n\");",
        "// Line_Reference 494:                         fprintf(stderr, \"Error: Input file is too short.\\n\");",
        "// Line_Reference 511:             fprintf(stderr, \"Error: Input file is too short.\\n\");",
        "// Line_Reference 523:     for(i=0; i<8192; i++)",
        "// Line_Reference 525:         sha256_starts(  &sha_ctx);",
        "// Line_Reference 526:         sha256_update(  &sha_ctx, digest, 32);",
        "// Line_Reference 527:         sha256_update(  &sha_ctx,",
        "// Line_Reference 528:                         passwd,",
        "// Line_Reference 529:                         passlen);",
        "// Line_Reference 530:         sha256_finish(  &sha_ctx,",
        "// Line_Reference 531:                         digest);",
        "// Line_Reference 544:     for(i=0; i<32; i++)",
        "// Line_Reference 558:         for(i=0; i<48; i+=16)",
        "// Line_Reference 564:                     fprintf(stderr, \"Error: Input file is too short.\\n\");",
        "// Line_Reference 582:             for(j=0; j<16; j++)",
        "// Line_Reference 584:                 iv_key[i+j] = (buffer[j] ^ IV[j]);",
        "// Line_Reference 602:                 fprintf(stderr, \"Error: Input file is too short.\\n\");",
        "// Line_Reference 613:             fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");",
        "// Line_Reference 635:         for(i=0; i<32; i++)",
        "// Line_Reference 637:             ipad[i] ^= iv_key[i+16];",
        "// Line_Reference 638:             opad[i] ^= iv_key[i+16];",
        "// Line_Reference 647: ",
        "// Line_Reference 666:              * greater files ( file size modulo + HMAC)",
        "// Line_Reference 671:                 fprintf(stderr, \"Error: Input file is corrupt (1:%u).\\n\",",
        "// Line_Reference 696:                     fprintf(stderr, \"Error: Input file is corrupt (2).\\n\");",
        "// Line_Reference 727:                     fprintf(stderr, \"Error: Input file is corrupt (3:%u).\\n\",",
        "// Line_Reference 777:             for(i=0; i<16; i++)",
        "// Line_Reference 798: ",
        "// Line_Reference 847:             fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");",
        "// Line_Reference 851:             fprintf(stderr, \"Error: Message has been altered and should not be trusted\\n\");",
        "// Line_Reference 888:     fprintf(stderr, \"\\nusage: %s {-e|-d} [ { -p <password> | -k <keyfile> } ] { [-o <output filename>] <file> | <file> [<file> ...] }\\n\\n\",",
        "// Line_Reference 949: ",
        "// Line_Reference 1013:                     passlen = passwd_to_utf16(  (unsigned char*) optarg,",
        "// Line_Reference 1014:                                                 strlen((char *)optarg),",
        "// Line_Reference 1015:                                                 MAX_PASSWD_LEN,",
        "// Line_Reference 1016:                                                 pass);",
        "// Line_Reference 1046: ",
        "// Line_Reference 1071:                 fprintf(stderr, \"Error: No password supplied.\\n\");",
        "// Line_Reference 1081:                 fprintf(stderr, \"Error in read_password: %s.\\n\",",
        "// Line_Reference 1086:                 fprintf(stderr, \"Error: Passwords don't match.\\n\");",
        "// Line_Reference 1091:         passlen = passwd_to_utf16(  pass,",
        "// Line_Reference 1092:                                     strlen((char*)pass),",
        "// Line_Reference 1093:                                     MAX_PASSWD_LEN,",
        "// Line_Reference 1094:                                     pass);",
        "// Line_Reference 1095: ",
        "// Line_Reference 1112:         fprintf(stderr, \"Error: A single output file may not be specified with multiple input files.\\n\");",
        "// Line_Reference 1132:                 fprintf(stderr, \"Error: STDIN may not be specified with multiple input files.\\n\");",
        "// Line_Reference 1158: ",
        "// Line_Reference 1178: ",
        "// Line_Reference 1202: ",
        "// Line_Reference 1209: ",
        "// Line_Reference 1236:         /* Reset input/output file names and desriptors */",
        "// Line_Reference 1244: "
    ]
}
