from .errors import PropertyError
def get_type_string(self) -> str:
if self.required:
def __post_init__(self) -> None:
super().__post_init__()
if self.default is not None:
self.default = f'"{self.default}"'
_type_string: ClassVar[str] = "datetime"
imports.update({"from datetime import datetime", "from typing import cast"})
_type_string: ClassVar[str] = "date"
imports.update({"from datetime import date", "from typing import cast"})
def __post_init__(self) -> None:
super().__post_init__()
if self.default is not None:
self.default = f"field(default_factory=lambda: cast({self.get_type_string()}, {self.default}))"
def get_type_string(self) -> str:
if self.required:
def get_type_string(self) -> str:
if self.required:
super().__post_init__()
inverse_values = {v: k for k, v in self.values.items()}
if self.default is not None:
self.default = f"{self.reference.class_name}.{inverse_values[self.default]}"
def get_type_string(self) -> str:
if self.required:
output[key] = value
def get_type_string(self) -> str:
if self.required:
def __post_init__(self) -> None:
super().__post_init__()
if self.default is not None:
self.default = f"field(default_factory=lambda: cast({self.get_type_string()}, {self.default}))"
def property_from_data(
