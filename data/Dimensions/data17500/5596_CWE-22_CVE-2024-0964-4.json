{
    "cve_id": "CVE-2024-0964",
    "cve_description": "A local file include could be remotely triggered in Gradio due to a vulnerable user-supplied JSON value in an API request.",
    "cve_publish_date": "2024-02-05",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "Fix api event drops (#6556)\n\n* changes\r\n\r\n* changes\r\n\r\n* add changeset\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changs\r\n\r\n* chagnes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes~git push\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* change\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n* changes\r\n\r\n---------\r\n\r\nCo-authored-by: gradio-pr-bot <gradio-pr-bot@users.noreply.github.com>\r\nCo-authored-by: Ubuntu <ubuntu@ip-172-31-25-241.us-west-2.compute.internal>\r\nCo-authored-by: Abubakar Abid <abubakar@huggingface.co>",
    "type_of_change": "Modification",
    "filename_of_changes": "queueing.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "69",
    "number_of_lines_deleted_vulnerable_to_cve": "76",
    "vulnerable_lines": [
        "// Line_Reference 26: from gradio.utils import run_coro_in_background, safe_get_lock, set_task_name",
        "// Line_Reference 40:         self.message_queue = ThreadQueue()",
        "// Line_Reference 51:     def send_message(",
        "// Line_Reference 52:         self,",
        "// Line_Reference 53:         message_type: str,",
        "// Line_Reference 54:         data: dict | None = None,",
        "// Line_Reference 55:         final: bool = False,",
        "// Line_Reference 56:     ):",
        "// Line_Reference 57:         data = {} if data is None else data",
        "// Line_Reference 58:         self.message_queue.put_nowait({\"msg\": message_type, **data})",
        "// Line_Reference 59:         if final:",
        "// Line_Reference 60:             self.message_queue.put_nowait(None)",
        "// Line_Reference 61: ",
        "// Line_Reference 62:     async def get_data(self, timeout=5) -> bool:",
        "// Line_Reference 63:         self.send_message(\"send_data\", {\"event_id\": self._id})",
        "// Line_Reference 64:         sleep_interval = 0.05",
        "// Line_Reference 65:         wait_time = 0",
        "// Line_Reference 66:         while wait_time < timeout and self.alive:",
        "// Line_Reference 67:             if self.data is not None:",
        "// Line_Reference 68:                 break",
        "// Line_Reference 69:             await asyncio.sleep(sleep_interval)",
        "// Line_Reference 70:             wait_time += sleep_interval",
        "// Line_Reference 71:         return self.data is not None",
        "// Line_Reference 72: ",
        "// Line_Reference 155:     def attach_data(self, body: PredictBody):",
        "// Line_Reference 156:         event_id = body.event_id",
        "// Line_Reference 157:         if event_id in self.awaiting_data_events:",
        "// Line_Reference 158:             event = self.awaiting_data_events[event_id]",
        "// Line_Reference 159:             event.data = body",
        "// Line_Reference 160:         else:",
        "// Line_Reference 161:             raise ValueError(\"Event not found\", event_id)",
        "// Line_Reference 279:                     event.send_message(\"progress\", event.progress.model_dump())",
        "// Line_Reference 323:                 event.send_message(\"log\", log_message.model_dump())",
        "// Line_Reference 324: ",
        "// Line_Reference 325:     def push(self, event: Event) -> int | None:",
        "// Line_Reference 326:         \"\"\"",
        "// Line_Reference 327:         Add event to queue, or return None if Queue is full",
        "// Line_Reference 328:         Parameters:",
        "// Line_Reference 329:             event: Event to add to Queue",
        "// Line_Reference 330:         Returns:",
        "// Line_Reference 331:             rank of submitted Event",
        "// Line_Reference 332:         \"\"\"",
        "// Line_Reference 333:         queue_len = len(self.event_queue)",
        "// Line_Reference 334:         if self.max_size is not None and queue_len >= self.max_size:",
        "// Line_Reference 335:             return None",
        "// Line_Reference 336:         self.event_queue.append(event)",
        "// Line_Reference 337:         return queue_len",
        "// Line_Reference 338: ",
        "// Line_Reference 339:     async def clean_event(self, event: Event | str) -> None:",
        "// Line_Reference 340:         if isinstance(event, str):",
        "// Line_Reference 341:             for job_set in self.active_jobs:",
        "// Line_Reference 342:                 if job_set:",
        "// Line_Reference 343:                     for job in job_set:",
        "// Line_Reference 344:                         if job._id == event:",
        "// Line_Reference 345:                             event = job",
        "// Line_Reference 346:                             break",
        "// Line_Reference 347:         if isinstance(event, str):",
        "// Line_Reference 348:             raise ValueError(\"Event not found\", event)",
        "// Line_Reference 349:         event.alive = False",
        "// Line_Reference 350:         if event in self.event_queue:",
        "// Line_Reference 394:         event.send_message(\"estimation\", estimation.model_dump())",
        "// Line_Reference 488:                 if not event.data:",
        "// Line_Reference 489:                     self.awaiting_data_events[event._id] = event",
        "// Line_Reference 490:                     client_awake = await event.get_data()",
        "// Line_Reference 491:                     del self.awaiting_data_events[event._id]",
        "// Line_Reference 492:                     if not client_awake:",
        "// Line_Reference 493:                         await self.clean_event(event)",
        "// Line_Reference 494:                         continue",
        "// Line_Reference 495:                 event.send_message(\"process_starts\")",
        "// Line_Reference 508:                     event.send_message(",
        "// Line_Reference 518:                         final=True,",
        "// Line_Reference 527:                         event.send_message(",
        "// Line_Reference 548:                     event.send_message(",
        "// Line_Reference 557:                         final=True,",
        "// Line_Reference 564:                     event.send_message(",
        "// Line_Reference 570:                         final=True,"
    ]
}
