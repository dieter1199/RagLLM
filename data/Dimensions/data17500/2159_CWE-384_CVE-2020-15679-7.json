{
    "cve_id": "CVE-2020-15679",
    "cve_description": "An OAuth session fixation vulnerability existed in the VPN login flow, where an attacker could craft a custom login URL, convince a VPN user to login via that URL, and obtain authenticated access as that user. This issue is limited to cases where attacker and victim are sharing the same source IP and could allow the ability to view session states and disconnect VPN sessions. This vulnerability affects Mozilla VPN iOS 1.0.7 < (929), Mozilla VPN Windows < 1.2.2, and Mozilla VPN Android 1.1.0 < (1360).",
    "cve_publish_date": "2022-12-22",
    "cwe_id": "CWE-384",
    "cwe_name": "Session Fixation",
    "cwe_description": "Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",
    "commit_message": "New non-polling authentication flow.\n\n- Fixes intermittent hanging during auth\n- Implements PKCE",
    "type_of_change": "Modification",
    "filename_of_changes": "Main.cs",
    "code_language": "C#",
    "number_of_lines_added_for_mitigation": "52",
    "number_of_lines_deleted_vulnerable_to_cve": "15",
    "vulnerable_lines": [
        "// Line_Reference 20:     internal class Entry : System.Windows.Application",
        "// Line_Reference 22:         /// <summary>",
        "// Line_Reference 23:         /// Global value that is used to indicate if there is already an instance of the application running.",
        "// Line_Reference 24:         /// </summary>",
        "// Line_Reference 25:         private static readonly Mutex RunOnceMutex = new Mutex(false, string.Concat(@\"Local\\\", ProductConstants.GUID));",
        "// Line_Reference 26: ",
        "// Line_Reference 35:             if (args.Count() == 1)",
        "// Line_Reference 62:             if (!RunOnceMutex.WaitOne(TimeSpan.Zero, true))",
        "// Line_Reference 64:                 // Already running, attempt to send a \"show\" command to the already running process before exiting",
        "// Line_Reference 65:                 var runningWindow = User32.FindWindow(ProductConstants.TrayWindowClassName, string.Empty);",
        "// Line_Reference 66:                 if (runningWindow != IntPtr.Zero)",
        "// Line_Reference 68:                     User32.SendMessage(runningWindow, User32.WmShow, IntPtr.Zero, string.Empty);",
        "// Line_Reference 70: ",
        "// Line_Reference 71:                 Environment.Exit(1);",
        "// Line_Reference 84:                 Manager.Initialize();"
    ]
}
