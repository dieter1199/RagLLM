{
    "cve_id": "CVE-2011-3209",
    "cve_description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
    "cve_publish_date": "2012-10-03",
    "cwe_id": "CWE-189",
    "cwe_name": "Numeric Errors",
    "cwe_description": "Weaknesses in this category are related to improper calculation or conversion of numbers.",
    "commit_message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "mmtimer.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "11",
    "number_of_lines_deleted_vulnerable_to_cve": "13",
    "vulnerable_lines": [
        "// Line_Reference 475: \ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)",
        "// Line_Reference 476: \t\t\t+ sgi_clock_offset.tv_sec;",
        "// Line_Reference 484: \tu64 rem;",
        "// Line_Reference 488: \tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);",
        "// Line_Reference 647: #define timespec_to_ns(x) ((x).tv_nsec + (x).tv_sec * NSEC_PER_SEC)",
        "// Line_Reference 648: #define ns_to_timespec(ts, nsec) (ts).tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &(ts).tv_nsec)",
        "// Line_Reference 649: ",
        "// Line_Reference 662: \tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);",
        "// Line_Reference 663: \tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);",
        "// Line_Reference 664: \treturn;",
        "// Line_Reference 682: \twhen = timespec_to_ns(new_setting->it_value);",
        "// Line_Reference 683: \tperiod = timespec_to_ns(new_setting->it_interval);",
        "// Line_Reference 698: \t\tnow = timespec_to_ns(n);"
    ]
}
