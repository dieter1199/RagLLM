{
    "cve_id": "CVE-2012-3552",
    "cve_description": "Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.",
    "cve_publish_date": "2012-10-03",
    "cwe_id": "CWE-362",
    "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "cwe_description": "The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "commit_message": "inet: add RCU protection to inet->opt\n\nWe lack proper synchronization to manipulate inet->opt ip_options\n\nProblem is ip_make_skb() calls ip_setup_cork() and\nip_setup_cork() possibly makes a copy of ipc->opt (struct ip_options),\nwithout any protection against another thread manipulating inet->opt.\n\nAnother thread can change inet->opt pointer and free old one under us.\n\nUse RCU to protect inet->opt (changed to inet->inet_opt).\n\nInstead of handling atomic refcounts, just copy ip_options when\nnecessary, to avoid cache line dirtying.\n\nWe cant insert an rcu_head in struct ip_options since its included in\nskb->cb[], so this patch is large because I had to introduce a new\nip_options_rcu structure.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "type_of_change": "Modification",
    "filename_of_changes": "ip_output.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "21",
    "number_of_lines_deleted_vulnerable_to_cve": "23",
    "vulnerable_lines": [
        "// Line_Reference 143: \t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)",
        "// Line_Reference 150: \tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));",
        "// Line_Reference 166: \tif (opt && opt->optlen) {",
        "// Line_Reference 167: \t\tiph->ihl += opt->optlen>>2;",
        "// Line_Reference 168: \t\tip_options_build(skb, opt, daddr, rt, 0);",
        "// Line_Reference 319: \tstruct ip_options *opt = inet->opt;",
        "// Line_Reference 339: \t\tif(opt && opt->srr)",
        "// Line_Reference 340: \t\t\tdaddr = opt->faddr;",
        "// Line_Reference 360: \tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)",
        "// Line_Reference 364: \tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));",
        "// Line_Reference 378: \tif (opt && opt->optlen) {",
        "// Line_Reference 379: \t\tiph->ihl += opt->optlen >> 2;",
        "// Line_Reference 380: \t\tip_options_build(skb, opt, inet->inet_daddr, rt, 0);",
        "// Line_Reference 1036: \tstruct ip_options *opt;",
        "// Line_Reference 1050: \t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);",
        "// Line_Reference 1454: \tstruct {",
        "// Line_Reference 1455: \t\tstruct ip_options\topt;",
        "// Line_Reference 1456: \t\tchar\t\t\tdata[40];",
        "// Line_Reference 1457: \t} replyopts;",
        "// Line_Reference 1462: \tif (ip_options_echo(&replyopts.opt, skb))",
        "// Line_Reference 1469: \tif (replyopts.opt.optlen) {",
        "// Line_Reference 1472: \t\tif (ipc.opt->srr)",
        "// Line_Reference 1473: \t\t\tdaddr = replyopts.opt.faddr;"
    ]
}
