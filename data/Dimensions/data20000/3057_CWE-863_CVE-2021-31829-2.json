{
    "cve_id": "CVE-2021-31829",
    "cve_description": "kernel/bpf/verifier.c in the Linux kernel through 5.12.1 performs undesirable speculative loads, leading to disclosure of stack content via side-channel attacks, aka CID-801c6058d14a. The specific concern is not protecting the BPF stack area against speculative loads. Also, the BPF stack can contain uninitialized data that might represent sensitive information previously operated on by the kernel.",
    "cve_publish_date": "2021-05-06",
    "cwe_id": "CWE-863",
    "cwe_name": "Incorrect Authorization",
    "cwe_description": "The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",
    "commit_message": "bpf: Fix leakage of uninitialized bpf stack under speculation\n\nThe current implemented mechanisms to mitigate data disclosure under\nspeculation mainly address stack and map value oob access from the\nspeculative domain. However, Piotr discovered that uninitialized BPF\nstack is not protected yet, and thus old data from the kernel stack,\npotentially including addresses of kernel structures, could still be\nextracted from that 512 bytes large window. The BPF stack is special\ncompared to map values since it's not zero initialized for every\nprogram invocation, whereas map values /are/ zero initialized upon\ntheir initial allocation and thus cannot leak any prior data in either\ndomain. In the non-speculative domain, the verifier ensures that every\nstack slot read must have a prior stack slot write by the BPF program\nto avoid such data leaking issue.\n\nHowever, this is not enough: for example, when the pointer arithmetic\noperation moves the stack pointer from the last valid stack offset to\nthe first valid offset, the sanitation logic allows for any intermediate\noffsets during speculative execution, which could then be used to\nextract any restricted stack content via side-channel.\n\nGiven for unprivileged stack pointer arithmetic the use of unknown\nbut bounded scalars is generally forbidden, we can simply turn the\nregister-based arithmetic operation into an immediate-based arithmetic\noperation without the need for masking. This also gives the benefit\nof reducing the needed instructions for the operation. Given after\nthe work in 7fedb63a8307 (\"bpf: Tighten speculative pointer arithmetic\nmask\"), the aux->alu_limit already holds the final immediate value for\nthe offset register with the known scalar. Thus, a simple mov of the\nimmediate to AX register with using AX as the source for the original\ninstruction is sufficient and possible now in this case.\n\nReported-by: Piotr Krysiuk <piotras@gmail.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nTested-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: Piotr Krysiuk <piotras@gmail.com>\nReviewed-by: John Fastabend <john.fastabend@gmail.com>\nAcked-by: Alexei Starovoitov <ast@kernel.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "verifier.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "17",
    "number_of_lines_deleted_vulnerable_to_cve": "10",
    "vulnerable_lines": [
        "// Line_Reference 12374: \t\t\tbool issrc, isneg;",
        "// Line_Reference 12387: \t\t\tif (isneg)",
        "// Line_Reference 12388: \t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);",
        "// Line_Reference 12389: \t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit);",
        "// Line_Reference 12390: \t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);",
        "// Line_Reference 12391: \t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);",
        "// Line_Reference 12392: \t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);",
        "// Line_Reference 12393: \t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);",
        "// Line_Reference 12394: \t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg);",
        "// Line_Reference 12402: \t\t\tif (issrc && isneg)"
    ]
}
