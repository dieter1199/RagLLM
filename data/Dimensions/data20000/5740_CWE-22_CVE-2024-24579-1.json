{
    "cve_id": "CVE-2024-24579",
    "cve_description": "stereoscope is a go library for processing container images and simulating a squash filesystem.  Prior to version 0.0.1, it is possible to craft an OCI tar archive that, when stereoscope attempts to unarchive the contents, will result in writing to paths outside of the unarchive temporary directory. Specifically, use of `github.com/anchore/stereoscope/pkg/file.UntarToDirectory()` function, the  `github.com/anchore/stereoscope/pkg/image/oci.TarballImageProvider` struct, or the higher level `github.com/anchore/stereoscope/pkg/image.Image.Read()` function express this vulnerability. As a workaround, if you are using the OCI archive as input into stereoscope then you can switch to using an OCI layout by unarchiving the tar archive and provide the unarchived directory to stereoscope.",
    "cve_publish_date": "2024-01-31",
    "cwe_id": "CWE-22",
    "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "cwe_description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "commit_message": "fix tar path traversal issue (#214)\n\nSigned-off-by: Alex Goodman <wagoodman@users.noreply.github.com>",
    "type_of_change": "Modification",
    "filename_of_changes": "tarutil.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "51",
    "number_of_lines_deleted_vulnerable_to_cve": "28",
    "vulnerable_lines": [
        "// Line_Reference 127: // UntarToDirectory writes the contents of the given tar reader to the given destination",
        "// Line_Reference 129: \tvisitor := func(entry TarFileEntry) error {",
        "// Line_Reference 130: \t\ttarget := filepath.Join(dst, entry.Header.Name)",
        "// Line_Reference 131: ",
        "// Line_Reference 132: \t\tswitch entry.Header.Typeflag {",
        "// Line_Reference 133: \t\tcase tar.TypeDir:",
        "// Line_Reference 134: \t\t\tif _, err := os.Stat(target); err != nil {",
        "// Line_Reference 135: \t\t\t\tif err := os.MkdirAll(target, 0755); err != nil {",
        "// Line_Reference 136: \t\t\t\t\treturn err",
        "// Line_Reference 137: \t\t\t\t}",
        "// Line_Reference 138: \t\t\t}",
        "// Line_Reference 140: \t\tcase tar.TypeReg:",
        "// Line_Reference 141: \t\t\tf, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))",
        "// Line_Reference 142: \t\t\tif err != nil {",
        "// Line_Reference 146: \t\t\t// limit the reader on each file read to prevent decompression bomb attacks",
        "// Line_Reference 147: \t\t\tnumBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))",
        "// Line_Reference 148: \t\t\tif numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {",
        "// Line_Reference 149: \t\t\t\treturn fmt.Errorf(\"zip read limit hit (potential decompression bomb attack)\")",
        "// Line_Reference 150: \t\t\t}",
        "// Line_Reference 151: \t\t\tif err != nil {",
        "// Line_Reference 152: \t\t\t\treturn fmt.Errorf(\"unable to copy file: %w\", err)",
        "// Line_Reference 153: \t\t\t}",
        "// Line_Reference 155: \t\t\tif err = f.Close(); err != nil {",
        "// Line_Reference 156: \t\t\t\tlog.Errorf(\"failed to close file during untar of path=%q: %w\", f.Name(), err)",
        "// Line_Reference 157: \t\t\t}",
        "// Line_Reference 159: \t\treturn nil",
        "// Line_Reference 160: \t}",
        "// Line_Reference 162: \treturn IterateTar(reader, visitor)"
    ]
}
