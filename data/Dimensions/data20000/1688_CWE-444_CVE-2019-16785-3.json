{
    "cve_id": "CVE-2019-16785",
    "cve_description": "Waitress through version 1.3.1 implemented a \"MAY\" part of the RFC7230 which states: \"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.\" Unfortunately if a front-end server does not parse header fields with an LF the same way as it does those with a CRLF it can lead to the front-end and the back-end server parsing the same HTTP message in two different ways. This can lead to a potential for HTTP request smuggling/splitting whereby Waitress may see two requests while the front-end server only sees a single HTTP message. This issue is fixed in Waitress 1.4.0.",
    "cve_publish_date": "2019-12-20",
    "cwe_id": "CWE-444",
    "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')",
    "cwe_description": "The product acts as an intermediary HTTP agent\n         (such as a proxy or firewall) in the data flow between two\n         entities such as a client and server, but it does not\n         interpret malformed HTTP requests or responses in ways that\n         are consistent with how the messages will be processed by\n         those entities that are at the ultimate destination.",
    "commit_message": "Remove support for non CRLF line endings\n\nhttps://tools.ietf.org/html/rfc7230#section-3.5 says that servers MAY\nimplement their parsers to use only the LF as a delimeter between lines,\nhowever if the frontend server does NOT do the same you can potentially\nallow a single HTTP request to be treated differently by the two\nservers.\n\nThis issue can be used to cause HTTP request smuggling or HTTP desync\nwhich may lead to vulnerabilities.\n\nTo increase robustness Waitress will no longer allow bare LF for HTTP\nmessages/headers and chunked encoding and instead now enforces that the\nline endings at CRLF.",
    "type_of_change": "Modification",
    "filename_of_changes": "test_channel.py",
    "code_language": "Python",
    "number_of_lines_added_for_mitigation": "8",
    "number_of_lines_deleted_vulnerable_to_cve": "22",
    "vulnerable_lines": [
        "// Line_Reference 426:         inst.received(b\"GET / HTTP/1.1\\n\\n\")",
        "// Line_Reference 441:         inst.received(b\"GET / HTTP/1.1\\n\\n\")",
        "// Line_Reference 452:         inst.received(b\"GET / HTTP/1.1\\n\\n\")",
        "// Line_Reference 463:         inst.received(b\"GET / HTTP/1.1\\n\\n\")",
        "// Line_Reference 476:         inst.received(b\"GET / HTTP/1.1\\n\\n\" + b\"a\" * 50000)",
        "// Line_Reference 480:     def test_received_preq_completed_n_lt_data(self):",
        "// Line_Reference 481:         inst, sock, map = self._makeOneWithMap()",
        "// Line_Reference 482:         inst.server = DummyServer()",
        "// Line_Reference 483:         preq = DummyParser()",
        "// Line_Reference 484:         inst.request = preq",
        "// Line_Reference 485:         preq.completed = True",
        "// Line_Reference 486:         preq.empty = False",
        "// Line_Reference 487:         line = b\"GET / HTTP/1.1\\n\\n\"",
        "// Line_Reference 488:         preq.retval = len(line)",
        "// Line_Reference 489:         inst.received(line + line)",
        "// Line_Reference 490:         self.assertEqual(inst.request, None)",
        "// Line_Reference 491:         self.assertEqual(len(inst.requests), 2)",
        "// Line_Reference 492:         self.assertEqual(len(inst.server.tasks), 1)",
        "// Line_Reference 493: ",
        "// Line_Reference 504:         inst.received(b\"GET / HTTP/1.1\\n\\n\")",
        "// Line_Reference 518:         inst.received(b\"GET / HTTP/1.1\\n\\n\")",
        "// Line_Reference 535:         inst.received(b\"GET / HTTP/1.1\\n\\n\")"
    ]
}
