{
    "cve_id": "CVE-2011-4621",
    "cve_description": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
    "cve_publish_date": "2012-05-17",
    "cwe_id": "CWE-835",
    "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
    "cwe_description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
    "commit_message": "Sched: fix skip_clock_update optimization\n\nidle_balance() drops/retakes rq->lock, leaving the previous task\nvulnerable to set_tsk_need_resched().  Clear it after we return\nfrom balancing instead, and in setup_thread_stack() as well, so\nno successfully descheduled or never scheduled task has it set.\n\nNeed resched confused the skip_clock_update logic, which assumes\nthat the next call to update_rq_clock() will come nearly immediately\nafter being set.  Make the optimization robust against the waking\na sleeper before it sucessfully deschedules case by checking that\nthe current task has not been dequeued before setting the flag,\nsince it is that useless clock update we're trying to save, and\nclear unconditionally in schedule() proper instead of conditionally\nin put_prev_task().\n\nSigned-off-by: Mike Galbraith <efault@gmx.de>\nReported-by: Bjoern B. Brandenburg <bbb.lst@gmail.com>\nTested-by: Yong Zhang <yong.zhang0@gmail.com>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: stable@kernel.org\nLKML-Reference: <1291802742.1417.9.camel@marge.simson.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>",
    "type_of_change": "Modification",
    "filename_of_changes": "sched.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "14",
    "number_of_lines_deleted_vulnerable_to_cve": "12",
    "vulnerable_lines": [
        "// Line_Reference 644: \tif (!rq->skip_clock_update) {",
        "// Line_Reference 645: \t\tint cpu = cpu_of(rq);",
        "// Line_Reference 646: \t\tu64 irq_time;",
        "// Line_Reference 648: \t\trq->clock = sched_clock_cpu(cpu);",
        "// Line_Reference 649: \t\tirq_time = irq_time_cpu(cpu);",
        "// Line_Reference 650: \t\tif (rq->clock - irq_time > rq->clock_task)",
        "// Line_Reference 651: \t\t\trq->clock_task = rq->clock - irq_time;",
        "// Line_Reference 653: \t\tsched_irq_time_avg_update(rq, irq_time);",
        "// Line_Reference 654: \t}",
        "// Line_Reference 2132: \tif (test_tsk_need_resched(rq->curr))",
        "// Line_Reference 3976: \trq->skip_clock_update = 0;",
        "// Line_Reference 4034: \tclear_tsk_need_resched(prev);"
    ]
}
