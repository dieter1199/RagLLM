{
    "cve_id": "CVE-2024-27102",
    "cve_description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-13",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "server(filesystem): rebuild everything imaginable\n\nThis wonderfully large commit replaces basically everything under the\n`server/filesystem` package, re-implementing essentially everything.\n\nThis is related to\nhttps://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9\n\nIf any vulnerabilities related to symlinks persist after this commit, I\nwill be very upset.\n\nSigned-off-by: Matthew Penner <me@matthewp.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "disk_space.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "40",
    "number_of_lines_deleted_vulnerable_to_cve": "74",
    "vulnerable_lines": [
        "// Line_Reference 6: \t\"syscall\"",
        "// Line_Reference 11: \t\"github.com/karrick/godirwalk\"",
        "// Line_Reference 23: // Update the last time that a disk space lookup was performed.",
        "// Line_Reference 38: // Returns the maximum amount of disk space that this Filesystem instance is allowed to use.",
        "// Line_Reference 40: \treturn atomic.LoadInt64(&fs.diskLimit)",
        "// Line_Reference 43: // Sets the disk space limit for this Filesystem instance.",
        "// Line_Reference 45: \tatomic.SwapInt64(&fs.diskLimit, i)",
        "// Line_Reference 68: \t\tlog.WithField(\"root\", fs.root).WithField(\"error\", err).Warn(\"failed to determine root fs directory size\")",
        "// Line_Reference 87: \treturn atomic.LoadInt64(&fs.diskUsed)",
        "// Line_Reference 117: \t\t\t\t\tlog.WithField(\"root\", fs.root).WithField(\"error\", err).Warn(\"failed to update fs disk usage from within routine\")",
        "// Line_Reference 124: \treturn atomic.LoadInt64(&fs.diskUsed), nil",
        "// Line_Reference 152: \tatomic.StoreInt64(&fs.diskUsed, size)",
        "// Line_Reference 157: // Determines the directory size of a given location by running parallel tasks to iterate",
        "// Line_Reference 158: // through all of the folders. Returns the size in bytes. This can be a fairly taxing operation",
        "// Line_Reference 159: // on locations with tons of files, so it is recommended that you cache the output.",
        "// Line_Reference 160: func (fs *Filesystem) DirectorySize(dir string) (int64, error) {",
        "// Line_Reference 161: \td, err := fs.SafePath(dir)",
        "// Line_Reference 166: \tvar size int64",
        "// Line_Reference 167: \tvar st syscall.Stat_t",
        "// Line_Reference 168: ",
        "// Line_Reference 169: \terr = godirwalk.Walk(d, &godirwalk.Options{",
        "// Line_Reference 170: \t\tUnsorted: true,",
        "// Line_Reference 171: \t\tCallback: func(p string, e *godirwalk.Dirent) error {",
        "// Line_Reference 172: \t\t\t// If this is a symlink then resolve the final destination of it before trying to continue walking",
        "// Line_Reference 173: \t\t\t// over its contents. If it resolves outside the server data directory just skip everything else for",
        "// Line_Reference 174: \t\t\t// it. Otherwise, allow it to continue.",
        "// Line_Reference 175: \t\t\tif e.IsSymlink() {",
        "// Line_Reference 176: \t\t\t\tif _, err := fs.SafePath(p); err != nil {",
        "// Line_Reference 177: \t\t\t\t\tif IsErrorCode(err, ErrCodePathResolution) {",
        "// Line_Reference 178: \t\t\t\t\t\treturn godirwalk.SkipThis",
        "// Line_Reference 179: \t\t\t\t\t}",
        "// Line_Reference 180: ",
        "// Line_Reference 181: \t\t\t\t\treturn err",
        "// Line_Reference 182: \t\t\t\t}",
        "// Line_Reference 183: \t\t\t}",
        "// Line_Reference 184: ",
        "// Line_Reference 185: \t\t\tif !e.IsDir() {",
        "// Line_Reference 186: \t\t\t\t_ = syscall.Lstat(p, &st)",
        "// Line_Reference 187: \t\t\t\tatomic.AddInt64(&size, st.Size)",
        "// Line_Reference 188: \t\t\t}",
        "// Line_Reference 191: \t\t},",
        "// Line_Reference 192: \t})",
        "// Line_Reference 194: \treturn size, errors.WrapIf(err, \"server/filesystem: directorysize: failed to walk directory\")",
        "// Line_Reference 197: // Helper function to determine if a server has space available for a file of a given size.",
        "// Line_Reference 198: // If space is available, no error will be returned, otherwise an ErrNotEnoughSpace error",
        "// Line_Reference 199: // will be raised.",
        "// Line_Reference 201: \tif fs.MaxDisk() == 0 {",
        "// Line_Reference 202: \t\treturn nil",
        "// Line_Reference 203: \t}",
        "// Line_Reference 204: \ts, err := fs.DiskUsage(true)",
        "// Line_Reference 205: \tif err != nil {",
        "// Line_Reference 206: \t\treturn err",
        "// Line_Reference 207: \t}",
        "// Line_Reference 208: \tif (s + size) > fs.MaxDisk() {",
        "// Line_Reference 216: \tsize := atomic.LoadInt64(&fs.diskUsed)",
        "// Line_Reference 217: ",
        "// Line_Reference 218: \t// Sorry go gods. This is ugly but the best approach I can come up with for right",
        "// Line_Reference 219: \t// now without completely re-evaluating the logic we use for determining disk space.",
        "// Line_Reference 220: \t//",
        "// Line_Reference 221: \t// Normally I would just be using the atomic load right below, but I'm not sure about",
        "// Line_Reference 222: \t// the scenarios where it is 0 because nothing has run that would trigger a disk size",
        "// Line_Reference 223: \t// calculation?",
        "// Line_Reference 224: \t//",
        "// Line_Reference 225: \t// Perhaps that isn't even a concern for the sake of this?",
        "// Line_Reference 226: \tif !fs.isTest {",
        "// Line_Reference 227: \t\tsize, _ = fs.DiskUsage(true)",
        "// Line_Reference 228: \t}",
        "// Line_Reference 229: ",
        "// Line_Reference 230: \t// If we're dropping below 0 somehow just cap it to 0.",
        "// Line_Reference 231: \tif (size + i) < 0 {",
        "// Line_Reference 232: \t\treturn atomic.SwapInt64(&fs.diskUsed, 0)",
        "// Line_Reference 233: \t}",
        "// Line_Reference 234: ",
        "// Line_Reference 235: \treturn atomic.AddInt64(&fs.diskUsed, i)"
    ]
}
