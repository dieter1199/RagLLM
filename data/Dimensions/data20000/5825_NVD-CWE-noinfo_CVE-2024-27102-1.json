{
    "cve_id": "CVE-2024-27102",
    "cve_description": "Wings is the server control plane for Pterodactyl Panel. This vulnerability impacts anyone running the affected versions of Wings. The vulnerability can potentially be used to access files and directories on the host system. The full scope of impact is exactly unknown, but reading files outside of a server's base directory (sandbox root) is possible. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. Details on the exploitation of this vulnerability are embargoed until March 27th, 2024 at 18:00 UTC. In order to mitigate this vulnerability, a full rewrite of the entire server filesystem was necessary. Because of this, the size of the patch is massive, however effort was made to reduce the amount of breaking changes. Users are advised to update to version 1.11.9. There are no known workarounds for this vulnerability.",
    "cve_publish_date": "2024-03-13",
    "cwe_id": "NVD-CWE-noinfo",
    "cwe_name": "Insufficient Information",
    "cwe_description": "There is insufficient information about the issue to classify it; details are unkown or unspecified.",
    "commit_message": "server(filesystem): rebuild everything imaginable\n\nThis wonderfully large commit replaces basically everything under the\n`server/filesystem` package, re-implementing essentially everything.\n\nThis is related to\nhttps://github.com/pterodactyl/wings/security/advisories/GHSA-494h-9924-xww9\n\nIf any vulnerabilities related to symlinks persist after this commit, I\nwill be very upset.\n\nSigned-off-by: Matthew Penner <me@matthewp.io>",
    "type_of_change": "Modification",
    "filename_of_changes": "archive.go",
    "code_language": "Go",
    "number_of_lines_added_for_mitigation": "63",
    "number_of_lines_deleted_vulnerable_to_cve": "58",
    "vulnerable_lines": [
        "// Line_Reference 6: \t\"fmt\"",
        "// Line_Reference 17: \t\"github.com/karrick/godirwalk\"",
        "// Line_Reference 60: \t// BasePath is the absolute path to create the archive from where Files and Ignore are",
        "// Line_Reference 61: \t// relative to.",
        "// Line_Reference 62: \tBasePath string",
        "// Line_Reference 101: // Stream .",
        "// Line_Reference 103: \tfor _, f := range a.Files {",
        "// Line_Reference 104: \t\tif strings.HasPrefix(f, a.BasePath) {",
        "// Line_Reference 107: ",
        "// Line_Reference 108: \t\treturn fmt.Errorf(\"archive: all entries in Files must be absolute and within BasePath: %s\\n\", f)",
        "// Line_Reference 133: \tpw := NewTarProgress(tw, a.Progress)",
        "// Line_Reference 135: \t// Configure godirwalk.",
        "// Line_Reference 136: \toptions := &godirwalk.Options{",
        "// Line_Reference 137: \t\tFollowSymbolicLinks: false,",
        "// Line_Reference 138: \t\tUnsorted:            true,",
        "// Line_Reference 139: \t}",
        "// Line_Reference 144: \tvar callback godirwalk.WalkFunc",
        "// Line_Reference 147: ",
        "// Line_Reference 148: \t\tcallback = a.callback(pw, func(_ string, rp string) error {",
        "// Line_Reference 149: \t\t\tif i.MatchesPath(rp) {",
        "// Line_Reference 150: \t\t\t\treturn godirwalk.SkipThis",
        "// Line_Reference 152: ",
        "// Line_Reference 156: \t\tcallback = a.withFilesCallback(pw)",
        "// Line_Reference 158: \t\tcallback = a.callback(pw)",
        "// Line_Reference 161: \t// Set the callback function, wrapped with support for context cancellation.",
        "// Line_Reference 162: \toptions.Callback = func(path string, de *godirwalk.Dirent) error {",
        "// Line_Reference 167: \t\t\treturn callback(path, de)",
        "// Line_Reference 169: \t}",
        "// Line_Reference 170: ",
        "// Line_Reference 171: \t// Recursively walk the path we are archiving.",
        "// Line_Reference 172: \treturn godirwalk.Walk(a.BasePath, options)",
        "// Line_Reference 177: func (a *Archive) callback(tw *TarProgress, opts ...func(path string, relative string) error) func(path string, de *godirwalk.Dirent) error {",
        "// Line_Reference 178: \treturn func(path string, de *godirwalk.Dirent) error {",
        "// Line_Reference 180: \t\tif de.IsDir() {",
        "// Line_Reference 184: \t\trelative := filepath.ToSlash(strings.TrimPrefix(path, a.BasePath+string(filepath.Separator)))",
        "// Line_Reference 185: ",
        "// Line_Reference 189: \t\t\tif err := opt(path, relative); err != nil {",
        "// Line_Reference 196: \t\treturn a.addToArchive(path, relative, tw)",
        "// Line_Reference 201: func (a *Archive) withFilesCallback(tw *TarProgress) func(path string, de *godirwalk.Dirent) error {",
        "// Line_Reference 202: \treturn a.callback(tw, func(p string, rp string) error {",
        "// Line_Reference 208: \t\t\tif f != p && !strings.HasPrefix(strings.TrimSuffix(p, \"/\")+\"/\", strings.TrimSuffix(f, \"/\")+\"/\") {",
        "// Line_Reference 215: \t\t\t// will be the godirwalk.SkipThis error.",
        "// Line_Reference 219: \t\treturn godirwalk.SkipThis",
        "// Line_Reference 224: func (a *Archive) addToArchive(p string, rp string, w *TarProgress) error {",
        "// Line_Reference 225: \t// Lstat the file, this will give us the same information as Stat except that it will not",
        "// Line_Reference 226: \t// follow a symlink to its target automatically. This is important to avoid including",
        "// Line_Reference 227: \t// files that exist outside the server root unintentionally in the backup.",
        "// Line_Reference 228: \ts, err := os.Lstat(p)",
        "// Line_Reference 230: \t\tif os.IsNotExist(err) {",
        "// Line_Reference 233: \t\treturn errors.WrapIff(err, \"failed executing os.Lstat on '%s'\", rp)",
        "// Line_Reference 253: \t\t\t\tlog.WithField(\"path\", rp).WithField(\"readlink_err\", err.Error()).Warn(\"failed reading symlink for target path; skipping...\")",
        "// Line_Reference 262: \t\treturn errors.WrapIff(err, \"failed to get tar#FileInfoHeader for '%s'\", rp)",
        "// Line_Reference 267: \t\theader.Name = rp",
        "// Line_Reference 271: \tif err := w.WriteHeader(header); err != nil {",
        "// Line_Reference 272: \t\treturn errors.WrapIff(err, \"failed to write tar#FileInfoHeader for '%s'\", rp)",
        "// Line_Reference 294: \tf, err := os.Open(p)",
        "// Line_Reference 304: \tif _, err := io.CopyBuffer(w, io.LimitReader(f, header.Size), buf); err != nil {",
        "// Line_Reference 307: "
    ]
}
