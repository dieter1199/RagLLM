{
    "cve_id": "CVE-2017-2598",
    "cve_description": "Jenkins before versions 2.44, 2.32.2 uses AES ECB block cipher mode without IV for encrypting secrets which makes Jenkins and the stored secrets vulnerable to unnecessary risks (SECURITY-304).",
    "cve_publish_date": "2018-05-23",
    "cwe_id": "CWE-326",
    "cwe_name": "Inadequate Encryption Strength",
    "cwe_description": "The product stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.",
    "commit_message": "Merge pull request #105 from jenkinsci-cert/SECURITY-304-t3\n\n[SECURITY-304] Encrypt new secrets with CBC and random IV instead of ECB",
    "type_of_change": "Modification",
    "filename_of_changes": "Secret.java",
    "code_language": "Java",
    "number_of_lines_added_for_mitigation": "94",
    "number_of_lines_deleted_vulnerable_to_cve": "53",
    "vulnerable_lines": [
        "// Line_Reference 37: import javax.crypto.SecretKey;",
        "// Line_Reference 66:     private Secret(String value) {",
        "// Line_Reference 103:     /**",
        "// Line_Reference 104:      * Turns {@link Jenkins#getSecretKey()} into an AES key.",
        "// Line_Reference 105:      *",
        "// Line_Reference 106:      * @deprecated",
        "// Line_Reference 107:      * This is no longer the key we use to encrypt new information, but we still need this",
        "// Line_Reference 108:      * to be able to decrypt what's already persisted.",
        "// Line_Reference 109:      */",
        "// Line_Reference 110:     @Deprecated",
        "// Line_Reference 111:     /*package*/ static SecretKey getLegacyKey() throws GeneralSecurityException {",
        "// Line_Reference 112:         String secret = SECRET;",
        "// Line_Reference 113:         if(secret==null)    return Jenkins.getInstance().getSecretKeyAsAES128();",
        "// Line_Reference 114:         return Util.toAes128Key(secret);",
        "// Line_Reference 115:     }",
        "// Line_Reference 116: ",
        "// Line_Reference 124:             Cipher cipher = KEY.encrypt();",
        "// Line_Reference 125:             // add the magic suffix which works like a check sum.",
        "// Line_Reference 126:             return new String(Base64.encode(cipher.doFinal((value+MAGIC).getBytes(\"UTF-8\"))));",
        "// Line_Reference 129:         } catch (UnsupportedEncodingException e) {",
        "// Line_Reference 130:             throw new Error(e); // impossible",
        "// Line_Reference 135:      * Pattern matching a possible output of {@link #getEncryptedValue}.",
        "// Line_Reference 136:      * Basically, any Base64-encoded value.",
        "// Line_Reference 137:      * You must then call {@link #decrypt} to eliminate false positives.",
        "// Line_Reference 140:     public static final Pattern ENCRYPTED_VALUE_PATTERN = Pattern.compile(\"[A-Za-z0-9+/]+={0,2}\");",
        "// Line_Reference 147:         if(data==null)      return null;",
        "// Line_Reference 148:         try {",
        "// Line_Reference 149:             byte[] in = Base64.decode(data.toCharArray());",
        "// Line_Reference 150:             Secret s = tryDecrypt(KEY.decrypt(), in);",
        "// Line_Reference 151:             if (s!=null)    return s;",
        "// Line_Reference 153:             // try our historical key for backward compatibility",
        "// Line_Reference 154:             Cipher cipher = getCipher(\"AES\");",
        "// Line_Reference 155:             cipher.init(Cipher.DECRYPT_MODE, getLegacyKey());",
        "// Line_Reference 156:             return tryDecrypt(cipher, in);",
        "// Line_Reference 157:         } catch (GeneralSecurityException e) {",
        "// Line_Reference 158:             return null;",
        "// Line_Reference 159:         } catch (UnsupportedEncodingException e) {",
        "// Line_Reference 160:             throw new Error(e); // impossible",
        "// Line_Reference 161:         } catch (IOException e) {",
        "// Line_Reference 162:             return null;",
        "// Line_Reference 163:         }",
        "// Line_Reference 164:     }",
        "// Line_Reference 165: ",
        "// Line_Reference 166:     /*package*/ static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {",
        "// Line_Reference 167:         try {",
        "// Line_Reference 168:             String plainText = new String(cipher.doFinal(in), \"UTF-8\");",
        "// Line_Reference 169:             if(plainText.endsWith(MAGIC))",
        "// Line_Reference 170:                 return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));",
        "// Line_Reference 171:             return null;",
        "// Line_Reference 172:         } catch (GeneralSecurityException e) {",
        "// Line_Reference 173:             return null; // if the key doesn't match with the bytes, it can result in BadPaddingException",
        "// Line_Reference 231:     private static final String MAGIC = \"::::MAGIC::::\";",
        "// Line_Reference 232: "
    ]
}
