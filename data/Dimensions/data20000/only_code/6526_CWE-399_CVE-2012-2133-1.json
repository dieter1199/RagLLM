struct address_space *mapping;
mapping = (struct address_space *) page_private(page);
if (mapping)
hugetlb_put_quota(mapping, 1);
* reservation and actually increase quota before an allocation can occur.
* Where any new reservation would be required the reservation change is
* prepared, but not committed.  Once the page has been quota'd allocated
* an instantiated the change should be committed via vma_commit_reservation.
* No action is required on failure.
struct address_space *mapping = vma->vm_file->f_mapping;
struct inode *inode = mapping->host;
* Processes that did not create the mapping will have no reserves and
* will not have accounted against quota. Check that the quota can be
* made before satisfying the allocation
* MAP_NORESERVE mappings may also need pages and quota allocated
* if no reserve mapping overlaps.
if (hugetlb_get_quota(inode->i_mapping, chg))
hugetlb_put_quota(inode->i_mapping, chg);
set_page_private(page, (unsigned long) mapping);
hugetlb_put_quota(vma->vm_file->f_mapping, reserve);
mapping = (struct address_space *)page_private(page);
* and filesystem quota without using reserves
/* There must be enough filesystem quota for the mapping */
if (hugetlb_get_quota(inode->i_mapping, chg))
* Hand back the quota if there are not
hugetlb_put_quota(inode->i_mapping, chg);
hugetlb_put_quota(inode->i_mapping, (chg - freed));