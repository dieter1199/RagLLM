// CachedResolveCheckResponse is very similar to ResolveCheckResponse except we
// do not store the ResolutionData. This is due to the fact that the resolution metadata
// will be incorrect as data is served from cache instead of actual database read.
type CachedResolveCheckResponse struct {
Allowed bool
}
func (c *CachedResolveCheckResponse) convertToResolveCheckResponse() *ResolveCheckResponse {
return &ResolveCheckResponse{
Allowed: c.Allowed,
ResolutionMetadata: &ResolveCheckResponseMetadata{
DatastoreQueryCount: 0,
},
}
}
func newCachedResolveCheckResponse(r *ResolveCheckResponse) *CachedResolveCheckResponse {
return &CachedResolveCheckResponse{
Allowed: r.Allowed,
}
}
cache        *ccache.Cache[*CachedResolveCheckResponse]
func WithExistingCache(cache *ccache.Cache[*CachedResolveCheckResponse]) CachedCheckResolverOpt {
ccache.Configure[*CachedResolveCheckResponse]().MaxSize(checker.maxCacheSize),
return cachedResp.Value().convertToResolveCheckResponse(), nil
c.cache.Set(cacheKey, newCachedResolveCheckResponse(resp), c.cacheTTL)
