// 3. If parsedMetadata is the empty set, return true.
// 4. Let metadata be the result of getting the strongest
const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))
// get the strongest algorithm
const strongest = list[0].algo
// get all entries that use the strongest algorithm; ignore weaker
const metadata = list.filter((item) => item.algo === strongest)
// 5. For each item in metadata:
let expectedValue = item.hash
if (expectedValue.endsWith('==')) {
expectedValue = expectedValue.slice(0, -2)
}
if (actualValue.endsWith('==')) {
actualValue = actualValue.slice(0, -2)
if (actualValue === expectedValue) {
return true
}
let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest('base64url')
if (actualBase64URL.endsWith('==')) {
actualBase64URL = actualBase64URL.slice(0, -2)
}
if (actualBase64URL === expectedValue) {
// 6. Return false.
const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-(?<hash>[A-Za-z0-9+/]+={0,2}(?=\s|$))( +[!-~]*)?/i
const supportedHashes = crypto.getHashes()
if (parsedToken === null || parsedToken.groups === undefined) {
const algorithm = parsedToken.groups.algo
if (supportedHashes.includes(algorithm.toLowerCase())) {
