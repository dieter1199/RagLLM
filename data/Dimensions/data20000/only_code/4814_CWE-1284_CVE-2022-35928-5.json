*  Copyright (C) 2007-2017
for (i=0; i<48; i+=16)
for(j=0; j<256; j++)
memcpy(iv_key+i, digest, 16);
sha256_starts(  &sha_ctx);
sha256_update(  &sha_ctx, (unsigned char *)&time, sizeof(current_time));
sha256_update(  &sha_ctx, (unsigned char *)&process_id, sizeof(process_id));
sha256_update(  &sha_ctx,
buffer,
32);
sha256_finish(  &sha_ctx, digest);
for(i=0; i<8192; i++)
sha256_starts(  &sha_ctx);
sha256_update(  &sha_ctx, digest, 32);
sha256_update(  &sha_ctx,
passwd,
(unsigned long)passlen);
sha256_finish(  &sha_ctx,
digest);
for(i=0; i<32; i++)
for(i=0; i<48; i+=16)
for(j=0; j<16; j++)
* key to now encrypt the datafile.  Also, reset the HMAC
for(i=0; i<32; i++)
for(i=0; i<16; i++)
fprintf(stderr, "Error: Input file is too short.\n");
fprintf(stderr, "Error: Bad file header (not aescrypt file or is corrupted? [%x, %x, %x])\n", aeshdr.aes[0], aeshdr.aes[1], aeshdr.aes[2]);
fprintf(stderr, "Error: Input file is too short.\n");
fprintf(stderr, "Error: Input file is too short.\n");
fprintf(stderr, "Error: Input file is too short.\n");
for(i=0; i<8192; i++)
sha256_starts(  &sha_ctx);
sha256_update(  &sha_ctx, digest, 32);
sha256_update(  &sha_ctx,
passwd,
passlen);
sha256_finish(  &sha_ctx,
digest);
for(i=0; i<32; i++)
for(i=0; i<48; i+=16)
fprintf(stderr, "Error: Input file is too short.\n");
for(j=0; j<16; j++)
iv_key[i+j] = (buffer[j] ^ IV[j]);
fprintf(stderr, "Error: Input file is too short.\n");
fprintf(stderr, "Error: Message has been altered or password is incorrect\n");
for(i=0; i<32; i++)
ipad[i] ^= iv_key[i+16];
opad[i] ^= iv_key[i+16];
* greater files ( file size modulo + HMAC)
fprintf(stderr, "Error: Input file is corrupt (1:%u).\n",
fprintf(stderr, "Error: Input file is corrupt (2).\n");
fprintf(stderr, "Error: Input file is corrupt (3:%u).\n",
for(i=0; i<16; i++)
fprintf(stderr, "Error: Message has been altered or password is incorrect\n");
fprintf(stderr, "Error: Message has been altered and should not be trusted\n");
fprintf(stderr, "\nusage: %s {-e|-d} [ { -p <password> | -k <keyfile> } ] { [-o <output filename>] <file> | <file> [<file> ...] }\n\n",
passlen = passwd_to_utf16(  (unsigned char*) optarg,
strlen((char *)optarg),
MAX_PASSWD_LEN,
pass);
fprintf(stderr, "Error: No password supplied.\n");
fprintf(stderr, "Error in read_password: %s.\n",
fprintf(stderr, "Error: Passwords don't match.\n");
passlen = passwd_to_utf16(  pass,
strlen((char*)pass),
MAX_PASSWD_LEN,
pass);
fprintf(stderr, "Error: A single output file may not be specified with multiple input files.\n");
fprintf(stderr, "Error: STDIN may not be specified with multiple input files.\n");
/* Reset input/output file names and desriptors */
