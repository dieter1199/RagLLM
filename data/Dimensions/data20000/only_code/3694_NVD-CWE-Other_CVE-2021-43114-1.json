/**
* Certificate repository "level". This aims to identify if the
* certificate is located at a distinct server than its father (common
* case when the RIRs delegate RPKI repositories).
*/
struct repo_level_node {
unsigned int level;
SLIST_ENTRY(repo_level_node) next;
};
SLIST_HEAD(repo_level_stack, repo_level_node);
/**
* Stacked data to store the repository "levels" (each level is a
* delegation of an RPKI server).
*/
struct repo_level_stack levels;
SLIST_INIT(&stack->levels);
struct repo_level_node *level;
stack_size = 0;
while (!SLIST_EMPTY(&stack->levels)) {
level = SLIST_FIRST(&stack->levels);
SLIST_REMOVE_HEAD(&stack->levels, next);
free(level);
stack_size++;
}
pr_val_debug("Deleted %u stacked levels.", stack_size);
struct repo_level_node *repo;
repo = SLIST_FIRST(&stack->levels);
if (repo == NULL)
pr_crit("Attempted to pop empty repo level stack");
SLIST_REMOVE_HEAD(&stack->levels, next);
free(repo);
struct repo_level_node *repo, *head_repo;
unsigned int work_repo_level;
repo = malloc(sizeof(struct repo_level_node));
if (repo == NULL)
return pr_enomem();
repo->level = 0;
work_repo_level = working_repo_peek_level();
head_repo = SLIST_FIRST(&stack->levels);
if (head_repo != NULL && work_repo_level > head_repo->level)
repo->level = work_repo_level;
SLIST_INSERT_HEAD(&stack->levels, repo, next);
if (meta == NULL) {
error = pr_enomem();
goto end3;
}
meta->resources = resources_create(false);
if (meta->resources == NULL) {
error = pr_enomem();
goto end4;
}
resources_set_policy(meta->resources, policy);
error = certificate_get_resources(x509, meta->resources, type);
goto end5;
/*
* rfc8630#section-2.3
* "The INR extension(s) of this TA MUST contain a non-empty set of
* number resources."
* The "It MUST NOT use the "inherit" form of the INR extension(s)"
* part is already handled in certificate_get_resources().
*/
if (type == TA && resources_empty(meta->resources)) {
error = pr_val_err("Trust Anchor certificate does not define any number resources.");
goto end5;
}
defer_separator = malloc(sizeof(struct defer_node));
goto end5;
defer_separator->type = DNT_SEPARATOR;
goto end5;
end5:	resources_destroy(meta->resources);
end4:	subjects_cleanup(&meta->subjects, subject_cleanup);
end3:	SLIST_REMOVE_HEAD(&stack->levels, next);
free(repo);
struct repo_level_node *repo = SLIST_FIRST(&stack->levels);
return (repo != NULL) ? repo->level : 0;
