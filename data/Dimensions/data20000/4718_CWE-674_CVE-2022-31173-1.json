{
    "cve_id": "CVE-2022-31173",
    "cve_description": "Juniper is a GraphQL server library for Rust. Affected versions of Juniper are vulnerable to uncontrolled recursion resulting in a program crash. This issue has been addressed in version 0.15.10. Users are advised to upgrade. Users unable to upgrade should limit the recursion depth manually.",
    "cve_publish_date": "2022-08-01",
    "cwe_id": "CWE-674",
    "cwe_name": "Uncontrolled Recursion",
    "cwe_description": "The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.",
    "commit_message": "Backport CVE-2022-31173 fix from GHSA-4rx6-g5vg-5f3j\n\nCo-authored-by: ilslv <ilya.solovyiov@gmail.com>",
    "type_of_change": "ModificationType.ADD",
    "filename_of_changes": "no_fragment_cycles.rs",
    "code_language": "Rust",
    "number_of_lines_added_for_mitigation": "43",
    "number_of_lines_deleted_vulnerable_to_cve": "25",
    "vulnerable_lines": [
        "// Line_Reference 10: pub struct NoFragmentCycles<'a> {",
        "// Line_Reference 11:     current_fragment: Option<&'a str>,",
        "// Line_Reference 12:     spreads: HashMap<&'a str, Vec<Spanning<&'a str>>>,",
        "// Line_Reference 13:     fragment_order: Vec<&'a str>,",
        "// Line_Reference 14: }",
        "// Line_Reference 15: ",
        "// Line_Reference 16: struct CycleDetector<'a> {",
        "// Line_Reference 17:     visited: HashSet<&'a str>,",
        "// Line_Reference 18:     spreads: &'a HashMap<&'a str, Vec<Spanning<&'a str>>>,",
        "// Line_Reference 19:     path_indices: HashMap<&'a str, usize>,",
        "// Line_Reference 20:     errors: Vec<RuleError>,",
        "// Line_Reference 21: }",
        "// Line_Reference 22: ",
        "// Line_Reference 41:             path_indices: HashMap::new(),",
        "// Line_Reference 47:                 let mut path = Vec::new();",
        "// Line_Reference 48:                 detector.detect_from(frag, &mut path);",
        "// Line_Reference 95:     fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {",
        "// Line_Reference 99:             return;",
        "// Line_Reference 102:         self.path_indices.insert(from, path.len());",
        "// Line_Reference 105:             let name = &node.item;",
        "// Line_Reference 106:             let index = self.path_indices.get(name).cloned();",
        "// Line_Reference 117:             } else if !self.visited.contains(name) {",
        "// Line_Reference 119:                 self.detect_from(name, path);",
        "// Line_Reference 120:                 path.pop();",
        "// Line_Reference 124:         self.path_indices.remove(from);"
    ]
}
