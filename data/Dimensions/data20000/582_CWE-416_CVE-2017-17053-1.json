{
    "cve_id": "CVE-2017-17053",
    "cve_description": "The init_new_context function in arch/x86/include/asm/mmu_context.h in the Linux kernel before 4.12.10 does not correctly handle errors from LDT table allocation when forking a new process, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program. This vulnerability only affected kernels built with CONFIG_MODIFY_LDT_SYSCALL=y.",
    "cve_publish_date": "2017-11-29",
    "cwe_id": "CWE-416",
    "cwe_name": "Use After Free",
    "cwe_description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer.",
    "commit_message": "x86/mm: Fix use-after-free of ldt_struct\n\nThe following commit:\n\n  39a0526fb3f7 (\"x86/mm: Factor out LDT init from context init\")\n\nrenamed init_new_context() to init_new_context_ldt() and added a new\ninit_new_context() which calls init_new_context_ldt().  However, the\nerror code of init_new_context_ldt() was ignored.  Consequently, if a\nmemory allocation in alloc_ldt_struct() failed during a fork(), the\n->context.ldt of the new task remained the same as that of the old task\n(due to the memcpy() in dup_mm()).  ldt_struct's are not intended to be\nshared, so a use-after-free occurred after one task exited.\n\nFix the bug by making init_new_context() pass through the error code of\ninit_new_context_ldt().\n\nThis bug was found by syzkaller, which encountered the following splat:\n\n    BUG: KASAN: use-after-free in free_ldt_struct.part.2+0x10a/0x150 arch/x86/kernel/ldt.c:116\n    Read of size 4 at addr ffff88006d2cb7c8 by task kworker/u9:0/3710\n\n    CPU: 1 PID: 3710 Comm: kworker/u9:0 Not tainted 4.13.0-rc4-next-20170811 #2\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n    Call Trace:\n     __dump_stack lib/dump_stack.c:16 [inline]\n     dump_stack+0x194/0x257 lib/dump_stack.c:52\n     print_address_description+0x73/0x250 mm/kasan/report.c:252\n     kasan_report_error mm/kasan/report.c:351 [inline]\n     kasan_report+0x24e/0x340 mm/kasan/report.c:409\n     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429\n     free_ldt_struct.part.2+0x10a/0x150 arch/x86/kernel/ldt.c:116\n     free_ldt_struct arch/x86/kernel/ldt.c:173 [inline]\n     destroy_context_ldt+0x60/0x80 arch/x86/kernel/ldt.c:171\n     destroy_context arch/x86/include/asm/mmu_context.h:157 [inline]\n     __mmdrop+0xe9/0x530 kernel/fork.c:889\n     mmdrop include/linux/sched/mm.h:42 [inline]\n     exec_mmap fs/exec.c:1061 [inline]\n     flush_old_exec+0x173c/0x1ff0 fs/exec.c:1291\n     load_elf_binary+0x81f/0x4ba0 fs/binfmt_elf.c:855\n     search_binary_handler+0x142/0x6b0 fs/exec.c:1652\n     exec_binprm fs/exec.c:1694 [inline]\n     do_execveat_common.isra.33+0x1746/0x22e0 fs/exec.c:1816\n     do_execve+0x31/0x40 fs/exec.c:1860\n     call_usermodehelper_exec_async+0x457/0x8f0 kernel/umh.c:100\n     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431\n\n    Allocated by task 3700:\n     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59\n     save_stack+0x43/0xd0 mm/kasan/kasan.c:447\n     set_track mm/kasan/kasan.c:459 [inline]\n     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551\n     kmem_cache_alloc_trace+0x136/0x750 mm/slab.c:3627\n     kmalloc include/linux/slab.h:493 [inline]\n     alloc_ldt_struct+0x52/0x140 arch/x86/kernel/ldt.c:67\n     write_ldt+0x7b7/0xab0 arch/x86/kernel/ldt.c:277\n     sys_modify_ldt+0x1ef/0x240 arch/x86/kernel/ldt.c:307\n     entry_SYSCALL_64_fastpath+0x1f/0xbe\n\n    Freed by task 3700:\n     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59\n     save_stack+0x43/0xd0 mm/kasan/kasan.c:447\n     set_track mm/kasan/kasan.c:459 [inline]\n     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524\n     __cache_free mm/slab.c:3503 [inline]\n     kfree+0xca/0x250 mm/slab.c:3820\n     free_ldt_struct.part.2+0xdd/0x150 arch/x86/kernel/ldt.c:121\n     free_ldt_struct arch/x86/kernel/ldt.c:173 [inline]\n     destroy_context_ldt+0x60/0x80 arch/x86/kernel/ldt.c:171\n     destroy_context arch/x86/include/asm/mmu_context.h:157 [inline]\n     __mmdrop+0xe9/0x530 kernel/fork.c:889\n     mmdrop include/linux/sched/mm.h:42 [inline]\n     __mmput kernel/fork.c:916 [inline]\n     mmput+0x541/0x6e0 kernel/fork.c:927\n     copy_process.part.36+0x22e1/0x4af0 kernel/fork.c:1931\n     copy_process kernel/fork.c:1546 [inline]\n     _do_fork+0x1ef/0xfb0 kernel/fork.c:2025\n     SYSC_clone kernel/fork.c:2135 [inline]\n     SyS_clone+0x37/0x50 kernel/fork.c:2129\n     do_syscall_64+0x26c/0x8c0 arch/x86/entry/common.c:287\n     return_from_SYSCALL_64+0x0/0x7a\n\nHere is a C reproducer:\n\n    #include <asm/ldt.h>\n    #include <pthread.h>\n    #include <signal.h>\n    #include <stdlib.h>\n    #include <sys/syscall.h>\n    #include <sys/wait.h>\n    #include <unistd.h>\n\n    static void *fork_thread(void *_arg)\n    {\n        fork();\n    }\n\n    int main(void)\n    {\n        struct user_desc desc = { .entry_number = 8191 };\n\n        syscall(__NR_modify_ldt, 1, &desc, sizeof(desc));\n\n        for (;;) {\n            if (fork() == 0) {\n                pthread_t t;\n\n                srand(getpid());\n                pthread_create(&t, NULL, fork_thread, NULL);\n                usleep(rand() % 10000);\n                syscall(__NR_exit_group, 0);\n            }\n            wait(NULL);\n        }\n    }\n\nNote: the reproducer takes advantage of the fact that alloc_ldt_struct()\nmay use vmalloc() to allocate a large ->entries array, and after\ncommit:\n\n  5d17a73a2ebe (\"vmalloc: back off when the current task is killed\")\n\nit is possible for userspace to fail a task's vmalloc() by\nsending a fatal signal, e.g. via exit_group().  It would be more\ndifficult to reproduce this bug on kernels without that commit.\n\nThis bug only affected kernels with CONFIG_MODIFY_LDT_SYSCALL=y.\n\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nAcked-by: Dave Hansen <dave.hansen@linux.intel.com>\nCc: <stable@vger.kernel.org> [v4.6+]\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Borislav Petkov <bp@alien8.de>\nCc: Brian Gerst <brgerst@gmail.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Denys Vlasenko <dvlasenk@redhat.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Rik van Riel <riel@redhat.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-mm@kvack.org\nFixes: 39a0526fb3f7 (\"x86/mm: Factor out LDT init from context init\")\nLink: http://lkml.kernel.org/r/20170824175029.76040-1-ebiggers3@gmail.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "type_of_change": "Modification",
    "filename_of_changes": "mmu_context.h",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "1",
    "number_of_lines_deleted_vulnerable_to_cve": "3",
    "vulnerable_lines": [
        "// Line_Reference 143: \tinit_new_context_ldt(tsk, mm);",
        "// Line_Reference 144: ",
        "// Line_Reference 145: \treturn 0;"
    ]
}
