{
    "cve_id": "CVE-2021-3997",
    "cve_description": "A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.",
    "cve_publish_date": "2022-08-23",
    "cwe_id": "CWE-674",
    "cwe_name": "Uncontrolled Recursion",
    "cwe_description": "The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.",
    "commit_message": "shared/rm-rf: loop over nested directories instead of instead of recursing\n\nTo remove directory structures, we need to remove the innermost items first,\nand then recursively remove higher-level directories. We would recursively\ndescend into directories and invoke rm_rf_children and rm_rm_children_inner.\nThis is problematic when too many directories are nested.\n\nInstead, let's create a \"TODO\" queue. In the the queue, for each level we\nhold the DIR* object we were working on, and the name of the directory. This\nallows us to leave a partially-processed directory, and restart the removal\nloop one level down. When done with the inner directory, we use the name to\nunlinkat() it from the parent, and proceed with the removal of other items.\n\nBecause the nesting is increased by one level, it is best to view this patch\nwith -b/--ignore-space-change.\n\nThis fixes CVE-2021-3997, https://bugzilla.redhat.com/show_bug.cgi?id=2024639.\nThe issue was reported and patches reviewed by Qualys Team.\nMauro Matteo Cascella and Riccardo Schirone from Red Hat handled the disclosure.",
    "type_of_change": "Modification",
    "filename_of_changes": "rm-rf.c",
    "code_language": "C",
    "number_of_lines_added_for_mitigation": "112",
    "number_of_lines_deleted_vulnerable_to_cve": "47",
    "vulnerable_lines": [
        "// Line_Reference 55: ",
        "// Line_Reference 119: static int rm_rf_children_inner(",
        "// Line_Reference 124:                 const struct stat *root_dev) {",
        "// Line_Reference 144:                 _cleanup_close_ int subdir_fd = -1;",
        "// Line_Reference 145: ",
        "// Line_Reference 146:                 /* if root_dev is set, remove subdirectories only if device is same */",
        "// Line_Reference 158: ",
        "// Line_Reference 172:                 subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);",
        "// Line_Reference 178:                 q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);",
        "// Line_Reference 196:         _cleanup_closedir_ DIR *d = NULL;",
        "// Line_Reference 199:         assert(fd >= 0);",
        "// Line_Reference 201:         /* This returns the first error we run into, but nevertheless tries to go on. This closes the passed",
        "// Line_Reference 202:          * fd, in all cases, including on failure. */",
        "// Line_Reference 204:         d = fdopendir(fd);",
        "// Line_Reference 205:         if (!d) {",
        "// Line_Reference 206:                 safe_close(fd);",
        "// Line_Reference 207:                 return -errno;",
        "// Line_Reference 208:         }",
        "// Line_Reference 210:         if (!(flags & REMOVE_PHYSICAL)) {",
        "// Line_Reference 211:                 struct statfs sfs;",
        "// Line_Reference 213:                 if (fstatfs(dirfd(d), &sfs) < 0)",
        "// Line_Reference 214:                         return -errno;",
        "// Line_Reference 216:                 if (is_physical_fs(&sfs)) {",
        "// Line_Reference 217:                         /* We refuse to clean physical file systems with this call, unless explicitly",
        "// Line_Reference 218:                          * requested. This is extra paranoia just to be sure we never ever remove non-state",
        "// Line_Reference 219:                          * data. */",
        "// Line_Reference 221:                         _cleanup_free_ char *path = NULL;",
        "// Line_Reference 223:                         (void) fd_get_path(fd, &path);",
        "// Line_Reference 224:                         return log_error_errno(SYNTHETIC_ERRNO(EPERM),",
        "// Line_Reference 225:                                                \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",",
        "// Line_Reference 226:                                                strna(path));",
        "// Line_Reference 227:                 }",
        "// Line_Reference 228:         }",
        "// Line_Reference 230:         FOREACH_DIRENT_ALL(de, d, return -errno) {",
        "// Line_Reference 231:                 int is_dir;",
        "// Line_Reference 233:                 if (dot_or_dot_dot(de->d_name))",
        "// Line_Reference 234:                         continue;",
        "// Line_Reference 236:                 is_dir =",
        "// Line_Reference 237:                         de->d_type == DT_UNKNOWN ? -1 :",
        "// Line_Reference 238:                         de->d_type == DT_DIR;",
        "// Line_Reference 240:                 r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);",
        "// Line_Reference 241:                 if (r < 0 && r != -ENOENT && ret == 0)",
        "// Line_Reference 242:                         ret = r;",
        "// Line_Reference 243:         }",
        "// Line_Reference 245:         if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)",
        "// Line_Reference 246:                 ret = -errno;",
        "// Line_Reference 338:         return rm_rf_children_inner(fd, name, -1, flags, NULL);"
    ]
}
